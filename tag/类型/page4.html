<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#类型</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#类型</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1009761.html">为什么电子壳层有一定的限制？</a></div><div class="item_title_en"><a target="_blank" href="http://www.madsci.org/posts/archives/1999-03/921736624.Ch.r.html">Why do electron shells have set limits?</a><span>(www.madsci.org)</span></div><span class="my_story_list_date">2020-7-4 9:57</span><div class="my_story_list_item_desc">第三壳层(n=3)可以具有三种类型的亚壳层(l=0，#34；s&34；，l=1，&#34；p&#34；和l=2，&#34；d&#34；轨道)。第四壳层(n=4)可以具有四种类型的子壳层(l=0，#34；s#34；，l=1，&#34；p&#34；，l=2，&#34；d&#34；和l=3，&#34；f&#34；轨道)。如......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/电子/">#电子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shells/">#shells</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008706.html">对卑鄙女孩的善意</a></div><div class="item_title_en"><a target="_blank" href="https://www.aymannadeem.com/haskell/2020/05/15/Kindness-for-Mean-Girls.html">Kindness for Mean Girls</a><span>(www.aymannadeem.com)</span></div><span class="my_story_list_date">2020-6-28 17:41</span><div class="my_story_list_item_desc">Haskell程序是在两个世界的交界处构建的：一个是类型，另一个是值。值是可操作的运行时实体，在语法上由代码中的术语表示。为此，类型对术语进行分类。它们提供了强大的抽象来组织数据、确定数据应该如何存储在内存中、通过各种操作，等等。从表面上看，这些领域之间的区别很简单：类型指的是数据类型，它们要么是内置的(如Integ......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/女孩/">#女孩</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/kindness/">#kindness</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008472.html">Tyescript 4.0 Beta版</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-beta/">TypeScript 4.0 Beta</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-6-27 2:9</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1008472.html"><img src="http://img.diglog.com/img/2020/6/thumb_1519d499b76cc3b5fe53e2cbfba9a9f6.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">今天，我们很兴奋地发布TypeScript编程语言的下一个重要里程碑的测试版：TypeScript4.0。
这个测试版让我们迈出了进入TypeScript4.0的第一步，虽然它带来了一个新的主要版本，但不要担心-没有比往常更大的突破性变化。我们发展TypeScript的理念一直是提供一条升级路径，将破坏性的破坏性更改......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/beta/">#beta</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1008286.html">基于查询的编译器体系结构</a></div><div class="item_title_en"><a target="_blank" href="https://ollef.github.io/blog/posts/query-based-compilers.html">Query-Based Compiler Architectures</a><span>(ollef.github.io)</span></div><span class="my_story_list_date">2020-6-26 5:18</span><div class="my_story_list_item_desc">注意：这是一篇来自Sixten编程语言文档的老帖子，我对它进行了润色和充实。在写完之后，我发现了Salsa，这是一个与我的Rock库有着非常相似目标的Rust库，它也绝对值得一看！
编译器不再仅仅是获取一堆源文件并产生汇编代码的黑匣子。我们期望他们：
是增量的，这意味着如果我们在做了一些更改之后重新编译一个项目，我们......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/based/">#based</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007308.html">线性类型在GHC中合并</a></div><div class="item_title_en"><a target="_blank" href="https://www.tweag.io/blog/2020-06-19-linear-types-merged">Linear types are merged in GHC</a><span>(www.tweag.io)</span></div><span class="my_story_list_date">2020-6-20 3:55</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1007308.html"><img src="http://img.diglog.com/img/2020/6/thumb_022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">已经快4年了。他们有4年了！我们学到了很多东西。我很疲惫，但最重要的是，我很高兴，我很感激，我很有希望。
GHC向线型的旅程始于2016年秋天。在这个时间点上，Jean-Philippe Bernardy和我从事分布式存储研发已经有一年左右的时间了。在此之前，我们两人都刚刚发表了对线性逻辑的研究。而且，我们开始在很多......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/types/">#types</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/线性/">#线性</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007114.html">纯C语言的代数数据类型和类型自省</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/Hirrolot/poica">Algebraic data types and type introspection for pure C</a><span>(github.com)</span></div><span class="my_story_list_date">2020-6-19 0:2</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1007114.html"><img src="http://img.diglog.com/img/2020/6/thumb_1f31a07d5f41037126cdbb56e2de1d13.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">唯一的依赖项是Boost/预处理器。如果您在类UNIX系统上，只需运行以下脚本：
由于poica是一个仅包含头文件的库，因此您可以随意将必要的文件复制到您的项目中，并使用#include&lt；poica.h&gt；导出其API(使用-i编译器选项)。就这些。
通常在C语言中，我们使用联合来告诉编译器我们将以不同的方......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/代数/">#代数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/data/">#data</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1007093.html">最新围棋通用设计简明指南</a></div><div class="item_title_en"><a target="_blank" href="https://pmihaylov.com/go-generics-draft-design/">A Concise Guide to the Latest Go Generics Draft Design</a><span>(pmihaylov.com)</span></div><span class="my_story_list_date">2020-6-18 22:38</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1007093.html"><img src="http://img.diglog.com/img/2020/6/thumb_c9ce2f07c81deb934b8d75df8319763d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">最近，围棋团队宣布了他们围棋提案中泛型的最新设计草案。它详细介绍了做出某些决定的原因、实施细节等。
在本文中，我的目标是总结即将发生的主要变化，因为整个设计草案可能会让很多人感到厌烦。
我将提供一些代码片段来演示主要功能，并让您有机会体验它们，这要归功于新的支持泛型的围棋游乐场。
下面是在类型参数上没有任何约束的泛型......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/通用/">#通用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/guide/">#guide</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006987.html">Go Generics草稿设计：构建哈希表·Matt Layher</a></div><div class="item_title_en"><a target="_blank" href="https://mdlayher.com/blog/go-generics-draft-design-building-a-hashtable/">Go generics draft design: building a hashtable · Matt Layher</a><span>(mdlayher.com)</span></div><span class="my_story_list_date">2020-6-18 2:54</span><div class="my_story_list_item_desc">2018年，我在Goas中实现了一个玩具哈希表，快速刷新了Go地图等数据类型的工作原理，该实现专门使用映射到字符串值的字符串键。
两年后，也就是2020年6月，Go团队发布了一篇题为“泛型的下一步”(The Next Step For Generics)的博客文章，提供了一个基于扩展Go现有接口的更新的泛型设计草案，......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/matt/">#matt</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/draft/">#draft</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1006314.html">Expresso：一种具有多态可扩展行类型的简单表达式语言</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/willtim/Expresso">Expresso: A simple expressions language with polymorphic extensible row types</a><span>(github.com)</span></div><span class="my_story_list_date">2020-6-13 2:52</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1006314.html"><img src="http://img.diglog.com/img/2020/6/thumb_4eb575976a3c62d83bd4d0666e2aa807.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Expresso是一种最小静态类型的函数式编程语言，设计时考虑了嵌入式和/或可扩展性。这种最小语言的可能用例包括配置(如Nix)、数据交换(如JSON)，甚至是自定义外部DSL的起点。
Expresso是一种函数式语言，因此我们使用lambda术语作为基本的抽象手段。要创建命名函数，我们只需使用let绑定一个lamb......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/多态/">#多态</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/simple/">#simple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1005162.html">聚利亚朗反模式</a></div><div class="item_title_en"><a target="_blank" href="https://white.ucc.asn.au/2020/04/19/Julia-Antipatterns.html">Julialang Antipatterns</a><span>(white.ucc.asn.au)</span></div><span class="my_story_list_date">2020-6-5 0:31</span><div class="my_story_list_item_desc">反模式是解决总体上使事情变得更糟的问题的常见解决方案。这篇博客文章旨在强调Julia代码中常见的几个反模式。我怀疑这在很大程度上是由于其他语言带来的包袱，这些语言不是反模式，但实际上是好的模式。这篇文章是为了澄清事情。
在这些问题上，有些人会不同意我的观点。没关系，他们可以犯错(😂I jest)。引用普赖斯、特科尔斯......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/利亚/">#利亚</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/julialang/">#julialang</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1004315.html">原生JavaScript的类型安全</a></div><div class="item_title_en"><a target="_blank" href="https://mmikowski.github.io/typecast-02/">Type Safety with Native JavaScript</a><span>(mmikowski.github.io)</span></div><span class="my_story_list_date">2020-5-30 4:45</span><div class="my_story_list_item_desc">这是对原文章的更新，更短、更简单、更合乎逻辑、更正确。
许多开发人员工具，如IDE、框架、库和链接器，都试图为JavaScript提供某种级别的类型安全。本文解释了什么是类型安全，为什么需要类型安全，以及如何使用原生JavaScript实现类型安全。
类型安全是编程语言阻止或防止类型错误的程度。当向函数或表达式提供意......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/safety/">#safety</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1003377.html">常见的锈蚀寿命误区</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions</a><span>(github.com)</span></div><span class="my_story_list_date">2020-5-23 15:14</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1003377.html"><img src="http://img.diglog.com/img/2020/5/thumb_88fd6ddb8253d4481c2e73bf9c8b9c36.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我曾经在某种程度上持有所有这些误解，今天我看到许多初学者都在与这些误解作斗争。我的一些术语可能不是标准的，所以这里有一张我使用的速记短语的表格，以及我想要表达的意思。
简而言之：变量的生存期是编译器可以静态验证它所指向的数据在其当前内存地址有效的时间长度。我现在将用接下来的6000个单词更详细地介绍人们通常会感到困惑......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/寿命/">#寿命</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002990.html">欢迎使用C#9.0</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/dotnet/welcome-to-c-9-0/">Welcome to C# 9.0</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-5-21 1:48</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1002990.html"><img src="http://img.diglog.com/img/2020/5/thumb_4d8f7fb3aa7a46aaaf49c2063aca8438.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">C#9.0正在成型，我想与您分享我们对该语言下一版本中添加的一些主要特性的看法。
对于每个新版本的C#，我们都努力在常见的编码场景中实现更高的清晰度和简单性，C#9.0也不例外。这一次的一个特别焦点是支持数据形状的简洁和不可变的表示形式。
对象初始化器非常棒。它们为某种类型的客户端提供了一种非常灵活且可读的格式来创建......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c#/">#c#</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002956.html">利斯科夫代换原理(简化)</a></div><div class="item_title_en"><a target="_blank" href="https://www.brainstobytes.com/the-liskov-substitution-principle/">The Liskov Substitution Principle (Simplified)</a><span>(www.brainstobytes.com)</span></div><span class="my_story_list_date">2020-5-20 22:15</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1002956.html"><img src="http://img.diglog.com/img/2020/5/thumb_14b9f01b0f6e7a3ae0238aeac2301dea.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">1987年，在发表关于数据抽象和层次结构的主旨演讲时，Barbara Liskov介绍了最终成为Liskov替换原则的想法。以下是对该原则的现代(且非常正式)描述：
设Φ(X)是关于类型T的对象x可证明的性质，则Φ(Y)对于类型S的对象y应该为真，其中S是T的子类型。
当我第一次读到定义时，我所理解的就是它在某种程度......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/斯科夫/">#斯科夫</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002276.html">Dgraph、GraphQL、Schemas和CRUD-Ardan实验室</a></div><div class="item_title_en"><a target="_blank" href="https://www.ardanlabs.com/blog/2020/05/dgraph-graphql-schemas-crud.html">Dgraph, GraphQL, Schemas, & CRUD – Ardan Labs</a><span>(www.ardanlabs.com)</span></div><span class="my_story_list_date">2020-5-16 2:16</span><div class="my_story_list_item_desc">在这篇文章的大多数评论中，有人问我为什么选择图形数据库而不是其他东西？这是一个很难回答的问题，因为我目前的经验仅限于图形数据库方面。我猜你也在想同样的事情，所以这是我迄今为止最好的回答。在我职业生涯的这个阶段，如果我在编写金融软件，我只会选择关系型数据库。关系数据库是非常严格的，所以您需要真正确保您事先了解您的数据。......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1002154.html">减弱循环，以便图灵可以停止</a></div><div class="item_title_en"><a target="_blank" href="http://pling.jondgoodwin.com/post/weakening-cycles/">Weakening Cycles So That Turing Can Halt</a><span>(pling.jondgoodwin.com)</span></div><span class="my_story_list_date">2020-5-15 5:43</span><div class="my_story_list_item_desc">值得注意的是，在导致类型理论兴起的历史进程中，悖论经常出现。解决罗素的悖论导致了他的类型理论。哥德尔的不完全性定理的证明依赖于说谎者悖论的一个变体。丘奇和图灵用他们独特的形式主义概括了这一结果。直觉主义类型理论就是为了避免这些悖论而设计的。事实就是如此。
作为一名本科生，作为谓词逻辑课程的一部分，我有幸学习了哥德尔的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/循环/">#循环</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cycles/">#cycles</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1001965.html">宣布打字稿3.9</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-9/">Announcing TypeScript 3.9</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-5-13 21:2</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1001965.html"><img src="http://img.diglog.com/img/2020/5/thumb_065a3a9a06a786d7328a931d00589001.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">如果您不熟悉TypeScript，那么它是一种通过添加类型声明和注释的语法而构建在JavaScript之上的语言。TypeScript编译器可以使用此语法对代码进行类型检查，然后输出在许多不同运行时上运行的干净、可读的JavaScript。静态类型检查可以在我们运行代码之前，或者甚至在我们保存文件之前就告诉我们代码中......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/宣布/">#宣布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1001288.html">打字系统(如打字稿)的底层</a></div><div class="item_title_en"><a target="_blank" href="https://medium.com/@tabu_craig/under-the-hood-of-type-systems-e-g-typescript-b3b0b5c18963">Under-the-hood of type systems (e.g. TypeScript)</a><span>(medium.com)</span></div><span class="my_story_list_date">2020-5-9 0:7</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1001288.html"><img src="http://img.diglog.com/img/2020/5/thumb_2dab65cdee8688c78066ebda7bf111af.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我努力从“JavaScript类型系统编译器”是如何实现的低级视图中找到解释。我了解类型系统的许多工作，但不确定涉及的机制以及它们如何协同工作。
本文旨在揭示幕后工作的一些基本原理。不可能把重点放在一篇文章中的所有内容上，所以这里我们将专门关注“类型检查”。从概述类型系统开始，然后构建我们自己的编译器，它可以运行类型......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/打字/">#打字</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1000726.html">高级编程语言</a></div><div class="item_title_en"><a target="_blank" href="http://matt.might.net/articles/best-programming-languages/">Advanced Programming Languages</a><span>(matt.might.net)</span></div><span class="my_story_list_date">2020-5-5 18:43</span><div class="my_story_list_item_desc">学生们经常要求推荐他们下一步应该学习什么语言。如果你正在找一份工业界的工作，我的回答是学习目前最热门的东西：C++、Java和C#--可能还有Python、Ruby、PHP和Perl。
另一方面，如果你对启蒙、学术研究或初创企业感兴趣，那么你选择下一门语言的标准不是就业能力，而是表达能力。在学术研究和创业中，你需要提......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/language/">#language</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程语言/">#编程语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1000325.html">语言设计：使用‘ident：type’而不是‘Type ident’</a></div><div class="item_title_en"><a target="_blank" href="https://soc.me/languages/type-annotations">Language Design: Use 'ident: Type' not 'Type ident'</a><span>(soc.me)</span></div><span class="my_story_list_date">2020-5-2 18:6</span><div class="my_story_list_item_desc">在表现型语言中，开发人员通常需要使用较少的临时变量，这意味着在典型的代码中定义的名称较少，但这些名称具有更高的重要性。
ident：type语法让开发人员将重点放在名称上，将其放在其类型注释之前。这意味着名称的垂直偏移量保持一致，无论是否存在类型批注(以及其长度有多长)1：
val x：string=&#34；hel......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/design/">#design</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/type/">#type</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/类型/">0</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page1.html">1</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page2.html">2</a></li><li class="page-item"><a class="page-link" href="/tag/类型/page3.html">3</a></li><li class="page-item active"><a class="page-link" href="/tag/类型/page4.html">4</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>