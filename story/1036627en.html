<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>è§£æå™¨ç”Ÿæˆå™¨DSLï¼šä½¿ç”¨Babelå’ŒJavaScriptæ¨¡æ¿æ„å»ºè§£æå™¨Parser Generator DSLs: Building Parsers with Babel and JavaScript Templates</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Parser Generator DSLs: Building Parsers with Babel and JavaScript Templates<br/>è§£æå™¨ç”Ÿæˆå™¨DSLï¼šä½¿ç”¨Babelå’ŒJavaScriptæ¨¡æ¿æ„å»ºè§£æå™¨</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-26 06:52:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/1bf7db1cefcd5c92e57847aa36377f1c.png"><img src="http://img2.diglog.com/img/2020/11/1bf7db1cefcd5c92e57847aa36377f1c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Ever since I started working on  styled-components Iâ€™ve been fascinated by parsers. Writing a plugin forWebpack or Babel for the first time felt like pure magic, especially if the plugin doesnâ€™t just transpilesome code for compatibility reasons or adds some metadata but instead generates entirely new codeor enables functionality that just isnâ€™t feasibly implemented as runtime-only code.</p><p>è‡ªä»æˆ‘å¼€å§‹å¤„ç†æ ·å¼åŒ–ç»„ä»¶ä»¥æ¥ï¼Œæˆ‘ä¸€ç›´å¯¹è§£æå™¨ç€è¿·ã€‚ç¬¬ä¸€æ¬¡ä¸ºWebpackæˆ–Babelç¼–å†™æ’ä»¶æ„Ÿè§‰å°±åƒæ˜¯çº¯ç²¹çš„é­”æœ¯ï¼Œå°¤å…¶æ˜¯å¦‚æœè¯¥æ’ä»¶ä¸åªæ˜¯å‡ºäºå…¼å®¹æ€§åŸå› è€Œä¼ é€’ä¸€äº›å¯ç§»æ¤çš„ä»£ç æˆ–æ·»åŠ ä¸€äº›å…ƒæ•°æ®ï¼Œè€Œæ˜¯ç”Ÿæˆäº†å…¨æ–°çš„ç¼–ç å™¨æˆ–å¯ç”¨äº†æ— æ³•åœ¨è¿è¡Œæ—¶å®ç°çš„åŠŸèƒ½æ—¶ï¼Œä»…ä»£ç ã€‚</p><p> These days as JavaScript developers parsers are all around us. When weâ€™re starting up aWebpack or Rollup process Acorn parses our code in the background. When weâ€™re using a CSS-in-JSlibrary then thereâ€™s a good chance  stylis is parsing ourCSS code. When weâ€™re using GraphQL the reference implementationâ€™s parser diligently does its workin the background.</p><p> è¿™äº›å¤©æ¥ï¼ŒJavaScriptå¼€å‘äººå‘˜è§£æå™¨æ— å¤„ä¸åœ¨ã€‚å½“æˆ‘ä»¬å¯åŠ¨Webpackæˆ–æ±‡æ€»è¿‡ç¨‹æ—¶ï¼ŒAcornä¼šåœ¨åå°è§£ææˆ‘ä»¬çš„ä»£ç ã€‚å½“æˆ‘ä»¬ä½¿ç”¨CSS-in-JSlibraryæ—¶ï¼Œstyliså¾ˆå¯èƒ½ä¼šè§£æCSSä»£ç ã€‚å½“æˆ‘ä»¬ä½¿ç”¨GraphQLæ—¶ï¼Œå‚è€ƒå®ç°çš„è§£æå™¨ä¼šåœ¨åå°åŠªåŠ›å·¥ä½œã€‚</p><p> To me, nothing exemplifies this  omnipresence of parsers more than  â€œBabelMacrosâ€, which is a Babel plugin that initself runs other plugins, which are embedded in special npm packages, called â€œmacrosâ€. Very meta.With macros, a package can feasibly appear as if it was just a JS library but use the fullpower of compile-time transpilation without us having to update our Babel config.For example,  eval.macro evaluates JS code inside tagged template literals during compile-time. Tagged template literals were even meant for embedding domain-specific languages(â€œDSLsâ€) into JavaScript, as Dr. Axel Rauschmayer writes  in his post onthem:</p><p> å¯¹æˆ‘è€Œè¨€ï¼Œæ²¡æœ‰ä»€ä¹ˆæ¯”â€œ BabelMacrosâ€æ›´èƒ½è¯´æ˜è¿™ç§è§£æå™¨çš„æ— å¤„ä¸åœ¨äº†ã€‚BabelMacrosæ˜¯ä¸€ä¸ªBabelæ’ä»¶ï¼Œå®ƒæœ¬èº«å¯ä»¥è¿è¡Œå…¶ä»–æ’ä»¶ï¼Œè¿™äº›æ’ä»¶åµŒå…¥ç‰¹æ®Šçš„npmè½¯ä»¶åŒ…ä¸­ï¼Œç§°ä¸ºâ€œ macrosâ€ã€‚éå¸¸å…·æœ‰å…ƒåŠŸèƒ½ï¼Œæœ‰äº†å®ï¼Œç¨‹åºåŒ…å°±å¯ä»¥çœ‹èµ·æ¥åƒåªæ˜¯ä¸€ä¸ªJSåº“ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ç¼–è¯‘æ—¶ç¼–è¯‘çš„å…¨éƒ¨åŠŸèƒ½ï¼Œè€Œæ— éœ€æ›´æ–°Babelé…ç½®ã€‚ä¾‹å¦‚ï¼Œeval.macroåœ¨æ ‡è®°çš„æ¨¡æ¿æ–‡å­—ä¸­è¯„ä¼°JSä»£ç åœ¨ç¼–è¯‘æ—¶ã€‚æ­£å¦‚Axel Rauschmayeråšå£«åœ¨å…¶ä¸»é¢˜æ–‡ç« ä¸­æ‰€å†™çš„é‚£æ ·ï¼Œå¸¦æœ‰æ ‡è®°çš„æ¨¡æ¿æ–‡å­—ç”šè‡³ç”šè‡³æ—¨åœ¨å°†ç‰¹å®šé¢†åŸŸçš„è¯­è¨€ï¼ˆâ€œ DSLsâ€ï¼‰åµŒå…¥åˆ°JavaScriptä¸­ï¼š</p><p> â€œIn ECMAScript 6, template strings are a syntactic construct that facilitates the implementationof embedded DSLs in JavaScript.â€</p><p> â€œåœ¨ECMAScript 6ä¸­ï¼Œæ¨¡æ¿å­—ç¬¦ä¸²æ˜¯ä¸€ç§è¯­æ³•æ„é€ ï¼Œæœ‰åŠ©äºåœ¨JavaScriptä¸­å®ç°åµŒå…¥å¼DSLã€‚â€</p><p> Given that macros can be used ad hoc to transpile any code, including tagged template literals,just by using importing a package, plugins like  eval.macro â€” which itself technically embedsJS into JS â€” can pre-compile some of their functionality:</p><p> é‰´äºå¯ä»¥ç«‹å³ä½¿ç”¨å®æ¥è½¬è¯‘ä»»ä½•ä»£ç ï¼ŒåŒ…æ‹¬åŠ æ ‡ç­¾çš„æ¨¡æ¿æ–‡å­—ï¼Œåªéœ€ä½¿ç”¨å¯¼å…¥åŒ…ï¼Œeval.macroä¹‹ç±»çš„æ’ä»¶ï¼ˆå…¶æŠ€æœ¯ä¸Šå°±å°†JSåµŒå…¥JSä¸­ï¼‰å¯ä»¥é¢„ç¼–è¯‘å…¶æŸäº›åŠŸèƒ½ï¼š</p><p> import  eval  from  &#39;eval.macro&#39; ; // using the macro this: const val  = eval  ` 7 * 6 ` ; // â€¦turns into this: const val  =  42 ;</p><p> ä»'eval.macro'å¯¼å…¥eval; //ä½¿ç”¨ä»¥ä¸‹å®ï¼šconst val = eval`7 * 6`; // ...å˜æˆè¿™æ ·ï¼šconst val = 42;</p><p> Parsers are indeed all around us and frequently grant us  amazing new abilities. But if we lookat the state of the JavaScript ecosystem from the perspective of native, compiled languages wemay notice that we can go a step further than this with  metacompilers, a fancy category ofprograms that also includes  parser generators. Parser Generators â€” an examplein JavaScript being  peg.js â€” allow us to write a parser in a DSL, whichoften looks similar to regular expressions, and subsequently generate the parserâ€™s codeautomatically.</p><p> è§£æå™¨ç¡®å®æ— å¤„ä¸åœ¨ï¼Œå¹¶ç»å¸¸èµ‹äºˆæˆ‘ä»¬æƒŠäººçš„æ–°èƒ½åŠ›ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ä»æœ¬åœ°ç¼–è¯‘è¯­è¨€çš„è§’åº¦çœ‹å¾…JavaScriptç”Ÿæ€ç³»ç»Ÿçš„çŠ¶æ€ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæ³¨æ„åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å…ƒç¼–è¯‘å™¨ï¼ˆæ¯”è¿™è¿˜ä¸é”™çš„ç¨‹åºç±»åˆ«ï¼Œè¿˜åŒ…æ‹¬è§£æå™¨ç”Ÿæˆå™¨ï¼‰åœ¨æ­¤æ–¹é¢èµ°å¾—æ›´è¿œã€‚è§£æå™¨ç”Ÿæˆå™¨ï¼ˆåœ¨JavaScriptä¸­æ˜¯peg.jsçš„ä¸€ä¸ªç¤ºä¾‹ï¼‰ä½¿æˆ‘ä»¬å¯ä»¥åœ¨DSLä¸­ç¼–å†™è§£æå™¨ï¼Œè¯¥è§£æå™¨é€šå¸¸çœ‹èµ·æ¥ä¸æ­£åˆ™è¡¨è¾¾å¼ç±»ä¼¼ï¼Œç„¶åè‡ªåŠ¨ç”Ÿæˆè§£æå™¨çš„ä»£ç ã€‚</p><p> Parser Generators allow us to write a parser in a DSL, which oftenlooks similar to regular expressions, and subsequently output the parser itself automatically.</p><p>è§£æå™¨ç”Ÿæˆå™¨ä½¿æˆ‘ä»¬å¯ä»¥åœ¨DSLä¸­ç¼–å†™è§£æå™¨ï¼Œè¯¥DSLé€šå¸¸çœ‹èµ·æ¥ä¸æ­£åˆ™è¡¨è¾¾å¼ç›¸ä¼¼ï¼Œç„¶åè‡ªåŠ¨è¾“å‡ºè§£æå™¨æœ¬èº«ã€‚</p><p> This on its own is pretty useful knowledge, but knowing Babel Macros, I was wondering whetherit was feasible to create a macro that allowed me to write a  parsing grammar in a taggedtemplate literal and transpile it to a parser. If a parser generator in JS was able to outputcompact code that is still reasonably fast, itâ€™d make itself very useful to create small &amp; quickDSLs that can be run in the browser. Letâ€™s look at how I built  RegHex!</p><p> è¿™æœ¬èº«æ˜¯éå¸¸æœ‰ç”¨çš„çŸ¥è¯†ï¼Œä½†æ˜¯äº†è§£Babel Macrosåï¼Œæˆ‘æƒ³çŸ¥é“åˆ›å»ºä¸€ä¸ªå®æ˜¯å¦å¯è¡Œï¼Œè¯¥å®å¯ä»¥ä½¿æˆ‘ä»¥æ ‡è®°æ¨¡æ¿æ–‡å­—ç¼–å†™è§£æè¯­æ³•å¹¶å°†å…¶è½¬æ¢ä¸ºè§£æå™¨ã€‚å¦‚æœJSä¸­çš„è§£æå™¨ç”Ÿæˆå™¨èƒ½å¤Ÿè¾“å‡ºä»ç„¶ç›¸å½“å¿«çš„ç´§å‡‘ä»£ç ï¼Œé‚£ä¹ˆåˆ›å»ºå¯åœ¨æµè§ˆå™¨ä¸­è¿è¡Œçš„å°å‹ä¸”å¿«é€Ÿçš„DSLæœ¬èº«å°†éå¸¸æœ‰ç”¨ã€‚è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘å¦‚ä½•æ„å»ºRegHexï¼</p><p>  When jumping into a complex project like this, I typically start at both ends of the processand ask, â€œWhat should the libraryâ€™s API look like?â€ and â€œWhat are the small implementationdetails I need some investigation first?â€ However, planning and starting are two steps that due to procrastination take me quiteâ€¦a considerable amount of time.</p><p>  å½“è¿›å…¥è¿™æ ·ä¸€ä¸ªå¤æ‚çš„é¡¹ç›®æ—¶ï¼Œæˆ‘é€šå¸¸ä»æµç¨‹çš„ä¸¤ç«¯å¼€å§‹ï¼Œé—®ï¼šâ€œåº“çš„APIåº”è¯¥æ˜¯ä»€ä¹ˆæ ·ï¼Ÿâ€å’Œâ€œå°çš„å®æ–½ç»†èŠ‚æ˜¯ä»€ä¹ˆï¼Œæˆ‘é¦–å…ˆéœ€è¦è¿›è¡Œè°ƒæŸ¥ï¼Ÿâ€ä½†æ˜¯ï¼Œè®¡åˆ’å’Œå¼€å§‹æ˜¯ä¸¤ä¸ªæ­¥éª¤ï¼Œç”±äºæ‹–å»¶ï¼Œæˆ‘èŠ±äº†ç›¸å½“å¤šçš„æ—¶é—´ã€‚</p><p> For this project, I came up with the rough idea for it about a year ago in 2019. I then wrote thefirst API design draft in April 2020, and implemented the library a month later in May 2020.I was pretty excited about the idea and have no excuses for this, so letâ€™s just move on. Thefirst draft for the  API design looked something like the following:</p><p> å¯¹äºè¿™ä¸ªé¡¹ç›®ï¼Œæˆ‘å¤§çº¦åœ¨ä¸€å¹´å‰çš„2019å¹´æå‡ºäº†ä¸€ä¸ªç²—ç•¥çš„æƒ³æ³•ã€‚ç„¶åï¼Œæˆ‘åœ¨2020å¹´4æœˆç¼–å†™äº†ç¬¬ä¸€ä¸ªAPIè®¾è®¡è‰æ¡ˆï¼Œå¹¶åœ¨2020å¹´5æœˆä¸€ä¸ªæœˆåå®ç°äº†è¯¥åº“ã€‚æ²¡æœ‰ä»»ä½•å€Ÿå£ï¼Œè®©æˆ‘ä»¬ç»§ç»­å‰è¿›ã€‚ APIè®¾è®¡çš„åˆç¨¿å¦‚ä¸‹æ‰€ç¤ºï¼š</p><p> const identifier  =  match ( &#39;identifier&#39; )  `    ${ / [ -\w ] + / }  ` ; const string  =  match ( &#39;string&#39; )  `  (   ${ / &#34;[^&#34; ] *&#34; / }  |   ${ / &#39;[^&#39; ] *&#39; / }  ) ` ; const values  =  match ( &#39;values&#39; )  `  (   ${identifier }  |   ${string }  )* ` ; // Input: &#34;string&#34; // Output: [[&#39;&#34;string&#34;&#39;, .tag: &#39;string&#39;], .tag: &#39;values&#39;] // Input: ident // Output: [[&#39;ident&#39;, .tag: &#39;identifier&#39;], .tag: &#39;values&#39;]</p><p> const identifier = matchï¼ˆ'identifier'ï¼‰`$ {/ [-\ w] + /}`; const string = matchï¼ˆ'string'ï¼‰`ï¼ˆ$ {/â€œ [^â€] *â€œ /} | $ {/'[^'] *'/}ï¼‰`; const values = matchï¼ˆ'values'ï¼‰`ï¼ˆ $ {identifier} | $ {string}ï¼‰*`; //è¾“å…¥ï¼šâ€œ stringâ€ //è¾“å‡ºï¼š[['â€œ stringâ€'ï¼Œ.tagï¼š'string']ï¼Œ.tagï¼š'values'] //è¾“å…¥ï¼šident //è¾“å‡ºï¼š[['ident'ï¼Œ.tagï¼š'identifier']ï¼Œ.tagï¼š'values']</p><p> The APIâ€™s general idea is to expose a  match function that is called with a parsing grammarâ€™sname. It then is called as a tagged template literal with a regular expression-like grammar,which contains interpolations with either regular expressions or other grammars, which areused to recursively parse bits of the input.The output of  match can then be used to start parsing a string and will return an abstractsyntax tree (â€œASTâ€), nested nodes describing the parsed contents of the input.</p><p> APIçš„ä¸€èˆ¬æƒ³æ³•æ˜¯å…¬å¼€ä¸€ä¸ªä½¿ç”¨è¯­æ³•åˆ†æåç§°è°ƒç”¨çš„matchå‡½æ•°ã€‚ç„¶åå°†å…¶ç§°ä¸ºå¸¦æœ‰æ­£åˆ™è¡¨è¾¾å¼æ ·è¯­æ³•çš„æ ‡è®°æ¨¡æ¿æ–‡å­—ï¼Œå…¶ä¸­åŒ…å«å…·æœ‰æ­£åˆ™è¡¨è¾¾å¼æˆ–å…¶ä»–è¯­æ³•çš„æ’å€¼ï¼Œç”¨äºå¯¹è¾“å…¥çš„ä½è¿›è¡Œé€’å½’è§£æ.matchçš„è¾“å‡ºå¯ç”¨äºå¼€å§‹è§£æaå­—ç¬¦ä¸²ï¼Œå¹¶å°†è¿”å›ä¸€ä¸ªæŠ½è±¡è¯­æ³•æ ‘ï¼ˆâ€œ ASTâ€ï¼‰ï¼Œè¯¥åµŒå¥—èŠ‚ç‚¹æè¿°è¾“å…¥çš„è§£æå†…å®¹ã€‚</p><p> To control the logic of how inputs are parsed around the interpolations â€œoperatorsâ€ similarto a regular expression syntax are used, while regular expressions will match at the currentindex of the input. Since regular expression syntax is common in parser generators and isfamiliar to many, it felt rather natural to write, e.g.  | for matching something elseif the first part of a group didnâ€™t match, or  * to allow for multiple matches.</p><p> ä¸ºäº†æ§åˆ¶å¦‚ä½•åœ¨æ’å€¼å‘¨å›´è§£æè¾“å…¥çš„é€»è¾‘ï¼Œä½¿ç”¨äº†ç±»ä¼¼äºæ­£åˆ™è¡¨è¾¾å¼è¯­æ³•çš„â€œè¿ç®—ç¬¦â€ï¼Œè€Œæ­£åˆ™è¡¨è¾¾å¼å°†åœ¨è¾“å…¥çš„å½“å‰ç´¢å¼•å¤„åŒ¹é…ã€‚ç”±äºæ­£åˆ™è¡¨è¾¾å¼è¯­æ³•åœ¨è§£æå™¨ç”Ÿæˆå™¨ä¸­å¾ˆå¸¸è§ï¼Œå¹¶ä¸”å¯¹è®¸å¤šè¯­æ³•ç”Ÿæˆå™¨æ¥è¯´éƒ½å¾ˆç†Ÿæ‚‰ï¼Œå› æ­¤ç¼–å†™ä¾‹å¦‚|å¦‚æœç»„çš„ç¬¬ä¸€éƒ¨åˆ†ä¸åŒ¹é…ï¼Œåˆ™ç”¨äºåŒ¹é…å…¶ä»–å†…å®¹ï¼›æˆ–*å…è®¸å¤šä¸ªåŒ¹é…ã€‚</p><p>  This initial draft revealed a crucial feature of my planned API. Because I chose to embedthe parsing grammar into JS code via a tagged template literal, the draft started lookinglike a â€œparser combinatorâ€. In short,  parser combinatorsare functions that accept other parsers as inputs and return a new parser. In this case, matchâ€™s template optionally accepts other  match parsers as interpolations.</p><p>æ­¤åˆç¨¿æ˜¾ç¤ºäº†æˆ‘è®¡åˆ’çš„APIçš„å…³é”®åŠŸèƒ½ã€‚å› ä¸ºæˆ‘é€‰æ‹©é€šè¿‡æ ‡è®°çš„æ¨¡æ¿æ–‡å­—å°†è§£æè¯­æ³•åµŒå…¥JSä»£ç ï¼Œæ‰€ä»¥è‰ç¨¿å¼€å§‹çœ‹èµ·æ¥åƒâ€œè§£æå™¨ç»„åˆå™¨â€ã€‚ç®€è€Œè¨€ä¹‹ï¼Œè§£æå™¨ç»„åˆå™¨æ˜¯æ¥å—å…¶ä»–è§£æå™¨ä½œä¸ºè¾“å…¥å¹¶è¿”å›æ–°è§£æå™¨çš„å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¯”èµ›çš„æ¨¡æ¿å¯ä»¥é€‰æ‹©æ¥å—å…¶ä»–æ¯”èµ›è§£æå™¨ä½œä¸ºæ’å€¼ã€‚</p><p> The grammar in the draft API states that either an identifier or a string matches as often as possible, while the two are grammars of their own too.</p><p> APIè‰æ¡ˆä¸­çš„è¯­æ³•æŒ‡å‡ºï¼Œæ ‡è¯†ç¬¦æˆ–å­—ç¬¦ä¸²å°½å¯èƒ½åŒ¹é…ï¼Œè€Œä¸¤è€…ä¹Ÿæ˜¯å®ƒä»¬è‡ªå·±çš„è¯­æ³•ã€‚</p><p> In short, parser combinators are functions that accept other parsers as inputs andreturn a new parser.</p><p> ç®€è€Œè¨€ä¹‹ï¼Œè§£æå™¨ç»„åˆå™¨æ˜¯æ¥å—å…¶ä»–è§£æå™¨ä½œä¸ºè¾“å…¥å¹¶è¿”å›æ–°è§£æå™¨çš„å‡½æ•°ã€‚</p><p> This allows a larger parser to be gradually composed from smaller, reusable bits of grammar, whichalso narrows down the task of generating parsing code to one small  match tag at a time. Asan API, this is what made tagged template literals a really compelling choice. To me, this feltsimilar to how styled-components splits up CSS for separate components, each rendering a singleelement with their own styles. ğŸ¤© Tagged template literals naturally force a libraryâ€™sAPI to  simplify and split up the exposed API surface.</p><p> è¿™å…è®¸è¾ƒå¤§çš„è§£æå™¨ç”±è¾ƒå°çš„å¯é‡ç”¨è¯­æ³•ä½é€æ¸ç»„æˆï¼Œè¿™ä¹Ÿå°†ä¸€æ¬¡ç”Ÿæˆè§£æä»£ç çš„ä»»åŠ¡çš„èŒƒå›´ç¼©å°åˆ°ä¸€ä¸ªå°çš„åŒ¹é…æ ‡è®°ã€‚ä½œä¸ºAsan APIï¼Œè¿™å°±æ˜¯ä½¿æ ‡è®°æ¨¡æ¿æ–‡å­—æˆä¸ºçœŸæ­£å¼•äººæ³¨ç›®çš„é€‰æ‹©çš„åŸå› ã€‚å¯¹æˆ‘æ¥è¯´ï¼Œè¿™ç±»ä¼¼äºæ ·å¼åŒ–ç»„ä»¶å¦‚ä½•å°†CSSæ‹†åˆ†ä¸ºå•ç‹¬çš„ç»„ä»¶ï¼Œæ¯ä¸ªç»„ä»¶éƒ½ä½¿ç”¨è‡ªå·±çš„æ ·å¼æ¥å‘ˆç°å•ä¸ªå…ƒç´ ã€‚ ğŸ¤©å¸¦æœ‰æ ‡ç­¾çš„æ¨¡æ¿æ–‡å­—è‡ªç„¶ä¼šè¿«ä½¿åº“çš„APIç®€åŒ–å¹¶æ‹†åˆ†æš´éœ²çš„APIè¡¨é¢ã€‚</p><p>  So far, the parser generator works by creating smaller pieces of grammar, defined by interpolatingother small matching grammars or regular expressions. Intuitively, the most straightforwardapproach to generate code from this would be to only transpile the pieces of grammar in thetemplate string, and to  reuse the interpolated regular expressions as is. Doing so withoutskipping over any characters in the input string is crucial however.</p><p>  åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè§£æå™¨ç”Ÿæˆå™¨é€šè¿‡åˆ›å»ºè¾ƒå°çš„è¯­æ³•ç‰‡æ®µæ¥å·¥ä½œï¼Œè¿™äº›è¯­æ³•ç‰‡æ®µæ˜¯é€šè¿‡æ’å€¼å…¶ä»–å°çš„åŒ¹é…è¯­æ³•æˆ–æ­£åˆ™è¡¨è¾¾å¼æ¥å®šä¹‰çš„ã€‚ç›´è§‚åœ°è®²ï¼Œä»ä¸­ç”Ÿæˆä»£ç çš„æœ€ç›´æ¥æ–¹æ³•æ˜¯ä»…åœ¨æ¨¡æ¿å­—ç¬¦ä¸²ä¸­è½¬æ¢è¯­æ³•ç‰‡æ®µï¼Œå¹¶æŒ‰åŸæ ·é‡ç”¨å†…æ’çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚ä½†æ˜¯ï¼Œè¿™æ ·åšçš„å‰ææ˜¯ä¸è·³è¿‡è¾“å…¥å­—ç¬¦ä¸²ä¸­çš„ä»»ä½•å­—ç¬¦ã€‚</p><p> Executing a regular expression typically scans over an input string until a match is found,which is both costly and counter to how a parser works. Instead of scanning the string, whatthe parser generator needs is to attempt to match the regular expression only at an exactlocation. Luckily, in  ECMAScript 6 support for the  â€œstickyflagâ€was added, which does just that:</p><p> æ‰§è¡Œæ­£åˆ™è¡¨è¾¾å¼é€šå¸¸ä¼šæ‰«æè¾“å…¥å­—ç¬¦ä¸²ï¼Œç›´åˆ°æ‰¾åˆ°åŒ¹é…ä¸ºæ­¢ï¼Œè¿™æ—¢æ˜‚è´µåˆä¸è§£æå™¨çš„å·¥ä½œæ–¹å¼èƒŒé“è€Œé©°ã€‚è€Œä¸æ˜¯æ‰«æå­—ç¬¦ä¸²ï¼Œè§£æå™¨ç”Ÿæˆå™¨éœ€è¦çš„æ˜¯å°è¯•ä»…åœ¨ç²¾ç¡®ä½ç½®ä¸ŠåŒ¹é…æ­£åˆ™è¡¨è¾¾å¼ã€‚å¹¸è¿çš„æ˜¯ï¼Œåœ¨ECMAScript 6ä¸­æ·»åŠ äº†å¯¹â€œ stickyflagâ€çš„æ”¯æŒï¼Œå®ƒçš„ä½œç”¨æ˜¯ï¼š</p><p> const regex  =  new   ( &#39;hi&#39; ,  &#39;y&#39; ) ; const input  =  &#39;oh hi&#39; ;regex . lastIndex  =  0 ;regex . exec (input ) ;  // nullregex . lastIndex  =  3 ;regex . exec (input ) ;  // [&#39;hi&#39;, index: 3]regex . lastIndex ;  // 5</p><p> const regex = newï¼ˆ'hi'ï¼Œ'y'ï¼‰; const input ='å“¦å—¨';æ­£åˆ™è¡¨è¾¾å¼ã€‚ lastIndex = 0; regexã€‚ execï¼ˆè¾“å…¥ï¼‰; // nullregexã€‚ lastIndex = 3; regexã€‚ execï¼ˆè¾“å…¥ï¼‰; // ['hi'ï¼Œç´¢å¼•ï¼š3] regexã€‚ lastIndex; // 5</p><p> The  lastIndex property now indicates where the regular expression should be executed,rather than where it should start searching the input string. As usual, the index isalso moved along if the regular expression has successfully matched a part of the inputstring. This lends itself very well to building a continuous parser combinator thatconsists mostly of regular expressions and some branches and loops, and enables theparser generator to only transpile our custom DSL rather than also reimplementingregular expressions.</p><p>ç°åœ¨ï¼ŒlastIndexå±æ€§æŒ‡ç¤ºåº”åœ¨ä½•å¤„æ‰§è¡Œæ­£åˆ™è¡¨è¾¾å¼ï¼Œè€Œä¸æ˜¯ä»ä½•å¤„å¼€å§‹æœç´¢è¾“å…¥å­—ç¬¦ä¸²ã€‚ä¸å¾€å¸¸ä¸€æ ·ï¼Œå¦‚æœæ­£åˆ™è¡¨è¾¾å¼å·²æˆåŠŸåŒ¹é…è¾“å…¥å­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™ç´¢å¼•ä¹Ÿä¼šéšä¹‹ç§»åŠ¨ã€‚è¿™éå¸¸é€‚åˆäºæ„å»ºä¸€ä¸ªè¿ç»­çš„è§£æå™¨ç»„åˆå™¨ï¼Œè¯¥ç»„åˆå™¨ä¸»è¦ç”±æ­£åˆ™è¡¨è¾¾å¼ä»¥åŠä¸€äº›åˆ†æ”¯å’Œå¾ªç¯ç»„æˆï¼Œå¹¶ä½¿è§£æå™¨ç”Ÿæˆå™¨ä»…èƒ½å¤Ÿè½¬æ¢æˆ‘ä»¬çš„è‡ªå®šä¹‰DSLï¼Œè€Œä¸å¿…é‡æ–°å®ç°æ­£åˆ™è¡¨è¾¾å¼ã€‚</p><p>  Starting the implementation of this parser generator, this is where things become  meta.Since  matchâ€™s tagged template API Iâ€™ve outlined is in itself a language that looks likeregular expression syntax, a small parser for this DSL is necessary. Luckily, the syntaxthat this particular DSL has to support is rather small and hence the parser ended up beingquite easy to write and compact too.RegHexâ€™s DSL was set to support  quantifiers, various types of groups,and alternations. As Iâ€™ve decided in the design process early on, it would be whitespaceinsignificant fore readability. Hereâ€™s a small overview of the operators that ended upin the DSLâ€™s syntax:</p><p>  å¼€å§‹æ‰§è¡Œæ­¤è§£æå™¨ç”Ÿæˆå™¨åï¼Œäº‹æƒ…å°±å˜æˆäº†å…ƒæ•°æ®ã€‚ç”±äºæˆ‘æ¦‚è¿°çš„åŒ¹é…æ ‡ç­¾æ¨¡æ¿APIæœ¬èº«å°±æ˜¯ä¸€ç§ç±»ä¼¼äºæ­£åˆ™è¡¨è¾¾å¼è¯­æ³•çš„è¯­è¨€ï¼Œå› æ­¤éœ€è¦ç”¨äºæ­¤DSLçš„å°å‹è§£æå™¨ã€‚å¹¸è¿çš„æ˜¯ï¼Œè¯¥ç‰¹å®šDSLå¿…é¡»æ”¯æŒçš„è¯­æ³•å¾ˆå°ï¼Œå› æ­¤è§£æå™¨æœ€ç»ˆä¹Ÿå˜å¾—å¾ˆå®¹æ˜“ç¼–å†™å’Œå‹ç¼©ã€‚RegHexçš„DSLè¢«è®¾ç½®ä¸ºæ”¯æŒé‡è¯ï¼Œå„ç§ç±»å‹çš„ç»„å’Œæ›¿æ¢ã€‚æ­£å¦‚æˆ‘æ—©åœ¨è®¾è®¡è¿‡ç¨‹ä¸­æ‰€å†³å®šçš„é‚£æ ·ï¼Œå®ƒå¯¹äºç©ºæ ¼çš„å¯è¯»æ€§æ„ä¹‰ä¸å¤§ã€‚ä»¥ä¸‹æ˜¯ä»¥DSLè¯­æ³•ç»“å°¾çš„è¿è¥å•†çš„ç®€è¦æ¦‚è¿°ï¼š</p><p> A  quantifier may be used to change how many matches are accepted, in order: one or none, one or more, or any amount.</p><p> é‡è¯å¯ç”¨äºæŒ‰é¡ºåºæ›´æ”¹æ¥å—å¤šå°‘ä¸ªåŒ¹é…ï¼šä¸€ä¸ªæˆ–ä¸€ä¸ªï¼Œä¸€ä¸ªæˆ–å¤šä¸ªæˆ–ä»»æ„æ•°é‡ã€‚</p><p> An  alternation can be used to match either one thing or another, falling back when the first interpolation fails.</p><p> äº¤æ›¿å¯ç”¨äºåŒ¹é…äº‹ç‰©ï¼Œå½“ç¬¬ä¸€ä¸ªæ’å€¼å¤±è´¥æ—¶å›é€€ã€‚</p><p> A  non-capturing group is like a regular group, but the interpolations matched inside it donâ€™t appear in the parserâ€™s output.</p><p> éæ•è·ç»„ç±»ä¼¼äºå¸¸è§„ç»„ï¼Œä½†æ˜¯å†…éƒ¨åŒ¹é…çš„æ’å€¼ä¸ä¼šå‡ºç°åœ¨è§£æå™¨çš„è¾“å‡ºä¸­ã€‚</p><p> A  positive lookahead checks whether interpolations match, and if so continues the matcher without changing the input. If it matches, itâ€™s essentially ignored.</p><p> æ­£å‰ç»å°†æ£€æŸ¥æ’å€¼æ˜¯å¦åŒ¹é…ï¼Œå¦‚æœåŒ¹é…ï¼Œåˆ™åŒ¹é…å™¨å°†ç»§ç»­è¿è¡Œè€Œä¸ä¼šæ›´æ”¹è¾“å…¥ã€‚å¦‚æœåŒ¹é…ï¼Œåˆ™åŸºæœ¬ä¸Šè¢«å¿½ç•¥ã€‚</p><p> A  negative lookahead checks whether interpolations  donâ€™t match, and if so continues the matcher without changing the input. If the interpolations do match the matcher is aborted.</p><p> å¦å®šçš„è¶…å‰æ£€æŸ¥ä¼šæ£€æŸ¥æ’å€¼æ˜¯å¦ä¸åŒ¹é…ï¼Œå¦‚æœåŒ¹é…ä¸åŒ¹é…ï¼Œåˆ™åŒ¹é…å™¨å°†ç»§ç»­è€Œä¸æ›´æ”¹è¾“å…¥ã€‚å¦‚æœæ’å€¼åŒ¹é…ï¼ŒåŒ¹é…å™¨å°†ä¸­æ­¢ã€‚</p><p> Arguably, the most important feature of this syntax listed above is undoubtedly alternations,since a parser that canâ€™t match several alternative patterns, wonâ€™t be able to express anyuseful grammar. Letâ€™s look at an example of the RegHex DSL in action with a grammar thatmatches strings of repeated â€œthisâ€s and â€œthatâ€s:</p><p>å¯ä»¥è¯´ï¼Œä¸Šé¢åˆ—å‡ºçš„è¿™ç§è¯­æ³•çš„æœ€é‡è¦ç‰¹å¾æ— ç–‘æ˜¯äº¤æ›¿ï¼Œå› ä¸ºè§£æå™¨æ— æ³•åŒ¹é…å‡ ç§æ›¿ä»£æ¨¡å¼ï¼Œå› æ­¤æ— æ³•è¡¨è¾¾ä»»ä½•æœ‰ç”¨çš„è¯­æ³•ã€‚è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªRegHex DSLçš„ç¤ºä¾‹ï¼Œè¯¥DSLçš„è¯­æ³•ä¸é‡å¤çš„â€œ thisâ€å’Œâ€œ thatâ€å­—ç¬¦ä¸²åŒ¹é…ï¼š</p><p> const thisThat  =  match ( &#39;thisThat&#39; )  `  (?:   ${ /and / } ) ( ((?!   ${ / . *that / } )   ${ / this / } +) | ((?!   ${ / . * this / } )   ${ /that / } +) ) ` ;</p><p> const thisThat = matchï¼ˆ'thisThat'ï¼‰`ï¼ˆï¼Ÿï¼š$ {/ and /}ï¼‰ï¼ˆï¼ˆï¼ˆï¼Ÿï¼$ {/ã€‚* that /}ï¼‰$ {/ this /} +ï¼‰|ï¼ˆï¼ˆï¼Ÿï¼$ {/ * * this /}ï¼‰$ {/ that /} +ï¼‰ï¼‰`;</p><p> This snippet will only match a given input if it starts with â€œandâ€. However, â€œandâ€ is in anon-capturing group and wonâ€™t be output to the AST node. It then matches either a repetitionof â€œthisâ€ or a repetition of â€œthatâ€. There are negative lookahead groups which will makesure that we  donâ€™t unnecessarily start parsing the entire string if any of the repeatedsequences contain both â€œthisâ€ and â€œthatâ€.</p><p> å¦‚æœæ­¤ä»£ç æ®µä»¥â€œ andâ€å¼€å¤´ï¼Œåˆ™åªä¼šåŒ¹é…ç»™å®šçš„è¾“å…¥ã€‚ä½†æ˜¯ï¼Œâ€œ andâ€å±äºéæ•è·ç»„ï¼Œä¸ä¼šè¾“å‡ºåˆ°ASTèŠ‚ç‚¹ã€‚ç„¶åï¼Œå®ƒåŒ¹é…â€œ thisâ€çš„é‡å¤æˆ–â€œ thatâ€çš„é‡å¤ã€‚å¦å®šçš„å‰ç»æ€§ç»„å°†ç¡®ä¿ï¼Œå¦‚æœä»»ä½•é‡å¤åºåˆ—åŒæ—¶åŒ…å«â€œ thisâ€å’Œâ€œ thatâ€ï¼Œæˆ‘ä»¬å°±ä¸å¿…ä¸å¿…è¦åœ°å¼€å§‹è§£ææ•´ä¸ªå­—ç¬¦ä¸²ã€‚</p><p> Given that this is very similar to the behaviour of regular expressions and fairlyconcise this made me pretty optimistic in that this would be a usable syntax and API.</p><p> é‰´äºè¿™ä¸æ­£åˆ™è¡¨è¾¾å¼çš„è¡Œä¸ºéå¸¸ç›¸ä¼¼å¹¶ä¸”éå¸¸ç®€æ´ï¼Œè¿™ä½¿æˆ‘éå¸¸ä¹è§‚ï¼Œå› ä¸ºè¿™å°†æ˜¯å¯ç”¨çš„è¯­æ³•å’ŒAPIã€‚</p><p> A diagram of our longer grammar of the matcher as shown in the code snippet above.</p><p> ä¸Šé¢çš„ä»£ç æ®µä¸­æ˜¾ç¤ºçš„åŒ¹é…å™¨è¾ƒé•¿è¯­æ³•çš„å›¾ã€‚</p><p>  Finally, the last part of the endeavour was writing the Babel plugin code which would pickup all written grammars and replace them with parsing code. While writing the Babel codeitself wasnâ€™t too hard, since I had some experience writing Babel plugins before, becauseone of the goals was to generate small &amp; quick code for the DSL, deciding  what the generatedparsing codeâ€™s patterns should be proved to be a little tricky. I decided early on togenerate code that is as compact as possible, which meant to me that each usage of  matchshould be compiled to only  a single function.</p><p>  æœ€åï¼Œå·¥ä½œçš„æœ€åä¸€éƒ¨åˆ†æ˜¯ç¼–å†™Babelæ’ä»¶ä»£ç ï¼Œè¯¥ä»£ç å°†æå–æ‰€æœ‰å·²ç¼–å†™çš„è¯­æ³•å¹¶å°†å…¶æ›¿æ¢ä¸ºè§£æä»£ç ã€‚è™½ç„¶è‡ªå·±ç¼–å†™Babelä»£ç å¹¶ä¸éš¾ï¼Œä½†ç”±äºæˆ‘ä¹‹å‰æœ‰ç¼–å†™Babelæ’ä»¶çš„ç»éªŒï¼Œå› ä¸ºç›®æ ‡ä¹‹ä¸€æ˜¯ä¸ºDSLç”Ÿæˆå°å‹å¿«é€Ÿä»£ç ï¼Œç¡®å®šåº”è¯æ˜ç”Ÿæˆçš„è§£æä»£ç çš„æ¨¡å¼æœ‰äº›æ£˜æ‰‹ã€‚æˆ‘å¾ˆæ—©å°±å†³å®šç”Ÿæˆå°½å¯èƒ½ç´§å‡‘çš„ä»£ç ï¼Œè¿™å¯¹æˆ‘æ¥è¯´æ„å‘³ç€matchçš„æ¯æ¬¡ä½¿ç”¨éƒ½åº”ç¼–è¯‘ä¸ºä¸€ä¸ªå‡½æ•°ã€‚</p><p> There are a lot of places in the parsing grammar where one part of the match may beunsuccessful and will jump to another â€” mostly due to alternations around groups.This means that there may be chained interpolations that the generated function willstart to match and, after failing, may give up on while skipping to the next partof the grammar after an alternation.</p><p> è§£æè¯­æ³•ä¸­æœ‰å¾ˆå¤šåœ°æ–¹åŒ¹é…çš„ä¸€éƒ¨åˆ†å¯èƒ½ä¸æˆåŠŸï¼Œå¹¶ä¸”ä¼šè·³è½¬åˆ°å¦ä¸€éƒ¨åˆ†-ä¸»è¦æ˜¯ç”±äºç»„å‘¨å›´çš„äº¤æ›¿ã€‚è¿™æ„å‘³ç€å¯èƒ½ä¼šæœ‰é“¾å¼æ’å€¼ï¼Œç”Ÿæˆçš„å‡½æ•°å°†å¼€å§‹åŒ¹é…ï¼Œå¹¶ä¸”åœ¨å¤±è´¥ä¹‹åï¼Œå¯èƒ½ä¼šåœ¨äº¤æ›¿åè·³åˆ°è¯­æ³•çš„ä¸‹ä¸€éƒ¨åˆ†æ—¶æ”¾å¼ƒã€‚</p><p>  For instance, given the above code, the grammar may match  1 and then repeatedly  2.However if at any point of the first part this grammar fails to match against theinput string, the function will still need to attempt to match  3. It needs to skipto  | ${3} and ensure that any results from the previously failed attempt arediscarded.</p><p>ä¾‹å¦‚ï¼Œç»™å®šä¸Šè¿°ä»£ç ï¼Œè¯­æ³•å¯èƒ½å…ˆåŒ¹é…1ï¼Œç„¶åé‡å¤2ã€‚ä½†æ˜¯ï¼Œå¦‚æœåœ¨ç¬¬ä¸€éƒ¨åˆ†çš„ä»»ä½•ä¸€ç‚¹ä¸Šè¯¥è¯­æ³•ä¸è¾“å…¥å­—ç¬¦ä¸²ä¸åŒ¹é…ï¼Œåˆ™è¯¥å‡½æ•°ä»éœ€è¦å°è¯•åŒ¹é…3ã€‚å®ƒéœ€è¦skipto | $ {3}ï¼Œå¹¶ç¡®ä¿ä¸¢å¼ƒå…ˆå‰å°è¯•å¤±è´¥çš„ç»“æœã€‚</p><p>  Investigating some potential patterns for this problem, I discovered that just asingle solution seems to exist to have this amount of control in a single function,and this solution is â€” what Iâ€™d consider â€” quite an archaic language feature inJavaScript:  Labelled Block Statements.</p><p>  åœ¨ç ”ç©¶è¯¥é—®é¢˜çš„ä¸€äº›æ½œåœ¨æ¨¡å¼æ—¶ï¼Œæˆ‘å‘ç°ä¼¼ä¹åªæœ‰ä¸€ä¸ªè§£å†³æ–¹æ¡ˆå¯ä»¥åœ¨å•ä¸ªå‡½æ•°ä¸­æ‹¥æœ‰å¦‚æ­¤å¤šçš„æ§åˆ¶æƒï¼Œè€Œè¯¥è§£å†³æ–¹æ¡ˆï¼ˆæˆ‘è®¤ä¸ºï¼‰æ˜¯JavaScriptä¸­çš„ä¸€ç§å¤è€çš„è¯­è¨€åŠŸèƒ½ï¼šLabeled Block Statementsã€‚</p><p> We may not see this feature very often in handwritten JavaScript code, but anyloop or block may be annotated using a label. Once we have a label we may breakout of it by calling  break.</p><p> æˆ‘ä»¬å¯èƒ½ä¸ä¼šåœ¨æ‰‹å†™JavaScriptä»£ç ä¸­ç»å¸¸çœ‹åˆ°æ­¤åŠŸèƒ½ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨æ ‡ç­¾å¯¹anyloopæˆ–blockè¿›è¡Œæ³¨é‡Šã€‚ä¸€æ—¦æœ‰äº†æ ‡ç­¾ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨breakçªç ´å®ƒã€‚</p><p> loop1 :  for  ( let i  =  0 ; i  &lt;  3 ; i ++ )  { loop2 :  for  ( let j  =  0 ; j  &lt;  3 ; j ++ )  {  if  (i  ===  1  &amp;&amp; j  ===  1 )  break loop1 ;  } }</p><p> loop1ï¼šforï¼ˆä»¤i = 0; i <3; i ++ï¼‰{loop2ï¼šforï¼ˆä»¤j = 0; j <3; j ++ï¼‰{ifï¼ˆi === 1 && j === 1ï¼‰ä¸­æ–­loop1; }}</p><p> This is quite useful for generated code that is trying to avoid additional functionsin its code output. However, if you use labels in your code a reviewer may likelyjust either complain or even exclaim in confusion. ğŸ¤· As  MDN putsitin their explanation of labelled statements:</p><p> è¿™å¯¹äºè¯•å›¾åœ¨å…¶ä»£ç è¾“å‡ºä¸­é¿å…é™„åŠ åŠŸèƒ½çš„ç”Ÿæˆä»£ç éå¸¸æœ‰ç”¨ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨åœ¨ä»£ç ä¸­ä½¿ç”¨æ ‡ç­¾ï¼Œåˆ™å®¡é˜…è€…å¯èƒ½ä¼šæ„Ÿåˆ°å›°æƒ‘ç”šè‡³æŠ±æ€¨ç”šè‡³æƒŠå¹ã€‚ Mæ­£å¦‚MDNæ‰€è¯´ï¼Œä»–ä»¬å¯¹å¸¦æ ‡ç­¾çš„é™ˆè¿°çš„è§£é‡Šæ˜¯ï¼š</p><p> â€œLabelled loops or blocks are very uncommon. Usually, function calls can be used instead of loop jumps.â€</p><p> ç¼©ç¯æˆ–å—å¾ˆå°‘è§ã€‚é€šå¸¸ï¼Œå¯ä»¥ä½¿ç”¨å‡½æ•°è°ƒç”¨æ¥ä»£æ›¿å¾ªç¯è·³è½¬ã€‚â€</p><p>  The Babel  code I wrotewasnâ€™t much of a surprise at this point â€” although it did end up becoming messy â€” andsplits each part of the grammar into a separate â€œNode Classâ€, specialised in acceptinga part of  the parsed meta DSL and outputting generated code justfor this part of the grammar. Some classes of nodes are  QuantifierNode,  AlternationNode,or  GroupNode.</p><p>  æˆ‘å†™çš„Babelä»£ç åœ¨è¿™ä¸€ç‚¹ä¸Šå¹¶ä¸ä»¤äººæƒŠè®¶-å°½ç®¡å®ƒæœ€ç»ˆå˜å¾—ä¸€å›¢ç³Ÿ-å¹¶å°†è¯­æ³•çš„æ¯ä¸ªéƒ¨åˆ†æ‹†åˆ†ä¸ºä¸€ä¸ªå•ç‹¬çš„â€œèŠ‚ç‚¹ç±»â€ï¼Œä¸“é—¨ç”¨äºæ¥å—å·²è§£æçš„å…ƒDSLçš„ä¸€éƒ¨åˆ†å¹¶è¾“å‡ºç”Ÿæˆçš„ä»£ç åªä¸ºè¿™éƒ¨åˆ†è¯­æ³•ã€‚æŸäº›ç±»åˆ«çš„èŠ‚ç‚¹ä¸ºQuantifierNodeï¼ŒAlternationNodeæˆ–GroupNodeã€‚</p><p> The resulting output of the  earlier example lookslike the following. Iâ€™ve annotated and modified the code snippet to be easier to read:</p><p>å…ˆå‰ç¤ºä¾‹çš„ç»“æœè¾“å‡ºå¦‚ä¸‹æ‰€ç¤ºã€‚æˆ‘å·²æ³¨é‡Šå¹¶ä¿®æ”¹äº†ä»£ç æ®µï¼Œä»¥ä½¿å…¶æ›´æ˜“äºé˜…è¯»ï¼š</p><p> // A helper function to execute sticky regexes and return the matched string import   { _exec  }  from  &#34;reghex&#34; ; const  parser  =  function  _parsed ( state )  {  // This creates the AST node, which is an array with a tag  const node  =  [ ] ; node . tag  =  &#34;parsed&#34; ;  let last_index  = state . index ;  let match ;  // This &#34;block_0&#34; contains the first group of our grammar block_0 :  {  var index_0  = state . index ;  var length_0  = node . length ;  // We first attempt to match &#34;1&#34;  if  (match  =  _exec (state ,   / 1 / y ) )  { node . push (match ) ;  }  else  {  // If we fail, we restore the node as it was, and break out of &#34;block_0&#34; node . length  = length_0 ; state . index  = index_0 ;  break block_0 ;  }  // We then attempt to match &#34;2&#34; repeatedly loop_1 :  for  ( var i  =  0 ;  true ; i ++ )  {  var index_1  = state . index ;  // Note that the matching itself is done the same, even in a loop  if  (match  =  _exec (state ,   / 2 / y ) )  { node . push (match ) ;  }  else  {  // If we had results we&#39;re good and can end the loop  if  (iter_1 )  { state . index  = index_1 ;  break loop_1 ;  }  // If we didn&#39;t, we again restore the node, and break out of &#34;block_0&#34; node . length  = length_0 ; state . index  = index_0 ;  break block_0 ;  }  }  // If we get here the first group matched. Success!  return node ;  }  // This is the second part of our grammar, where we attempt to match &#34;3&#34;  if  (match  =  _exec (state ,   / 3 / y ) )  { node . push (match ) ;  }  else  {  // there&#39;s nothing left anymore since the grammar is over  // restore the the index from before any matchers ran and return state . index  = last_index ;  return ;  }  // We matched a &#34;3&#34;. Success!  return node ; } ;</p><p> //ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œç”¨äºæ‰§è¡Œç²˜æ€§æ­£åˆ™è¡¨è¾¾å¼å¹¶ä»â€œ reghexâ€è¿”å›åŒ¹é…çš„å­—ç¬¦ä¸²import {_exec}ï¼› const parser = function _parsedï¼ˆstateï¼‰{//è¿™å°†åˆ›å»ºASTèŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹æ˜¯å¸¦æœ‰æ ‡ç­¾çš„æ•°ç»„const node = [];èŠ‚ç‚¹ã€‚ tag =â€œå·²è§£æâ€ï¼›è®©last_index = stateã€‚æŒ‡æ ‡;è®©æ¯”èµ›; //è¿™ä¸ªâ€œ block_0â€åŒ…å«æˆ‘ä»¬è¯­æ³•çš„ç¬¬ä¸€ç»„block_0ï¼š{var index_0 = stateã€‚æŒ‡æ ‡; var length_0 =èŠ‚ç‚¹ã€‚é•¿åº¦ ; // //å¦‚æœï¼ˆmatch = _execï¼ˆstateï¼Œ/ 1 / yï¼‰ï¼‰{nodeï¼Œæˆ‘ä»¬é¦–å…ˆå°è¯•åŒ¹é…â€œ 1â€ã€‚æ¨ï¼ˆæ¯”èµ›ï¼‰; } else {//å¦‚æœå¤±è´¥ï¼Œæˆ‘ä»¬å°†æŒ‰åŸæ ·è¿˜åŸè¯¥èŠ‚ç‚¹ï¼Œç„¶åè„±ç¦»â€œ block_0â€ nodeã€‚é•¿åº¦= length_0;çŠ¶æ€ã€‚ç´¢å¼•=ç´¢å¼•_0;æ‰“ç ´block_0; } //ç„¶åï¼Œæˆ‘ä»¬å°è¯•åå¤åŒ¹é…loop_1çš„â€œ 2â€ï¼šforï¼ˆvar i = 0; true; i ++ï¼‰{var index_1 = stateã€‚æŒ‡æ ‡; // //æ³¨æ„ï¼Œå³ä½¿ï¼ˆmatch = _execï¼ˆstateï¼Œ/ 2 / yï¼‰ï¼‰{nodeï¼Œå³ä½¿åœ¨å¾ªç¯ä¸­ï¼ŒåŒ¹é…æœ¬èº«ä¹Ÿæ˜¯ä¸€æ ·ã€‚æ¨ï¼ˆæ¯”èµ›ï¼‰; } else {//å¦‚æœæˆ‘ä»¬æœ‰ç»“æœï¼Œæˆ‘ä»¬å°±å¾ˆå¥½ï¼Œå¦‚æœï¼ˆiter_1ï¼‰{stateï¼Œå¯ä»¥ç»“æŸå¾ªç¯ã€‚ index = index_1;ä¸­æ–­loop_1; } //å¦‚æœæ²¡æœ‰ï¼Œåˆ™å†æ¬¡è¿˜åŸè¯¥èŠ‚ç‚¹ï¼Œç„¶åè„±ç¦»â€œ block_0â€èŠ‚ç‚¹ã€‚é•¿åº¦= length_0;çŠ¶æ€ã€‚ç´¢å¼•=ç´¢å¼•_0;æ‰“ç ´block_0; }} //å¦‚æœåˆ°è¾¾æ­¤å¤„ï¼Œåˆ™ç¬¬ä¸€ä¸ªç»„åŒ¹é…ã€‚æˆåŠŸï¼è¿”å›èŠ‚ç‚¹; } //è¿™æ˜¯è¯­æ³•çš„ç¬¬äºŒéƒ¨åˆ†ï¼Œå¦‚æœï¼ˆmatch = _execï¼ˆstateï¼Œ/ 3 / yï¼‰ï¼‰{nodeï¼Œæˆ‘ä»¬å°è¯•åŒ¹é…â€œ 3â€ã€‚æ¨ï¼ˆæ¯”èµ›ï¼‰; } else {//è‡ªä»è¯­æ³•ç»“æŸä»¥æ¥ï¼Œå·²ç»ä¸€æ— æ‰€æœ‰// //ä»åŒ¹é…å™¨è¿è¡Œå¹¶è¿”å›stateä¹‹å‰æ¢å¤ç´¢å¼•ã€‚ç´¢å¼•= last_index;å›æŠ¥; } //æˆ‘ä»¬åŒ¹é…äº†â€œ 3â€ã€‚æˆåŠŸï¼è¿”å›èŠ‚ç‚¹; };</p><p> In general,  each sequence that RegHex generatesfollows this same pattern of setting up a block, adding the prior index and node length to it,and then adding in the rest of the grammar recursively. It passes on a  break statement tothe lower nodes, which those can use to break out of a block.</p><p> é€šå¸¸ï¼ŒRegHexç”Ÿæˆçš„æ¯ä¸ªåºåˆ—éƒ½éµå¾ªä»¥ä¸‹ç›¸åŒçš„æ¨¡å¼ï¼šå»ºç«‹ä¸€ä¸ªå—ï¼Œå‘å…¶æ·»åŠ å…ˆéªŒç´¢å¼•å’ŒèŠ‚ç‚¹é•¿åº¦ï¼Œç„¶åé€’å½’åœ°æ·»åŠ å…¶ä½™è¯­æ³•ã€‚å®ƒä¼šå°†breakè¯­å¥ä¼ é€’åˆ°è¾ƒä½çš„èŠ‚ç‚¹ï¼Œè¿™äº›è¾ƒä½çš„èŠ‚ç‚¹å¯ç”¨äºä¸­æ–­ä¸€ä¸ªå—ã€‚</p><p> If you use labelled block statements in your code a reviewer may likely just either complainor even exclaim in confusion. ğŸ¤·</p><p> å¦‚æœæ‚¨åœ¨ä»£ç ä¸­ä½¿ç”¨å¸¦æ ‡ç­¾çš„è¯­å¥ï¼Œåˆ™å®¡é˜…è€…å¯èƒ½åªæ˜¯æŠ±æ€¨è€…ä¸­çš„ä»»ä½•ä¸€ä¸ªç”šè‡³ä¼šæ„Ÿåˆ°å›°æƒ‘ã€‚ ğŸ¤·</p><p> The trickiest part here is to even  read the code that the generator outputs,as itâ€™s not very readable to humans. However, I believe itâ€™s the  mostcompact code that can be generated given the requirements â€”Â and  Googleâ€™s ClosureCompiler, which is an optimisingJavaScript compiler, agrees! Closure Compiler actually outputs labelled blockstatements too when inlining some functions into loops. In fact, when I triedto  handcode the above example with inline functions instead, Closure Compilerturned those back into labelled block statements.</p><p> è¿™é‡Œæœ€æ£˜æ‰‹çš„éƒ¨åˆ†æ˜¯ç”šè‡³é˜…è¯»ç”Ÿæˆå™¨è¾“å‡ºçš„ä»£ç ï¼Œå› ä¸ºå®ƒå¯¹äººç±»ä¸æ˜¯å¾ˆå¯è¯»ã€‚ä½†æ˜¯ï¼Œæˆ‘è®¤ä¸ºè¿™æ˜¯å¯ä»¥æ ¹æ®è¦æ±‚ç”Ÿæˆçš„æœ€ç´§å‡‘çš„ä»£ç -Googleçš„ClosureCompilerï¼ˆä¸€ç§ä¼˜åŒ–çš„JavaScriptç¼–è¯‘å™¨ï¼‰ä¹ŸåŒæ„ï¼å½“å°†æŸäº›å‡½æ•°å†…è”åˆ°å¾ªç¯ä¸­æ—¶ï¼ŒClosure Compilerå®é™…ä¸Šä¹Ÿä¼šè¾“å‡ºæ ‡è®°çš„è¯­å¥å—ã€‚å®é™…ä¸Šï¼Œå½“æˆ‘å°è¯•ä½¿ç”¨å†…è”å‡½æ•°æ‰‹åŠ¨ç¼–ç ä¸Šé¢çš„ç¤ºä¾‹æ—¶ï¼ŒClosure Compilerå°†å®ƒä»¬è½¬æ¢å›å¸¦æœ‰æ ‡ç­¾çš„è¯­å¥ã€‚</p><p>  From an implementation standpoint, Iâ€™m quite pleased with the result. The APIthat I ended up with uses a lot of different ideas and language features allin a single project, which has been a rewarding learning experience and exercise.If youâ€™ve read this far this post has already covered four broad topics:</p><p>  ä»å®ç°çš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘å¯¹ç»“æœæ„Ÿåˆ°éå¸¸æ»¡æ„ã€‚æˆ‘æœ€ç»ˆä½¿ç”¨çš„APIåœ¨ä¸€ä¸ªé¡¹ç›®ä¸­éƒ½ä½¿ç”¨äº†è®¸å¤šä¸åŒçš„æƒ³æ³•å’Œè¯­è¨€åŠŸèƒ½ï¼Œè¿™æ˜¯ä¸€æ¬¡æœ‰ç›Šçš„å­¦ä¹ ä½“éªŒå’Œç»ƒä¹ ã€‚å¦‚æœæ‚¨åˆ°ç›®å‰ä¸ºæ­¢å·²è¯»è¿‡è¿™ç¯‡æ–‡ç« ï¼Œåˆ™å·²ç»æ¶µç›–äº†å››ä¸ªä¸»é¢˜ï¼š</p><p>  To then put RegHex through its paces, I generated a parser for the  GraphQL querylanguage, which has been published as  graphql-parse. The grammar ended upbeing about  300 lines long and given that the generated implementation isreally compact the compiled output comes in at only about  2.6kB (minified andgzipped).</p><p>  ä¸ºäº†ä½¿RegHexæ­¥å…¥æ­£è½¨ï¼Œæˆ‘ä¸ºGraphQLæŸ¥è¯¢è¯­è¨€ç”Ÿæˆäº†ä¸€ä¸ªè§£æå™¨ï¼Œè¯¥è§£æå™¨å·²å‘å¸ƒä¸ºgraphql-parseã€‚è¯­æ³•ç»“æŸæ—¶é•¿çº¦300è¡Œï¼Œå¹¶ä¸”è€ƒè™‘åˆ°ç”Ÿæˆçš„å®ç°ç¡®å®éå¸¸ç´§å‡‘ï¼Œå› æ­¤ç¼–è¯‘åçš„è¾“å‡ºä»…çº¦2.6kBï¼ˆæœ€å°åŒ–å¹¶å‹ç¼©ï¼‰ã€‚</p><p> Because it looks nice and fits. The graphql-parse bundle in one image. Ok, old joke thanks to Jason Miller.</p><p>å› ä¸ºå®ƒçœ‹èµ·æ¥ä¸é”™å¹¶ä¸”å¾ˆåˆé€‚ã€‚ä¸€ä¸ªå›¾åƒä¸­çš„graphql-parseæ†ç»‘åŒ…ã€‚å¥½çš„ï¼Œè€ç¬‘è¯è¦æ„Ÿè°¢Jason Millerã€‚</p><p> Running some benchmarks reveals that, probably due to the non-trivial overhead ofregular expressions in JavaScript however, the performance of this parser is onlya third of the reference implementation. That being said, this is a little betterthan I expected given that RegHex is still a good tool for prototyping and createsa rather small parser implementation at  a fraction of the effort for developers.</p><p> è¿è¡Œä¸€äº›åŸºå‡†æµ‹è¯•è¡¨æ˜ï¼Œå¯èƒ½æ˜¯ç”±äºJavaScriptä¸­çš„æ­£åˆ™è¡¨è¾¾å¼å…·æœ‰ä¸å°çš„å¼€é”€ï¼Œä½†æ˜¯ï¼Œæ­¤è§£æå™¨çš„æ€§èƒ½ä»…æ˜¯å‚è€ƒå®ç°çš„ä¸‰åˆ†ä¹‹ä¸€ã€‚è¯è™½è¿™ä¹ˆè¯´ï¼Œè¿™æ¯”æˆ‘é¢„æœŸçš„è¦å¥½ä¸€äº›ï¼Œå› ä¸ºRegHexä»ç„¶æ˜¯åŸå‹åˆ¶ä½œå’Œåˆ›å»ºç›¸å½“å°çš„è§£æå™¨å®ç°çš„å¥½å·¥å…·ï¼Œè€Œå¼€å‘äººå‘˜çš„å·¥ä½œé‡å¾ˆå°ã€‚</p><p>  Itâ€™s worth noting that RegHex could also  support parsing entire tagged templateliterals, which would increase thelevel of meta-ness even more, since itâ€™d allow RegHex to generate its own DSLâ€™sparser, which would make it somewhat of a  self-hostingparser.</p><p>  å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒRegHexè¿˜å¯ä»¥æ”¯æŒè§£ææ•´ä¸ªå¸¦æ ‡ç­¾çš„æ¨¡æ¿æ–‡å­—ï¼Œè¿™å°†è¿›ä¸€æ­¥æé«˜å…ƒæ€§æ°´å¹³ï¼Œå› ä¸ºå®ƒå…è®¸RegHexç”Ÿæˆè‡ªå·±çš„DSLåˆ†æå™¨ï¼Œè¿™ä½¿å…¶å…·æœ‰æŸç§è‡ªæˆ‘æ‰˜ç®¡åˆ†æå™¨çš„èƒ½åŠ›ã€‚</p><p> RegHex also doesnâ€™t support errors very well, since it doesnâ€™t unroll a nicestack to where parsing ultimately failed, which means it may not give any usefulhints as to what went wrong at all. Adding this could be a major improvementfor using its generated parsers in a build tool or server-side code.</p><p> RegHexä¹Ÿä¸èƒ½å¾ˆå¥½åœ°æ”¯æŒé”™è¯¯ï¼Œå› ä¸ºå®ƒæ— æ³•å°†å°¼æ–¯æ ˆå±•å¼€åˆ°æœ€ç»ˆå¯¼è‡´è§£æå¤±è´¥çš„åœ°æ–¹ï¼Œè¿™æ„å‘³ç€å®ƒå¯èƒ½æ ¹æœ¬æ— æ³•æä¾›ä»»ä½•æç¤ºã€‚æ·»åŠ æ­¤åŠŸèƒ½å¯èƒ½æ˜¯å¯¹åœ¨æ„å»ºå·¥å…·æˆ–æœåŠ¡å™¨ç«¯ä»£ç ä¸­ä½¿ç”¨å…¶ç”Ÿæˆçš„è§£æå™¨çš„ä¸€é¡¹é‡å¤§æ”¹è¿›ã€‚</p><p> However, given how many concepts RegHexâ€™s code base touches, it was still aworthwhile experience to work on this proof of concept, despite its currentshortcomings.   Check out the code, if youâ€™d like to learn more even more about RegHex!</p><p> ä½†æ˜¯ï¼Œè€ƒè™‘åˆ°RegHexçš„ä»£ç åº“æ¶‰åŠå¤šå°‘ä¸ªæ¦‚å¿µï¼Œå°½ç®¡å­˜åœ¨å½“å‰çš„ç¼ºé™·ï¼Œä½†ä»å€¼å¾—ä»äº‹æ­¤æ¦‚å¿µéªŒè¯å·¥ä½œã€‚å¦‚æœæ‚¨æƒ³è¿›ä¸€æ­¥äº†è§£RegHexï¼Œè¯·æŸ¥çœ‹ä»£ç ï¼</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kitten.sh/parser-generator-dsl">https://kitten.sh/parser-generator-dsl</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/è§£æå™¨/">#è§£æå™¨</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/generator/">#generator</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/è¯­æ³•/">#è¯­æ³•</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>