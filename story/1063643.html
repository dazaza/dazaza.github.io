<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Zig 0.8.0发行说明 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Zig 0.8.0发行说明 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-05 07:04:09</div><div class="page_narrow text-break page_content"><p>ZIG是一种通用编程语言和工具链，用于维护强大，最佳和可重复使用的软件。</p><p>  该项目支持ZIG软件基金会，该项目是经济可持续的，为核心团队成员提供满足的时间：</p><p>      此版本具有7个月的工作和从144个不同的贡献者的变化，在2711次提交之间传播。</p><p>          绿色复选标记（✅）表示目标符合支持层的所有要求。另一个图标指示可防止目标到达支持层的内容。换句话说，图标是做项目。如果您在此发现有错误的数据，请提交拉动请求！</p><p>    Zig不仅可以为这些目标生成机器代码，但标准库跨平台抽象具有这些目标的实现。</p><p>    📦CIServer自动为这些目标生成预构建的二进制文件，每个提交寄存器，并使用链接更新下载页面。</p><p>      🐛所有行为测试和适用的标准库测试此目标的传递。已知所有语言功能都可以正常工作。实验特征不计入签订第1层的操作系统或架构。 </p><p>💀如果操作系统是专有的，则该目标未被供应商弃用，例如MacOS / X86。</p><p>      📖标准图书馆支持此目标，但它可能会提供一些API将给予＆＃34;不支持的OS＆＃34;编译错误。一个可以链接与libc或其他库来填补标准库中的空白。</p><p>  🔍已知这些目标工作，但可能不会自动测试，因此有偶尔的回归。</p><p>  当我们对第1层支持的工作时，可能会对这些目标禁用某些测试。</p><p>      这些目标没有经常测试;一个可能需要为Zig做出贡献，以便为这些目标建立。</p><p>        如果LLVM提供此目标，则LLVM可能将目标作为实验目标，这意味着您需要使用Zig提供的二进制文件来获得目标的目标，或者从具有特殊配置标志的源构建LLVM。如果可用，则Zig目标将显示目标。</p><p>  该目标可以被官方聚会弃用，例如MacOSX / I386，在这种情况下，此目标将保持在第4层中永久粘在一起。 </p><p>此目标只能支持 - 缩放ASM，无法发出目标文件（默认启用 -  emno-emit-bin，并且无法被覆盖）。</p><p>    32位X86 MacOS，32位ARM MacOS，PowerPC32和PowerPC64 MacOS，因为Apple已正式删除了对它们的支持。</p><p>      链接Libc时，避免冗余提供Windows TLS启动符号，因为它们已由Libcrt提供。</p><p>                          为Windows实现了NT路径转换。修复。并且..不在STD.FS路径中工作。</p><p>    由于Zig船用MingW-W64，Zig可用于在Windows上编译C和C ++代码而不安装MSVC。但是，在此版本之前，它不明显利用此功能，因为默认行为是与MSVC集成。</p><p>  在此版本中，默认行为是忽略MSVC，并仅基于Zig安装执行所有操作。这使得使用Zig在Windows AN＆＃34上编译C和C ++代码;它只是有效＆＃34;经验。</p><p>  可以通过使用-target本机 - 原生-MSVC来实现MSVC集成。请注意，MINGW-W64与MSVC相兼容，因此由一个产生的任何构建工件都是由另一个的消耗品。但是，相应的C头文件并不总是API兼容，这就是为什么仍然是默认默认的用例。 </p><p>随着自主托管链接器的出现，Zig现在能够在ARM64 MacOS（AKA Apple Silicon）上生成良好形成的和代号的二进制文件。它还能够将C，C ++和Zig代码交叉编译到ARM64和X86_64 MacOS。此外，ARM64每晚Zig二进制文件由我们的连续集成服务自动生成，这意味着ARM64和X86_64 MacOS都是Tier 1目标。</p><p>  为了便于增量链接，自主主机编译器现在默认生成DSYM捆绑包，存储DWARF调试信息和在MACO上的调试符号。这将Zig放在Xcode开发环境中成为真正替代的路径。</p><p>  最后，作为一个侧面实验，jakub在Zig构建系统集成与达令（＃8760），是麦斯科斯州Syscalls到Linux的翻译层，其目的是能够简单地在Linux上直接交叉测试Macho二进制文件和麦斯科斯特定测试在Zig Build Test中传递额外的旗帜Dadling。</p><p>  在0.8.0中，Zig使用实验的Fetch-Hom-MacOS-Rements项目为X86_64-MacOS和AARCH64-MACOS提供Libc标题文件。有一个神话是Apple＆＃39; s c头文件的占用许可证，但这不是这种情况。它们在苹果公共源许可证下许可，实际上是非常宽容的。</p><p>  Zig 0.8.0即使在编译此时，也依赖于这些标题，只要没有系统依赖性即可。这使得Zig能够在没有安装Xcode的情况下编译C和C ++代码（＃6773）。</p><p>      自托管编译器获得了一个进展的webassembly后端，它提供了zig编译为没有llvm的wasm的能力。</p><p>  Zig现在与Wasi Libc一起船舶，并支持交叉编译C代码。这也使Zig成为手动下载和构建WASI LIBC和/或WASI SDK的诱惑替代品（＃8837）。 </p><p>就像每个其他目标一样，Zig Build-lib现在为WASM构建了一个静态存档，除非指定了动态。</p><p>    Al Hoang贡献了一些初步的工作来让Zig在Haiku下运行。一些现在工作的东西：</p><p>        LLVM 12带来CSKY支持。 Glibc已经支持CSKY，但Zig没有为此发出Glibc头文件，因为LLVM没有它的后端。 Zig 0.8.0另外还为CSKY划船Glibc头文件。</p><p>          在编译C / C ++代码时传递-MOUMB。 Clang驱动程序需要此标志并忽略目标三倍。</p><p>                        Zig现在具有PowerPC-Linux-None和PowerPC-Linux-Musl的CI测试覆盖范围。阻止Glibc支持的问题是＃4927。</p><p>      Lemonboy在＃4926中取得进展，防止Zig能够在I386-Linux-GNU上构建Glibc。他得到了它的工作，并且测试通过，但它揭示了标准库中的漏洞（＃8930）与所有32位目标上的分配对齐有关。此问题未在0.8.0中解决，但计划在0.8.1错误修复版本中解决。之后，我们期望对I386-Linux-GNU进行测试覆盖范围。</p><p>    在0.8.0释放周期期间，Zig＆＃39; Zig＆＃39; SIPS支持大大提高，为小型MIPS获得了全面的测试覆盖范围，包括建筑物和GLIBC。 </p><p>然而，尽管提交了开放式发布阻止器错误，但所有MIPS目标都会随着LLVM 12的发布而退化。不仅如此，而且修复程序已经在LLVM主分支整个月，截至本文的时间，然而，解决方案没有将其成12.0.1-RC1，尽管错误被标记为12.0 .1释放阻止器。</p><p>  一旦LLVM发布一个包含修复的错误修复版本，Zig就可以重新启用MIPS测试覆盖范围。</p><p>    更新语言引用，以反映此发布周期中语言和标准库的更改。</p><p>                  DOCGEN：使用STD.Progress API，以便在等待文档构建时看到终端进度栏。</p><p>  贡献者：Andrew Kelley，CarlosZúñiga，Devin Gauer，德国拜耳，埃莉诺·拜耳，Jakub Konka，Jay Petacat，Jonas Carpay，Josh Holland，Josh Wolfe，Lemonboy，Martin Wickham，Mathieu Guay-Paquet，Matthowe Borkowski，Ryan Liptak ，Tadeo Kondrak，Veikka Tuominen，Data-Man，Jacob Gw，Xackus</p><p>    与其他版本相比，Zig语言看到此循环的更改更改，为自托管编译器实现提供相对稳定的目标。尽管如此，还有几种添加和破坏变化。</p><p>    const a = extern enum {foo，bar}; const b = packed enum {foo，bar}; </p><p>test.zig：1：11：错误：枚举不支持＆＃39;包装＆＃39;或＆＃39; extern＆＃39 ;;而是提供一个显式整数标签Typeconst A = Extern Enum {foo，bar}; ^ test.zig：2：11：错误：枚举不支持＆＃39;包装＆＃39;或＆＃39; extern＆＃39 ;;而是提供一个显式整数标签TypeConst B = Packed Enum {foo，bar}; ^</p><p>  自托管编译器（由于整个文件AST降低）捕获此错误，但尚未由Bootstrap编译器捕获。相关提案：＃8970</p><p>                        无名的测试是免于--Test-Filter参数，使得可以使用--Test-il过滤器，同时仍然指向root源文件的Zig测试。</p><p>          $ ./zig test a.zigb.test＆＃34; fail＆＃34; fail ...失败（testunexpectedresult）/home/andy/downloads/zig/lib/std/testing.zig：310:14：0x24d54b在std中。 testing.expect（测试）如果（！确定）返回错误.testunexpedresult; ^ /home/andy/downloads/zig/build/b.zig：7:5：0x2068b1在b.tiest＆＃34;失败＆＃34; （测试）尝试std.testing.expect（false）; ^ 2通过; 0跳过; 1失败。错误2测试通过了。</p><p>       const std = @import（＆＃34; std＆＃34;）; const enum =枚举{一，两个，三个};测试＆＃34;旧代码＆＃34; {const t = @tagtype（枚举）;尝试std.testing.Expectequal（U2，T）;}</p><p>      const std = @import（＆＃34; std＆＃34;）; const enum =枚举{一，两个，三个}; const tagtype = std.meta.tagtype;测试＆＃34;新代码＆＃34; {const t = tagtype（枚举）;尝试std.testing.Expectequal（U2，T）;}</p><p>       nosuspend块现在允许在其范围内恢复，因为恢复暂停的异步函数调用实际上是一个同步操作。 </p><p>nosuspend块现在允许异步函数调用它们的范围内，因为启动异步函数调用实际上是一个同步操作，因为呼叫者在Callee上不等待返回值。</p><p>      Pub const callingConvention =枚举{未指定，C，裸体，异步，内联，中断，信号，stdcall，fastcall，VectorCall，ThisCall，APC，AAPCS，AAPCSVFP，SYSV，};</p><p>     const std = @import（＆＃34; std＆＃34;）; const期望= std.testing.expect; const maxint = std.math.maxint;测试＆＃34;未签名的否定包装＆＃34; {try testunsignednegationWrappteval（1）;编辑尝试testunsignednegationWrappingeval（1）;} fn testunsignednegationWrappteval（x：u16）！ void {尝试期待（x == 1）; const neg =  - ％x;尝试期待（neg == maxint（u16））;}</p><p>            const std = @import（＆＃34; std＆＃34;）; const buildin = @import（＆＃34;内置＆＃34;）; //＆lt; ---看这里测试＆＃34;旧代码＆＃34; {const stacktrace = buildin.stacktrace;}</p><p> $ zig test test.zig ./docgen_tmp/test.zig：5:31：错误：容器＆＃39;内置＆＃39;没有成员叫做＆＃39; Stacktrace＆＃39; Const StackTrace = BuildIn.Stacktrace; ^</p><p>     const std = @import（＆＃34; std＆＃34;）; const buildin = std.builtin; //＆lt; ---看这里测试＆＃34;新代码＆＃34; {const stacktrace = buildin.stacktrace;}</p><p>     const std = @import（＆＃34; std＆＃34;）; const buildin = std.builtin; //＆lt; ---看这里测试＆＃34;已弃用的代码＆＃34; {const native_arch = buildin.cpu.arch; //弃用！} </p><p>const std = @import（＆＃34; std＆＃34;）; const buildin = @import（＆＃34;内置＆＃34;）; //＆lt; ---看这里测试＆＃34;新代码＆＃34; {const native_arch = buildin.cpu.arch; // 好的}</p><p>     在上一个版本中，以及此版本，每个人都使用的主要Zig编译器是Bootstrap编译器，写在C ++中，也称为＆＃34; Stage1＆＃34;尽管此释放周期的主要重点是自主主机编译器，但也有一些改进。</p><p>  将特定于架构的clobbers添加到ASM（）。 We＆＃39; Re基本上追随铿cl＆＃39; s铅，添加必要的clobbers，以最大限度地减少生成错误代码的风险。</p><p>          发出编译错误，而不是倒回C以获取不受支持的调用约定。 （＃6829）</p><p>                        允许多叉开关臂的可变捕获，在使用范围案例（＃7188）时处理多叉壳。</p><p>  让LLVM将溢出的OPS合法化向量上，因为它足以产生紧密的溢出检查序列。</p><p>                在全局应用LLVM SSP属性而不是每函数。否则LLVM伴随着：＆＃34;堆栈受保护的Callee，但呼叫者请求没有堆栈保护器＆＃34; </p><p>返回销价匹配自托管编译器。主要是，这使得Stage1和Stage2逻辑彼此匹配，使得同时保持两者。它也是一种可忽略的内存使用情况。</p><p>  为每个功能存储LLVM模块中的目标信息。这是需要使用用户指定的目标选项（＃8803）的目标选项来生产代码所需的这一点。</p><p>              通过std.builtin解决内置的类型和值，而不是通过@import（＆＃34;内置＆＃34;）。这有助于避免在构建中使用的名称空间或在std.builtin中使用。</p><p>  这里的好消息是，几乎所有这些修复都有附加的行为测试，我们可以用来验证自托管的编译器不会退化。</p><p>  这里的一个特别值得注意的变化是lemonboy＆＃39; s fix，以便在-oreleasemall模式下在-oreleasemall模式下生产紧凑码。以前，使用-OreleaseMall有时导致输出二进制文件较大！ （＃7048，＃7077）</p><p>  很大，很大，感谢Lemonboy在此发布周期中解决这么多阶段1错误。这是努力，低估，他一直在做的巨大影响力。但实际上，他一直在单手中让我们漂浮在完成自主主办的编译器时。</p><p>  贡献者：lemonboy，安德鲁克利，萨卡穆卡，veikka tuominen，tadeo kondrak，迈克尔道斯·斯塔克，雅典konka，弗拉米斯，麦克风，哈康，亚历山大号艾萨克·弗慎，杰什·佩罗特，吉什沃尔夫，李大炮，马修骑士，内森迈克尔斯，赵壮，蒂蒙克鲁奈，Woze Parrot，Jacob Gw，Lars，Pfg，Xackus </p><p>这是LLVM下游用户的粗略释放循环。在测试释放候选者期间，我们发现并报告了LLVM 11的7个回归。然而，尽管报告了作为释放阻滞剂的可再生回归，但LLVM项目标记为12.0.0版。此时不仅有开放的回归，而且12.0.0标记甚至没有标记释放/ 12.x分支的尖端 - 所以已经提交到没有使其进入标记的发布分支的修复程序。</p><p>  在本写作时，有31个打开的释放阻滞剂12.0.1，但LLVM已经标记了12.0.1 rc1。正如MichałGórny所说：</p><p>  我开始测试，击中了两个错误我已经报道了12.0.0 rcsand弄清楚了我的时间。似乎LLVM达到了释放的点，只为炸弹释放，并且QA不存在QA＆＃39;</p><p>  我希望LLVM项目能够更加认真地加强和释放释放和回归。</p><p>  无论哪种方式，它开始清楚地将LLVM转换为可选的依赖性，从而为LLVM单一文化提供替代方案，正在成为ZIG项目提供的越来越多的特征。在此版本中，您可以看到我们在这个前面打破了地面：x86-64后端，aarch64后端，arm后端，webassembly后端，risc-v 64后端，c backend，spir-v后端</p><p>    此释放周期的主要重点是自主主机编译器（也称为＆＃34; Stage2＆＃34;）。</p><p>  尽管如此，默认情况下，默认情况下仍然在此版本中使用Bootstrap编译器编译，主要驱动程序代码已经是自托管的，以及许多功能，如Zig CC，C翻译和CPU功能检测。对＆＃34的改进; Stage2＆＃34;在这些领域实际上影响了主要的Zig用户体验。 </p><p>Lemonboy基于解析/ PROC / CPUInfo对Linux上的主机CPU检测添加了一个框架，并实现了64位SPARC目标作为概念证明的模型检测。</p><p>    CPU检测代码几乎处于具有LLVM的特征奇偶校验。我们确实支持检测SPARC系统和麦克斯的本机CPU，我们的ARM / AARCH64模型列表非常全面，我们的PPC One也是如此。唯一缺失的部分是：</p><p>  ARM32对达尔文主机的检测（令人疑问的任何人都计划在Old-As iPhone上运行编译器）</p><p>  由于所有这项工作，我们丢弃了LLVM＆＃39;将主机CPU检测方法作为回退。这是Zig在LLVM上的依赖性较少，使我们更接近使LLVM成为可选的扩展而不是所需的依赖性。</p><p>    Zig＆＃39; S目标CPU特征意识是LLVM＆＃39; s的超集，这意味着对于每个目标CPU功能Zig都知道，它必须知道是否以及如何将其映射到LLVM＆＃39; S目标CPU功能。</p><p>  为此目的，Andrew创建了update_cpu_features.zig工具。此工具生成.zig代码，其中包含Zig所知的所有各种CPU的枚举和数据声明。</p><p>      在此版本之前，更新目标CPU功能响应LLVM更新是一个手动过程，其中它太容易引入错误。 </p><p>现在，该工具完全自动化该过程，并且在LLVM更新时不再涉及的任何手动步骤，而不是重新运行该工具。</p><p>  此外，Andrew改进了它，以对每个目标并行化工作，尽管通过许多LLVM-TBLGEN JSON Dumps涉及许多兆字节，但使它会更快地运行。</p><p>    在--watch repl中，空命令重新运行以前的命令。这可以特别有用，与新的更新和运行命令相结合。</p><p>      我一直在读Richard Fabian＆＃39;书籍，以数据为导向的设计，最后事情开始＆＃34;点击＆＃34;为我。我有这些想法在我脑海里旋转多年，但最近我觉得我有一个直观的掌握现代CPU工作如何，特别是对于L1缓存，以及未加工的内存负荷的相对延迟vs计算。</p><p>  编译速度是设计ZIG自主主机编译器以及语言本身的首要任务。我一直小心地设计语言，以解锁潜在的快速编译器的潜力。</p><p>  在此版本周期中，我花了时间重新制作了编译器管道的4个阶段的内存布局：</p><p>  标记➡️解析➡️AST降低➡️语义分析➡️机代码 </p><p>该图中的每个箭头表示编译器流水线中的相位以一种形式输入数据，并以不同的形式输出数据，用于下一阶段。</p><p>    我决定尝试减少令牌列表的堆分配字节数以及AST，作为对ZIR和AIR的类似策略的试验试验。我在这里有一些主要的见解：</p><p>  基础前提：使用较少的内存将使事情更快，因为较少的分配和更好的缓存利用率。同样使用较少的内存在其本身和本身的价值是有价值的。</p><p>  对于令牌和AST节点使用阵列结构，保存枚举标记之间的填充字节（哪种令牌;它是哪种AST节点）和结构中的下一个字段。它还提高了缓存一致性，因为人们可以在令牌阵列中窥视，而无需加载令牌的源位置。</p><p>  可以通过仅具有标记（1字节）和字节偏移量（4字节）来保存令牌存储器，每个令牌总共5个字节。没有必要存储令牌结束字节偏移，因为稍后可以始终重新销量，但是大多数令牌的长度可以单独地从标签中窥探，并且对于它而不是其中，例如它的字符串文字。 ，一个人必须在astgen中稍后再次解析字符串文字，使其自由地重新实现</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ziglang.org/download/0.8.0/release-notes.html">https://ziglang.org/download/0.8.0/release-notes.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/发行/">#发行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/release/">#release</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1044740.html"><img src="http://img2.diglog.com/img/2021/1/thumb_e562575810f5fc85936eeda129dbc894.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044740.html">软件发行及其今天的作用 </a></div><span class="my_story_list_date">2021-1-18 0:45</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038681.html"><img src="http://img2.diglog.com/img/2020/12/thumb_c13477f6896e3f061f40791358604777.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038681.html">Rocky Linux：与RHEL兼容的社区企业OS </a></div><span class="my_story_list_date">2020-12-10 2:10</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038591.html"><img src="http://img2.diglog.com/img/2020/12/thumb_9b2a7fcceee51585feb5628a787bccaa.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038591.html">GitHub自述文件中的CSS </a></div><span class="my_story_list_date">2020-12-9 20:1</span></div><div class="col-sm"><div><a target="_blank" href="/story/1035546.html"><img src="http://img2.diglog.com/img/2020/11/thumb_d2e8f22302825b0c29019cb5435526a0.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1035546.html">《 1984年奇妙女人》将于12月25日登陆HBO Max（和美国一些剧院）</a></div><span class="my_story_list_date">2020-11-21 12:53</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>