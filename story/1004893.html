<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>AsyncAPI代码生成：使用Spring云流的微服务</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">AsyncAPI代码生成：使用Spring云流的微服务</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-06-03 04:58:48</div><div class="page_narrow text-break page_content"><p>代码生成不是简单的壮举。当涉及到生成有用的应用程序代码时，有很多复杂性。在这篇文章中，我将指导您使用Spring Cloud Stream和AsyncAPI代码生成器生成您自己的微服务。在定义和实现异步应用程序时，这些工具应该有助于简化工作。我在一段视频中解释了同样的想法，你可以在这里观看，所有的工件都可以在GitHub中找到。</p><p>在我们开始代码生成之前，让我们先从基础开始--什么是AsyncAPI？在过去的几年中，AsyncAPI已经成为定义异步、事件驱动的API的行业标准；您可以将其视为异步世界的OpenAPI。它是一项开放源码计划，它既提供了以机器可读格式描述和记录异步应用程序的规范，也提供了工具(如代码生成器)来简化负责实现这些应用程序的开发人员的工作。</p><p>我不打算详细介绍该规范，但是对于上下文，您应该知道它定义了有关异步API的元数据、可用于发送/接收消息的通道以及定义正在交换的消息的组件(如模式)。有关该规范的更多信息，您可以在此处阅读。</p><p>使用AsyncAPI进行代码生成的第一步是获取定义要开发的应用程序的AsyncAPI文档。根据规范，本文档表示为JSON对象，并且必须符合JSON标准。YAML是JSON的超集，也可以使用。获取此文档的方式主要有两种：手动创建文档或使用事件门户。</p><p>如果您在熟悉规范后决定手动创建文档，请不要担心-您不会从头开始。AsyncAPI计划提供了一个名为AsyncAPI Hub的方便的交互式工具来简化这一过程。在Hub的左侧，您可以熟悉规范并对真正的AsyncAPI文档进行更改，当您这样做时，屏幕右侧会更新以显示如何将文档解析为更易于阅读的格式。</p><p>第二种方式是使用事件门户。例如，Solace PubSub+event Portal允许架构师和开发人员使用GUI协作来设计事件驱动的架构。团队将定义系统中存在的应用程序，以及交换的事件和定义它们的架构。拥有一个组织良好的频道和事件目录以供重复使用，还可以在协作时节省您的时间和麻烦，而不是必须梳理不同位置的一堆文件。</p><p>一旦设计就绪，PubSub+event Portal允许开发人员选择他们负责开发的应用程序，并下载JSON或YAML格式的AsyncAPI文档。</p><p>既然我们已经有了描述应用程序的AsyncAPI文档，接下来就可以开发应用程序了。AsyncAPI代码生成器支持模板来为各种不同的语言和协议生成代码，但在本例中，我们将使用Spring Cloud Stream模板。需要注意的是，该模板生成了一个Maven项目。</p><p>Spring Cloud Stream框架提供了一种简单的方法来开始使用事件驱动的微服务，因为它提供了绑定器，允许开发人员在不必学习消息传递API的情况下创建他们的微服务。</p><p>当然，第一步是安装AsyncAPI生成器本身。如果您安装了NodeJS，这只需要一个简单的npm命令，如下所示。您可以在GitHub上的代码生成器中找到所需的版本。</p><p>一旦安装了生成器，就可以使用ag命令运行它。您至少必须指定要运行它的AsyncAPI文档和要使用的模板，如下所示。</p><p>在大多数情况下，您会希望利用正在使用的模板指定的参数和规范扩展。例如，我在本例中使用的Spring Cloud Stream模板允许我配置许多选项，包括我想要使用的Spring Cloud Stream绑定器-例如，Solace绑定器。</p><p>使用这些选项，我的ag命令可能如下所示，其中-o指定输出目录：</p><p>ag-o ExpenseIntegration-p绑定器=solace-p view=Provider-p致动器=TRUE-p artifactId=ExpenseIntegration-p groupId=acme.rideshare-p javaPackage=acme.rideshare.expend-p host=localhost：55555-p用户名=default-p密码=default-p msgVpn=default~/downloads/ExpenseIntegration.yaml@asyncapi/java-Spring-cloud。</p><p>此时，生成器已经创建了包含Maven项目的ExpenseIntegration目录。我们可以使用选择的IDE并导入Maven项目来添加业务逻辑。</p><p>如下图所示，一旦导入，项目看起来就像一个普通的Spring Boot Java项目，在前面定义的javaPackage下生成了类，并有一个用于配置的application ation.yml文件。javaPackage下生成的类包括从AsyncAPI文档中的模式定义的Plain Old Java Objects(POJO)和Application.java，后者包含实际的Spring Cloud函数，我们将在其中添加业务逻辑。</p><p>与上图中的RideReceipt一样，生成的POJO根据AsyncAPI文档中包含的模式定义数据模型。这些POJO包含变量，为每个属性定义了getter和setter，既允许开发人员快速编码而无需手动创建对象，也允许Spring Cloud Stream自动将消息直接转换为POJO。</p><p>然后是Application.java类，可以使用javaClass参数重命名。生成器将添加函数来处理在AsyncAPI文档中定义的通道上传递的消息，如模板中所述。</p><p>在下面的示例中，我们可以看到单个java.util.function.Consumer bean，因为我们的AsyncAPI文档将我们的应用程序描述为其有效负载由RideReceipt模式定义的消息的订阅者。注意这里声明//添加业务逻辑的注释；这是开发人员可以添加他们的业务逻辑的地方。</p><p>@SpringBootApplicationpublic class Application{Private Static Final Logger logger=LoggerFactory.getLogger(Application.class)；public static void Main(String[]args){SpringApplication.run(Application.class)；}@Bean public Consumer&lt；RideReceipt&gt；acmeRideshareBillingReceiptCreated001Consumer(){//在此添加业务逻辑。返回NULL；}}。</p><p>您可能会说：“Marc，那太好了，但是该函数实际上是如何绑定到消息传递通道的呢？”这就是application.yml文件发挥作用的地方。</p><p>生成的application.yml文件定义了在AsyncAPI文档中或从传递到生成器的参数中指定的几项内容。首先，它定义了它希望Spring Cloud Stream在spring.cloud.Stream.function.Definition下知道的函数列表。其次，它告诉Spring Cloud Stream在spring.cloud.stream s.bindings下将这些函数绑定到哪些通道。最后，它包含到消息传递系统的连接信息。连接信息由不同的参数指定，具体取决于您选择的绑定器，但在本例中，它是在solace.java下定义的。</p><p>Spring：Cloud：Stream：Function：Definition：acmeRideshareBillingReceiptCreated001消费者绑定：acmeRideshareBillingReceiptCreated001Consumer-in-0：Destination：acme/rideshare/billing/receipt/created/0.0.1solace：Java：Host：&#39；localhost：55555&#39；msgVpn：Default ClientUsername：Default ClientPassword：defaultLogging：Level：Root：Info org：Sprringframework：Info。</p><p>请注意，所有这些都是为开发人员完成的，因此他们不必跟踪需要设置哪些SCST参数、将函数映射到绑定等。他们只需添加他们的业务逻辑来代替项目并点击Run！在本例中，因为它是一个Spring Boot项目，所以您可以在IDE中“作为Spring Boot应用程序运行”，甚至可以使用MVN Spring-boot：run从命令行运行。</p><p>使用AsyncAPI Spring Cloud Stream模板#︎创建微服务的有用参数和规范扩展。</p><p>正如我提到的，当涉及到从微服务生成有用的应用程序代码时，有很多复杂性。由于这些复杂性，我想我应该介绍使用AsyncAPI Spring Cloud Stream模板的一些提示、技巧和难点。</p><p>在生成代码时，您应该考虑一些不同的参数和规范扩展。所有这些参数都可以在这里找到，但我将回顾一下我经常使用的几个参数：</p><p>绑定器参数允许您指定要使用的Spring Cloud Stream绑定器。目前，发电机支持卡夫卡、兔子和安慰。</p><p>可以在AsyncAPI文档中的INFO级别设置info.x-view规范扩展。此扩展允许您定义应该如何从应用程序的角度查看文档。默认情况下，AsyncAPI规范采用客户机视图，文档中定义的操作(发布/订阅)表示应用程序接受的内容(或如何与该应用程序通信)。但是，对于代码生成，您可能希望生成应用程序实际执行的操作。这就是设置视图参数的用武之地。如果将view设置为Provider的值，则文档中定义的操作将被视为应用程序实际执行的操作。注意，这个扩展也可以使用一些生成器模板上的view参数来设置，比如Java Spring Cloud Stream one。</p><p>可以在AsyncAPI文档中的发布或订阅操作上设置Operation.x-scs-function-name规范扩展，这不仅允许您命名生成的函数，还允许您将两个操作绑定在一起，以形成一个函数，该函数订阅一个频道，并在使用相同名称时发布到另一个频道。例如，如果您的AsyncAPI文档看起来像下面的图像，那么将生成一个名为“culatePercentage”的java.util.function.Function bean，它订阅输入通道并发布到输出通道。</p><p>频道：&#39；输入&#39；：订阅：x-scs-函数名称：计算百分比消息：$REF：&#39；#/components/messages/CovidTracking_SingleStateCurrentDataUpdate&#39；&#39；输出&#39；：发布：x-scs-函数名称：计算百分比消息：$REF：&#39；#/components/messages/CovidTracking_SingleStateTestPercentagesUpdate&#39；</p><p>可以在订阅操作上指定x-scs-destination规范扩展，允许您覆盖通常与频道匹配的默认目标值。当您使用Solace绑定器并且遵循发布到主题和从队列消费的Solace模式时，这很有用。在本例中，x-scs-estination值将被视为您的微服务将从中消费的队列的名称，并且AsyncAPI文档中的通道名称将被添加为该队列的主题订阅。</p><p>还可以在订阅操作上指定x-scs-group规范扩展，允许将组添加到生成的Spring Cloud Stream绑定中。这允许使用使用者组，并将在使用Solace绑定器时创建持久队列。</p><p>使用代码生成器使用Spring Cloud Stream创建事件驱动的微服务的提示#︎。</p><p>除了配置选项之外，在使用生成器通过Spring Cloud Stream创建事件驱动的微服务时，还有一些事情需要牢记。</p><p>确保生成的POJO具有您期望的生成变量的Java类型！例如，如果您的JSON模式将属性类型定义为数字或整数，则它们将分别映射到Java中的Double或Integer。如果您想要另一种类型，如Float或Long，则需要进行更改。同样重要的是要确保密切关注表示日期和/或时间的数据，因为在默认情况下，这些数据很可能最终只是由字符串表示。</p><p>AsyncAPI SCST代码生成器尚不支持动态主题。我们将在将来对它们进行增强，以支持动态主题，但现在您需要从AsyncAPI文档中的通道中删除主题的动态片段，然后将它们添加到代码中。</p><p>在创建不包含java.util.function.Supplier的Spring Cloud Stream微服务时，包括一个Web服务器，以便微服务继续运行并侦听要处理的消息。这可以通过包括-p Actuator=true参数来实现，以包括Spring Actuator功能，该功能本身需要一个Web服务器，并且还提供一些很酷的管理和监控功能。或者，您也可以在生成Spring-boot-starter-web starter之后将其添加到您的pom中。注这不是AsyncAPI生成器模板的问题，而是Solace Spring Cloud Stream绑定器的错误，它将与使用生成器的人相关。</p><p>我希望这篇文章对您有帮助，您可以在研究完上面描述的示例后，快速开始使用Spring Cloud Stream和AsyncAPI代码生成器生成您自己的事件驱动的微服务。</p><p>您可以立即开始使用Solace PubSub+活动门户，通过注册新的云帐户免费生成您的AsyncAPI文档！</p><p>如果您有更多的问题或想要分享您使用这些工具的经验，您可以在Solace社区论坛上让我们知道，或者考虑加入我们的行列，直接为AsyncAPI计划做出贡献。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.asyncapi.com/blog/asyncapi_codegen_scst/">https://www.asyncapi.com/blog/asyncapi_codegen_scst/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码生成/">#代码生成</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/code/">#code</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1004860.html"><img src="http://img.diglog.com/img/2020/6/thumb_6f5a49f145712a17e8ba9b818cc705c9.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1004860.html">带代码的论文</a></div><span class="my_story_list_date">2020-6-3 1:3</span></div><div class="col-sm"><div><a target="_blank" href="/story/1004579.html"><img src="http://img.diglog.com/img/2020/6/thumb_3df3474847de939912d1bd066c096481.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1004579.html">展开引擎代码样式</a></div><span class="my_story_list_date">2020-6-1 5:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1004431.html"><img src="http://img.diglog.com/img/2020/5/thumb_bff2a714cd7081340512131d66996508.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1004431.html">为什么C到Z80编译器产生的代码很差？</a></div><span class="my_story_list_date">2020-5-31 3:24</span></div><div class="col-sm"><div><a target="_blank" href="/story/1004255.html"><img src="http://img.diglog.com/img/2020/5/thumb_2bd8776b22ac6709b4b656fd199fc5d1.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1004255.html">谷歌在全球简化寻址系统的努力中使共享Plus代码变得更容易</a></div><span class="my_story_list_date">2020-5-29 23:22</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>