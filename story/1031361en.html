<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>è§£æRISC-Vç¨‹åºé›†</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">è§£æRISC-Vç¨‹åºé›†</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 06:26:25</div><div class="page_narrow text-break page_content"><p>Recently, I needed to analyze some RISC-V assembly code for a research project and then calculate some basic metrics, but I couldn&#39;t find a suitable tool. Ok, I&#39;ll just grab a parser from one of the smaller open-source assemblers. This wasn&#39;t successful though since the ones I looked at use crude, regex-based parsers that don&#39;t maintain information about the structure.</p><p>æœ€è¿‘ï¼Œæˆ‘éœ€è¦ä¸ºä¸€ä¸ªç ”ç©¶é¡¹ç›®åˆ†æä¸€äº›RISC-Væ±‡ç¼–ä»£ç ï¼Œç„¶åè®¡ç®—ä¸€äº›åŸºæœ¬æŒ‡æ ‡ï¼Œä½†æˆ‘æ‰¾ä¸åˆ°åˆé€‚çš„å·¥å…·ã€‚å¥½çš„ï¼Œæˆ‘å°†ä»ä¸€ä¸ªè¾ƒå°çš„å¼€æ”¾æºç æ±‡ç¼–å™¨ä¸­è·å–ä¸€ä¸ªè§£æå™¨ã€‚è¿™å¹¶ä¸æˆåŠŸï¼Œå› ä¸ºæˆ‘çœ‹åˆ°çš„é‚£äº›ä½¿ç”¨ç²—ç³™çš„ã€åŸºäºæ­£åˆ™è¡¨è¾¾å¼çš„è§£æå™¨ï¼Œè¿™äº›è§£æå™¨ä¸ç»´æŠ¤æœ‰å…³ç»“æ„çš„ä¿¡æ¯ã€‚</p><p> Not a problem, I&#39;ll implement my own! Let me just look up the grammar for RISC-V assembly... oh no, there isn&#39;t an official one?! Wait. The language itself isn&#39;t even standardized beyond the instruction set, and each major assembler supports different notations and features???</p><p>æ²¡é—®é¢˜ï¼Œæˆ‘ä¼šå®ç°æˆ‘è‡ªå·±çš„ï¼è®©æˆ‘æŸ¥ä¸€ä¸‹RISC-Væ±‡ç¼–çš„è¯­æ³•...ã€‚å“¦ï¼Œä¸ï¼Œæ²¡æœ‰æ­£å¼çš„å—ï¼Ÿï¼ç­‰ã€‚é™¤äº†æŒ‡ä»¤é›†ä¹‹å¤–ï¼Œè¯­è¨€æœ¬èº«ç”šè‡³æ²¡æœ‰æ ‡å‡†åŒ–ï¼Œè€Œä¸”æ¯ä¸ªä¸»è¦æ±‡ç¼–è¯­è¨€éƒ½æ”¯æŒä¸åŒçš„ç¬¦å·å’ŒåŠŸèƒ½ï¼Ÿ</p><p>  Challenge accepted! My goal is to write a parser that supports the GNU assembler&#39;s (GAS) syntax.</p><p>æ¥å—æŒ‘æˆ˜ï¼æˆ‘çš„ç›®æ ‡æ˜¯ç¼–å†™ä¸€ä¸ªæ”¯æŒGNUæ±‡ç¼–ç¨‹åº(GAS)è¯­æ³•çš„è§£æå™¨ã€‚</p><p>  If you are looking for a hand-written lexer and parser for RISC-V assembly that builds a parse tree and does not have any third-party dependencies (e.g., ANTLR or Yacc), then this is for you. It could be handy in making your own linter, prettifier, or assembler for RISC-V. Alternatively, if you want a more in-depth tutorial on parsing, see the first part of my tutorial series:  Let&#39;s make a Teeny Tiny compiler.</p><p>å¦‚æœæ‚¨æ­£åœ¨å¯»æ‰¾ç”¨äºRISC-Vç¨‹åºé›†çš„æ‰‹å†™è¯æ³•åˆ†æå™¨å’Œè§£æå™¨ï¼Œå¯ä»¥æ„å»ºè§£ææ ‘ï¼Œå¹¶ä¸”æ²¡æœ‰ä»»ä½•ç¬¬ä¸‰æ–¹ä¾èµ–é¡¹(ä¾‹å¦‚ï¼ŒANTLRæˆ–Yacc)ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸ºæ‚¨å‡†å¤‡çš„ã€‚åœ¨ä¸ºRISC-Våˆ¶ä½œè‡ªå·±çš„çŸ­ç»’ã€ç¾å®¹å‰‚æˆ–æ±‡ç¼–å™¨æ—¶ï¼Œå®ƒå¯èƒ½ä¼šå¾ˆæ–¹ä¾¿ã€‚æˆ–è€…ï¼Œå¦‚æœæ‚¨éœ€è¦æ›´æ·±å…¥çš„è§£ææ•™ç¨‹ï¼Œè¯·å‚é˜…æˆ‘çš„æ•™ç¨‹ç³»åˆ—çš„ç¬¬ä¸€éƒ¨åˆ†ï¼šè®©æˆ‘ä»¬åšä¸€ä¸ªTeeny Tinyç¼–è¯‘å™¨ã€‚</p><p> The source code for the parser can be found on  GitHub. If you want to know more about RISC-V assembly, see my colleague&#39;s  lecture notes.</p><p>è§£æå™¨çš„æºä»£ç å¯ä»¥åœ¨GitHubä¸Šæ‰¾åˆ°ã€‚å¦‚æœä½ æƒ³äº†è§£æ›´å¤šå…³äºRISC-Vç»„ä»¶çš„çŸ¥è¯†ï¼Œè¯·çœ‹æˆ‘åŒäº‹çš„è¯¾å ‚è®²ç¨¿ã€‚</p><p>  The core of most assembly languages is beautifully simple. A source file is composed of zero or more labels, instructions, directives, and comments. We can represent it in EBNF like so:</p><p>å¤§å¤šæ•°æ±‡ç¼–è¯­è¨€çš„æ ¸å¿ƒéƒ½éå¸¸ç®€å•ã€‚æºæ–‡ä»¶ç”±é›¶ä¸ªæˆ–å¤šä¸ªæ ‡ç­¾ã€æŒ‡ä»¤ã€æŒ‡ä»¤å’Œæ³¨é‡Šç»„æˆã€‚æˆ‘ä»¬å¯ä»¥ç”¨EBNFè¡¨ç¤ºå®ƒï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p><p>  Such a language would be very easy to parse. At the start of each line, decide whether it is a label, an instruction, a directive, or a comment. Let&#39;s keep going with this and expand these terms:</p><p>è¿™æ ·çš„è¯­è¨€å°†éå¸¸å®¹æ˜“è§£æã€‚åœ¨æ¯è¡Œçš„å¼€å¤´ï¼Œç¡®å®šå®ƒæ˜¯æ ‡ç­¾ã€æŒ‡ä»¤ã€æŒ‡ä»¤è¿˜æ˜¯æ³¨é‡Šã€‚è®©æˆ‘ä»¬ç»§ç»­è¿™æ ·åšï¼Œå¹¶æ‰©å±•è¿™äº›æœ¯è¯­ï¼š</p><p> program ::= {label | instruction | directive | comment}	label ::= symbol &#39;:&#39;instruction ::= symbol [symbol {&#39;,&#39; symbol}]directive ::= &#39;.&#39; symbol [symbol {&#39;,&#39; symbol}]</p><p>ç¨‹åºï¼šï¼š={Label|Instructive|Directive|Comment}æ ‡ç­¾ï¼šï¼š=Symbol&#39ï¼›ï¼š&#39ï¼›æŒ‡ä»¤ï¼šï¼š=Symbol[Symbol{&#39ï¼›ï¼Œ&#39ï¼›Symbol}]æŒ‡ä»¤ï¼šï¼š=&#39ï¼›.&#39ï¼›Symbol[Symbol{&#39ï¼›ï¼Œ&#39ï¼›Symbol}]</p><p> Label is simple enough. An instruction is a symbol followed by zero or more operands that are comma separated. Here I am using symbol as a catch all. It can be a number, a register, an instruction, or a label. A directive is essentially the same as an instruction but it starts with a period.</p><p>æ ‡ç­¾å¾ˆç®€å•ã€‚æŒ‡ä»¤æ˜¯ä¸€ä¸ªç¬¦å·ï¼Œåè·Ÿä»¥é€—å·åˆ†éš”çš„é›¶ä¸ªæˆ–å¤šä¸ªæ“ä½œæ•°ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä½¿ç”¨ç¬¦å·ä½œä¸ºä¸€ä¸ªåŒ…ç½—ä¸‡è±¡çš„è¯ã€‚å®ƒå¯ä»¥æ˜¯æ•°å­—ã€å¯„å­˜å™¨ã€æŒ‡ä»¤æˆ–æ ‡ç­¾ã€‚æŒ‡ä»¤æœ¬è´¨ä¸Šä¸æŒ‡ä»¤ç›¸åŒï¼Œä½†å®ƒä»¥å¥ç‚¹å¼€å¤´ã€‚</p><p> Are we ready to implement the parser yet? Not quite. Although this is almost enough for RISC-V assembly, it is still missing quite a few features. To name a few: labels can be on the same line as an instruction, values can have a leading positive or negative sign, and offsets can be specified for an operand.</p><p>æˆ‘ä»¬å‡†å¤‡å¥½å®ç°è§£æå™¨äº†å—ï¼Ÿä¸å®Œå…¨æ˜¯ã€‚è™½ç„¶è¿™å¯¹äºRISC-Vç»„è£…æ¥è¯´å‡ ä¹è¶³å¤Ÿäº†ï¼Œä½†å®ƒä»ç„¶ç¼ºå°‘ç›¸å½“å¤šçš„åŠŸèƒ½ã€‚ä»…ä¸¾å‡ ä¾‹ï¼šæ ‡ç­¾å¯ä»¥ä¸æŒ‡ä»¤ä½äºåŒä¸€è¡Œï¼Œå€¼å¯ä»¥å…·æœ‰å‰å¯¼æ­£å·æˆ–è´Ÿå·ï¼Œå¹¶ä¸”å¯ä»¥ä¸ºæ“ä½œæ•°æŒ‡å®šåç§»é‡ã€‚</p><p>  program ::= {[label] [directive | instruction] [comment] newline}label ::= symbol &#39;:&#39;directive ::= &#39;.&#39; symbol [[&#39;.&#39; | &#39;+&#39; | &#39;-&#39;] symbol {&#39;,&#39; [&#39;+&#39; | &#39;-&#39;] symbol}]instruction ::= symbol [operand {&#39;,&#39; operand}]operand ::= [&#39;+&#39; | &#39;-&#39;] (symbol &#39;(&#39; symbol &#39;)&#39; | symbol)# Lexer rules in regex-ish notation.newline ::= [\n\r]+comment ::= #[^\n\r]+symbol ::= ([a-zA-Z0-9](&#39;.&#39;?[a-zA-Z0-9])*) | (\&#34;(\\[^\n]|[^&#34;\n])*\&#34;)# Whitespace, commas, colons, and parentheses are token delimiters.# Spaces and tabs can be used interchangeably and consecutively.</p><p>ç¨‹åºï¼šï¼š={[Label][æŒ‡ä»¤|æŒ‡ä»¤][æ³¨é‡Š]newline}æ ‡ç­¾ï¼šï¼š=Symbol&#39ï¼›ï¼š&#39ï¼›æŒ‡ä»¤ï¼šï¼š=&#39ï¼›.&#39ï¼›|&#39ï¼›+&#39ï¼›|&#39ï¼›-&#39ï¼›]Symbol{&#39ï¼›ï¼Œ&#39ï¼›[&#39ï¼›+&#39ï¼›|&#39ï¼›-&#39ï¼›]Symbol}]æŒ‡ä»¤ï¼šï¼š=Symbol[Operand{&#39ï¼›ï¼Œ&#39ï¼›Operand}]æ“ä½œæ•°ï¼šï¼š=[&#39ï¼›+&#39ï¼›|&#39ï¼›-&#39ï¼›](Symbol&#39ï¼›(&#39ï¼›Symbol&#39ï¼›)&#39ï¼›|Symbol)#æ­£åˆ™è¡¨ç¤ºæ³•çš„è¯æ³•åˆ†æå™¨è§„åˆ™ã€‚newlineï¼šï¼š=[\n\r]+COMMENTï¼šï¼š=#[^\n\r]+Symbolï¼šï¼š=([a-Za-Z0-9](&#39ï¼›.&#39ï¼›ï¼Ÿ[A-Za-Z0-9])*)|(\&#34ï¼›(\\[^\n]|[^&#34ï¼›\n])*\&#34ï¼›)#ç©ºæ ¼ã€é€—å·ã€å†’å·å’Œåœ†æ‹¬å·æ˜¯æ ‡è®°åˆ†éš”ç¬¦ã€‚#ç©ºæ ¼å’Œåˆ¶è¡¨ç¬¦å¯ä»¥äº’æ¢å’Œè¿ç»­ä½¿ç”¨ã€‚</p><p> But wait! How do we know that an instruction or register was used properly? I decided to keep the grammar as minimal as possible and to verify such things later on. That means that this grammar will accept some code that is not allowed, but that in the next step we can prune out. For example, &#34;xor xor, xor, xor, xor&#34; will be parsed just fine, despite it not being legal RISC-V assembly. We can fix that.</p><p>ä½†æ˜¯ç­‰ç­‰ï¼æˆ‘ä»¬å¦‚ä½•çŸ¥é“æŒ‡ä»¤æˆ–å¯„å­˜å™¨æ˜¯å¦æ­£ç¡®ä½¿ç”¨ï¼Ÿæˆ‘å†³å®šå°½é‡å‡å°‘è¯­æ³•ï¼Œå¹¶åœ¨ä»¥åéªŒè¯è¿™äº›å†…å®¹ã€‚è¿™æ„å‘³ç€è¯¥è¯­æ³•å°†æ¥å—ä¸€äº›ä¸å…è®¸çš„ä»£ç ï¼Œä½†æ˜¯åœ¨ä¸‹ä¸€æ­¥æˆ‘ä»¬å¯ä»¥åˆ é™¤ã€‚ä¾‹å¦‚ï¼Œ&#34ï¼›xor xorï¼Œxor&34ï¼›å¯ä»¥å¾ˆå¥½åœ°è§£æï¼Œå°½ç®¡å®ƒä¸æ˜¯åˆæ³•çš„RISC-Vç¨‹åºé›†ã€‚æˆ‘ä»¬å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p><p>  If you are interested in using the parser for your own project, there may be a few things you&#39;ll want to add. Namely, a  verification step, similar to a semantic analysis step in compilers, that checks some of the following things:</p><p>å¦‚æœæ‚¨å¯¹å°†è§£æå™¨ç”¨äºæ‚¨è‡ªå·±çš„é¡¹ç›®æ„Ÿå…´è¶£ï¼Œé‚£ä¹ˆæ‚¨å¯èƒ½éœ€è¦æ·»åŠ ä¸€äº›ä¸œè¥¿ã€‚å³ï¼Œç±»ä¼¼äºç¼–è¯‘å™¨ä¸­çš„è¯­ä¹‰åˆ†ææ­¥éª¤çš„éªŒè¯æ­¥éª¤ï¼Œå…¶æ£€æŸ¥ä»¥ä¸‹å†…å®¹ä¸­çš„ä¸€äº›ï¼š</p><p> Literal values are of correct form and size (e.g., hex or can be represented with 16 bits)</p><p>æ–‡å­—å€¼çš„å½¢å¼å’Œå¤§å°æ­£ç¡®(ä¾‹å¦‚ï¼Œåå…­è¿›åˆ¶æˆ–å¯ä»¥ç”¨16ä½è¡¨ç¤º)ã€‚</p><p> You would check these in the parser, by modifying the grammar functions,  Label(),  Directive(),  Instruction(), and  Operand(), to check the contents of the tokens.</p><p>æ‚¨å¯ä»¥é€šè¿‡ä¿®æ”¹è¯­æ³•å‡½æ•°Label()ã€Directive()ã€Instruction()å’ŒOperand()åœ¨è§£æå™¨ä¸­æ£€æŸ¥è¿™äº›æ ‡è®°ï¼Œä»¥æ£€æŸ¥æ ‡è®°çš„å†…å®¹ã€‚</p><p>  void Parser::Instruction() { NextToken(); // Is there at least one operand? if(!CheckToken(TokenType::Newline) &amp;&amp; !CheckToken(TokenType::Comment)) { Operand(); // Zero or more operands. while(CheckToken(TokenType::Comma)) { NextToken(); Operand(); } }}</p><p>Void Parserï¼šï¼šInstruction(){NextToken()ï¼›//æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªæ“ä½œæ•°ï¼ŸIF(ï¼CheckToken(TokenTypeï¼šï¼šnewline)&ampï¼›&ampï¼›ï¼CheckToken(TokenTypeï¼šï¼šComment)){Operand()ï¼›//é›¶ä¸ªæˆ–å¤šä¸ªæ“ä½œæ•°ã€‚While(CheckToken(TokenTypeï¼šï¼šComma)){NextToken()ï¼›Operand()ï¼›}</p><p>  void Parser::Instruction() { int numOperands = verifier-&gt;LookupInstruction(token-&gt;literal); if(numOperands == -1) { ReportError(&#34;Invalid instruction.&#34;); } NextToken(); // Is there at least one operand? int actNumOperands = 0; if(!CheckToken(TokenType::Newline) &amp;&amp; !CheckToken(TokenType::Comment)) { Operand(); actNumOperands++; // Zero or more operands. while(CheckToken(TokenType::Comma)) { NextToken(); Operand(); actNumOperands++; } // Verify correct number of operands. if(numOperands != actNumOperands) { ReportError(&#34;Incorrect number of operands.&#34;); } }}</p><p>Void Parserï¼šï¼šInstruction(){int numOperands=verifier-&gtï¼›LookupInstruction(token-&gtï¼›literal)ï¼›if(numOperands==-1){ReportError(&#34ï¼›Invalid Instruction.&#34ï¼›)ï¼›}NextToken()ï¼›//æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªæ“ä½œæ•°ï¼ŸInt actNumOperands=0ï¼›if(ï¼CheckToken(TokenTypeï¼šï¼šNewline)&ampï¼›&ampï¼›ï¼CheckToken(TokenTypeï¼šï¼šComment)){Operand()ï¼›actNumOperands++ï¼›//é›¶ä¸ªæˆ–å¤šä¸ªæ“ä½œæ•°ã€‚While(CheckToken(TokenTypeï¼šï¼šComma)){NextToken()ï¼›Operand()ï¼›actNumOperands++ï¼›}//éªŒè¯æ“ä½œæ•°æ˜¯å¦æ­£ç¡®ã€‚If(numOperandsï¼=actNumOperands){ReportError(&#34ï¼›æ“ä½œæ•°ä¸æ­£ç¡®ã€‚&#34ï¼›)ï¼›}ã€‚</p><p> Voila! The instructions and number of operands are now verified. To actually do this, I recommend implementing a  Verifier class that has functions for looking up if an instruction/directive exists and the number and format of operands for each, along with functions for verifying literals, registers, and labels.</p><p>ç§å•Šï¼ç°åœ¨éªŒè¯äº†æŒ‡ä»¤å’Œæ“ä½œæ•°çš„æ•°é‡ã€‚è¦çœŸæ­£åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘å»ºè®®å®ç°ä¸€ä¸ªVerizerç±»ï¼Œè¯¥ç±»å…·æœ‰æŸ¥æ‰¾æŒ‡ä»¤/æŒ‡ä»¤æ˜¯å¦å­˜åœ¨ä»¥åŠæ¯ä¸ªæŒ‡ä»¤çš„æ“ä½œæ•°çš„æ•°é‡å’Œæ ¼å¼çš„å‡½æ•°ï¼Œä»¥åŠç”¨äºéªŒè¯æ–‡å­—ã€å¯„å­˜å™¨å’Œæ ‡ç­¾çš„å‡½æ•°ã€‚</p><p> Similarly, you can add an  emitter step if you were building an assembler. In this scenario, you would look up the corresponding binary representation of each instruction and operand, emitting those to a file as you parse. You can see how a compiler does this in the emitting portion of my  Let&#39;s make a Teeny Tiny compiler tutorial.</p><p>åŒæ ·ï¼Œå¦‚æœæ‚¨æ­£åœ¨æ„å»ºæ±‡ç¼–å™¨ï¼Œåˆ™å¯ä»¥æ·»åŠ å‘å°„å™¨æ­¥éª¤ã€‚åœ¨æ­¤æ–¹æ¡ˆä¸­ï¼Œæ‚¨å°†æŸ¥æ‰¾æ¯æ¡æŒ‡ä»¤å’Œæ“ä½œæ•°çš„ç›¸åº”äºŒè¿›åˆ¶è¡¨ç¤ºå½¢å¼ï¼Œå¹¶åœ¨è§£ææ—¶å°†å…¶å‘é€åˆ°æ–‡ä»¶ã€‚æ‚¨å¯ä»¥åœ¨æˆ‘çš„letâ€˜s make a Teeny Tinyç¼–è¯‘å™¨æ•™ç¨‹çš„å‘å‡ºéƒ¨åˆ†çœ‹åˆ°ç¼–è¯‘å™¨æ˜¯å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹çš„ã€‚</p><p>  A notable feature that cannot be parsed with this parser is math expressions. Luckily, this is a fairly easy thing to add! I have previously written a tutorial on parsing that covers math expressions. See part 1 of  Let&#39;s make a Teeny Tiny compiler. The GNU assembler supports two prefix operators, - and ~ for negation and complementation, and these binary operators from highest precedence to lowest: *, /, %, &lt;, &lt;&lt;, &gt;, &gt;&gt;, |, &amp;, ^, !, +, -.</p><p>è¿™ä¸ªè§£æå™¨ä¸èƒ½è§£æçš„ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„ç‰¹æ€§æ˜¯æ•°å­¦è¡¨è¾¾å¼ã€‚å¹¸è¿çš„æ˜¯ï¼Œè¿™æ˜¯ä¸€ä¸ªç›¸å½“å®¹æ˜“æ·»åŠ çš„ä¸œè¥¿ï¼æˆ‘ä»¥å‰å†™è¿‡ä¸€ç¯‡å…³äºè§£æçš„æ•™ç¨‹ï¼Œæ¶µç›–äº†æ•°å­¦è¡¨è¾¾å¼ã€‚è¯·å‚é˜…â€œè®©æˆ‘ä»¬åšä¸€ä¸ªå°å°çš„ç¼–è¯‘å™¨â€çš„ç¬¬1éƒ¨åˆ†ã€‚GNUæ±‡ç¼–å™¨æ”¯æŒä¸¤ä¸ªå‰ç¼€è¿ç®—ç¬¦-å’Œ~ç”¨äºå¦å®šå’Œäº’è¡¥ï¼Œå¹¶ä¸”è¿™äº›äºŒå…ƒè¿ç®—ç¬¦ä»æœ€é«˜ä¼˜å…ˆçº§åˆ°æœ€ä½ä¼˜å…ˆçº§ä¾æ¬¡ä¸ºï¼š*ã€/ã€%ã€&ltï¼›ã€&ltï¼›ã€&gtï¼›ã€&gtï¼›&gtï¼›ã€|ã€&ampï¼›ã€^ã€ï¼ã€+ã€-ã€‚</p><p>  expression ::= bitwise {( &#34;-&#34; | &#34;+&#34; ) bitwise}bitwise ::= term {( &#39;|&#39; | &#39;&amp;&#39; |&#39;^&#39; ) term}term ::= unary {( &#34;/&#34; | &#34;*&#34; ) unary}unary ::= [&#34;+&#34; | &#34;-&#34;] symbol</p><p>è¡¨è¾¾å¼ï¼šï¼š=æŒ‰ä½{(&#34ï¼›-&#34ï¼›|&#34ï¼›+&#34ï¼›)æŒ‰ä½}æŒ‰ä½ï¼š=Term{(&#39ï¼›|&#39ï¼›|&#39ï¼›&ampï¼›&#39ï¼›|&#39ï¼›^&#39ï¼›)Term}Termï¼šï¼š=ä¸€å…ƒ{(&#34ï¼›/&#34ï¼›|&#34ï¼›*&#34ï¼›)ä¸€å…ƒ}ç¬¦å·ï¼šï¼š=[&#34ï¼›+&#34ï¼›|&#34ï¼›-&#34ï¼›]ç¬¦å·ã€‚</p><p> Preprocessor features (i.e., #include and #define) and multi-line comments are left as an exercise to the reader... ğŸ™‚</p><p>é¢„å¤„ç†å™¨ç‰¹æ€§(å³#includeå’Œ#define)å’Œå¤šè¡Œæ³¨é‡Šç•™ç»™è¯»è€…ä½œä¸ºç»ƒä¹ â€¦â€¦ã€‚ğŸ™‚ã€‚</p><p>  The core of assemblers really are quite simple. They do little more than string substitution, so parsing should be trivial. Assembly languages aren&#39;t even recursive! You just need to replace instruction mnemonics and operands with their respective binary representation. However, the mainstream assemblers allow constructs that make parsing a little more complicated, plus assembly languages are not standardized. Despite all this, this article should prove that these problems can be solved if you take them step by step.</p><p>æ±‡ç¼–å™¨çš„æ ¸å¿ƒç¡®å®éå¸¸ç®€å•ã€‚å®ƒä»¬åªåšå­—ç¬¦ä¸²æ›¿æ¢ï¼Œæ‰€ä»¥è§£æåº”è¯¥å¾ˆç®€å•ã€‚æ±‡ç¼–è¯­è¨€ç”šè‡³ä¸æ˜¯é€’å½’çš„ï¼æ‚¨åªéœ€å°†æŒ‡ä»¤åŠ©è®°ç¬¦å’Œæ“ä½œæ•°æ›¿æ¢ä¸ºå®ƒä»¬å„è‡ªçš„äºŒè¿›åˆ¶è¡¨ç¤ºå½¢å¼ã€‚ç„¶è€Œï¼Œä¸»æµæ±‡ç¼–å™¨å…è®¸æ„é€ ä½¿è§£æç¨å¾®å¤æ‚ä¸€äº›ï¼Œè€Œä¸”æ±‡ç¼–è¯­è¨€æ²¡æœ‰æ ‡å‡†åŒ–ã€‚å°½ç®¡å¦‚æ­¤ï¼Œæœ¬æ–‡åº”è¯¥è¯æ˜ï¼Œå¦‚æœä½ å¾ªåºæ¸è¿›ï¼Œè¿™äº›é—®é¢˜æ˜¯å¯ä»¥è§£å†³çš„ã€‚</p><p>  Hopefully this parser can help you with your RISC-V project. If you use it, shoot me an email and let me know about your project! You can find the source code on  GitHub.</p><p>å¸Œæœ›è¿™ä¸ªè§£æå™¨å¯ä»¥å¸®åŠ©æ‚¨å¤„ç†RISC-Vé¡¹ç›®ã€‚å¦‚æœä½ ä½¿ç”¨å®ƒï¼Œç»™æˆ‘å‘ä¸€å°ç”µå­é‚®ä»¶ï¼Œè®©æˆ‘çŸ¥é“ä½ çš„é¡¹ç›®ï¼æ‚¨å¯ä»¥åœ¨GitHubä¸Šæ‰¾åˆ°æºä»£ç ã€‚</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://web.eecs.utk.edu/~azh/blog/parsingriscv.html">https://web.eecs.utk.edu/~azh/blog/parsingriscv.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ç¨‹åº/">#ç¨‹åº</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/æŒ‡ä»¤/">#æŒ‡ä»¤</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031352.html"><img src="http://img2.diglog.com/img/2020/10/thumb_5605bf4ec42c70945d13b66251f27051.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031352.html">è®ºæœ¬åœ°åº”ç”¨ç¨‹åº</a></div><span class="my_story_list_date">2020-10-27 6:23</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031336.html"><img src="http://img2.diglog.com/img/2020/10/thumb_1a65df924f8779c225ea2e11e4155568.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031336.html">ä½¿ç”¨Reaction Native for Webåœ¨Webä¸Šè¿è¡Œæ‚¨çš„Reaction Nativeåº”ç”¨ç¨‹åº</a></div><span class="my_story_list_date">2020-10-27 6:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031283.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2cb6bfd97ab3ee538969ec06516b4c0a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031283.html">UEFI-rsï¼šç”¨Rustç¼–å†™UEFIåº”ç”¨ç¨‹åº</a></div><span class="my_story_list_date">2020-10-27 0:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031259.html"><img src="http://img2.diglog.com/img/2020/10/thumb_895c4bbecd9ceab3d056ef918cb36859.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031259.html">
YouTubeæ›´æ–°äº†å…¶ç§»åŠ¨åº”ç”¨ç¨‹åºï¼Œå¢åŠ äº†æ–°æ‰‹åŠ¿ã€è§†é¢‘ç« èŠ‚åˆ—è¡¨ç­‰åŠŸèƒ½</a></div><span class="my_story_list_date">2020-10-27 0:2</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¾å›½/">#ç¾å›½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¨‹åº/">#ç¨‹åº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>