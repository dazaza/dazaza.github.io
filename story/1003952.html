<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>首先了解JavaScript中的记录和元组</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">首先了解JavaScript中的记录和元组</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-28 00:57:35</div><div class="page_narrow text-break page_content"><p>在这篇博客文章中，我们首先来看看由Robin Ricard和Rick Button提出的ECMAScript提案“Record&amp；Tuple”。该方案在JavaScript中增加了两种复合原始值：</p><p>目前，JavaScript仅按值比较诸如字符串之类的原始值(通过查看其内容)：</p><p>相反，对象按身份进行比较(对象仅与其自身严格相等)：</p><p>&gt；{x：1，y：4}=={x：1，y：4}false&gt；[&#39；a&#39；，&#39；b&#39；]=[&#39；a&#39；，&#39；b&#39；]false。</p><p>Proposal Record&amp；Tuple(由Robin Ricard和Rick Button编写)允许我们创建按值进行比较的复合值。</p><p>例如，通过在对象文本前面加上数字符号(#)，我们创建了一条记录-一个按值比较且不可变的复合值：</p><p>如果我们以#作为Array文字的前缀，则会创建一个tuple-一个按值比较且不可变的Array：</p><p>按值比较的复合值称为复合基元值或复合基元。</p><p>警告：这些转换很浅。如果值树中的任何节点不是原始节点，那么Record()和Tuple.from()将抛出异常。</p><p>const record=#{x：1，y：4}；//访问属性assert.equal(record.y，4)；//Destructuringconst{x}=Records；assert.equal(x，1)；//Spreadingassert.ok(#{.record，x：3，z：9}=#{x：3，y：4，z：9})；</p><p>const tuple=#[&#39；a&#39；，&#39；b&#39；]；//访问elementsassert.etc(tuple[1]，&#39；b&#39；)；//解构(元组是可迭代的)const[a]=tuple；assert.etc(a，&#39；a&#39；)；//Spreadingassert.ok(#[.tuple，&#39；c&#39；]=。，&#39；c&#39；])；//Updatingassert.ok(tuple.with(0，&#39；x&#39；)=#[&#39；x&#39；，&#39；b&#39；])；</p><p>某些数据结构(如散列映射和搜索树)具有根据其值放置关键字的槽。如果密钥的值发生更改，则通常必须将其放入不同的插槽中。这就是为什么在JavaScript中，可以用作键的值是：</p><p>深入比较对象-这是一个内置操作，可以调用，例如，VIA=。</p><p>共享值：如果一个对象是可变的，如果我们想要安全地共享它，我们需要深入复制它。对于不变的值，共享不是问题。</p><p>数据的非破坏性更新：当我们创建复合值的修改副本时，我们可以安全地重用该复合值的某些部分(因为所有内容都是不可变的)。</p><p>使用诸如Maps和Set这样的数据结构：它们变得更加强大，因为在语言中的任何地方(包括Maps的键和Set的元素)，具有相同内容的两个复合原语被认为是严格相等的。</p><p>使用复合原语，即使它们是复合的(而不是原子的，就像原始值一样)，我们也可以消除重复项：</p><p>由于对象是按标识进行比较的，因此将它们用作(非弱)映射中的键几乎没有意义：</p><p>如果我们使用复合原语，这就不同了：A行中的Map将地址(记录)映射到名称。</p><p>Const People=[#{name：&#39；Eddie&#39；，address：#{Street：&#39；1313 Mockingbird Lane&#39；，City：&#39；Mockingbird Heights&#39；，}，}，#{name：&#39；Dawn&#39；，地址：#{Street：&#39；1630 Revello Drive&#39；，City：&#39；Sunnydale&#39；，}，}，，地址：#{Street：&#39；1313 Mockingbird Lane&#39；，City：&#39；，}，}，#{name：&#39；Joyce&#39；，地址：#{Street：&#39；1630 Revello Drive&#39；，City：&#39；Sunnydale&#39；，}，}，]；const address sToNames=new Map()；//(A)for(Const Person Of Person){if(！AddressToNames.has(Person.address)){AddressToNames.set(Pers.address，new set())；}addressToNames.get(person.address).add(person.name)；}assert.deepEqual(//将映射转换为键值对数组，//这样我们就可以通过assert.deepequal.()进行比较。[.AddressToNames]，[#{Street：&#39；1313 Mockingbird Lane&#39；，City：&#39；Mockingbird Heights&#39；，}，new set([&#39；Eddie&#39；，&#39；Herman&#39；])，]，[#{Street：&#39；1630 Revello Drive&#39；，City：&#39；Sunnydale&#39；，}，New。Joyce&#39；]))，]，])；</p><p>在下面的示例中，我们使用Array方法.filter()(行B)提取地址等于地址(行A)的所有条目。</p><p>Const People=[#{name：&#39；Eddie&#39；，address：#{Street：&#39；1313 Mockingbird Lane&#39；，City：&#39；Mockingbird Heights&#39；，}，}，#{name：&#39；Dawn&#39；，地址：#{Street：&#39；1630 Revello Drive&#39；，City：&#39；Sunnydale&#39；，}，}，，地址：#{Street：&#39；1313 Mockingbird Lane&#39；，City：&#39；Mockingbird Heights&#39；，}，}，#{name：&#39；Joyce&#39；，地址：#{Street：&#39；1630 Revello Drive&#39；，City：&#39；Sunnydale&#39；，}，}，]；Const Address=#{//(A)Street：&#39，城市：&#39；Sunnydale&#39；，}；assert.Deep Equity(Persons.filter(p=&gt；p.address=地址)，//(B)[#{name：&#39；Dawn&#39；，address：#{Street：&#39；1630 Revello Drive&#39；，City：&#39；Sunnydale&#39；，}，}，#{name：&#39；Joyce&#39；，地址：#{Street：&#39；1630 Revello Drive&#39；，City：&#39；Sunnydale&#39；，}，}，#{name：&#39；Joyce&#39；，地址：#{Street：&#39。，城市：&#39；Sunnydale&#39；，}，}，])；</p><p>每当我们处理缓存数据(如下例中的previousData)时，内置的深度相等功能使我们可以有效地检查是否有任何更改。</p><p>让previousData；function Displaydata(Data){if(data=previousData)返回；//··}Displaydata(#[&#39；Hello&#39；，&#39；world&#39；])；//displayeddisplayData(#[&#39；Hello&#39；，&#39；world&#39；])；//不显示</p><p>大多数测试框架都支持深度相等，以检查计算是否产生预期结果。例如，内置的Node.js模块assert具有函数DeepEquity()。对于复合原语，我们有一种替代此类功能的方法：</p><p>函数invert(Color){return#{red：255-color.red，green：255-color.green，}；}assert.ok(invert(#{red：255，green：153，Blue：51})=#{red：0，green：102，Blue：204})；</p><p>注意：考虑到内置的相等检查不只是比较值，它们更有可能支持复合原语并且对它们更有效(与过时的检查相比)。</p><p>新语法的一个缺点是，字符#已经在其他地方使用(用于私有字段)，并且非字母数字字符总是稍显隐晦。我们可以在这里看到这一点：</p><p>Const della=#{name：&#39；Della&#39；，孩子：#[#{name：&#39；Huey&39；，}，#{name：&#39；Dewey&39；，}，#{name：&#39；Louie&39；，}，]，}；</p><p>优点是该语法非常简洁。如果经常使用某个构造，并且我们希望避免冗长，那么这一点很重要。此外，因为我们已经习惯了这种语法，所以隐蔽性就不是什么问题了。</p><p>const della=记录({：&#39；Della&#39；，：tuple([ord({：&#39；Huey&39；，})，Record({：&#39；Dewey&39；，})，Record({：&#39；Louie&39；，})，]，})；</p><p>如果JavaScript支持标记集合文字(Kat Marchán提出的建议，但她已撤回)，则可以改进此语法：</p><p>const della=记录！{：&#39；Della&39；，：tuple！[RECORD！{：&#39；Huey&39；，}，Record！{：&#39；Dewey&39；，}，Record！{：&#39；Louie&#39；，}，]，}；</p><p>const R=记录；const T=Tuple；const della=R！{：&#39；Della&#39；，：t！[r！{：&#39；Huey&39；，}，R！{：&#39；Dewey&39；，}，R！{：&#39；Louie&#39；，}，]，}；</p><p>parseImmutable的工作原理与JSON.parse()类似，但是返回记录而不是对象和元组，而不是数组(递归)。</p><p>我喜欢使用通常只是数据容器的类，而不是普通的对象或数组，因为它们将名称附加到对象。出于这个原因，我希望我们最终能得到实例不变并按值进行比较的类。</p><p>如果我们还支持深度、非破坏性地更新包含值类型类生成的对象的数据，那就太好了。</p><p>在其他人中，以下人回复了我的一条推文，并对这篇博客帖子做出了贡献：@asp_net，@blomret，@imchrisitchens，@jamiedixon，@mattxcurtis，@orangecms。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://2ality.com/2020/05/records-tuples-first-look.html">https://2ality.com/2020/05/records-tuples-first-look.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tuples/">#tuples</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1003460.html"><img src="http://img.diglog.com/img/2020/5/thumb_477ab4645a7305579ddf76a77377ad89.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1003460.html">Java编程语言庆祝其25周年诞辰。下一个是什么？</a></div><span class="my_story_list_date">2020-5-24 7:36</span></div><div class="col-sm"><div><a target="_blank" href="/story/1003206.html"><img src="http://img.diglog.com/img/2020/5/thumb_24bb5b081b20c39c228b9c4f36bbc507.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1003206.html">一元函数控制流微库的JavaScript/TypeScript</a></div><span class="my_story_list_date">2020-5-22 6:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1002993.html"><img src="http://img.diglog.com/img/2020/5/thumb_9e62b936a141e39fbdf5eb53cc783c82.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1002993.html">JavaScript的第三个时代</a></div><span class="my_story_list_date">2020-5-21 1:50</span></div><div class="col-sm"><div><a target="_blank" href="/story/1002747.html"><img src="http://img.diglog.com/img/2020/5/thumb_d88be342f778ae311b6e5a0efb01cc19.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1002747.html">Java.net.SocketInputStream.socketRead0中的线程卡住</a></div><span class="my_story_list_date">2020-5-19 15:9</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>