<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>MinisSelectï¼šå®ç”¨å’Œé€šç”¨çš„é€‰æ‹©ç®—æ³•</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">MinisSelectï¼šå®ç”¨å’Œé€šç”¨çš„é€‰æ‹©ç®—æ³•</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 04:59:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/e4f9124f2ea9fec53ac26d7acba0b222.png"><img src="http://img2.diglog.com/img/2020/11/e4f9124f2ea9fec53ac26d7acba0b222.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Today I present a big effort from my side to publish  miniselect â€” generic C++ library to support multiple selection and partial sorting algorithms. It is already  used in  ClickHouse with huge performance benefits. Exact benchmarks and results will be later in this post and now letâ€™s tell some stories about how it all arose. I publish this library under Boost License and any contributions are highly welcome.</p><p>ä»Šå¤©ï¼Œæˆ‘åœ¨å‘å¸ƒè¿·ä½ é€‰æ‹©æ³›å‹C++åº“æ–¹é¢åšäº†å¾ˆå¤§çš„åŠªåŠ›ï¼Œä»¥æ”¯æŒå¤šé‡é€‰æ‹©å’Œéƒ¨åˆ†æ’åºç®—æ³•ã€‚å®ƒå·²ç»åœ¨ClickHouseä¸­ä½¿ç”¨ï¼Œå¸¦æ¥äº†å·¨å¤§çš„æ€§èƒ½ä¼˜åŠ¿ã€‚ç¡®åˆ‡çš„åŸºå‡†å’Œç»“æœå°†åœ¨è¿™ç¯‡æ–‡ç« çš„åé¢ä»‹ç»ï¼Œç°åœ¨è®©æˆ‘ä»¬æ¥è®²è¿°ä¸€äº›å…³äºè¿™ä¸€åˆ‡æ˜¯å¦‚ä½•å‘ç”Ÿçš„æ•…äº‹ã€‚æˆ‘åœ¨Boostè®¸å¯ä¸‹å‘å¸ƒäº†è¿™ä¸ªåº“ï¼Œä»»ä½•è´¡çŒ®éƒ½æ˜¯éå¸¸å—æ¬¢è¿çš„ã€‚</p><p>  While reading lots of articles, papers, and posts from Hacker News, I found it pretty funny each several months new â€œshinyâ€, â€œfastestâ€, â€œgenericâ€ sorting algorithms to come or remembered from old papers such as the recent paper on  learned sorting,  Kirkpatrick-Reisch sort or  pdqsort. It is that we are essentially 65+ years into writing sorting algorithms, and we still find improvements. Shouldnâ€™t sorting items be a â€œsolvedâ€ problem by now? Unfortunately, not. New hardware features come, we find that sorting numbers can be actually done faster than best comparison   time complexity and we still find improvements in sorting algorithms like avoiding  branches in partitions and trying to find good pivots as pdqsort does. Also, there are many open questions in that area as â€œwhat is the minimum number of comparisons needed?â€.</p><p>åœ¨é˜…è¯»Hacker Newsçš„å¤§é‡æ–‡ç« ã€è®ºæ–‡å’Œå¸–å­æ—¶ï¼Œæˆ‘å‘ç°æ¯éš”å‡ ä¸ªæœˆå°±ä¼šæœ‰æ–°çš„â€œé—ªäº®â€ã€â€œæœ€å¿«â€ã€â€œé€šç”¨â€çš„æ’åºç®—æ³•ä»æ—§æŠ¥çº¸ä¸Šå‡ºç°æˆ–è®°ä½ï¼Œæ¯”å¦‚æœ€è¿‘å‘è¡¨çš„å…³äºå­¦ä¹ æ’åºã€Kirkpatrick-Reischæ’åºæˆ–pdqortçš„è®ºæ–‡ã€‚é‚£å°±æ˜¯æˆ‘ä»¬åŸºæœ¬ä¸Šå·²ç»èŠ±äº†65å¹´ä»¥ä¸Šçš„æ—¶é—´æ¥ç¼–å†™æ’åºç®—æ³•ï¼Œè€Œä¸”æˆ‘ä»¬ä»ç„¶åœ¨å¯»æ‰¾æ”¹è¿›ä¹‹å¤„ã€‚åˆ†æ‹£ç‰©å“ç°åœ¨ä¸åº”è¯¥æ˜¯ä¸€ä¸ªâ€œè§£å†³â€çš„é—®é¢˜å—ï¼Ÿä¸å¹¸çš„æ˜¯ï¼Œæ²¡æœ‰ã€‚æ–°çš„ç¡¬ä»¶ç‰¹æ€§å‡ºç°åï¼Œæˆ‘ä»¬å‘ç°å¯¹æ•°å­—è¿›è¡Œæ’åºå®é™…ä¸Šå¯ä»¥æ¯”æœ€ä½³æ¯”è¾ƒæ—¶é—´å¤æ‚åº¦æ›´å¿«ï¼Œæˆ‘ä»¬ä»ç„¶å‘ç°æ’åºç®—æ³•çš„æ”¹è¿›ï¼Œæ¯”å¦‚é¿å…åˆ†åŒºä¸­çš„åˆ†æ”¯ï¼Œä»¥åŠåƒpdqsorté‚£æ ·è¯•å›¾æ‰¾åˆ°å¥½çš„è½´å¿ƒç‚¹ã€‚æ­¤å¤–ï¼Œåœ¨è¿™ä¸€é¢†åŸŸè¿˜æœ‰è®¸å¤šæ‚¬è€Œæœªå†³çš„é—®é¢˜ï¼Œæ¯”å¦‚â€œéœ€è¦è¿›è¡Œçš„æœ€å°æ¯”è¾ƒæ¬¡æ•°æ˜¯å¤šå°‘ï¼Ÿâ€</p><p> Huge competition is still going on in sorting algorithms and I believe we are not near the optimal sorting and learned sorting looks like the next step. But it uses the fundamental fact that no one expects sorting to be completed in a couple of passes and we can understand something about data during first array passes. We will understand why it matters later.</p><p>æ’åºç®—æ³•æ–¹é¢çš„æ¿€çƒˆç«äº‰ä»åœ¨ç»§ç»­ï¼Œæˆ‘ç›¸ä¿¡æˆ‘ä»¬è¿˜æ²¡æœ‰è¾¾åˆ°æœ€ä½³æ’åºï¼Œè€Œä¹ å¾—æ’åºçœ‹èµ·æ¥æ˜¯ä¸‹ä¸€æ­¥ã€‚ä½†å®ƒä½¿ç”¨çš„åŸºæœ¬äº‹å®æ˜¯ï¼Œæ²¡æœ‰äººæœŸæœ›åœ¨å‡ æ¬¡æ•°ç»„éå†ä¸­å®Œæˆæ’åºï¼Œå¹¶ä¸”æˆ‘ä»¬å¯ä»¥åœ¨ç¬¬ä¸€æ¬¡æ•°ç»„éå†æœŸé—´ç†è§£ä¸€äº›å…³äºæ•°æ®çš„å†…å®¹ã€‚æˆ‘ä»¬ç¨åä¼šæ˜ç™½ä¸ºä»€ä¹ˆè¿™å¾ˆé‡è¦ã€‚</p><p> My favorite general sorting is  pdqsort, it proves to be currently the best general sorting algorithm and it shows a significant boost over all standard sorts that are provided in C++. It is also  used in Rust.</p><p>æˆ‘æœ€å–œæ¬¢çš„é€šç”¨æ’åºæ˜¯pdqortï¼Œå®ƒè¢«è¯æ˜æ˜¯ç›®å‰æœ€å¥½çš„é€šç”¨æ’åºç®—æ³•ï¼Œè€Œä¸”å®ƒæ¯”C++æä¾›çš„æ‰€æœ‰æ ‡å‡†æ’åºéƒ½æœ‰å¾ˆå¤§çš„æå‡ã€‚å®ƒä¹Ÿè¢«ç”¨åœ¨ç”Ÿé”ˆä¸­ã€‚</p><p>  Nearly a couple of months ago I started thinking about a slightly different approach when it comes to sorting â€” partial sorting algorithms. It means that you donâ€™t need to sort all   elements but only find   smallest and sort them. For example, it is widely used in SQL queries when you do  ORDER BY LIMIT N and  N is often small, from 1-10 to ideally couple of thousands, bigger values still happen but rare. And, oh god, how little engineering and theoretical research has been done there compared to full sorting algorithms. In fact, the question of specifically finding  th order statistics when   is small is open and no good solution is presented. Also, partial sorting is quite easy to obtain after that, you need to sort the first   elements by some sorting algorithm to get optimal   comparisons and we will look at only one example when it is not the case. Yes, there are a bunch of median algorithms that can be generalized to find the  th smallest element. So, what are they? Yeah, you may know some of them but letâ€™s revise, it is useful to know your enemies.</p><p>å¤§çº¦å‡ ä¸ªæœˆå‰ï¼Œæˆ‘å¼€å§‹è€ƒè™‘ä¸€ç§ç•¥å¾®ä¸åŒçš„æ’åºæ–¹æ³•--éƒ¨åˆ†æ’åºç®—æ³•ã€‚è¿™æ„å‘³ç€æ‚¨ä¸éœ€è¦å¯¹æ‰€æœ‰å…ƒç´ è¿›è¡Œæ’åºï¼Œåªéœ€æ‰¾åˆ°æœ€å°çš„å…ƒç´ å¹¶å¯¹å…¶è¿›è¡Œæ’åºã€‚ä¾‹å¦‚ï¼Œå®ƒåœ¨SQLæŸ¥è¯¢ä¸­è¢«å¹¿æ³›ä½¿ç”¨ï¼Œå½“æ‚¨æ‰§è¡ŒORDER BY LIMIT Næ—¶ï¼ŒNé€šå¸¸å¾ˆå°ï¼Œä»1-10åˆ°ç†æƒ³çš„å‡ åƒï¼Œæ›´å¤§çš„å€¼ä»ç„¶ä¼šå‡ºç°ï¼Œä½†å¾ˆå°‘å‡ºç°ã€‚è€Œä¸”ï¼Œå¤©å“ªï¼Œä¸å…¨æ’åºç®—æ³•ç›¸æ¯”ï¼Œåœ¨é‚£é‡Œåšçš„å·¥ç¨‹å’Œç†è®ºç ”ç©¶æ˜¯å¤šä¹ˆçš„å°‘ã€‚äº‹å®ä¸Šï¼Œåœ¨å°çš„æƒ…å†µä¸‹å…·ä½“å¯»æ‰¾é¡ºåºç»Ÿè®¡é‡çš„é—®é¢˜ä¸€ç›´æ˜¯ä¸€ä¸ªæœªè§£å†³çš„é—®é¢˜ï¼Œä¹Ÿæ²¡æœ‰å¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆã€‚æ­¤å¤–ï¼Œéƒ¨åˆ†æ’åºåœ¨æ­¤ä¹‹åéå¸¸å®¹æ˜“è·å¾—ï¼Œæ‚¨éœ€è¦é€šè¿‡æŸç§æ’åºç®—æ³•å¯¹ç¬¬ä¸€ä¸ªå…ƒç´ è¿›è¡Œæ’åºï¼Œä»¥è·å¾—æœ€ä½³æ¯”è¾ƒï¼Œå¦‚æœä¸æ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬å°†åªçœ‹ä¸€ä¸ªä¾‹å­ã€‚æ˜¯çš„ï¼Œæœ‰å¾ˆå¤šä¸­å€¼ç®—æ³•å¯ä»¥æ¨å¹¿åˆ°å¯»æ‰¾ç¬¬å‡ ä¸ªæœ€å°çš„å…ƒç´ ã€‚é‚£ä¹ˆï¼Œå®ƒä»¬æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ˜¯çš„ï¼Œä½ å¯èƒ½çŸ¥é“å…¶ä¸­çš„ä¸€äº›ï¼Œä½†è®©æˆ‘ä»¬å¤ä¹ ä¸€ä¸‹ï¼Œäº†è§£ä½ çš„æ•Œäººæ˜¯æœ‰ç”¨çš„ã€‚</p><p>  This is almost the very first algorithm for finding the  th smallest element, just do like  QuickSort but donâ€™t go recursively in two directions, thatâ€™s it. Pick middle or even random element and partition by this element, see in which of two parts   is located, update the one of the borders, voila, after maximum of   partitions you will find  th smallest element. Good news that on average it takes   comparisons if we pick random pivot. That is because if we define   is the expected number of comparisons for finding  th element in   elements and  , then during one stage we do   comparisons and uniformly pick any pivot, then even if we pick the biggest part on each step</p><p>è¿™å‡ ä¹æ˜¯ç¬¬ä¸€ä¸ªæ‰¾åˆ°ç¬¬å‡ ä¸ªæœ€å°å…ƒç´ çš„ç®—æ³•ï¼Œå°±åƒå¿«é€Ÿæ’åºä¸€æ ·ï¼Œä½†ä¸è¦åœ¨ä¸¤ä¸ªæ–¹å‘é€’å½’ï¼Œä»…æ­¤è€Œå·²ã€‚é€‰å–ä¸­é—´ç”šè‡³éšæœºçš„å…ƒç´ å¹¶æŒ‰æ­¤å…ƒç´ è¿›è¡Œåˆ’åˆ†ï¼Œçœ‹çœ‹ä¸¤ä¸ªéƒ¨åˆ†ä¸­çš„å“ªä¸€ä¸ªä½äºå…¶ä¸­ï¼Œæ›´æ–°å…¶ä¸­ä¸€ä¸ªè¾¹ç•Œï¼Œç§ï¼Œåœ¨æœ€å¤§çš„åˆ’åˆ†ä¹‹åï¼Œæ‚¨å°†æ‰¾åˆ°æœ€å°çš„å…ƒç´ ã€‚å¥½æ¶ˆæ¯æ˜¯ï¼Œå¹³å‡è€Œè¨€ï¼Œå¦‚æœæˆ‘ä»¬é€‰æ‹©éšæœºè½´å¿ƒï¼Œå°±éœ€è¦è¿›è¡Œæ¯”è¾ƒã€‚è¿™æ˜¯å› ä¸ºï¼Œå¦‚æœæˆ‘ä»¬å®šä¹‰çš„æ˜¯åœ¨å…ƒç´ ä¸­æŸ¥æ‰¾å…ƒç´ çš„é¢„æœŸæ¯”è¾ƒæ¬¡æ•°ï¼Œç„¶ååœ¨ä¸€ä¸ªé˜¶æ®µä¸­ï¼Œæˆ‘ä»¬è¿›è¡Œæ¯”è¾ƒå¹¶ç»Ÿä¸€é€‰æ‹©ä»»ä½•è½´å¿ƒï¼Œé‚£ä¹ˆå³ä½¿æˆ‘ä»¬åœ¨æ¯ä¸€æ­¥ä¸­é€‰æ‹©æœ€å¤§çš„éƒ¨åˆ†ã€‚</p><p>     Bad news is that the worst case will still be   if we are unfortunate and always pick the biggest element as a pivot, thus partitioning .</p><p>åæ¶ˆæ¯æ˜¯ï¼Œæœ€åçš„æƒ…å†µä»ç„¶æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å¾ˆä¸å¹¸ï¼Œæ€»æ˜¯é€‰æ‹©æœ€å¤§çš„å…ƒç´ ä½œä¸ºæ”¯ç‚¹ï¼Œä»è€Œè¿›è¡Œåˆ†å‰²ã€‚</p><p> In that sense that algorithm provides lots of pivot â€œstrategiesâ€ that are used nowadays, for example, picking pivot as a   element of the array or picking pivot from 3 random elements . Or do like  std::nth_element from libcxx â€” choose the middle out out of  .</p><p>ä»è¿™ä¸ªæ„ä¹‰ä¸Šè¯´ï¼Œè¯¥ç®—æ³•æä¾›äº†è®¸å¤šç°åœ¨ä½¿ç”¨çš„æ¢è½´â€œç­–ç•¥â€ï¼Œä¾‹å¦‚ï¼Œé€‰å–æ¢è½´ä½œä¸ºæ•°ç»„çš„ä¸€ä¸ªå…ƒç´ ï¼Œæˆ–è€…ä»3ä¸ªéšæœºå…ƒç´ ä¸­é€‰å–æ¢è½´ã€‚æˆ–è€…åƒlibcxxä¸­çš„stdï¼šï¼šnth_elementä¸€æ ·-ä»ä¸­é€‰æ‹©ä¸­é—´éƒ¨åˆ†ã€‚</p><p> I decided to visualize all algorithms I am going to talk about today, so quickselect with a median of 3 strategy on random input looks something like this:</p><p>æˆ‘å†³å®šå°†æˆ‘ä»Šå¤©è¦è®¨è®ºçš„æ‰€æœ‰ç®—æ³•å¯è§†åŒ–ï¼Œæ‰€ä»¥éšæœºè¾“å…¥ç­–ç•¥ä¸­å€¼ä¸º3çš„QuickSelectå¦‚ä¸‹æ‰€ç¤ºï¼š</p><p>    For a strategy like  libcxx (C++ llvm standard library) does, there are quadratic counterexamples that are pretty easy to detect, such patterns also appear in real data. The counterexample looks like that:</p><p>å¯¹äºåƒlibcxx(C++llvmæ ‡å‡†åº“)è¿™æ ·çš„ç­–ç•¥ï¼Œæœ‰ä¸€äº›å¾ˆå®¹æ˜“æ£€æµ‹åˆ°çš„äºŒæ¬¡å‹åä¾‹ï¼Œè¿™æ ·çš„æ¨¡å¼ä¹Ÿå‡ºç°åœ¨å®é™…æ•°æ®ä¸­ã€‚åä¾‹å¦‚ä¸‹ï¼š</p><p>   This is definitely quadratic. By the way, this is perfectly ok with the C++ standard wording as it says:</p><p>è¿™ç»å¯¹æ˜¯äºŒæ¬¡æ›²çº¿ã€‚é¡ºä¾¿è¯´ä¸€å¥ï¼Œè¿™ä¸C++æ ‡å‡†æªè¾å®Œå…¨ä¸€è‡´ï¼Œå› ä¸ºå®ƒæ˜¯è¿™æ ·å†™çš„ï¼š</p><p>   For a long time, computer scientists thought that it is impossible to find medians in worst-case linear time, however, Blum, Floyd, Pratt, Rivest, Tarjan came up with BFPRT algorithm or like sometimes it is called, median of medians algorithm.</p><p>é•¿æœŸä»¥æ¥ï¼Œè®¡ç®—æœºç§‘å­¦å®¶è®¤ä¸ºä¸å¯èƒ½åœ¨æœ€åçš„çº¿æ€§æ—¶é—´å†…æ‰¾åˆ°ä¸­å€¼ï¼Œç„¶è€Œï¼ŒBlumï¼ŒFloydï¼ŒPrattï¼ŒRivestï¼ŒTarjanç­‰äººæå‡ºäº†BFPRTç®—æ³•æˆ–ç±»ä¼¼çš„ç®—æ³•ï¼Œæœ‰æ—¶è¢«ç§°ä¸ºä¸­å€¼ç®—æ³•ã€‚</p><p>  Group the array into   groups of size 5 and find the median of each group. (For simplicity, we will ignore integrality issues.)</p><p>å°†æ•°ç»„åˆ†æˆå¤§å°ä¸º5çš„ç»„ï¼Œå¹¶æ±‚å‡ºæ¯ç»„çš„ä¸­ä½æ•°ã€‚(ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†å¿½ç•¥å®Œæ•´æ€§é—®é¢˜ã€‚)ã€‚</p><p> When we find the median   of   groups, at least   of them have at least 3 out of 5 elements that are smaller or equal than  , that said the biggest out of 2 partitioned chunks have size   and we have the reccurence</p><p>å½“æˆ‘ä»¬æ‰¾åˆ°ç¾¤çš„ä¸­ä½æ•°æ—¶ï¼Œè‡³å°‘å…¶ä¸­è‡³å°‘æœ‰3/5çš„å…ƒç´ å°äºæˆ–ç­‰äºï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ2ä¸ªåˆ†å‰²çš„å—ä¸­æœ€å¤§çš„æœ‰å¤§å°ï¼Œæˆ‘ä»¬æœ‰é‡ç°æ€§ã€‚</p><p>     Actually, this constant 10 is really big. For example, if we look a bit closer,   is at least 1 because we need to partition the array, then finding median out of 5 elements cannot be done in less than 6 comparisons (can be proven by only brute-forcing) and in 6 comparisons it can be done in the following way</p><p>å®é™…ä¸Šï¼Œè¿™ä¸ªå¸¸æ•°10çœŸçš„å¾ˆå¤§ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬çœ‹å¾—æ›´è¿‘ä¸€ç‚¹ï¼Œè‡³å°‘æ˜¯1ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦å¯¹æ•°ç»„è¿›è¡Œåˆ†åŒºï¼Œé‚£ä¹ˆåœ¨å°‘äº6æ¬¡æ¯”è¾ƒ(åªèƒ½é€šè¿‡æš´åŠ›å¼ºåˆ¶)ä¸­æ‰¾å‡º5ä¸ªå…ƒç´ ä¸­çš„ä¸­ä½æ•°æ˜¯ä¸å¯èƒ½çš„ï¼Œå¹¶ä¸”åœ¨6æ¬¡æ¯”è¾ƒä¸­å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ¥å®Œæˆã€‚</p><p> If  , then the problem is fairly easy. If  , the median value is the smaller of   and  . If not, the median value is the smaller of   and  .</p><p>å¦‚æœæ˜¯çš„è¯ï¼Œé‚£ä¹ˆé—®é¢˜å°±ç›¸å½“ç®€å•äº†ã€‚å¦‚æœæ˜¯ï¼Œåˆ™ä¸­å€¼ä¸ºå’Œçš„è¾ƒå°å€¼ã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™ä¸­å€¼ä¸ºå’Œä¸­çš„è¾ƒå°å€¼ã€‚</p><p> So  . If  , then the solution is the smaller of   and  . Otherwise, the solution is the smaller of   and  .</p><p>æ‰€ä»¥ã€‚å¦‚æœæ˜¯ï¼Œåˆ™è§£æ˜¯å’Œä¸­è¾ƒå°çš„ä¸€ä¸ªã€‚å¦åˆ™ï¼Œè§£æ˜¯å’Œä¸­è¾ƒå°çš„ä¸€ä¸ªã€‚</p><p> So that maximum   can be   and it gives us the upper bound   comparisons which looks like it can be achieved. Some other tricks can be done in place to achieve a bit lower constants like   (for example, sorting arrays of 5 and comparing less afterwards). In practice, the constant is really big and you can see it from the following demonstration which was even fastened because it took quite a few seconds:</p><p>æ‰€ä»¥æœ€å¤§å€¼æ˜¯å¯ä»¥çš„ï¼Œå®ƒç»™äº†æˆ‘ä»¬ä¸Šç•Œçš„æ¯”è¾ƒï¼Œçœ‹èµ·æ¥å®ƒæ˜¯å¯ä»¥è¾¾åˆ°çš„ã€‚è¿˜å¯ä»¥ä½¿ç”¨å…¶ä»–ä¸€äº›æŠ€å·§æ¥å®ç°æ›´ä½çš„å¸¸é‡ï¼Œä¾‹å¦‚ï¼Œå¯¹5çš„æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åæ¯”è¾ƒæ›´å°‘çš„æ•°ç»„(ä¾‹å¦‚ï¼Œå¯¹5çš„æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åè¿›è¡Œæ›´å°‘çš„æ¯”è¾ƒ)ã€‚åœ¨å®è·µä¸­ï¼Œè¿™ä¸ªå¸¸é‡çœŸçš„å¾ˆå¤§ï¼Œä½ å¯ä»¥ä»ä¸‹é¢çš„æ¼”ç¤ºä¸­çœ‹åˆ°å®ƒï¼Œå®ƒç”šè‡³è¢«å›ºå®šä½äº†ï¼Œå› ä¸ºå®ƒèŠ±äº†ç›¸å½“å¤šçš„æ—¶é—´ï¼š</p><p>   Another approach to finding  th element is to create a  heap on an array of size   and push other   elements into this heap. C++  std::partial_sort works that way (with additional heap sorting of the first heap). It shows good results for very small   and random/ascending arrays, however starts to significantly degrade with growing   and becomes impractical. Best case  , worst  , average  .</p><p>æ‰¾åˆ°è¯¥å…ƒç´ çš„å¦ä¸€ç§æ–¹æ³•æ˜¯åœ¨ä¸€ä¸ªå¤§å°æ•°ç»„ä¸Šåˆ›å»ºä¸€ä¸ªå †ï¼Œå¹¶å°†å…¶ä»–å…ƒç´ æ¨å…¥è¯¥å †ä¸­ã€‚C++stdï¼šï¼šPartial_Sortä»¥è¿™ç§æ–¹å¼å·¥ä½œ(å¯¹ç¬¬ä¸€å †è¿›è¡Œé¢å¤–çš„å †æ’åº)ã€‚å®ƒå¯¹éå¸¸å°çš„éšæœº/ä¸Šå‡é˜µåˆ—æ˜¾ç¤ºå‡ºå¾ˆå¥½çš„æ•ˆæœï¼Œä½†æ˜¯éšç€å¢é•¿å¼€å§‹æ˜¾è‘—ä¸‹é™ï¼Œå˜å¾—ä¸åˆ‡å®é™…ã€‚æœ€å¥½çš„ï¼Œæœ€åçš„ï¼Œä¸€èˆ¬çš„ã€‚</p><p>   As the previous algorithm is not very much practical and QuickSelect is really good on average, in 1997  â€œIntrospective Sorting and Selection Algorithmsâ€ from David Musser came out with a sorting algorithm called â€œIntroSelectâ€.</p><p>ç”±äºä»¥å‰çš„ç®—æ³•ä¸æ˜¯å¾ˆå®ç”¨ï¼ŒQuickSelectçš„å¹³å‡è¡¨ç°ä¹Ÿå¾ˆå¥½ï¼Œ1997å¹´David Musserçš„â€œå†…çœæ’åºå’Œé€‰æ‹©ç®—æ³•â€æå‡ºäº†ä¸€ç§åä¸ºâ€œIntroSelectâ€çš„æ’åºç®—æ³•ã€‚</p><p> IntroSelect works by optimistically starting out with QuickSelect and only switching to MedianOfMedians if it recurses too many times without making sufficient progress. Simply limiting the recursion to constant depth is not good enough, since this would make the algorithm switch on all sufficiently large arrays. Musser discusses a couple of simple approaches:</p><p>IntroSelectçš„å·¥ä½œåŸç†æ˜¯ä¹è§‚åœ°ä»QuickSelectå¼€å§‹ï¼Œåªæœ‰åœ¨å®ƒå¾ªç¯å¤ªå¤šæ¬¡è€Œæ²¡æœ‰å–å¾—è¶³å¤Ÿè¿›å±•çš„æƒ…å†µä¸‹æ‰åˆ‡æ¢åˆ°MedianOfMediansã€‚ç®€å•åœ°å°†é€’å½’é™åˆ¶ä¸ºæ’å®šæ·±åº¦æ˜¯ä¸å¤Ÿçš„ï¼Œå› ä¸ºè¿™ä¼šä½¿ç®—æ³•åˆ‡æ¢åˆ°æ‰€æœ‰è¶³å¤Ÿå¤§çš„æ•°ç»„ä¸Šã€‚é©¬å¡å°”è®¨è®ºäº†å‡ ç§ç®€å•çš„æ–¹æ³•ï¼š</p><p> Keep track of the list of sizes of the subpartitions processed so far. If at any point  Â recursive calls have been made without halving the list size, for some small positive  , switch to the worst-case linear algorithm.</p><p>è·Ÿè¸ªåˆ°ç›®å‰ä¸ºæ­¢å·²å¤„ç†çš„å­åˆ†åŒºçš„å¤§å°åˆ—è¡¨ã€‚å¦‚æœåœ¨ä»»ä½•æ—¶å€™ï¼Œåœ¨æ²¡æœ‰å°†åˆ—è¡¨å¤§å°å‡åŠçš„æƒ…å†µä¸‹è¿›è¡Œé€’å½’è°ƒç”¨ï¼Œå¯¹äºä¸€äº›å°çš„æ­£æ•°ï¼Œè¯·åˆ‡æ¢åˆ°æœ€åæƒ…å†µçº¿æ€§ç®—æ³•ã€‚</p><p> Sum the size of all partitions generated so far. If this exceeds the list size times some small positive constant  , switch to the worst-case linear algorithm.</p><p>æ±‚å‡ºåˆ°ç›®å‰ä¸ºæ­¢ç”Ÿæˆçš„æ‰€æœ‰åˆ†åŒºçš„å¤§å°ä¹‹å’Œã€‚å¦‚æœè¶…è¿‡åˆ—è¡¨å¤§å°ä¹˜ä»¥æŸä¸ªå°çš„æ­£å¸¸é‡ï¼Œåˆ™åˆ‡æ¢åˆ°æœ€åæƒ…å†µçº¿æ€§ç®—æ³•ã€‚</p><p> This algorithm came into  libstdcxx and guess which strategy was chosen? Correct, none of them. Instead, they try   QuickSelect steps and if not successful, fallback to HeapSelect algorithm. So, worst case  , average</p><p>è¿™ä¸ªç®—æ³•è¿›å…¥libstdcxxï¼ŒçŒœçŒœé€‰æ‹©äº†å“ªç§ç­–ç•¥ï¼Ÿæ²¡é”™ï¼Œéƒ½ä¸æ˜¯ã€‚ç›¸åï¼Œä»–ä»¬å°è¯•QuickSelectæ­¥éª¤ï¼Œå¦‚æœä¸æˆåŠŸï¼Œåˆ™é€€å›åˆ°HeapSelectç®—æ³•ã€‚æ‰€ä»¥ï¼Œæœ€åçš„æƒ…å†µï¼Œå¹³å‡è€Œè¨€</p><p>   Now that most of the known algorithms come to an end ğŸ˜ˆ, we can start looking into something special and extraordinary. And the first one to look at is pdqselect which comes pretty straightforward from  pdqsort, the algorithm is basically QuickSelect but with some interesting ideas on how to choose an appropriate pivot:</p><p>ç°åœ¨å¤§å¤šæ•°å·²çŸ¥çš„ç®—æ³•éƒ½ç»“æŸäº†ğŸ˜ˆï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹ç ”ç©¶ä¸€äº›ç‰¹åˆ«å’Œéå‡¡çš„ä¸œè¥¿äº†ã€‚ç¬¬ä¸€ä¸ªè¦çœ‹çš„æ˜¯pdqselectï¼Œå®ƒéå¸¸ç®€å•åœ°æ¥è‡ªpdqortï¼Œç®—æ³•åŸºæœ¬ä¸Šæ˜¯QuickSelectï¼Œä½†æœ‰ä¸€äº›å…³äºå¦‚ä½•é€‰æ‹©é€‚å½“çš„è½´å¿ƒç‚¹çš„æœ‰è¶£æƒ³æ³•ï¼š</p><p> If there are   elements, use  insertion sort to partition or even sort them. As insertion sort is really fast for a small amount of elements, it is reasonable</p><p>å¦‚æœæœ‰å…ƒç´ ï¼Œå¯ä»¥ä½¿ç”¨æ’å…¥æ’åºå¯¹å…¶è¿›è¡Œåˆ†åŒºç”šè‡³æ’åºã€‚ç”±äºæ’å…¥æ’åºå¯¹äºå°‘é‡å…ƒç´ æ¥è¯´éå¸¸å¿«ï¼Œæ‰€ä»¥å®ƒæ˜¯åˆç†çš„ã€‚</p><p> If it is more, choose   â€” pivot: If there are less or equal than 128 elements, choose pseudomedian (or â€œnintherâ€, or median of medians which are all them same) of the following 3 groups:</p><p>å¦‚æœå¤§äºï¼Œåˆ™é€‰æ‹©-Pivotï¼šå¦‚æœå°‘äºæˆ–ç­‰äº128ä¸ªå…ƒç´ ï¼Œåˆ™ä»ä»¥ä¸‹3ç»„ä¸­é€‰æ‹©ä¼ªä¸­å€¼(æˆ–â€œä¹â€ï¼Œæˆ–å…¨éƒ¨ç›¸åŒçš„ä¸­å€¼çš„ä¸­ä½æ•°)ï¼š</p><p> If there are more than 128 elements, choose median of 3 from begin, mid, end</p><p>å¦‚æœè¶…è¿‡128ä¸ªå…ƒç´ ï¼Œåˆ™ä»å¼€å§‹ã€ä¸­é—´ã€ç»“æŸé€‰æ‹©3çš„ä¸­ä½æ•°ã€‚</p><p> Partition the array by the chosen pivot with avoiding  branches: If the total number of bad partitions exceeds  , use  std::nth_element or any other fallback algorithm and return</p><p>ä½¿ç”¨é¿å…åˆ†æ”¯çš„æ‰€é€‰é€è§†å¯¹æ•°ç»„è¿›è¡Œåˆ†åŒºï¼šå¦‚æœååˆ†åŒºæ€»æ•°è¶…è¿‡ï¼Œè¯·ä½¿ç”¨stdï¼šï¼šnth_elementæˆ–ä»»ä½•å…¶ä»–åå¤‡ç®—æ³•å¹¶è¿”å›ã€‚</p><p> Otherwise, try to defeat some patterns in the partition by (sizes are l_size and r_size respectively):</p><p>å¦åˆ™ï¼Œå°è¯•é€šè¿‡ä»¥ä¸‹æ–¹å¼å‡»è´¥åˆ†åŒºä¸­çš„æŸäº›æ¨¡å¼(å¤§å°åˆ†åˆ«ä¸ºl_SIZEå’Œr_SIZE)ï¼š</p><p>   For a long time, there were no practical improvements in finding  th element, and only in 2017 very well recognized among C++ community Andrei Alexandrescu published a paper on  Fast Deterministic Selection where worst case median algorithm becomes practical and can be used in real code.</p><p>åœ¨å¾ˆé•¿ä¸€æ®µæ—¶é—´é‡Œï¼Œåœ¨å¯»æ‰¾ç¬¬thä¸ªå…ƒç´ æ–¹é¢æ²¡æœ‰å®é™…çš„æ”¹è¿›ï¼Œç›´åˆ°2017å¹´ï¼ŒC++ç¤¾åŒºéå¸¸è®¤å¯Andrei Alexandresuå‘è¡¨äº†ä¸€ç¯‡å…³äºå¿«é€Ÿç¡®å®šæ€§é€‰æ‹©çš„è®ºæ–‡ï¼Œå…¶ä¸­æœ€åæƒ…å†µä¸­å€¼ç®—æ³•å˜å¾—å®ç”¨ï¼Œå¹¶å¯ä»¥åœ¨çœŸå®ä»£ç ä¸­ä½¿ç”¨ã€‚</p><p>  We now find the pseudomedian (or ninther, or median of medians which are all the same) of 9 elements as it was done similarly in pdqsort. Use that partition when</p><p>æˆ‘ä»¬ç°åœ¨æ‰¾åˆ°äº†9ä¸ªå…ƒç´ çš„ä¼ªä¸­å€¼(æˆ–9ä¸ªç›¸åŒä¸­å€¼çš„ä¸­ä½æ•°)ï¼Œè¿™ä¸åœ¨pdqæ’åºä¸­ç±»ä¼¼ã€‚åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä½¿ç”¨è¯¥åˆ†åŒº</p><p>  Introduce MedianOfMinima for  . MedianOfMedians computes medians of small groups and takes their median to find a pivot approximating the median of the array. In this case, we pursue an order statistic skewed to the left, so instead of the median of each group, we compute its minimum; then, we obtain the pivot by computing the median of those groupwise minima.</p><p>ä»‹ç»MedianOfMinima forã€‚MedianOfMediansè®¡ç®—å°ç»„çš„ä¸­ä½æ•°ï¼Œå¹¶å–å…¶ä¸­ä½æ•°æ¥æ‰¾åˆ°è¿‘ä¼¼æ•°ç»„ä¸­å€¼çš„è½´å¿ƒç‚¹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¿½æ±‚ä¸€ä¸ªå‘å·¦å€¾æ–œçš„é¡ºåºç»Ÿè®¡é‡ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸è®¡ç®—æ¯ä¸ªç»„çš„ä¸­ä½æ•°ï¼Œè€Œæ˜¯è®¡ç®—å®ƒçš„æœ€å°å€¼ï¼›ç„¶åï¼Œæˆ‘ä»¬é€šè¿‡è®¡ç®—è¿™äº›GroupWiseæœ€å°å€¼çš„ä¸­ä½æ•°æ¥è·å¾—æ¢è½´ã€‚</p><p>  is not chosen arbitrarily because in order to preserve the linearity of the algorithm we need to make sure that while recursing on   elements we partition more than   elements and thus  . MedianOfMaxima is done the same way and for  . The resulting algorithm turns out to be the following</p><p>ä¸æ˜¯ä»»æ„é€‰æ‹©çš„ï¼Œå› ä¸ºä¸ºäº†ä¿æŒç®—æ³•çš„çº¿æ€§ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿åœ¨å¯¹å…ƒç´ è¿›è¡Œé€’å½’æ—¶ï¼Œæˆ‘ä»¬åˆ’åˆ†çš„å…ƒç´ å¤šäºå…ƒç´ ï¼Œå› æ­¤ã€‚MedianOfMaximaçš„å®ç°æ–¹å¼ä¸Forç›¸åŒã€‚æœ€ç»ˆå¾—åˆ°çš„ç®—æ³•å¦‚ä¸‹æ‰€ç¤ºã€‚</p><p>  Turns out it is a better algorithm than all above (except it did not know about pdqselect) and shows good results. My advice that if you need a deterministic worst-case linear algorithm this one is the best (we will talk about a couple of more randomized algorithms later).</p><p>äº‹å®è¯æ˜ï¼Œè¿™æ˜¯ä¸€ä¸ªæ¯”ä¸Šé¢æ‰€æœ‰ç®—æ³•éƒ½æ›´å¥½çš„ç®—æ³•(é™¤äº†å®ƒä¸çŸ¥é“pdqselect)ï¼Œå¹¶ä¸”æ˜¾ç¤ºäº†å¾ˆå¥½çš„ç»“æœã€‚æˆ‘çš„å»ºè®®æ˜¯ï¼Œå¦‚æœæ‚¨éœ€è¦ç¡®å®šæ€§çš„æœ€åæƒ…å†µçº¿æ€§ç®—æ³•ï¼Œè¿™ä¸ªç®—æ³•æ˜¯æœ€å¥½çš„(æˆ‘ä»¬ç¨åå°†è®¨è®ºå‡ ä¸ªæ›´éšæœºåŒ–çš„ç®—æ³•)ã€‚</p><p>   All these algorithms are good and linear but they require lots of comparisons, like, minimum   for all  . However, I know a good algorithm for   which requires only   comparisons (I am also not going to prove it is minimal but it is). Letâ€™s quickly revise how it works.</p><p>æ‰€æœ‰è¿™äº›ç®—æ³•éƒ½æ˜¯å¥½çš„å’Œçº¿æ€§çš„ï¼Œä½†å®ƒä»¬éœ€è¦è¿›è¡Œå¤§é‡çš„æ¯”è¾ƒï¼Œæ¯”å¦‚ï¼Œå¯¹æ‰€æœ‰äººæ¥è¯´éƒ½æ˜¯æœ€ä½é™åº¦çš„æ¯”è¾ƒã€‚ç„¶è€Œï¼Œæˆ‘çŸ¥é“ä¸€ä¸ªå¥½çš„ç®—æ³•ï¼Œå®ƒåªéœ€è¦æ¯”è¾ƒ(æˆ‘ä¹Ÿä¸æ‰“ç®—è¯æ˜å®ƒæ˜¯æœ€å°çš„ï¼Œä½†å®ƒæ˜¯æœ€å°çš„)ã€‚è®©æˆ‘ä»¬å¿«é€Ÿä¿®æ”¹ä¸€ä¸‹å®ƒçš„å·¥ä½œåŸç†ã€‚</p><p> For finding a minimum you just compare linearly the winner with all others and basically the second place can be anyone who lost to the winner, so we need to compare them within each other. Unfortunately, the winner may have won linear number of others and we will not get the desired amount of comparisons. To mitigate this, we need to make a knockout tournament where the winner only plays   games like that:</p><p>ä¸ºäº†æ‰¾åˆ°æœ€å°å€¼ï¼Œä½ åªéœ€å°†è·èƒœè€…ä¸æ‰€æœ‰å…¶ä»–è·èƒœè€…è¿›è¡Œçº¿æ€§æ¯”è¾ƒï¼ŒåŸºæœ¬ä¸Šç¬¬äºŒåå¯èƒ½æ˜¯ä»»ä½•è¾“ç»™è·èƒœè€…çš„äººï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å°†å®ƒä»¬ç›¸äº’æ¯”è¾ƒã€‚ä¸å¹¸çš„æ˜¯ï¼Œè·èƒœè€…å¯èƒ½èµ¢å¾—äº†çº¿æ€§æ•°é‡çš„å…¶ä»–äººï¼Œæˆ‘ä»¬ä¸ä¼šå¾—åˆ°æƒ³è¦çš„æ¯”è¾ƒæ•°é‡ã€‚ä¸ºäº†ç¼“è§£è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦ä¸¾åŠä¸€åœºæ·˜æ±°èµ›ï¼Œè·èƒœè€…åªç©è¿™æ ·çš„æ¸¸æˆï¼š</p><p>  And all we need to do next is to compare all losers to the winner</p><p>æˆ‘ä»¬ä¸‹ä¸€æ­¥è¦åšçš„å°±æ˜¯æŠŠæ‰€æœ‰è¾“å®¶å’Œèµ¢å®¶è¿›è¡Œæ¯”è¾ƒã€‚</p><p>  And any of them can be the second. And we use only   comparisons for that.</p><p>ä»–ä»¬ä¸­çš„ä»»ä½•ä¸€ä¸ªéƒ½å¯èƒ½æ˜¯ç¬¬äºŒä¸ªã€‚æˆ‘ä»¬åªå¯¹æ­¤è¿›è¡Œæ¯”è¾ƒã€‚</p><p> What can we do to find the third and other elements? Possibly not optimal in comparison count but at least not so bad can follow the strategy:</p><p>æˆ‘ä»¬èƒ½åšäº›ä»€ä¹ˆæ¥æ‰¾åˆ°ç¬¬ä¸‰ä¸ªå…ƒç´ å’Œå…¶ä»–å…ƒç´ å‘¢ï¼Ÿåœ¨æ¯”è¾ƒè®¡æ•°ä¸Šå¯èƒ½ä¸æ˜¯æœ€ä¼˜çš„ï¼Œä½†è‡³å°‘ä¸æ˜¯é‚£ä¹ˆç³Ÿç³•ï¼Œå¯ä»¥éµå¾ªè¿™æ ·çš„ç­–ç•¥ï¼š</p><p> First set up a binary tree for a knockout tournament on   items. (This takes   comparisons.) The largest item is greater than   others, so it canâ€™t be  th largest. Replace it, where it appears at an external node of the tree, by one of the   elements held in reserve, and find the largest element of the resulting  ; this requires at most   comparisons because we need to recompute only one path in the tree. Repeat this operation   times in all, for each element held in reserve.</p><p>é¦–å…ˆå»ºç«‹é¡¹ç›®æ·˜æ±°èµ›çš„äºŒå‰æ ‘ã€‚(è¿™éœ€è¦è¿›è¡Œæ¯”è¾ƒã€‚)ã€‚æœ€å¤§çš„é¡¹ç›®æ¯”å…¶ä»–é¡¹ç›®æ›´å¤§ï¼Œæ‰€ä»¥å®ƒä¸å¯èƒ½æ˜¯ç¬¬ä¸‰å¤§é¡¹ç›®ã€‚å½“å®ƒå‡ºç°åœ¨æ ‘çš„å¤–éƒ¨èŠ‚ç‚¹æ—¶ï¼Œç”¨ä¿ç•™çš„å…ƒç´ ä¹‹ä¸€æ›¿æ¢å®ƒï¼Œå¹¶æ‰¾åˆ°ç»“æœä¸­æœ€å¤§çš„å…ƒç´ ï¼›è¿™è‡³å¤šéœ€è¦æ¯”è¾ƒï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦é‡æ–°è®¡ç®—æ ‘ä¸­çš„ä¸€æ¡è·¯å¾„ã€‚å¯¹äºä¿ç•™çš„æ¯ä¸ªå…ƒç´ ï¼Œæ€»å…±é‡å¤æ­¤æ“ä½œæ¬¡æ•°ã€‚</p><p> It will give us the estimation of   comparisons. Assume you need to find top 10 out of millions of long strings and this might be a good solution to this instead of comparing at least   times.  However, it requires additional memory to remember the path of the winner and I currently do not know how to remove it thus making the algorithm impractical because of allocations or additional level of indirections.</p><p>å®ƒå°†ç»™æˆ‘ä»¬æä¾›æ¯”è¾ƒçš„ä¼°è®¡ã€‚å‡è®¾æ‚¨éœ€è¦ä»æ•°ç™¾ä¸‡ä¸ªé•¿å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°å‰10ä¸ªï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆï¼Œè€Œä¸æ˜¯è‡³å°‘æ¯”è¾ƒæ—¶é—´ã€‚ç„¶è€Œï¼Œå®ƒéœ€è¦é¢å¤–çš„å†…å­˜æ¥è®°ä½è·èƒœè€…çš„è·¯å¾„ï¼Œè€Œæˆ‘ç›®å‰ä¸çŸ¥é“å¦‚ä½•åˆ é™¤å®ƒï¼Œå› æ­¤ç”±äºåˆ†é…æˆ–é¢å¤–çº§åˆ«çš„é—´æ¥æ€§ï¼Œä½¿å¾—è¯¥ç®—æ³•ä¸åˆ‡å®é™…ã€‚</p><p> At that time my knowledge of selection algorithms ended and I decided to address one known guy.</p><p>é‚£æ—¶ï¼Œæˆ‘å¯¹é€‰æ‹©ç®—æ³•çš„äº†è§£ç»“æŸäº†ï¼Œæˆ‘å†³å®šå‘ä¸€ä¸ªçŸ¥åçš„äººå‘è¡¨æ¼”è®²ã€‚</p><p>  In The Art of Computer Programming, Volume 3, Sorting and Searching I read almost 100-150 pages in order to understand what the world knows about minimal comparison sorting and selection algorithms and found a pretty interesting one called Floyd-Rivest algorithm. Actually, even Alexandrescu paper cites it but in an unusual way:</p><p>åœ¨ã€Šè®¡ç®—æœºç¼–ç¨‹è‰ºæœ¯ã€‹(The Art of Computer Programmingï¼Œç¬¬ä¸‰å·ï¼ŒSorting and Search)ä¸€ä¹¦ä¸­ï¼Œæˆ‘è¯»äº†è¿‘100åˆ°150é¡µï¼Œä»¥ä¾¿äº†è§£å…¨ä¸–ç•Œå¯¹æœ€å°æ¯”è¾ƒæ’åºå’Œé€‰æ‹©ç®—æ³•çš„äº†è§£ï¼Œå‘ç°äº†ä¸€ä¸ªéå¸¸æœ‰è¶£çš„ç®—æ³•ï¼Œåä¸ºå¼—æ´›ä¼Šå¾·-é‡Œç»´æ–¯ç‰¹ç®—æ³•(Floyd-Rivest Algorithm)ã€‚å®é™…ä¸Šï¼Œå°±è¿äºšå†å±±å¤§Â·é›·æ–¯åº“çš„è®ºæ–‡ä¹Ÿå¼•ç”¨äº†è¿™å¥è¯ï¼Œä½†å¼•ç”¨çš„æ–¹å¼ä¸åŒå¯»å¸¸ï¼š</p><p>     FromÂ  , recursively select two elements,Â  Â andÂ  , such that   (essentially they take   and  ). These two elements will be theÂ  pivotsÂ for the partition and are expected to contain the   th smallest element of the entire list between them.</p><p>ä»ä¸­é€’å½’åœ°é€‰æ‹©ä¸¤ä¸ªå…ƒç´ ï¼šå’Œï¼Œè¿™æ ·(æœ¬è´¨ä¸Šå®ƒä»¬å–å’Œ)ã€‚è¿™ä¸¤ä¸ªå…ƒç´ å°†æ˜¯åˆ†åŒºçš„ç¬¬äºŒä¸ªè½´å¿ƒç‚¹ï¼Œé¢„è®¡å®ƒä»¬ä¹‹é—´å°†åŒ…å«æ•´ä¸ªåˆ—è¡¨ä¸­çš„ç¬¬å‡ ä¸ªæœ€å°å…ƒç´ ã€‚</p><p>  Partition the remaining elements in  the arrayÂ by comparing them toÂ  uÂ orÂ  vÂ and placing them into the appropriate set. IfÂ  Â is smaller than half the number of the elements inÂ the array, then the remaining elements should be compared toÂ  Â first and then only toÂ  Â if they are smaller thanÂ  . Otherwise, the remaining elements should be compared toÂ  Â first and only toÂ  Â if they are greater thanÂ  .</p><p>é€šè¿‡å°†æ•°ç»„ä¸­å‰©ä½™çš„å…ƒç´ ä¸uæˆ–vè¿›è¡Œæ¯”è¾ƒï¼Œå¹¶å°†å®ƒä»¬æ”¾å…¥é€‚å½“çš„é›†åˆä¸­ï¼Œå¯¹æ•°ç»„ä¸­çš„å…¶ä½™å…ƒç´ è¿›è¡Œåˆ†åŒºã€‚å¦‚æœå°äºæ•°ç»„ä¸­å…ƒç´ æ•°é‡çš„ä¸€åŠï¼Œåˆ™åº”å…ˆå°†å‰©ä½™å…ƒç´ ä¸è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åå†ä¸å°äºçš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒã€‚å¦åˆ™ï¼Œå…¶ä½™çš„å…ƒç´ åº”è¯¥é¦–å…ˆä¸è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå®ƒä»¬å¤§äºï¼Œåˆ™åªä¸è¿›è¡Œæ¯”è¾ƒã€‚</p><p> Apply the algorithm recursively to the appropriate set to select theÂ  th smallest in the array.</p><p>å°†è¯¥ç®—æ³•é€’å½’åœ°åº”ç”¨äºé€‚å½“çš„é›†åˆï¼Œä»¥é€‰æ‹©æ•°ç»„ä¸­çš„ç¬¬åä¸ªæœ€å°çš„ã€‚</p><p> Then in 2004 it was  proven that this method (slighly modified in bound selection) will have   comparisons with probability at least   (and the constant in the power can be tuned).</p><p>ç„¶ååœ¨2004å¹´è¯æ˜äº†è¿™ç§æ–¹æ³•(åœ¨ç•Œé™é€‰æ‹©ä¸Šç¨ä½œä¿®æ”¹)è‡³å°‘å¯ä»¥ä¸æ¦‚ç‡è¿›è¡Œæ¯”è¾ƒ(å¹¶ä¸”å¹‚ä¸­çš„å¸¸æ•°æ˜¯å¯ä»¥è°ƒèŠ‚çš„)ã€‚</p><p> This algorithm tries to find the appropriate subsamples and proves that the  th element will be there with high probability.</p><p>è¯¥ç®—æ³•è¯•å›¾æ‰¾åˆ°åˆé€‚çš„å­æ ·æœ¬ï¼Œå¹¶è¯æ˜ç¬¬thä¸ªå…ƒç´ å­˜åœ¨çš„æ¦‚ç‡å¾ˆå¤§ã€‚</p><p>   Yet the worst case of the algorithm is still   but it tries to optimize the minimum amount of comparisons on average case, not the worst case.</p><p>ç„¶è€Œï¼Œè¯¥ç®—æ³•çš„æœ€åæƒ…å†µä»ç„¶æ˜¯ï¼Œä½†å®ƒè¯•å›¾ä¼˜åŒ–å¹³å‡æƒ…å†µä¸‹çš„æœ€å°æ¯”è¾ƒæ¬¡æ•°ï¼Œè€Œä¸æ˜¯æœ€åæƒ…å†µä¸‹çš„æœ€å°æ¯”è¾ƒæ¬¡æ•°ã€‚</p><p> For small   it is really good as it only used   comparisons which is significantly better than all â€œat least   comparisonsâ€ algorithms and even for median it is   which is significantly better.</p><p>å¯¹äºå°çš„ï¼Œå®ƒçœŸçš„å¾ˆå¥½ï¼Œå› ä¸ºå®ƒåªä½¿ç”¨æ¯”è¾ƒï¼Œè¿™æ¯”æ‰€æœ‰â€œè‡³å°‘æ¯”è¾ƒâ€çš„ç®—æ³•éƒ½è¦å¥½å¾—å¤šï¼Œç”šè‡³å¯¹äºä¸­ä½æ•°ï¼Œå®ƒä¹Ÿæ˜¯æ˜æ˜¾æ›´å¥½çš„ã€‚</p><p>  So I decided to code all these algorithms with the C++ standard API and to test against each other and possibly submit to something performance heavy as DBMS for ORDER BY LIMIT N clauses.</p><p>å› æ­¤ï¼Œæˆ‘å†³å®šç”¨C++æ ‡å‡†APIå¯¹æ‰€æœ‰è¿™äº›ç®—æ³•è¿›è¡Œç¼–ç ï¼Œå¹¶å¯¹å®ƒä»¬è¿›è¡Œç›¸äº’æµ‹è¯•ï¼Œå¯èƒ½è¿˜ä¼šæäº¤ä¸€äº›æ€§èƒ½è¾ƒé«˜çš„ä¸œè¥¿ï¼Œæ¯”å¦‚DBMSæ¥æ‰§è¡ŒORDER BY LIMIT Nå­å¥ã€‚</p><p> I ended up doing  miniselect library. For now, it is header-only but I donâ€™t guarantee that in the future, it contains almost all algorithms except the tournament one which is very hard to do in the general case.</p><p>æˆ‘æœ€ç»ˆåšäº†è¿·ä½ ç²¾é€‰å›¾ä¹¦é¦†ã€‚ç›®å‰ï¼Œå®ƒåªæ˜¯å¤´çƒï¼Œä½†æˆ‘ä¸èƒ½ä¿è¯åœ¨æœªæ¥ï¼Œå®ƒåŒ…å«äº†é™¤äº†é”¦æ ‡èµ›ä»¥å¤–çš„å‡ ä¹æ‰€æœ‰ç®—æ³•ï¼Œè¿™åœ¨ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯å¾ˆéš¾åšåˆ°çš„ã€‚</p><p> I tested on  Intel(R) Core(TM) i5-4200H CPU @ 2.80GHz (yeah, a bit old, sorry). We are going to find median and 1000th elements out of   and   arrays. Benchmark data:</p><p>æˆ‘åœ¨2.80 GHzçš„è‹±ç‰¹å°”(R)é…·ç¿(TM)i5-4200H CPUä¸Šè¿›è¡Œäº†æµ‹è¯•(æ˜¯çš„ï¼Œæœ‰ç‚¹æ—§ï¼Œå¯¹ä¸èµ·)ã€‚æˆ‘ä»¬å°†ä»å’Œæ•°ç»„ä¸­æ‰¾å‡ºä¸­ä½æ•°å’Œç¬¬1000ä¸ªå…ƒç´ ã€‚åŸºå‡†æ•°æ®ï¼š</p><p>    As you see, Floyd-Rivest outperforms in time all other algorithms and even Alexandrescu in most of the cases. One downside is that Floyd-Rivest performs worse on data where there are many equal elements, that is expected and probably can be fixed as it is pointed out in  Kiwielâ€™s paper.</p><p>å¦‚ä½ æ‰€è§ï¼ŒFloyd-Riveståœ¨æ—¶é—´ä¸Šä¼˜äºæ‰€æœ‰å…¶ä»–ç®—æ³•ï¼Œç”šè‡³åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ä¼˜äºAlexandresuã€‚ä¸€ä¸ªç¼ºç‚¹æ˜¯ï¼ŒFloyd-Riveståœ¨æœ‰è®¸å¤šç›¸ç­‰å…ƒç´ çš„æ•°æ®ä¸Šè¡¨ç°è¾ƒå·®ï¼Œè¿™æ˜¯æ„æ–™ä¹‹ä¸­çš„ï¼Œæ­£å¦‚Kiwielçš„è®ºæ–‡ä¸­æŒ‡å‡ºçš„é‚£æ ·ï¼Œè¿™å¯èƒ½æ˜¯å¯ä»¥ä¿®å¤çš„ã€‚</p><p>  This effort also resulted in a  patch to  ClickHouse where we got the following  benchmarks:</p><p>è¿™ä¸€åŠªåŠ›è¿˜å¯¼è‡´äº†ClickHouseçš„è¡¥ä¸ï¼Œæˆ‘ä»¬åœ¨è¯¥è¡¥ä¸ä¸­è·å¾—äº†ä»¥ä¸‹åŸºå‡†ï¼š</p><p>  As you see, most of the queries have ORDER BY LIMIT N. Topmost queries were significantly optimized because  std::partial_sort works worst when the data is descending, real-world usage as you can see in string_sort benchmarks was optimized by 10-15%. Also, there were many queries that have been optimized by 5% where sorting is not the bottleneck but still, it is nice. It ended up with a  2.5% overall performance boost across all queries.</p><p>å¦‚æ‚¨æ‰€è§ï¼Œå¤§å¤šæ•°æŸ¥è¯¢éƒ½æœ‰ORDER BY LIMIT Nã€‚æœ€é¡¶å±‚çš„æŸ¥è¯¢å¾—åˆ°äº†æ˜¾è‘—ä¼˜åŒ–ï¼Œå› ä¸ºSTDï¼šï¼šPARTIAL_SORTåœ¨æ•°æ®ä¸‹é™æ—¶å·¥ä½œæœ€å·®ï¼Œå®é™…ä½¿ç”¨æƒ…å†µ(å¦‚æ‚¨åœ¨STRING_SORTåŸºå‡†æµ‹è¯•ä¸­çœ‹åˆ°çš„)ä¼˜åŒ–äº†10-15%ã€‚æ­¤å¤–ï¼Œæœ‰è®¸å¤šæŸ¥è¯¢å·²ç»ä¼˜åŒ–äº†5%ï¼Œå…¶ä¸­æ’åºä¸æ˜¯ç“¶é¢ˆï¼Œä½†ä»ç„¶å¾ˆä¸é”™ã€‚æœ€ç»ˆï¼Œæ‰€æœ‰æŸ¥è¯¢çš„æ•´ä½“æ€§èƒ½æå‡äº†2.5%ã€‚</p><p> Other algorithms showed worse performance and you can see it from the benchmarks above. So, now Floyd-Rivest is used in production, and for a good reason. But, of course, it does not diminish the results of Mr. Alexandrescu and his contributions are very valuable when it comes to determinism and worst case.</p><p>å…¶ä»–ç®—æ³•çš„æ€§èƒ½è¾ƒå·®ï¼Œæ‚¨å¯ä»¥ä»ä¸Šé¢çš„åŸºå‡†æµ‹è¯•ä¸­çœ‹å‡ºè¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼Œç°åœ¨å¼—æ´›ä¼Šå¾·-é‡Œç»´æ–¯ç‰¹è¢«ç”¨äºç”Ÿäº§ï¼Œè€Œä¸”æœ‰ä¸€ä¸ªå¾ˆå¥½çš„ç†ç”±ã€‚ä½†æ˜¯ï¼Œå½“ç„¶ï¼Œè¿™å¹¶ä¸ä¼šå‰Šå¼±äºšå†å±±å¾·é›·æ–¯åº“å…ˆç”Ÿçš„æˆæœï¼Œåœ¨å†³å®šè®ºå’Œæœ€åçš„æƒ…å†µä¸‹ï¼Œä»–çš„è´¡çŒ®æ˜¯éå¸¸å®è´µçš„ã€‚</p><p>  I publish  miniselect under Boost License for everybody to use and adjust to the projects. I spent several days in the last week trying to make it work everywhere (except Windows for now but it should be good). We support C++11 and further with GCC 7+ and Clang 6+. We carefully test the algorithms for standard compliance, with fuzzing, sanitizers, etc. Fuzzing managed to find bugs that I thought only at the last moment so it really helps.</p><p>æˆ‘åœ¨Boostè®¸å¯è¯ä¸‹å‘å¸ƒè¿·ä½ ç²¾é€‰ï¼Œä¾›æ¯ä¸ªäººä½¿ç”¨å’Œè°ƒæ•´ä»¥é€‚åº”é¡¹ç›®ã€‚ä¸Šå‘¨ï¼Œæˆ‘èŠ±äº†å‡ å¤©æ—¶é—´ï¼Œè¯•å›¾è®©å®ƒåœ¨æ‰€æœ‰åœ°æ–¹éƒ½èƒ½è¿è¡Œ(ç›®å‰é™¤äº†Windowsï¼Œä½†å®ƒåº”è¯¥æ˜¯å¥½çš„)ã€‚æˆ‘ä»¬æ”¯æŒC++11ä»¥åŠGCC 7+å’ŒClang 6+ã€‚æˆ‘ä»¬ä»”ç»†åœ°æµ‹è¯•äº†ç®—æ³•çš„æ ‡å‡†ç¬¦åˆæ€§ï¼Œä½¿ç”¨äº†æ¨¡ç³Šã€æ¶ˆæ¯’å‰‚ç­‰ã€‚æ¨¡ç³ŠæˆåŠŸåœ°æ‰¾åˆ°äº†æˆ‘åœ¨æœ€åä¸€åˆ»æ‰æƒ³åˆ°çš„é”™è¯¯ï¼Œæ‰€ä»¥å®ƒçœŸçš„å¾ˆæœ‰å¸®åŠ©ã€‚</p><p> If you want to use it, please read the API but it should be an easy  sed/ perl/ regex replacement with zero issues except for the ties between elements might resolve in a different way, however, C++ standard says it is ok and you should not rely on that.</p><p>å¦‚æœä½ æƒ³ä½¿ç”¨å®ƒï¼Œè¯·é˜…è¯»APIï¼Œä½†å®ƒåº”è¯¥æ˜¯ä¸€ä¸ªç®€å•çš„sed/perl/regexæ›¿ä»£å“ï¼Œæ²¡æœ‰ä»»ä½•é—®é¢˜ï¼Œé™¤äº†å…ƒç´ ä¹‹é—´çš„è”ç³»å¯èƒ½ä¼šä»¥ä¸åŒçš„æ–¹å¼è§£å†³ä¹‹å¤–ï¼Œç„¶è€Œï¼ŒC++æ ‡å‡†è¯´å®ƒæ˜¯å¯ä»¥çš„ï¼Œä½ ä¸åº”è¯¥ä¾èµ–å®ƒã€‚</p><p> Any contributions and other algorithms that I might miss are highly welcome, I intend to get this library as a reference to many implementations of selection algorithms so that the users can try and choose the best options for them. (Should I do the same for sorting algorithms?)</p><p>ä»»ä½•æˆ‘å¯èƒ½é”™è¿‡çš„è´¡çŒ®å’Œå…¶ä»–ç®—æ³•éƒ½æ˜¯éå¸¸å—æ¬¢è¿çš„ï¼Œæˆ‘æ‰“ç®—å°†è¿™ä¸ªåº“ä½œä¸ºé€‰æ‹©ç®—æ³•çš„è®¸å¤šå®ç°çš„å‚è€ƒï¼Œä»¥ä¾¿ç”¨æˆ·å¯ä»¥å°è¯•ä¸ºä»–ä»¬é€‰æ‹©æœ€å¥½çš„é€‰é¡¹ã€‚(æˆ‘åº”è¯¥å¯¹æ’åºç®—æ³•åšåŒæ ·çš„äº‹æƒ…å—ï¼Ÿ)ã€‚</p><p>  This was a long story of me trying to find the solutions to the problems that were puzzling me for the past month or so. I probably read 300+ pages of math/algorithms/discussions/forums to finally find everything that the world knows about it and to make it work for real-world applications with huge performance benefits. I think I can come up with something better in a long term after researching this stuff for a while longer but I will let you know in this blog if anything arises ğŸ™‚</p><p>è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„æ•…äº‹ï¼Œæˆ‘è¯•å›¾æ‰¾åˆ°è§£å†³é—®é¢˜çš„åŠæ³•ï¼Œè¿™äº›é—®é¢˜åœ¨è¿‡å»ä¸€ä¸ªæœˆå·¦å³çš„æ—¶é—´é‡Œä¸€ç›´å›°æ‰°ç€æˆ‘ã€‚æˆ‘å¯èƒ½é˜…è¯»äº†300å¤šé¡µçš„æ•°å­¦/ç®—æ³•/è®¨è®º/è®ºå›ï¼Œä»¥æœ€ç»ˆæ‰¾åˆ°ä¸–ç•Œæ‰€çŸ¥é“çš„å…³äºå®ƒçš„ä¸€åˆ‡ï¼Œå¹¶ä½¿å…¶é€‚ç”¨äºå…·æœ‰å·¨å¤§æ€§èƒ½ä¼˜åŠ¿çš„çœŸå®ä¸–ç•Œçš„åº”ç”¨ç¨‹åºã€‚æˆ‘æƒ³åœ¨é•¿æœŸç ”ç©¶è¿™ä¸ªä¸œè¥¿ä¹‹åï¼Œæˆ‘å¯ä»¥æƒ³å‡ºæ›´å¥½çš„ä¸œè¥¿ï¼Œä½†æ˜¯å¦‚æœæœ‰ä»€ä¹ˆäº‹æƒ…å‘ç”Ÿï¼Œæˆ‘ä¼šåœ¨è¿™ä¸ªåšå®¢é‡Œå‘Šè¯‰ä½ çš„ã€‚ğŸ™‚ã€‚</p><p>  Selection Algorithms with Small Groups where the Median of Medians algorithms are a little bit twisted for groups of size 3 and 4 with linear time worst-case guarantee</p><p>å…·æœ‰å°ç¾¤ä½“çš„é€‰æ‹©ç®—æ³•ï¼Œå…¶ä¸­ä¸­å€¼ç®—æ³•çš„ä¸­ä½æ•°å¯¹äºå¤§å°ä¸º3å’Œ4çš„ç¾¤ä½“åœ¨çº¿æ€§æ—¶é—´æœ€åæƒ…å†µä¸‹æ˜¯æœ‰ç‚¹æ‰­æ›²çš„ã€‚</p><p>   The Art of Computer Programming, Volume 3, Sorting and Searching, Chapter about Minimum-Comparison Sorting and Selection</p><p>è®¡ç®—æœºç¼–ç¨‹è‰ºæœ¯ï¼Œç¬¬ä¸‰å·ï¼Œæ’åºå’Œæœç´¢ï¼Œå…³äºæœ€å°æ¯”è¾ƒæ’åºå’Œé€‰æ‹©çš„ç« èŠ‚</p><p>    An efficient algorithm for the approximate median selection problem by S. Battiato, D. Cantone, D. Catalano and G. Cincotti</p><p>S.Battiatoï¼ŒD.Canoneï¼ŒD.Catalanoå’ŒG.Cincottiæå‡ºçš„è¿‘ä¼¼ä¸­å€¼é€‰æ‹©é—®é¢˜çš„ä¸€ä¸ªæœ‰æ•ˆç®—æ³•ã€‚</p><p> Today I present miniselect â€” generic C++ library for various selection algorithms  https://t.co/NAJmqMOE8a. Aaand post about my efforts and research in that area  https://t.co/YrNgZshrAJ. Many insights and gifs are included!</p><p>ä»Šå¤©ï¼Œæˆ‘å°†ä»‹ç»ç”¨äºå„ç§é€‰æ‹©ç®—æ³•https://t.co/NAJmqMOE8a.çš„è¿·ä½ é€‰æ‹©é€šç”¨C++åº“ã€‚æˆ‘åœ¨è¿™æ–¹é¢æ‰€åšçš„åŠªåŠ›å’Œç ”ç©¶çš„å¸–å­https://t.co/YrNgZshrAJ.ã€‚å…¶ä¸­åŒ…å«äº†è®¸å¤šè§è§£å’Œgifï¼</p><p>â€” Danila Kutenin (@Danlark1)  November 11, 2020</p><p>--Danila Kutenin(@Danlark1)2020å¹´11æœˆ11æ—¥</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danlark.org/2020/11/11/miniselect-practical-and-generic-selection-algorithms/">https://danlark.org/2020/11/11/miniselect-practical-and-generic-selection-algorithms/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ç®—æ³•/">#ç®—æ³•</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/å®ç”¨/">#å®ç”¨</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/practical/">#practical</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033773.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c080a81f8785ce41c9fcfedc4efe020b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033773.html">Syneriseæ¨å‡ºAI Cleoraç®—æ³•ä½œä¸ºå¼€æº</a></div><span class="my_story_list_date">2020-11-8 9:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033755.html"><img src="http://img2.diglog.com/img/2020/11/thumb_68eaef96ef90392715a86ab4529d5a51.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033755.html">è´¹æ›¼ã€ç®—æ³•ç¼–æ’å’ŒåŸºäºèŠ‚ç‚¹çš„ç¼–ç¨‹</a></div><span class="my_story_list_date">2020-11-8 9:34</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032980.html"><img src="http://img2.diglog.com/img/2020/11/thumb_5ea50c11e87601962553e2d5ad6a8d28.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032980.html">åº”è¯¥å…è®¸å—äººå·¥æ™ºèƒ½å†³ç­–å½±å“æœ€å¤§çš„äººåœ¨å¡‘é€ å…³äºç®—æ³•æ²»ç†å’Œç›‘ç®¡çš„å¯¹è¯ä¸­å‘æŒ¥æ ¸å¿ƒä½œç”¨</a></div><span class="my_story_list_date">2020-11-3 22:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032364.html"><img src="http://img2.diglog.com/img/2020/10/thumb_358ec8b565c36520433f972ae2130006.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032364.html">
æ ¹æ®æ¬§ç›Ÿè®¡åˆ’ï¼Œå¤§å‹ç§‘æŠ€å…¬å¸çš„â€œé»‘åŒ£å­â€ç®—æ³•é¢ä¸´ç›‘ç®¡ç›‘ç£</a></div><span class="my_story_list_date">2020-10-31 3:34</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¾å›½/">#ç¾å›½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¨‹åº/">#ç¨‹åº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>