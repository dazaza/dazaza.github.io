<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>åœ¨Clojureä¸­æ¨¡æ‹ŸRAM</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">åœ¨Clojureä¸­æ¨¡æ‹ŸRAM</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-14 09:54:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/431e2b990983268b5d9ef9eecaa335d6.png"><img src="http://img2.diglog.com/img/2020/11/431e2b990983268b5d9ef9eecaa335d6.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>â€œComputers are all made out of logic gatesâ€. Weâ€™ve heard that saying before. We also have a sense that logic gates are very simple machines, analogous to light switches even. This raises the question:  how exactly do kind-of-light-switches come together to form computers? How does â€œstoring a variableâ€ or â€œcalling a functionâ€ translate into logic gates going on or off?</p><p>â€œè®¡ç®—æœºéƒ½æ˜¯ç”±é€»è¾‘é—¨ç»„æˆçš„ã€‚â€æˆ‘ä»¬ä»¥å‰å¬è¿‡è¿™å¥è¯ã€‚æˆ‘ä»¬ä¹Ÿæœ‰ä¸€ç§æ„Ÿè§‰ï¼Œé€»è¾‘é—¨æ˜¯éå¸¸ç®€å•çš„æœºå™¨ï¼Œç”šè‡³ç±»ä¼¼äºç”µç¯å¼€å…³ã€‚è¿™å°±æå‡ºäº†ä¸€ä¸ªé—®é¢˜ï¼šè¿™ç§å…‰å¼€å…³ç©¶ç«Ÿæ˜¯å¦‚ä½•ç»„åˆåœ¨ä¸€èµ·å½¢æˆè®¡ç®—æœºçš„ï¼Ÿâ€œå­˜å‚¨å˜é‡â€æˆ–â€œè°ƒç”¨å‡½æ•°â€å¦‚ä½•è½¬æ¢ä¸ºé€»è¾‘é—¨æ‰“å¼€æˆ–å…³é—­ï¼Ÿ</p><p> On a journey to answer that question, I discovered J Clark Scottâ€™s excellent book  â€œHow do It Know?â€. He starts with NAND gates and takes you on a journey to build a computer using them.</p><p>åœ¨å›ç­”è¿™ä¸ªé—®é¢˜çš„æ—…é€”ä¸­ï¼Œæˆ‘å‘ç°äº†JÂ·å…‹æ‹‰å…‹Â·æ–¯ç§‘ç‰¹(J Clark Scott)çš„æ°ä½œâ€œå®ƒæ˜¯å¦‚ä½•çŸ¥é“çš„ï¼Ÿâ€ä»–ä»ä¸éé—¨å¼€å§‹ï¼Œå¸¦ä½ è¸ä¸Šç”¨å®ƒä»¬å»ºé€ è®¡ç®—æœºçš„æ—…ç¨‹ã€‚</p><p> I liked his book so much that I took his schematic for RAM, and simulated it in Clojure. In this essay, Iâ€™ll guide you through doing just that: weâ€™ll simulate NAND gates, and use about  14 thousand of them to build 256 bytes of RAM.</p><p>æˆ‘éå¸¸å–œæ¬¢ä»–çš„ä¹¦ï¼Œæ‰€ä»¥æˆ‘æ‹¿äº†ä»–çš„RAMç¤ºæ„å›¾ï¼Œå¹¶ç”¨Clojureè¿›è¡Œäº†æ¨¡æ‹Ÿã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å°†æŒ‡å¯¼æ‚¨å®Œæˆè¿™é¡¹å·¥ä½œï¼šæˆ‘ä»¬å°†æ¨¡æ‹ŸNANDé—¨ï¼Œå¹¶ä½¿ç”¨å¤§çº¦14,000ä¸ªNANDé—¨æ¥æ„å»º256å­—èŠ‚çš„RAMã€‚</p><p> Going through this simulation ingrained an â€œahaâ€ feeling in me: watching 14 thousand little machines chug away makes you feel that whoever uses a computer is a wizard. A wizard with an army of millions of machine servants doing billions of little jobs for them every second. I hope it gives you the same feeling. ğŸ™‚</p><p>é€šè¿‡è¿™æ¬¡æ¨¡æ‹Ÿï¼Œæˆ‘æœ‰ä¸€ç§â€œå•Šå“ˆâ€çš„æ„Ÿè§‰ï¼šçœ‹ç€14000å°å°æœºå™¨å—¡å—¡ä½œå“ï¼Œä½ ä¼šè§‰å¾—æ— è®ºæ˜¯è°ä½¿ç”¨è®¡ç®—æœºï¼Œéƒ½æ˜¯ä¸€ä¸ªå·«å¸ˆã€‚ä¸€ä¸ªæ‹¥æœ‰æ•°ä»¥ç™¾ä¸‡è®¡çš„æœºå™¨ä»†äººçš„å·«å¸ˆï¼Œæ¯ç§’éƒ½åœ¨ä¸ºä»–ä»¬åšæ•°åäº¿ä»¶å°äº‹ã€‚æˆ‘å¸Œæœ›å®ƒèƒ½ç»™ä½ åŒæ ·çš„æ„Ÿè§‰ã€‚ğŸ™‚ã€‚</p><p>    This describes a NAND gate. A NAND gate is a machine that has two input wires. If both input wires have a â€œhighâ€ charge (represented as 1), the output charge is â€œlowâ€ (represented as zero). With any other combination of input charges, the output charge is high.</p><p>è¿™æè¿°äº†ä¸éé—¨ã€‚ä¸éé—¨æ˜¯ä¸€ç§æœ‰ä¸¤æ¡è¾“å…¥çº¿çš„æœºå™¨ã€‚å¦‚æœä¸¤æ ¹è¾“å…¥çº¿éƒ½æœ‰â€œé«˜â€ç”µè·(è¡¨ç¤ºä¸º1)ï¼Œåˆ™è¾“å‡ºç”µè·ä¸ºâ€œä½â€(è¡¨ç¤ºä¸ºé›¶)ã€‚è¾“å…¥ç”µè·çš„ä»»ä½•å…¶ä»–ç»„åˆï¼Œè¾“å‡ºç”µè·éƒ½å¾ˆé«˜ã€‚</p><p> Notice that the wires carry a charge, but we choose to interpret  meaning in the charge. â€œhigh chargeâ€ means 1, and â€œlow chargeâ€ means 0. Nothing changes in the machine, this is just something we decided as humans (1).</p><p>è¯·æ³¨æ„ï¼Œå¯¼çº¿å¸¦æœ‰ç”µè·ï¼Œä½†æˆ‘ä»¬é€‰æ‹©è§£é‡Šç”µè·çš„å«ä¹‰ã€‚â€œé«˜ç”µè·é‡â€è¡¨ç¤º1ï¼Œâ€œä½ç”µè·é‡â€è¡¨ç¤º0ã€‚è¿™å°æœºå™¨æ²¡æœ‰ä»€ä¹ˆå˜åŒ–ï¼Œè¿™åªæ˜¯æˆ‘ä»¬ä½œä¸ºäººç±»å†³å®šçš„äº‹æƒ…(1)ã€‚</p><p> On the left you see a circuit diagram. You can read it as input wires  a and  b carrying charges into the  NAND gate. The  NAND gate has a wire  c, carrying the output charge. For all the circuit diagrams weâ€™ll draw, you can read them as electricity â€œflowingâ€ from left to right, or top to bottom.</p><p>åœ¨å·¦è¾¹ä½ å¯ä»¥çœ‹åˆ°ä¸€å¼ ç”µè·¯å›¾ã€‚æ‚¨å¯ä»¥å°†å…¶ç†è§£ä¸ºå°†ç”µè·å¸¦å…¥ä¸éé—¨çš„è¾“å…¥çº¿aå’Œbã€‚ä¸éé—¨æœ‰ä¸€æ ¹å¯¼çº¿cï¼Œæºå¸¦è¾“å‡ºç”µè·ã€‚å¯¹äºæˆ‘ä»¬å°†è¦ç»˜åˆ¶çš„æ‰€æœ‰ç”µè·¯å›¾ï¼Œæ‚¨å¯ä»¥å°†å…¶ç†è§£ä¸ºç”µæµä»å·¦åˆ°å³æˆ–ä»ä¸Šåˆ°ä¸‹â€œæµåŠ¨â€ã€‚</p><p> On the right is a â€œtruthâ€ table for a NAND gate. This is just a fancy name for summarizing every state a  NAND gate can be, based on the input wires.</p><p>å³è¾¹æ˜¯ä¸€ä¸ªâ€œä¸éâ€é—¨çš„â€œçœŸâ€è¡¨ã€‚è¿™åªæ˜¯ä¸€ä¸ªå¥‡ç‰¹çš„åå­—ï¼Œç”¨æ¥æ ¹æ®è¾“å…¥çº¿æ€»ç»“NANDé—¨å¯èƒ½è¾¾åˆ°çš„æ¯ä¸€ç§çŠ¶æ€ã€‚</p><p> Now, we can start even lower than a  NAND gate, but this machine is simple enough. It canâ€™t be so hard to build something that turns off when two inputs are turned on. You donâ€™t have to take my word for it though, you can search up â€œbuilding a NAND gate with transistorsâ€, and come back when youâ€™re convinced.</p><p>ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»æ¯”NANDé—¨æ›´ä½çš„ä½ç½®å¼€å§‹ï¼Œä½†è¿™å°æœºå™¨éå¸¸ç®€å•ã€‚å½“ä¸¤ä¸ªè¾“å…¥æ¥é€šæ—¶ï¼Œæ„å»ºä¸€ä¸ªå¯ä»¥å…³é—­çš„ä¸œè¥¿ä¸ä¼šé‚£ä¹ˆéš¾ã€‚ä¸è¿‡ä½ ä¸å¿…ç›¸ä¿¡æˆ‘çš„è¯ï¼Œä½ å¯ä»¥æœç´¢â€œç”¨æ™¶ä½“ç®¡å»ºé€ ä¸éé—¨â€ï¼Œå½“ä½ ç¡®ä¿¡çš„æ—¶å€™å†å›æ¥ã€‚</p><p>   First things first, we need some way to represent the state of our circuit. We know that our RAM will be built completely from  NAND gates, so letâ€™s take inspiration from one:</p><p>é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€äº›æ–¹æ³•æ¥è¡¨ç¤ºæˆ‘ä»¬èµ›é“çš„çŠ¶æ€ã€‚æˆ‘ä»¬çŸ¥é“æˆ‘ä»¬çš„RAMå°†å®Œå…¨ç”±NANDé—¨æ„å»ºï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ä»å…¶ä¸­ä¸€ä¸ªä¸­è·å¾—çµæ„Ÿï¼š</p><p>    Hereâ€™s one way we can map that to a data structure in Clojure:</p><p>ä»¥ä¸‹æ˜¯æˆ‘ä»¬å¯ä»¥å°†å…¶æ˜ å°„åˆ°Clojureä¸­çš„æ•°æ®ç»“æ„çš„ä¸€ç§æ–¹æ³•ï¼š</p><p> ( def  ex-state-v0 { :charge-map  { :a   1   :b   1   :c   0 }   :nand-gates  [{ :ins  [ :a   :b ]   :out   :c }]})</p><p>(def ex-state-v0{ï¼šCharge-Map{ï¼šA 1ï¼šB 1ï¼šC 0}ï¼šNAND-GATES[{ï¼šINS[ï¼šAï¼šB]ï¼šOUTï¼šC}]})ã€‚</p><p> We can use keywords to represent our wires. We can also keep a map that tells us the charges of our wires. Finally, we can keep a list of NAND gates, which tell us how these wires connect.</p><p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å…³é”®å­—æ¥è¡¨ç¤ºæˆ‘ä»¬çš„ç”µçº¿ã€‚æˆ‘ä»¬è¿˜å¯ä»¥ä¿å­˜ä¸€å¼ åœ°å›¾ï¼Œå‘Šè¯‰æˆ‘ä»¬ç”µçº¿çš„ç”µè·ã€‚æœ€åï¼Œæˆ‘ä»¬å¯ä»¥ä¿å­˜NANDé—¨çš„åˆ—è¡¨ï¼Œå®ƒå‘Šè¯‰æˆ‘ä»¬è¿™äº›çº¿æ˜¯å¦‚ä½•è¿æ¥çš„ã€‚</p><p> Fine enough way to represent our circuit for now! Letâ€™s create a few functions that can help us manage this representation:</p><p>å°±ç›®å‰è€Œè¨€ï¼Œè¿™è¶³ä»¥ä»£è¡¨æˆ‘ä»¬çš„èµ›é“ï¼è®©æˆ‘ä»¬åˆ›å»ºå‡ ä¸ªå‡½æ•°æ¥å¸®åŠ©æˆ‘ä»¬ç®¡ç†è¿™ä¸ªè¡¨ç¤ºï¼š</p><p> ; update state v0 ; --------------- ( def  empty-state { :charge-map  {}  :nand-gates  []}) ( defn  charge [state wire]  ( get-in  state [ :charge-map  wire])) ( defn  charges [state wires]  ( map  ( partial  charge state) wires)) ( defn  set-charge [state wire charge]  ( assoc-in  state [ :charge-map  wire] charge)) ( defn  wire-nand-gate [state a b o]  ( update  state  :nand-gates  conj { :ins  [a b]  :out  o}))</p><p>ï¼›æ›´æ–°çŠ¶æ€V0ï¼›-(def Empty-State{ï¼šCharge-MAP{}ï¼šNAND-GATES[]})(Defn Charge[State wire](Get-in State[ï¼šCharge-Map wire]))(Defn Chards[State wire](MAP(éƒ¨åˆ†ç”µè·çŠ¶æ€)wire))(Defn Set-Charge[State wire](Assoc-In State[ï¼šCharge-Map wire]Charge)(Defn wire-NAND-ã€‚GATE[STATE a b o](æ›´æ–°çŠ¶æ€ï¼šNAND-GATES conj{ï¼šins[a b]ï¼šout o})ã€‚</p><p> These are all the basic tools we need to â€œconnectâ€ a NAND gate into our circuit. Letâ€™s try them out in the REPL:</p><p>è¿™äº›éƒ½æ˜¯æˆ‘ä»¬å°†ä¸éé—¨â€œè¿æ¥â€åˆ°ç”µè·¯ä¸­æ‰€éœ€çš„åŸºæœ¬å·¥å…·ã€‚è®©æˆ‘ä»¬åœ¨REPLä¸­å°è¯•ä¸€ä¸‹ï¼š</p><p> ( charges  ( -&gt;  empty-state  ( set-charge   :a   1 )  ( set-charge   :b   0 ))  [ :a   :b ]) ; =&gt; (1 0) ( wire-nand-gate  empty-state  :a   :b   :c ) ; =&gt; {:charge-map {}, :nand-gates [{:ins [:a :b], :out :c}]}</p><p>(ç”µè·(-&gtï¼›ç©ºçŠ¶æ€(Set-Chargeï¼šA1)(Set-Chargeï¼šB 0))[ï¼šAï¼šB])ï¼›=&gtï¼›(1 0)(Wire-NAND-GATEç©ºçŠ¶æ€ï¼šAï¼šBï¼šC)ï¼›=&gtï¼›{ï¼šç”µè·æ˜ å°„{}ï¼Œï¼šNAND-GATES[{ï¼šINS[ï¼šAï¼šB]ï¼Œï¼šOUTï¼šC}]}ã€‚</p><p> Nice! We can now â€œwireâ€ up a circuit. Letâ€™s run some electricity through it.</p><p>å¥½çš„!ã€‚æˆ‘ä»¬ç°åœ¨å¯ä»¥â€œæ¥çº¿â€ä¸€æ¡çº¿è·¯ã€‚è®©æˆ‘ä»¬é€šç”µé€šè¿‡å®ƒã€‚</p><p>  To figure out how to simulate electricity into our circuit, letâ€™s remember our diagram again:</p><p>ä¸ºäº†å¼„æ¸…æ¥šå¦‚ä½•å°†ç”µæµæ¨¡æ‹Ÿåˆ°æˆ‘ä»¬çš„ç”µè·¯ä¸­ï¼Œè®©æˆ‘ä»¬å†æ¬¡è®°ä½æˆ‘ä»¬çš„å›¾ï¼š</p><p>  One way we can model this is to imagine that electricity is like water: It â€œflowsâ€ from sources into wires, and â€œtriggersâ€ all the devices that are connected to those wires.</p><p>æˆ‘ä»¬å¯ä»¥æ¨¡æ‹Ÿè¿™ç§æƒ…å†µçš„ä¸€ç§æ–¹å¼æ˜¯æŠŠç”µæƒ³è±¡æˆæ°´ï¼šå®ƒä»æºå¤´â€œæµâ€åˆ°ç”µçº¿ï¼Œå¹¶â€œè§¦å‘â€æ‰€æœ‰è¿æ¥åˆ°è¿™äº›ç”µçº¿ä¸Šçš„è®¾å¤‡ã€‚</p><p> With a model like that, hereâ€™s what would happen if a charge was â€œtriggeredâ€ on  a:</p><p>å¯¹äºè¿™æ ·çš„æ¨¡å‹ï¼Œå¦‚æœåœ¨ä»¥ä¸‹æƒ…å†µä¸‹â€œè§¦å‘â€ä¸€é¡¹æ”¶è´¹ï¼Œå°†ä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼š</p><p> After that  a â€˜s charge would transfer to all the NAND gates that are connected to it. In this case, it would be our one NAND gate above.</p><p>æ­¤åï¼ŒAçš„ç”µè·å°†è½¬ç§»åˆ°ä¸å…¶è¿æ¥çš„æ‰€æœ‰ä¸éé—¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒå°†æ˜¯æˆ‘ä»¬ä¸Šé¢çš„ä¸€ä¸ªä¸éé—¨ã€‚</p><p> Each NAND gate would then recompute its charge, and if it changed, trigger its output wire in turn. In our case thatâ€™s  c</p><p>ç„¶åï¼Œæ¯ä¸ªä¸éé—¨å°†é‡æ–°è®¡ç®—å…¶ç”µè·ï¼Œå¦‚æœç”µè·æ”¹å˜ï¼Œåˆ™ä¾æ¬¡è§¦å‘å…¶è¾“å‡ºçº¿ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™æ˜¯cã€‚</p><p> If  c was connected to other  NAND gates, those gates would trigger, and the process would continue.</p><p>å¦‚æœcè¿æ¥åˆ°å…¶ä»–NANDé—¨ï¼Œè¿™äº›é—¨å°†è¢«è§¦å‘ï¼Œè¯¥è¿‡ç¨‹å°†ç»§ç»­ã€‚</p><p> Now, this is a very naive view of how electricity works (2), but itâ€™s good enough for us to model RAM!</p><p>ç°åœ¨ï¼Œè¿™æ˜¯ä¸€ä¸ªå…³äºç”µæ˜¯å¦‚ä½•å·¥ä½œçš„éå¸¸å¤©çœŸçš„è§‚ç‚¹(2)ï¼Œä½†å®ƒè¶³ä»¥è®©æˆ‘ä»¬ä¸ºRAMå»ºæ¨¡ï¼</p><p>     Our  nand-output function takes two input charges, and produces the output charge that a  NAND gate would produce.</p><p>æˆ‘ä»¬çš„ä¸éè¾“å‡ºå‡½æ•°æ¥å—ä¸¤ä¸ªè¾“å…¥ç”µè·ï¼Œå¹¶äº§ç”Ÿä¸éé—¨å°†äº§ç”Ÿçš„è¾“å‡ºç”µè·ã€‚</p><p> Next, we need a function to find all the  NAND gates that are connected to a specific wire:</p><p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥æŸ¥æ‰¾è¿æ¥åˆ°ç‰¹å®šå¯¼çº¿çš„æ‰€æœ‰ä¸éé—¨ï¼š</p><p>   This searches all of our  NAND gates in our circuit, and finds the ones which are connected to a specific wire.</p><p>è¿™å°†æœç´¢ç”µè·¯ä¸­çš„æ‰€æœ‰NANDé—¨ï¼Œå¹¶æ‰¾åˆ°è¿æ¥åˆ°ç‰¹å®šå¯¼çº¿çš„é‚£äº›é—¨ã€‚</p><p>  ( declare  trigger-nand-gate) ( defn  trigger  ([state wire new-v]  ( let  [old-charge ( charge  state wire)  state&#39; ( set-charge  state wire new-v)  new-charge ( charge  state&#39; wire)]  ( if  ( =  old-charge new-charge)  state&#39;  ( reduce  ( fn  [acc-state out] ( trigger-nand-gate  acc-state out))  state&#39;  ( dependent-nand-gates  state&#39; wire))))))</p><p>(å£°æ˜Trigger-NAND-GATE)(Defn Trigger([STATE WIRE NEW-V](LET[OLD-Charge(Charge State Wire)State&#39ï¼›(Set-Charge State Wire NEW-v)new-Charge(Charge State)](IF(=Old-Charge New-Charge)STATE&#39ï¼›(Reduce(FN[Acc-State Out](Trigger-NAND-Gate Acc-State Out)STATE&#39ï¼›(Dependent-NAND-GATES STATE&#)(Dependent-NAND-GATES STATE&#)ã€‚ç”µçº¿)ã€‚</p><p>   Whatâ€™s left is to implement what a  NAND gate does when it is triggered:</p><p>å‰©ä¸‹çš„å°±æ˜¯å®ç°NANDé—¨åœ¨è¢«è§¦å‘æ—¶æ‰€åšçš„äº‹æƒ…ï¼š</p><p> ( defn  trigger-nand-gate  [state { :keys  [ins out]}]  ( let  [new-charge ( apply  nand-output ( charges  state ins))]  ( trigger  state out new-charge)))</p><p>(å®šä¹‰è§¦å‘å™¨ä¸éé—¨[STATE{ï¼šKEYS[INS OUT]}](LET[NEW-CHAGE(åº”ç”¨NAND-OUT(ç”µè·çŠ¶æ€INS))]](è§¦å‘çŠ¶æ€OUT NEW-CHAGE))ã€‚</p><p> This calculates the new charge of a  NAND gate, and triggers the  output wire with that charge.</p><p>è¿™ä¼šè®¡ç®—ä¸éé—¨çš„æ–°ç”µè·ï¼Œå¹¶ç”¨è¯¥ç”µè·è§¦å‘è¾“å‡ºçº¿ã€‚</p><p>  One final helper function: letâ€™s create something that will will let us â€œtriggerâ€ many wires:</p><p>æœ€åä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼šè®©æˆ‘ä»¬åˆ›å»ºä¸€äº›å¯ä»¥è®©æˆ‘ä»¬â€œè§¦å‘â€å¤šæ¡çº¿è·¯çš„ä¸œè¥¿ï¼š</p><p> ( defn  trigger-many [state wires charges]  ( reduce  ( fn  [acc-state [wire charge]]  ( trigger  acc-state wire charge))  state  ( map  vector wires charges)))</p><p>(Defnè§¦å‘å™¨-å¤šä¸ª[çŠ¶æ€å¯¼çº¿ç”µè·](Reduce(fn[acc-state[å¯¼çº¿ç”µè·]](è§¦å‘accçŠ¶æ€å¯¼çº¿ç”µè·))çŠ¶æ€(æ˜ å°„å‘é‡å¯¼çº¿ç”µè·)ã€‚</p><p> Weâ€™ll want to do this so much that itâ€™s good to have around.</p><p>æˆ‘ä»¬éå¸¸æƒ³åšè¿™ä»¶äº‹ï¼Œæ‰€ä»¥æœ‰è¿™æ ·çš„äººåœ¨èº«è¾¹æ˜¯å¾ˆå¥½çš„ã€‚</p><p>  We have what we need to simulate a simple charge flowing through a NAND gate. Letâ€™s write a test for that:</p><p>æˆ‘ä»¬å·²ç»æœ‰äº†æ¨¡æ‹Ÿé€šè¿‡NANDé—¨çš„ç®€å•ç”µè·æ‰€éœ€çš„ä¸œè¥¿ã€‚è®©æˆ‘ä»¬ä¸ºæ­¤ç¼–å†™ä¸€ä¸ªæµ‹è¯•ï¼š</p><p> ( deftest  test-nand-gate  ( let  [s1 ( -&gt;  empty-state  ( wire-nand-gate   :a   :b   :o )  ( trigger-many  [ :a   :b ] [ 1   0 ]))  s2 ( -&gt;  s1  ( trigger   :b   1 ))]  ( testing   &#34;just a is on&#34;  ( is  ( =  &#39;( 1   0   1 ) ( charges  s1 [ :a   :b   :o ]))))  ( testing   &#34;both a and b are on&#34;  ( is  ( =  &#39;( 1   1   0 ) ( charges  s2 [ :a   :b   :o ]))))))</p><p>(Deftest-NAND-GATE(è®¾[S1(-&gt;ï¼›EMPTY-STATE(Wire-NAND-GATEï¼šAï¼šBï¼šO))(Trigger-My[ï¼šAï¼šB][1 0]))S2(-&&gt;S1(Triggerï¼šB1))](Testing&#34ï¼›Just a is on&#34ï¼›(is(=&#39ï¼›(1 0 1)(è´¹ç”¨s1[ï¼šaï¼šbï¼šo])(æµ‹è¯•&#34ï¼›aå’Œbéƒ½åœ¨&#34ï¼›(is(=&#39ï¼›(1 1 0)(è´¹ç”¨s2[ï¼šaï¼šbï¼šo])ã€‚</p><p>    What would happen, if we took a NAND gate, and fed the  same wire in both inputs?</p><p>å¦‚æœæˆ‘ä»¬å–ä¸€ä¸ªNANDé—¨ï¼Œå¹¶åœ¨ä¸¤ä¸ªè¾“å…¥ç«¯é¦ˆå…¥ç›¸åŒçš„å¯¼çº¿ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ</p><p>  Well, the output would end up being the opposite of its input. When  a is zero,  c is 1, when  a is 1,  c is 0. Boom, that happens to be a  NOT gate. Hereâ€™s how that looks:</p><p>é‚£ä¹ˆï¼Œè¾“å‡ºå°†æœ€ç»ˆä¸å…¶è¾“å…¥ç›¸åã€‚å½“aä¸ºé›¶æ—¶ï¼Œcä¸º1ï¼Œå½“aä¸º1æ—¶ï¼Œcä¸º0ã€‚ç °çš„ä¸€å£°ï¼Œé‚£æ­£å¥½æ˜¯ä¸€æ‰‡â€œéé—¨â€ã€‚è¿™çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š</p><p>  To implement our  NOT gate, we can do exactly as our diagram described: Feed the same wire to  both inputs of a  NAND gate:</p><p>è¦å®ç°æˆ‘ä»¬çš„NOTé—¨ï¼Œæˆ‘ä»¬å¯ä»¥å®Œå…¨æŒ‰ç…§å›¾ä¸­æè¿°çš„é‚£æ ·åšï¼šå°†ç›¸åŒçš„å¯¼çº¿é¦ˆé€åˆ°NANDé—¨çš„ä¸¤ä¸ªè¾“å…¥ç«¯ï¼š</p><p>   ( deftest  test-not-gate  ( let  [s1 ( -&gt;  empty-state  ( wire-not-gate   :a   :o )  ( trigger   :a   0 ))  s2 ( -&gt;  s1  ( trigger   :a   1 ))]  ( testing   &#34;a is off&#34;  ( is  ( =  &#39;( 0   1 ) ( charges  s1 [ :a   :o ]))))  ( testing   &#34;a is on&#34;  ( is  ( =  &#39;( 1   0 ) ( charges  s2 [ :a   :o ]))))))</p><p>(Deftest-NOT-GATE(è®¾[S1(-&&gt;ï¼›EMPTY-STATE(Wire-NOT-GATEï¼šAï¼šO))(Triggerï¼šA0))S2(-&gtï¼›S1(Triggerï¼šA1))](æµ‹è¯•&#34ï¼›aå…³é—­&#34ï¼›(is(=&#39ï¼›(0 1)(è´¹ç”¨S1[ï¼šAï¼šO])(æµ‹è¯•&#34ï¼›aæ‰“å¼€&#34ï¼›(is(=&#39ï¼›(1 0)(è´¹ç”¨s2[ï¼šAï¼šO])ã€‚</p><p>    What if we plugged the output of one  NAND as the input of a  NOT gate?</p><p>å¦‚æœæˆ‘ä»¬æ’å…¥ä¸€ä¸ªNANDçš„è¾“å‡ºä½œä¸ºNOTé—¨çš„è¾“å…¥ï¼Œä¼šæ€ä¹ˆæ ·ï¼Ÿ</p><p>  Well, it would be opposite of a  NAND gate:  d would only be 1 when  both  a and  b are 1. Thatâ€™s the  AND gate:</p><p>å®ƒä¸NANDé—¨ç›¸åï¼šåªæœ‰å½“aå’Œbéƒ½æ˜¯1æ—¶ï¼Œdæ‰ä¼šæ˜¯1ã€‚è¿™å°±æ˜¯ANDé—¨ï¼š</p><p>   ( defn  wire-and-gate [state a b o]  ( let  [nand-o  :c ]  ( -&gt;  state  ( wire-nand-gate  a b nand-o)  ( wire-not-gate  nand-o o))))</p><p>(Defn Wire-and-Gate[State a b o](è®¾[NAND-oï¼šc](-&gtï¼›State(Wire-NAND-Gate a b NAND-o)(Wire-Not-Gate NAND-o)ã€‚</p><p> This would workâ€¦almost. The tricky thing here is that inside the function we have an â€œintermediaryâ€ wire  c, which connects the  NAND gate and  NOT gate. If we made  two  AND gates for example, then they would share the same wire  :c!</p><p>è¿™ä¼šå¥æ•ˆçš„ï¼Œâ€¦ã€‚å·®ä¸å¤šäº†ã€‚è¿™é‡Œçš„æ£˜æ‰‹ä¹‹å¤„åœ¨äºï¼Œåœ¨å‡½æ•°å†…éƒ¨ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªâ€œä¸­é—´â€å¯¼çº¿cï¼Œå®ƒè¿æ¥ä¸éé—¨å’Œéé—¨ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åˆ¶ä½œäº†ä¸¤ä¸ªANDé—¨ï¼Œé‚£ä¹ˆå®ƒä»¬å°†å…±äº«åŒä¸€æ ¹å¯¼çº¿ï¼šCï¼</p><p>  ( def  _u ( atom  {})) ( defn  uniq-n [k]  ( swap!  _u update k ( fn  [i] ( inc  ( or  i  0 ))))  ( get  @_u k)) ( defn  kw [&amp; args]  ( -&gt;&gt;  args  ( map  ( fn  [x] ( if  (( some-fn  keyword? symbol?) x)  ( name  x)  x)))  ( apply  str)  keyword)) ( defn  wire  ([n]  ( let  [i ( uniq-n  n)]  ( if  ( &gt;  i  1 ) ( kw  n  &#34;#&#34;  i) n))))</p><p>(def_u(atom{}))(Defn uniq-n[k](SWAPï¼_u UPDATE k(FN[i](Inc(Or I 0)(get@_u k)(Defn kw[&ampï¼›args](-&&gt;ï¼›&&gt;args(MAP(fn[x])(if((æŸäº›-fnå…³é”®å­—ï¼Ÿç¬¦å·ï¼Ÿ)ã€‚X)(åç§°x)(åº”ç”¨å­—ç¬¦ä¸²å…³é”®å­—))(Defn wire([n](let[i(uniq-n n)](if(&gtï¼›i 1)(kw n&#34ï¼›#&#34ï¼›i)n)ã€‚</p><p>   Now if we create a wire with a name that already exists, itâ€™ll add a nice little â€œ#2â€ beside it.</p><p>ç°åœ¨ï¼Œå¦‚æœæˆ‘ä»¬ç”¨å·²ç»å­˜åœ¨çš„åç§°åˆ›å»ºä¸€æ¡çº¿ï¼Œå®ƒä¼šåœ¨å®ƒçš„æ—è¾¹æ·»åŠ ä¸€ä¸ªæ¼‚äº®çš„å°â€œ#2â€ã€‚</p><p>  ( defn  wire-and-gate [state a b o]  ( let  [nand-o ( wire  ( kw  a b  :and-nand-o ))]  ( -&gt;  state  ( wire-nand-gate  a b nand-o)  ( wire-not-gate  nand-o o))))</p><p>(Defn Wire-and-Gate[State a b o](let[NAND-o(wire(kw a bï¼šand-nAND-o))](-&gtï¼›state(wire-NAND-gate a b NAND-o)(Wire-NOT-GATE NAND-o)</p><p>  ( deftest  test-and-gate  ( let  [s1 ( -&gt;  empty-state  ( wire-and-gate   :a   :b   :o )  ( trigger-many  [ :a   :b ] [ 1   0 ]))  s2 ( -&gt;  s1  ( trigger   :b   1 ))]  ( testing   &#34;just a is on&#34;  ( is  ( =  &#39;( 1   0   0 ) ( charges  s1 [ :a   :b   :o ]))))  ( testing   &#34;a and b on&#34;  ( is  ( =  &#39;( 1   1   1 ) ( charges  s2 [ :a   :b   :o ]))))))</p><p>(Deftest-and-gate(è®¾[S1(-&gt;ï¼›Empty-State(Wire-and-Gateï¼šAï¼šBï¼šO)(Trigger-My[ï¼šAï¼šB][1 0])S2(-&gtï¼›S1(Triggerï¼šB1))](Testing&#34ï¼›Just a is on&#34ï¼›(is(=&#39ï¼›(1 0 0)(è´¹ç”¨s1[ï¼šaï¼šbï¼šo])(æµ‹è¯•&#34ï¼›aå’Œb&#34ï¼›(is(=&#39ï¼›(111)(è´¹ç”¨s2[ï¼šaï¼šbï¼šo])ã€‚</p><p>    Now comes one of the hardest and most important circuits weâ€™ll need to understand. Letâ€™s start by describing our goal:</p><p>ç°åœ¨æ˜¯æˆ‘ä»¬éœ€è¦äº†è§£çš„æœ€éš¾ä¹Ÿæ˜¯æœ€é‡è¦çš„èµ›é“ä¹‹ä¸€ã€‚è®©æˆ‘ä»¬ä»æè¿°æˆ‘ä»¬çš„ç›®æ ‡å¼€å§‹ï¼š</p><p>  Notice the interesting thing here. When the  s wire is â€œ1â€, the value of  i is transferred to  o. When it is â€œ0â€, the value of  o is  no longer affected by i.  o&#39;s charge is  whatever it was before.</p><p>è¯·æ³¨æ„è¿™é‡Œçš„æœ‰è¶£ä¹‹å¤„ã€‚å½“sçº¿ä¸ºâ€œ1â€æ—¶ï¼Œiçš„å€¼è¢«è½¬ç§»åˆ°oã€‚å½“å®ƒä¸ºâ€œ0â€æ—¶ï¼Œoçš„å€¼ä¸å†å—içš„å½±å“ï¼Œoçš„ç”µè·ä¿æŒä¸å˜ã€‚</p><p> If we can make something like this, that would mean that the charge on â€œoâ€ is  stored.  Since it can be either 1 or 0, we can in effect â€œstoreâ€ 1 bit of data.</p><p>å¦‚æœæˆ‘ä»¬èƒ½åšå‡ºè¿™æ ·çš„ä¸œè¥¿ï¼Œé‚£å°±æ„å‘³ç€â€œoâ€ä¸Šçš„ç”µè·è¢«å‚¨å­˜èµ·æ¥äº†ã€‚å› ä¸ºå®ƒå¯ä»¥æ˜¯1ä¹Ÿå¯ä»¥æ˜¯0ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥â€œå­˜å‚¨â€1ä½æ•°æ®ã€‚</p><p>   The trick with this circuit is the way  o and  c are connected together. This intertwining thing is called a â€œlatchâ€, because once a charge gets set in a certain way, these gates will find an equilibrium that causes  o to be stored. Pretty cool!</p><p>è¿™ä¸ªç”µè·¯çš„è¯€çªåœ¨äºoå’Œcè¿æ¥åœ¨ä¸€èµ·çš„æ–¹å¼ã€‚è¿™ç§ç¼ ç»•åœ¨ä¸€èµ·çš„ä¸œè¥¿è¢«ç§°ä¸ºâ€œé”å­˜â€ï¼Œå› ä¸ºä¸€æ—¦ä»¥æŸç§æ–¹å¼è®¾ç½®äº†ç”µè·ï¼Œè¿™äº›é—¨å°±ä¼šæ‰¾åˆ°ä¸€ä¸ªå¹³è¡¡ç‚¹ï¼Œä»è€Œå¯¼è‡´oè¢«å‚¨å­˜èµ·æ¥ã€‚ç›¸å½“é…·ï¼</p><p> This circuit is pretty complicated and a bit  hard to understand (3), but weâ€™ve got the power of simulation at our fingertips! Letâ€™s try building it and test it out:</p><p>è¿™ä¸ªç”µè·¯ç›¸å½“å¤æ‚ï¼Œæœ‰ç‚¹éš¾æ‡‚(3)ï¼Œä½†æˆ‘ä»¬å¯¹æ¨¡æ‹Ÿèƒ½åŠ›äº†å¦‚æŒ‡æŒï¼è®©æˆ‘ä»¬å°è¯•æ„å»ºå®ƒå¹¶å¯¹å…¶è¿›è¡Œæµ‹è¯•ï¼š</p><p> ( defn  wire-memory-bit   &#34;To understand the variables in this circuit,  follow along with the diagram in the tutorial&#34;  ([state s i o]  ( let  [a ( wire   :a )  b ( wire   :b )  c ( wire   :c )]  ( -&gt;  state  ( wire-nand-gate  i s a)  ( wire-nand-gate  a s b)  ( wire-nand-gate  a c o)  ( wire-nand-gate  b o c)))))</p><p>(è¦ç†è§£æœ¬ç”µè·¯ä¸­çš„å˜é‡ï¼Œè¯·æŒ‰ç…§æ•™ç¨‹ä¸­çš„å›¾è¡¨è¿›è¡Œæ“ä½œ&#34ï¼›([STATE s I o](è®¾[a(wireï¼ša)b(wireï¼šb)c(wireï¼šc)](-&gtï¼›state(wire-NAND-gate i s a)(wire-NAND-gate a s b)(wire-NAND-gate a c)(wire-NAND-gate b o c)ã€‚</p><p> Looks so pretty for such a complicated machine. Now the ultimate questionâ€¦will it work?!</p><p>å¯¹äºè¿™æ ·ä¸€å°å¤æ‚çš„æœºå™¨æ¥è¯´ï¼Œå®ƒçœ‹èµ·æ¥çœŸæ¼‚äº®ã€‚ç°åœ¨æ˜¯ç»ˆæé—®é¢˜â€¦ã€‚å®ƒä¼šèµ·ä½œç”¨å—ï¼Ÿï¼</p><p> ( deftest  test-memory-bit  ( let  [s1 ( -&gt;  empty-state  ( wire-memory-bit   :s   :i   :o )  ( trigger-many  [ :i   :s ] [ 1   0 ]))  s2 ( -&gt;  s1  ( trigger   :s   1 ))  s3 ( -&gt;  s2  ( trigger-many  [ :s   :i ] [ 0   0 ]))]  ( testing   &#34;turning i on does not affect the rest&#34;  ( is  ( =  &#39;( 0   1   0 ) ( charges  s1 [ :s   :i   :o ]))))  ( testing   &#34;enabling set transfers i to o&#34;  ( is  ( =  &#39;( 1   1   1 )  ( charges  s2 [ :s   :i   :o ]))))  ( testing   &#34;disabling set, removes further effects on o&#34;  ( is  ( =  &#39;( 0   0   1 )  ( charges  s3 [ :s   :i   :o ]))))))</p><p>(Deftest-Memory-Bit(è®¾[S1(-&gt;ï¼›Empty-State(Wire-Memory-bitï¼šSï¼šIï¼šO)(Trigger-Memory[ï¼šIï¼šS][1 0])S2(-&&gt;S1(Triggerï¼šS 1))S3(-&&gt;S2(Trigger-Many[ï¼šSï¼šI][0 0]))](Testing&#34ï¼›æ‰“å¼€Iä¸ä¼šå½±å“å…¶ä½™&#34ï¼›(IS(=&#39ï¼›(0 1 0)(è´¹ç”¨S1[ï¼šSï¼šIï¼šO])(æµ‹è¯•&#34ï¼›å¯ç”¨SETä¼ è¾“Iåˆ°O&#34ï¼›(IS(=&#39ï¼›(11 1)(è´¹ç”¨S2[ï¼šSï¼šIï¼šO])(æµ‹è¯•&#34ï¼›ç¦ç”¨SETï¼Œæ¶ˆé™¤å¯¹O&#34ï¼›çš„è¿›ä¸€æ­¥å½±å“ï¼›(IS(=&#39ï¼›(001)(è´¹ç”¨S3[ï¼šSï¼šIï¼šO])ã€‚</p><p>    Now that we have a bit, we can take one  s wire and tie 8 memory bits together with it. That would let us  set 8 bits together, which means we can â€œstoreâ€ 8 bits of dataâ€¦which gives us a byte! (5). Hereâ€™s how that would look:</p><p>ç°åœ¨æˆ‘ä»¬æœ‰äº†ä½ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€æ ¹å¯¼çº¿å°†8ä¸ªå†…å­˜ä½æ†ç»‘åœ¨ä¸€èµ·ã€‚è¿™å°†å…è®¸æˆ‘ä»¬ä¸€èµ·è®¾ç½®8ä½ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥â€œå­˜å‚¨â€8ä½æ•°æ®â€¦ã€‚è¿™ç»™äº†æˆ‘ä»¬ä¸€ä¸ªå­—èŠ‚ï¼(5)ã€‚è¿™çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š</p><p>  Note that in our diagram now â€œtwo wires togetherâ€ is short-hand for writing  8 wires.</p><p>è¯·æ³¨æ„ï¼Œåœ¨æˆ‘ä»¬çš„å›¾è¡¨ä¸­ï¼Œâ€œä¸¤æ¡å¯¼çº¿åœ¨ä¸€èµ·â€æ˜¯ä¹¦å†™8æ¡å¯¼çº¿çš„ç¼©å†™ã€‚</p><p>  ( defn  wire-byte [state s ins outs]  ( reduce  ( fn  [acc-state [i o]]  ( wire-memory-bit  acc-state s i o))  state  ( map  vector ins outs)))</p><p>(å®šä¹‰çº¿å­—èŠ‚[çŠ¶æ€s INS OUTS](Reduce(fn[acc-state[i o]](Wire-Memory-bit acc-state s i o))çŠ¶æ€(æ˜ å°„å‘é‡INS OUTS)ã€‚</p><p>  To test this out though, weâ€™re going to need a way to â€œcreateâ€ a bunch of names for wires. Letâ€™s write a few helper functions that make this easy:</p><p>ä¸è¿‡ï¼Œè¦æµ‹è¯•è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥ä¸ºå¯¼çº¿â€œåˆ›å»ºâ€ä¸€ç»„åç§°ã€‚è®©æˆ‘ä»¬ç¼–å†™å‡ ä¸ªå¸®åŠ©å™¨å‡½æ•°æ¥ç®€åŒ–è¿™ä¸€è¿‡ç¨‹ï¼š</p><p> ( defn  names [n r]  ( mapv  ( fn  [i] ( kw  n  &#34;-&#34;  i)) ( range  r))) ( def  wires ( comp  ( partial  mapv wire) names))</p><p>(å®šä¹‰åç§°[n r](mapv(fn[i](kw n&#34ï¼›-&#34ï¼›i))(èŒƒå›´r))(å®šä¹‰ç„Šçº¿(å…ƒä»¶(éƒ¨åˆ†mapvç„Šçº¿)åç§°))ã€‚</p><p>    ( deftest  test-byte  ( let  [ii ( wires   :i   8 )  os ( wires   :o   8 )  s1 ( -&gt;  empty-state  ( wire-byte   :s  ii os)  ( trigger-many  ii [ 1   1   1   0   0   0   0   0 ])  ( trigger   :s   0 ))  s2 ( -&gt;  s1  ( trigger   :s   1 ))  s3 ( -&gt;  s2  ( trigger   :s   0 )  ( trigger-many  ii [ 0   0   0   0   0   0   0   1 ]))]  ( testing   &#34;disabling set, removes further effects on o&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s1 ii)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 os))))  ( testing   &#34;set s, so os become 1 1 1&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 os))))  ( testing   &#34;freeze by disabling s. see that further changes to i do nothing to o&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   1 )  ( charges  s3 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 os))))))</p><p>(Deftest-byte(let[II(wireï¼šI 8)os(wireï¼šO 8)S1(-&gtï¼›Empty-State(wire-byteï¼šS II os)(Trigger-Many II[1 1 0 0 0])(Triggerï¼šS 0))S2(-&gtï¼›S1(Triggerï¼šS 1))S3(-&gtï¼›S2(TRIGGERï¼šS 0)(TRIGGER-MANY II[0 0 0 1])](æµ‹è¯•&#34ï¼›ç¦ç”¨è®¾ç½®ï¼Œæ¶ˆé™¤å¯¹O&#34ï¼›(IS(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨S1 II)(IS(=&#39ï¼›(0 0 0)(è´¹ç”¨s1 os)(æµ‹è¯•&#34ï¼›è®¾ç½®sï¼Œå› æ­¤oså˜ä¸º1 11&#34ï¼›(is(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨s2 II)(is(=&#39ï¼›(1 1 1 0 0 0)(è´¹ç”¨s2 os)(æµ‹è¯•&#34ï¼›é€šè¿‡ç¦ç”¨Sæ¥å†»ç»“ã€‚è¯·å‚è§å¯¹içš„è¿›ä¸€æ­¥æ›´æ”¹ä¸ä¼šå¯¹o&#34ï¼›(is(=&#39ï¼›(0 0 0 1)(è´¹ç”¨S3 II)(is(=&#39ï¼›(1 1 1 0 0 0)(è´¹ç”¨s2 os)ã€‚</p><p>       Notice how the output wires are  shared between  B1 and  B2. If  B1 had a charge of â€œ11110000â€, and  B2 had a charge of â€œ0001111â€, what would happen to the output wires? It would carry a charge of â€œ1111111â€! Say we wanted to make sure  only one of the bytes sent their output charge into  output wires. How could we do that?</p><p>è¯·æ³¨æ„B1å’ŒB2ä¹‹é—´çš„è¾“å‡ºçº¿æ˜¯å¦‚ä½•å…±äº«çš„ã€‚å¦‚æœB1çš„ç”µè·æ˜¯â€œ11110000â€ï¼Œè€ŒB2çš„ç”µè·æ˜¯â€œ0001111â€ï¼Œé‚£ä¹ˆè¾“å‡ºçº¿ä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿå®ƒå°†æºå¸¦â€œ1111111â€çš„è´¹ç”¨ï¼å‡è®¾æˆ‘ä»¬æƒ³è¦ç¡®ä¿åªæœ‰ä¸€ä¸ªå­—èŠ‚å°†å…¶è¾“å‡ºç”µè·å‘é€åˆ°è¾“å‡ºçº¿ã€‚æˆ‘ä»¬æ€ä¹ˆèƒ½è¿™ä¹ˆåšå‘¢ï¼Ÿ</p><p> Weâ€™ll need a new machine. Letâ€™s consider what would happen if we took a bunch of  AND gates, and connected them together like this:</p><p>æˆ‘ä»¬éœ€è¦ä¸€å°æ–°æœºå™¨ã€‚è®©æˆ‘ä»¬æ¥è€ƒè™‘ä¸€ä¸‹ï¼Œå¦‚æœæˆ‘ä»¬æŠŠä¸€ä¸²ANDé—¨è¿æ¥åœ¨ä¸€èµ·ä¼šå‘ç”Ÿä»€ä¹ˆï¼Œå°±åƒè¿™æ ·ï¼š</p><p>  Now, if the â€œeâ€ wire is â€œonâ€, the output wires are charged with whatever the input wires are. Buut, if the â€œeâ€ wire is â€œoffâ€, the output  zeroes out. This machine is called the â€œenablerâ€. If we put this together right, we could control what charge gets sent to  output wires!</p><p>ç°åœ¨ï¼Œå¦‚æœâ€œeâ€çº¿æ˜¯â€œå¼€â€çš„ï¼Œé‚£ä¹ˆæ— è®ºè¾“å…¥çº¿æ˜¯ä»€ä¹ˆï¼Œè¾“å‡ºçº¿éƒ½ä¼šè¢«å……ç”µã€‚ä½†æ˜¯ï¼Œå¦‚æœâ€œeâ€çº¿æ˜¯â€œOFFâ€ï¼Œåˆ™è¾“å‡ºä¸ºé›¶ã€‚è¿™å°æœºå™¨è¢«ç§°ä¸ºâ€œå¯åŠ¨å™¨â€ã€‚å¦‚æœæˆ‘ä»¬æŠŠè¿™äº›æ”¾åœ¨ä¸€èµ·ï¼Œæˆ‘ä»¬å°±èƒ½æ§åˆ¶é€åˆ°è¾“å‡ºçº¿çš„ç”µè·ï¼</p><p>  ( defn  wire-enabler  [state e ins outs]  ( reduce  ( fn  [acc-state [in out]]  ( wire-and-gate  acc-state e in out))  state  ( map  vector ins outs)))</p><p>(Defn Wire-Enabler[State e Ins Out](Reduce(fn[acc-state[In Out]](çº¿æ …Acc-State e In Out)çŠ¶æ€(è´´å›¾å‘é‡Ins Out))ã€‚</p><p>  ( deftest  test-enabler  ( let  [ii ( wires   :i   8 )  os ( wires   :o   8 )  s1 ( -&gt;  empty-state  ( wire-enabler   :e  ii os)  ( trigger-many  ii [ 1   1   1   0   0   0   0   0 ])  ( trigger   :e   0 ))  s2 ( trigger  s1  :e   1 )  s3 ( trigger  s2  :e   0 )]  ( testing   &#34;is should be set, but os should be 0&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s1 ii)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 os))))  ( testing   &#34;os should pass if enabled&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 os))))  ( testing   &#34;os should revert if disabled&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 ii)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s3 os))))))</p><p>(Deftest-Enabler(è®©[II(wireï¼šI 8)os(wireï¼šO 8)S1(-&gt;ï¼›Empty-State(wire-Enablerï¼šE II os)(Trigger-Many II[1 1 0 0 0])(Triggerï¼šE 0))S2(Trigger S1ï¼šE 1)S3(Trigger S2ï¼šE 0)](Testing&#34ï¼›isåº”è¯¥è®¾ç½®ï¼Œä½†OSåº”è¯¥æ˜¯0&#34ï¼›(IS(=&#39ï¼›(1 1 1 0 0 0)(è´¹ç”¨S1II)(IS(=&#39ï¼›(0 0 0)(è´¹ç”¨S1 os)(æµ‹è¯•&#34ï¼›OSå¦‚æœå¯ç”¨&#34ï¼›((IS(=&#39ï¼›(1 1 1 0 0 0)(è´¹ç”¨S2 II))(IS(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨S2 OS)(æµ‹è¯•&#34ï¼›OSå¦‚æœç¦ç”¨åº”æ¢å¤&#34ï¼›(IS(=&#39ï¼›(1 1 1 0 0 0)(è´¹ç”¨S3 II)(IS(=&#39ï¼›(0 0 0)(æ”¶è´¹S3 os)ã€‚</p><p>    Hereâ€™s how we could â€œfixâ€ our problem with  B1 and  B2:</p><p>ä¸‹é¢æ˜¯æˆ‘ä»¬å¦‚ä½•â€œä¿®å¤â€B1å’ŒB2çš„é—®é¢˜ï¼š</p><p>  If we stuck an â€œenablerâ€ in front of each byte, we could control what gets sent to  output wires. If we wanted to have  B1&#39;s charge, we would â€œenable  E1â€, and make sure  E2 was disabled, and vice versa.</p><p>å¦‚æœæˆ‘ä»¬åœ¨æ¯ä¸ªå­—èŠ‚å‰é¢åŠ ä¸Šä¸€ä¸ªâ€œå¯ç”¨ç â€ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ§åˆ¶å‘é€åˆ°è¾“å‡ºçº¿çš„å†…å®¹ã€‚å¦‚æœæˆ‘ä»¬æƒ³è®©B1å……ç”µï¼Œæˆ‘ä»¬ä¼šâ€œå¯ç”¨E1â€ï¼Œå¹¶ç¡®ä¿ç¦ç”¨E2ï¼Œåä¹‹äº¦ç„¶ã€‚</p><p> This combination of byte and enabler is so common that we can build a machine for that:</p><p>å­—èŠ‚å’Œå¯ç”¨ç çš„è¿™ç§ç»„åˆéå¸¸å¸¸è§ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºæ­¤æ„å»ºä¸€å°æœºå™¨ï¼š</p><p>  Itâ€™s called a register! Registers let us both control  what bytes are stored, and  when these bytes are exposed as output.</p><p>è¿™å«æ”¶é“¶æœºï¼å¯„å­˜å™¨è®©æˆ‘ä»¬å¯ä»¥æ§åˆ¶å­˜å‚¨å“ªäº›å­—èŠ‚ï¼Œä»¥åŠä½•æ—¶å°†è¿™äº›å­—èŠ‚å…¬å¼€ä¸ºè¾“å‡ºã€‚</p><p> To set this up, all we need to do is to tie together a byte and an enabler:</p><p>è¦è®¾ç½®å®ƒï¼Œæˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯å°†ä¸€ä¸ªå­—èŠ‚å’Œä¸€ä¸ªå¯ç”¨ç ç»‘å®šåœ¨ä¸€èµ·ï¼š</p><p> ( defn  wire-register [state s e ins bits outs]  ( -&gt;  state  ( wire-byte  s ins bits)  ( wire-enabler  e bits outs)))</p><p>(Defnçº¿å¯„å­˜å™¨[çŠ¶æ€s e insä½è¾“å‡º](-&gtï¼›state(çº¿å­—èŠ‚s insä½)(çº¿å¯ç”¨å™¨eä½è¾“å‡º)ã€‚</p><p> Badabing, badaboom, it should work. This is a pretty important machine, so letâ€™s make darn sure it works:</p><p>å·´è¾¾å®¾ï¼Œå·´è¾¾åšï¼Œåº”è¯¥è¡Œå¾—é€šã€‚è¿™æ˜¯ä¸€å°éå¸¸é‡è¦çš„æœºå™¨ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ç¡®ä¿å®ƒèƒ½æ­£å¸¸å·¥ä½œï¼š</p><p> ( deftest  test-register  ( let  [ii ( wires   :i   8 )  bs ( wires   :b   8 )  os ( wires   :o   8 )  s1 ( -&gt;  empty-state  ( wire-register   :s   :e  ii bs os)  ( trigger-many  ii [ 1   1   1   0   0   0   0   0 ])  ( trigger   :s   0 )  ( trigger   :e   0 ))  s2 ( trigger  s1  :s   1 )  s3 ( trigger  s2  :e   1 )  s4 ( -&gt;  s3  ( trigger   :s   0 )  ( trigger-many  ii [ 0   0   0   0   0   0   0   1 ]))  s5 ( trigger  s4  :e   0 )]  ( testing   &#34;is should be set, but bs and os should be 0, b/c s &amp; e are 0&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s1 ii)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 bs)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 os))))  ( testing   &#34;is &amp; bs should be set, as s is on. but os should be 0, b/c e is off&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 bs)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 os))))  ( testing   &#34;is &amp; bs should be set, as s is on. but os should be 0, b/c e is off&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 bs)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 os))))  ( testing   &#34;is should be new v, but bs and os should be the old value&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   1 )  ( charges  s4 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s4 bs)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s4 os))))  ( testing   &#34;os should 0 out again&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   1 )  ( charges  s5 ii)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s5 bs)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s5 os))))))</p><p>(Deftest-Register(è®¾II(wireï¼šI 8)bs(wireï¼šB 8)os(wireï¼šO 8)s1(-&gtï¼›ç©ºçŠ¶æ€(çº¿å¯„å­˜å™¨ï¼šSï¼šE II bs os)(è§¦å‘å™¨å¤šII[1 1 0 0 0])(è§¦å‘å™¨ï¼šS 0)(è§¦å‘å™¨ï¼šE 0)S2(è§¦å‘å™¨S1ï¼šS 1)S3(è§¦å‘å™¨S2ï¼šE 1)S4(-&gtï¼›S3(TRIGGERï¼šS 0)(TRIGGER-MANY II[0 0 0 1])S5(TRIGGER S4ï¼šE 0)](æµ‹è¯•åº”è¯¥è®¾ç½®ï¼Œä½†æ˜¯bså’Œosåº”è¯¥æ˜¯0ï¼Œb/c s&ampï¼›eæ˜¯0&#34ï¼›(is(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨s1 II)(is(=&#39ï¼›(0 0 0)(è´¹ç”¨s1 bs)(is(=&#39ï¼›(0 0 0)(è´¹ç”¨s1 os)(æµ‹è¯•&34ï¼›is&ampï¼›bsåº”è®¾ç½®ï¼Œå› ä¸ºsä¸ºONã€‚ä½†æ“ä½œç³»ç»Ÿåº”ä¸º0ï¼Œb/c eä¸ºOFF&#34ï¼›(is(=&#39ï¼›(11 1 0 0 0)(è´¹ç”¨S2 II)(is(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨S2 bs)(is(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨S2 bs)ã€‚(0 0 0)(å……ç”µs2 os)(æµ‹è¯•&34ï¼›is&ampï¼›bsåº”è®¾ç½®ï¼Œå› ä¸ºså·²æ‰“å¼€ã€‚ä½†æ“ä½œç³»ç»Ÿåº”ä¸º0ï¼Œb/c eä¸ºOFF&#34ï¼›(is(=&#39ï¼›(11 1 0 0 0)(è´¹ç”¨S3 II)(is(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨S3 bs)(is(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨S3 bs))ã€‚(1110 000000)(è´¹ç”¨S3os)(æµ‹è¯•&#34ï¼›isåº”è¯¥æ˜¯æ–°çš„vï¼Œä½†æ˜¯bså’Œosåº”è¯¥æ˜¯æ—§å€¼&#34ï¼›(is(=&#39ï¼›(0000000001)(è´¹ç”¨S4ii)(is(=&#39ï¼›(0000000001)(è´¹ç”¨S4ii)(ã€‚(1 1 1 0 0 0)(è´¹ç”¨S4 bs))(IS(=&#39ï¼›(1 1 0 0 0)(è´¹ç”¨S4 os)(æµ‹è¯•&#34ï¼›OSåº”å†æ¬¡è¾“å‡º&#34ï¼›(IS(=&#39ï¼›(0 0 0 1)(è´¹ç”¨S5 II)(IS(=&#39ï¼›(0 0 0 1)(è´¹ç”¨S5 II)(ã€‚(1 1 1 0 0 0)(è´¹ç”¨S5 bs))(is(=&#39ï¼›(0 0 0)(è´¹ç”¨S5 os)ã€‚</p><p>    Okay, letâ€™s continue our experiment, to an astounding result: what if we connected the inputs  and outputs of a bunch of registers to the  same wires?</p><p>å¥½ï¼Œè®©æˆ‘ä»¬ç»§ç»­æˆ‘ä»¬çš„å®éªŒï¼Œå¾—å‡ºä¸€ä¸ªä»¤äººéœ‡æƒŠçš„ç»“æœï¼šå¦‚æœæˆ‘ä»¬å°†ä¸€ç»„å¯„å­˜å™¨çš„è¾“å…¥å’Œè¾“å‡ºè¿æ¥åˆ°ç›¸åŒçš„å¯¼çº¿ä¸Šä¼šæ€ä¹ˆæ ·ï¼Ÿ</p><p>  Now, remember that  s allows us to decide what gets â€œstoredâ€ into a register, and â€œeâ€ lets us â€œpassâ€ the charge of a registerâ€™s byte  through to the output.</p><p>ç°åœ¨ï¼Œè¯·è®°ä½ï¼Œså…è®¸æˆ‘ä»¬å†³å®šå°†ä»€ä¹ˆâ€œå­˜å‚¨â€åˆ°å¯„å­˜å™¨ä¸­ï¼Œè€Œâ€œeâ€å…è®¸æˆ‘ä»¬å°†å¯„å­˜å™¨å­—èŠ‚çš„è´¹ç”¨â€œä¼ é€’â€åˆ°è¾“å‡ºã€‚</p><p> What would happen in the following scenario. Say R1â€™s byte contains â€œ111â€, all  s and  e wires are 0.</p><p>åœ¨ä¸‹é¢çš„åœºæ™¯ä¸­ä¼šå‘ç”Ÿä»€ä¹ˆã€‚å‡è®¾R1çš„å­—èŠ‚åŒ…å«â€œ111â€ï¼Œæ‰€æœ‰çš„så’Œeçº¿éƒ½æ˜¯0ã€‚</p><p> â€œCharge  R1â€™s  e to 1â€.  Now  R1 would enable, and the  bus wires would carry the same charge as  R1</p><p>â€œæŠŠR1çš„eå……ç”µåˆ°1â€ã€‚ç°åœ¨R1å°†å¯ç”¨ï¼Œæ¯çº¿å°†æºå¸¦ä¸R1ç›¸åŒçš„ç”µè·</p><p> â€œCharge  R3â€™s  s to 1, then 0â€.  This would set the value of  R3, to the current charge flowing in  bus.  This happens to be the output of  R1!</p><p>å°†R3å……ç”µä¸º1ï¼Œç„¶åå……ç”µä¸º0ã€‚è¿™ä¼šå°†R3çš„å€¼è®¾ç½®ä¸ºæµç»æ¯çº¿çš„å½“å‰ç”µè·ã€‚è¿™æ°å¥½æ˜¯R1çš„è¾“å‡ºï¼</p><p> â€œSet  R1&#39;s  e to 0â€ Now the current in  bus would disappear again</p><p>â€œSet R1&#s e to 0â€(å°†R1çš„eè®¾ç½®ä¸º0)ï¼Œæ­¤æ—¶è¾“å…¥æ¯çº¿çš„ç”µæµå°†å†æ¬¡æ¶ˆå¤±ã€‚</p><p> The result?  The byte in R1 would have been â€œcopiedâ€ to R3. Weâ€™ve just created a  bus.</p><p>ç»“æœæ˜¯ä»€ä¹ˆå‘¢ï¼ŸR1ä¸­çš„å­—èŠ‚å°†è¢«â€œå¤åˆ¶â€åˆ°R3ã€‚æˆ‘ä»¬åˆšåˆšåˆ›é€ äº†ä¸€è¾†å·´å£«ã€‚</p><p> To create a bus, all we need to do is to connect a registerâ€™s input and output to the same â€œbusâ€ wires:</p><p>è¦åˆ›å»ºæ€»çº¿ï¼Œæˆ‘ä»¬åªéœ€å°†å¯„å­˜å™¨çš„è¾“å…¥å’Œè¾“å‡ºè¿æ¥åˆ°ç›¸åŒçš„â€œæ€»çº¿â€å¯¼çº¿ï¼š</p><p>  This is only a single line, but itâ€™s pretty important to get right. Itâ€™s what lets us â€œcopyâ€ registers after all. Letâ€™s see if it works:</p><p>è¿™åªæ˜¯ä¸€è¡Œä»£ç ï¼Œä½†æ˜¯æ­£ç¡®ä½¿ç”¨æ˜¯éå¸¸é‡è¦çš„ã€‚æ¯•ç«Ÿï¼Œè¿™å°±æ˜¯è®©æˆ‘ä»¬â€œå¤åˆ¶â€å¯„å­˜å™¨çš„ä¸œè¥¿ã€‚è®©æˆ‘ä»¬çœ‹çœ‹å®ƒæ˜¯å¦æœ‰æ•ˆï¼š</p><p> ( deftest  test-wire-bus  ( let  [bw ( wires   :bw   8 )  r1-bits ( wires   :r1   8 )  r2-bits ( wires   :r2   8 )  r3-bits ( wires   :r2   8 )  s1 ( -&gt;  empty-state  ( wire-bus  bw  :s1   :e1  r1-bits)  ( wire-bus  bw  :s2   :e2  r2-bits)  ( wire-bus  bw  :s3   :e3  r3-bits)  ( trigger-many  bw [ 1   1   1   0   0   0   0   0 ])  ( trigger   :s1   0 )  ( trigger   :e1   0 ))  s2 ( -&gt;  s1  ( trigger   :s1   1 )  ( trigger   :s1   0 )  ( trigger-many  bw [ 0   0   0   0   0   0   0   0 ]))  s3 ( -&gt;  s2  ( trigger   :e1   1 )  ( trigger   :s3   1 )  ( trigger   :s3   0 )  ( trigger   :e1   0 ))]  ( testing   &#34;only bus should have charge&#34;  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s1 bw)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 r1-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 r2-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s1 r3-bits))))  ( testing   &#34;r1 should have the charge&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 bw)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s2 r1-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 r2-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 r3-bits))))  ( testing   &#34;move r1 to r3&#34;  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s3 bw)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 r1-bits)))  ( is  ( =  &#39;( 0   0   0   0   0   0   0   0 )  ( charges  s2 r2-bits)))  ( is  ( =  &#39;( 1   1   1   0   0   0   0   0 )  ( charges  s3 r3-bits))))))</p><p>(Deftest-wire-bus(è®©[BW(WIRESï¼šBW 8)R1-BITS(WIRESï¼šR1 8)R2-BITS(WIRESï¼šR2 8)R3-BITS(WIRESï¼šR2 8)S1(-&gtï¼›ç©ºçŠ¶æ€(æœ‰çº¿æ€»çº¿BWï¼šS1ï¼šE1 R1ä½)(æœ‰çº¿æ€»çº¿BWï¼šS2ï¼šE2 R2ä½)(æœ‰çº¿æ€»çº¿BWï¼šS3ï¼šE3 R3ä½)(è§¦å‘å™¨å¤šä¸ªBW[1 1 0 0 0])(è§¦å‘å™¨ï¼šS1 0)(è§¦å‘å™¨ï¼šE1 0)S2(-&gtï¼›S1(è§¦å‘ï¼šs1 1)(è§¦å‘ï¼šs1 0)(è§¦å‘å¤šä¸ªå¸¦å®½[0 0 0]))s3(-&gtï¼›s2(è§¦å‘ï¼še1 1)(è§¦å‘ï¼šs3 1)(è§¦å‘ï¼šs30)(è§¦å‘ï¼še1 0)](æµ‹è¯•&#34ï¼›ä»…æ€»çº¿åº”è¯¥æœ‰ç”µè·&#34ï¼›(IS(=&#39ï¼›(1 1 1 0 0 0)(ç”µè·S1BW))(IS(=&#39ï¼›(0 0 0)(ç”µè·S1 R1æ¯”ç‰¹)(IS(=&#39ï¼›(0 0 0)(ç”µè·S1 R2æ¯”ç‰¹)(IS(=&#39ï¼›(0 0 0)(ç”µè·S1 R2æ¯”ç‰¹))ã€‚(0 0 0)(ç”µè·S1R3æ¯”ç‰¹)(æµ‹è¯•&#34ï¼›R1åº”å…·æœ‰ç”µè·&#34ï¼›(IS(=&#39ï¼›(0 0 0)(ç”µè·S2 BW)(IS(=&#39ï¼›(1 1 1 0 0 0)(ç”µè·S2 R1æ¯”ç‰¹)(IS(=&#39ï¼›(0 0 0)(ç”µè·S2 R1æ¯”ç‰¹)ã€‚(0 0 0(å……ç”µS2 R2ä½)(IS(=&#39ï¼›(0 0 0(å……ç”µS2 R3ä½)(æµ‹è¯•&#34ï¼›å°†R1ç§»åŠ¨åˆ°R3&34ï¼›(IS(=&#39ï¼›(0 0 0)(å……ç”µS3BW)(IS(=&#39ï¼›(1 1 1 0 0 0)(ç”µè·S3 R1ä½))(IS(=&#39ï¼›(0 0 0)(ç”µè·S2 R2ä½)(IS(=&#39ï¼›(1 1 1 0 0 0)(ç”µè·S3 R3ä½)ã€‚</p><p>      Remember that the  bus wires can â€œreceiveâ€ a charge now from the outputs of  R1 ,  R2, or  R3. Hereâ€™s how our  set-charge looked:</p><p>è¯·è®°ä½ï¼Œæ¯çº¿ç°åœ¨å¯ä»¥ä»R1ã€R2æˆ–R3çš„è¾“å‡ºç«¯â€œæ¥æ”¶â€ç”µè·ã€‚æˆ‘ä»¬çš„å¥—è£…ç‚¸è¯çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š</p><p>  Imagine if  R1 was enabled and a wire was charged to  1. What would happen if  R3 got triggered?</p><p>æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœR1è¢«å¯ç”¨ï¼Œä¸€æ ¹ç”µçº¿å……ç”µä¸º1ã€‚å¦‚æœR3è¢«è§¦å‘ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ</p><p>  Time to to evolve our model. One way to think</p><p>æ˜¯æ—¶å€™å‘å±•æˆ‘ä»¬çš„æ¨¡å¼äº†ã€‚ä¸€ç§æ€è€ƒæ–¹å¼ã€‚</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stopa.io/post/258">https://stopa.io/post/258</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/æ¨¡æ‹Ÿ/">#æ¨¡æ‹Ÿ</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ram/">#ram</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ç”µè·/">#ç”µè·</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033976.html"><img src="http://img2.diglog.com/img/2020/11/thumb_95396440dfb0857f21b03a6688277eef.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033976.html">æ¨¡æ‹Ÿæµä½“çš„æœ‰è¶£ç½‘ç«™</a></div><span class="my_story_list_date">2020-11-9 12:58</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031665.html"><img src="http://img2.diglog.com/img/2020/10/thumb_54170c7b87208396b2410f838de3120e.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031665.html">æˆ‘ä»¬ç”Ÿæ´»åœ¨æ¨¡æ‹Ÿä¸­å—ï¼Ÿå‡ ç‡å¤§çº¦æ˜¯50%</a></div><span class="my_story_list_date">2020-10-28 8:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029958.html"><img src="http://img2.diglog.com/img/2020/10/thumb_29462690e0c5aab8f1750c80206ff0d1.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029958.html">æ¨¡æ‹Ÿé—®é¢˜çš„å¢åŠ </a></div><span class="my_story_list_date">2020-10-20 12:35</span></div><div class="col-sm"><div><a target="_blank" href="/story/1028664.html"><img src="http://img2.diglog.com/img/2020/10/thumb_54170c7b87208396b2410f838de3120e.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1028664.html">æˆ‘ä»¬ç”Ÿæ´»åœ¨æ¨¡æ‹Ÿä¸­å—ï¼Ÿå‡ ç‡å¤§çº¦æ˜¯50%</a></div><span class="my_story_list_date">2020-10-14 8:24</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¾å›½/">#ç¾å›½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¨‹åº/">#ç¨‹åº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>