<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>宣布推出HyperDrive V10-一种点对点文件系统</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">宣布推出HyperDrive V10-一种点对点文件系统</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-15 00:37:05</div><div class="page_narrow text-break page_content"><p>在过去的一年里，我们一直在努力开发HyperDrive的V10版本。经过长时间的测试版测试，我们很兴奋地宣布，它已经可以普遍使用了！</p><p>HyperDrive是一种点对点文件系统，旨在帮助您直接从计算机快速、安全地共享文件。多年来，HyperDrive v9和其他许多以HYPER为前缀的模块一直是Dat的主干--如果您深入研究了Dat的内部结构，您可能已经熟悉了HyperDrive。</p><p>在这次发布之前，我们做了一些重组：HyperDrive和它的许多超级兄弟现在生活在一个名为Hypercore Protocol的小型、专注于技术的品牌/组织之下。实际上，这一改变除了品牌之外意义不大，但我们希望它能让模块有机会独树一帜。有鉴于此，下面让我们来看看超空间引擎的内部情况。</p><p>在这篇文章中，我们将逐步介绍我们在V10中所做的一些改进，解释HyperDrive如何适应更广泛的Hypercore协议生态系统，并向您展示如何开始使用它。此版本只是个开始，我们将在展望部分介绍我们的下一步工作。</p><p>改进的索引：我们正在使用一种新的基于HAMT的索引结构，称为Hypertrie，它提供了巨大的性能/可伸缩性提升。</p><p>超级驱动器守护程序：我们已经创建了一个跨平台的守护程序，提供对守护程序管理的驱动器的FUSE和GRPC访问。</p><p>更好的基础：我们最近引入了超暖分布式哈希表，以及对超核协议的改进，这有助于使我们的整个堆栈更快、更可靠。</p><p>HyperDrive是用Node.js编写的、与POSIX兼容的文件系统实现，旨在成为快速、可扩展和安全的对等应用程序的存储层。对于大多数开发人员来说，使用Hyperdrive的感觉应该就像使用Node的标准fs模块一样，只需稍加改动。我们的主要目标一直是使使用单个32字节密钥(即hyper：//ab13d.)与他人共享整个文件系统成为可能。从现在开始，我们将Hyperdrive文件系统称为驱动器。</p><p>驱动器非常适合单个编写器想要向多个读取器分发大型可变文件集合的应用程序。文件集合可以是视频库、个人博客、科学数据集或您拥有的任何东西。与BitTorrent类似，对等点可以从其他对等点下载文件，而不会牺牲信任(驱动器内容由原始作者签名)。</p><p>与BitTorrent不同，可以在创建驱动器后添加或修改文件，同行可以监视驱动器进行更新，这意味着更新通知会实时发送给读者！</p><p>重要的是，驱动器支持高效的随机访问文件读取，这意味着您可以在视频中进行搜索，并且它只会按需下载您正在重新查看的视频部分。我们称这种属性为稀疏下载，对于大型网站(假设所有维基百科都镜像到一个驱动器)等读者一次只能浏览一个页面的情况来说，它非常有用。</p><p>在幕后，HyperDrive是使用两个称为Hypercores的仅附加日志数据结构构建的，一个用于高效的元数据索引，另一个用于二进制文件内容。您可以从Hypercore协议网站了解有关Hypercore的更多信息。Hypercore为交换有序数据块提供了快速而安全的基础，但是一个好的文件系统依赖于一个好的索引。</p><p>为了支持执行的文件系统操作，如目录遍历，我们在Hypercore之上分层了一个称为Hypertrie的索引数据结构，它是散列数组映射trie的仅附加实现。描述Hypertrie的全貌本身就是一篇博客文章，但最重要的是，它允许我们使用O(log_4(N))网络请求(最坏情况下)来定位文件/目录元数据，这些元数据可能分散在许多对等点上。在实践中，我们使用专门的Hypercore扩展来显著提高速度(大多数情况下为O(1))。</p><p>Hypercore协议生态系统最近有了重大改进，HyperDrive直接受益于所有这些改进。最重要的是，HyperDrive V10利用Hypertrie实现更好的索引，利用Hypersarm实现更好的联网。</p><p>超级暖和是一个卡德姆利亚支持的分布式哈希表实现，是专门为家庭设计的。它使用分布式方法来保持转发--分布式哈希表中的对等点可以帮助引导连接到其他对等点--允许我们遍历绝大多数家庭路由器。</p><p>超群还提供了大量的启发式算法，旨在绕过离线节点并保持路由表的健康。当与HolepPunking相结合时，启发式方法使发现和连接到同级的速度大大加快。</p><p>HyperDrive v9使用的索引数据结构适用于小型驱动器，但随着驱动器或目录变大，该结构很快就崩溃了。在V10中，我们使用的是Hypertrie。它具有很好的伸缩性--作为演示，我们将一个完整的维基百科镜像(数千万个文件，分散在几个目录中)放入一个驱动器中，读取速度保持非常快。</p><p>我们将在后续的帖子中对Hypertrie进行扩展，但目前主要的结论是，您的目录可以像您(现实地)喜欢的那样大，并且文件查找将保持快速！</p><p>在此版本中，我们将重点放在提高可用性、简化驱动器管理和减少共享摩擦的功能上。我们想要介绍的两个最大的东西是挂载，它允许您创建嵌套的超级驱动器，以及超级驱动器守护程序，用作管理驱动器集合的一站式商店。</p><p>Hypercore为HyperDrive提供了许多很好的功能，比如稀疏下载，而且免费--大部分工作都是在这一层处理的。然而，Hypercore从根本上说是一种单编写器数据结构。核心的写入器维护一个私钥，该私钥用于签署所有附加的数据，使读者可以在他们之间交换数据，而不必担心被篡改。只允许一个人(在一台机器上！)。不过，对驱动器进行更改是一个很大的限制。不出所料，对多个编写器的支持长期以来一直是我们最需要的功能之一。</p><p>在V10中，我们不会一直走到通用的多编写器解决方案；可伸缩地解决多编写器，而不会招致重大的性能损失或混淆UX，仍然是我们的研究问题。这就是说，V10引入了挂载，这些挂载几乎链接到外观和行为都与普通目录相似的其他超驱动器。</p><p>挂载为更细粒度的共享和有趣的多用户应用程序提供了很多机会。在共享方面，您可以创建一个projects/目录，其中包含诸如projects/my-module、projects/my-WebSite之类的挂载--您正在处理的每件事情都有一个驱动器。有了mount，您可以自己共享my-WebSite，而不会放弃对project/中的所有内容的访问。此模式在守护进程中特别方便，我们将在下面讨论该守护进程。</p><p>当你要安装的驱动器不是你自己的时候，事情会变得更有趣。我们在组模式方面取得了很大成功，在这种模式下，组所有者首先创建顶级组驱动器，然后在组中装载用户配置文件：</p><p>/my-group//由组所有者(例如用户A)拥有/user-a//由用户A拥有/user-b//由用户B拥有.</p><p>使用这种模式，您可以编写简单的群件，在组驱动器上使用递归的readdir来聚合用户间的内容。(#34；Groupware&#34；)。例如，要查找组中的所有博客帖子，您可以在每个用户的博客/目录中搜索所有Markdown文件。</p><p>如果您直接使用HyperDrive，则可以使用drive.mount(path，key，[opts])方法。它的工作方式与您从args中期望的一样(挂载密钥位于path)，并且选项可以包括静态驱动器版本。</p><p>通过CLI在守护进程中创建装载也很容易，下面我们将介绍这一点。</p><p>HyperDrive在构建时考虑到了模块化存储和联网--您可以随心所欲地存储驱动器内容，并且可以通过任何Node.js流复制它们。这种灵活性有好处，但它使开始工作变得更加困难。为此，我们创建了一个跨平台的后台服务(守护程序)，它为您处理存储/网络，同时为您提供访问守护程序管理的驱动器的多种方式。</p><p>守护程序是一项长期运行的服务，因此它可以使您的驱动器保持在线并可供读者使用。它对分布式哈希表的健康也很有好处：因为您的计算机上的节点是稳定的，所以分布式哈希表的路由表中包含的离线节点较少。这转化为更快的密钥查找，这意味着更快的加载时间。</p><p>最重要的是，该守护进程充当向外部服务公开驱动器的中心点--目前我们支持GRPC API，以及相应的Node.js客户端库和FUSE接口。</p><p>FUSE允许我们从Node.js代码中模拟本地文件系统目录。它可以让我们将超级驱动器变成您计算机上的普通目录！这意味着每当守护进程运行时，您都可以直接从OSX Finder中访问驱动器，比如说，作为~/Hyperdrive中的虚拟目录。</p><p>有了FUSE，其他程序可以立即访问驱动器。您可以使用VLC观看电影，使用您最喜欢的阅读器程序加载PDF，并使用诸如find和ls之类的Unix实用程序来浏览驱动器。我们将在下面的入门部分进行更深入的介绍。</p><p>HyperDrive CLI工具包含一些命令，用于与FUSE交互以及显示有关驱动器的信息。它还为那些不想摆弄~/Hyperdrive的用户提供导入和导出命令。</p><p>虽然添加~/Hyperdrive目录是为了简化最终用户UX，但GRPC API是为开发人员提供的--您现在可以用任何语言使用Hyperdrive编程，而不需要处理棘手的联网API。如果您正在使用Node.js，客户端库将为您提供一个感觉与普通驱动器完全相同的RemoteHyperdrive界面。要开始，请跳到这里。</p><p>我们希望守护程序能为希望共享数据的终端用户和想要使用HyperDrive构建应用程序和服务的开发人员提供一个无摩擦的入口点。如果您对用户体验有什么想法或反馈，请不要犹豫加入我们的聊天！</p><p>跳入Hyperdrive堆栈的最佳方式是安装守护程序。这可以通过NPM实现：</p><p>一旦安装了后台进程，您就可以访问HyperDrive CLI命令。从这里开始，您有几个选择。有关更详细的指南，最好参考守护程序的自述文件，但我们将在此重点介绍关键步骤。</p><p>注意：FUSE目前仅在Linux和OSX上可用。CLI的导入和导出命令可用于在Windows上将数据移入/移出驱动器。</p><p>安装之后，您需要立即执行一次性设置步骤，这将请求sudo访问--不用担心，守护进程本身并不是以root用户身份运行的。这是配置捆绑的熔丝内核模块所必需的：</p><p>之后，正常启动守护进程，您会注意到~/Hyperdrive目录存在，并且包含一个名为Network的子目录。如果你看到“网络”，你就可以开始了。</p><p>正如守护程序自述文件中的演练中所述，~/Hyperdrive是您的&#34；根驱动器，您可以将其视为Home目录的替代品。您可以根据需要在其中创建子目录，如文档、视频或项目。</p><p>~/Hyperdrive/Network是一个神奇的目录，因为它实际上并不存在于您的根驱动器中。它的存在是为了让您可以轻松地执行以下操作：</p><p>有关网络的详细信息，以及您可以用来填充和浏览根驱动器的所有CLI命令的说明，可以在自述文件中找到。</p><p>如果您正在运行守护程序实例，则可以使用hydrive-daemon-client模块创建RemoteHyperdrive对象。在幕后，它们将通过GRPC向守护程序管理的驱动器发送命令。</p><p>RemoteHyperdrive API镜像Hyperdrive。以下代码片断将创建一个客户端实例，使用该客户端创建一个新驱动器，然后将文件写入该驱动器：</p><p>const{HyperdriveClient}=Required(&#39；Hyperdrive-daemon-client&#39；)//自动连接到守护进程const client=new()等待客户端。Ready()//创建新驱动器并写入文件const drive=await client.drive。get()等待驾驶。writeFile(&#39；foo.txt&#39；，&#39；bar&#39；)。</p><p>守护进程的自述文件提供了更多示例。到今天为止，我们只有一个Node.js客户端，但是守护进程的GRPC架构是可用的，我们欢迎任何用其他语言创建客户端的努力。</p><p>烧杯浏览器在内部大量使用HyperDrive。今天也将发布的Baker 1.0 Beta实际上会在后台为您安装和管理守护程序！Beaker自带创作工具，用于创建P2P网站并与他人分享。</p><p>Beaker开发者门户包含详尽的文档和教程(提示：在Beaker中打开该网站，使教程具有交互性！)，因此您将立即上手，构建包含功能齐全的Web应用程序的超硬盘(想想个人维基、相册、博客聚合器等等)。</p><p>您可能希望在大多数时间使用守护进程/客户端，但如果您不想使用-可能是在一次性脚本或某种嵌入式场景中-您可以将HyperDrive用作程序中的一个模块。自述文件向您展示了如何操作，您也可以在自述文件中找到完整的API文档。</p><p>这里是一个要点，其中包含一个端到端的小示例，展示了如何使用超级暖盘来发现和同步来自另一个对等点的超级硬盘。</p><p>在未来，我们计划制作一些关于编程使用Hyperdrive的详细教程。请记住，如果您正在寻找最简单的解决方案，请查看守护进程和/或烧杯！</p><p>如你所见，最近发生了很多事情！但仍有更多工作要做。随着这些功能的发布，下面是我们下一步计划的草图。</p><p>目前实施的Hypertrie&#39；s导致了重大收益。这就是说，它缺少一些您可能期望从文件系统获得的功能，最重要的是原子重命名。此外，由于Trie迭代的工作方式，符号链接和挂载的效率都略低于所需的效率。</p><p>我们已经坐在一个新的、严重模糊的Trie实现上有一段时间了，但我们还没有集成它的周期。它通过统一的迭代器抽象(我们称之为Trie控制器)支持符号链接(直接，而不是在超级驱动层中)、挂载和原子重命名。它在各方面都要好一些。</p><p>别担心，新的Trie将完全落后于我们现在发布的Trie。</p><p>该守护进程提供了许多新的机会，因为它既将所有驱动器存储在磁盘上的一个位置，又在一个位置处理网络。通过全面控制存储/网络，我们可以在您的整个驱动器集合中执行优化。</p><p>在网络方面，我们重新研究了对已由其他驱动器满足的数据块请求进行重复数据消除的方法。这里的最终目标是：即使相同的数据包含在不同的驱动器中，您也不应该下载相同的数据两次。</p><p>在存储方面，我们正在考虑支持内容寻址的数据块存储，这意味着如果您有两个类似的驱动器，则只有一组唯一的数据块将持久保存在磁盘上--公共数据块将只存储一次。</p><p>虽然写入器可以随心所欲地更新其驱动器(即添加新文件、删除文件、附加到文件等)，但某些操作比其他操作效率更高。不幸的是，编辑现有文件是效率低下的工作之一--它目前会导致文件复制。如果您希望在FUSE上运行数据库或将其追加到日志文件，这是个坏消息。</p><p>更好的垃圾收集，可以轻松地从磁盘中清除旧版本的文件(对于简单情况很好，但对数据库仍然不好)。</p><p>高效的文件更新，写入现有文件不会导致数据复制。</p><p>我们正在为(2)探索基于inode的各种方法。就像一般的兼职作家一样，涉及到一个棘手的平衡行为。支持这些更新的索引将不可避免地增加没有随机访问修改的文件的读取延迟。如果你看的是一部大电影，从头到尾都没有修改过，这是不会有什么影响的。</p><p>如上所述，文件更新的仅附加性质意味着我们并不完全保守地使用您的磁盘空间。HyperDrive目前不支持清除旧文件版本，但我们已经使用&#34；标签朝这个方向迈出了一步。&#34；</p><p>使用标签，您可以为您希望保留的驱动器版本指定名称。我们将很快添加对clearUntagged方法的支持，该方法将从磁盘中删除未标记的文件版本。</p><p>有了clearUntag，随机访问写入就变得不那么重要了，所以我们希望它能在短期内充当一个很好的权宜之计。</p><p>坐骑目前不能相互重叠。组模型绕过了这一限制，启用了有用的多用户应用程序，但在许多情况下，您希望在多个驱动器上显示合并视图。</p><p>为了做到这一点，我们正在考虑扩展坐骑的方法。我们上面提到的Trie控制器设计使得这里的实验变得更容易。一个简单的联合挂载功能，没有任何固执己见的冲突解决方案(即并排显示冲突文件)，是很自然的下一步。</p><p>具有可定制的冲突解决挂钩的通用多编写器解决方案仍在我们的待办事项列表上，但这仍是一个遥远的未来功能。我们想先看看坐骑能走多远。</p><p>在过去的一年里，为这个版本做准备是一个大团队的努力，我们非常感谢Dat社区中的许多贡献者，他们帮助测试了堆栈的alpha版本，修复了bug，并审查了文档。</p><p>特别要感谢三星，它慷慨的三星NEXT赠款为这项工作提供了大量资金。非常感谢里卡多和三星NEXT团队的其他成员！</p><p>要了解更多关于HyperDrive如何在幕后工作的信息，您最好的选择是查看GitHub上的源代码。我们的代码目前分散在多个repos中，大部分在Hypercore Protocol组织内。以下是我们在这篇文章中讨论的内容的几个直接链接：</p><p>如果您对HyperDrive的设计有疑问，或者想要谈论堆栈，请给我们发不和谐的信息--这就是我们将进行面向开发的对话的地方。</p><p>如果您遇到任何错误，请继续在我们的社区回购上打开问题。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.hypercore-protocol.org/posts/announcing-hyperdrive-10/">https://blog.hypercore-protocol.org/posts/announcing-hyperdrive-10/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/推出/">#推出</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/peer/">#peer</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/驱动器/">#驱动器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>