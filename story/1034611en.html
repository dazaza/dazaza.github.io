<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>å¤§è§„æ¨¡é‡‡ç”¨æ‰“å­—ç¨¿çš„æ„Ÿæ‚Ÿ</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">å¤§è§„æ¨¡é‡‡ç”¨æ‰“å­—ç¨¿çš„æ„Ÿæ‚Ÿ</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-12 02:32:15</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/ed4d9f6bb8a5a76b5af188414a92585d.jpg"><img src="http://img2.diglog.com/img/2020/11/ed4d9f6bb8a5a76b5af188414a92585d.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A few years ago, Bloomberg Engineering decided to adopt  TypeScript as a first-class supported language. This article shares some of the insights and lessons we learned during this journey.</p><p>å‡ å¹´å‰ï¼Œå½­åšå·¥ç¨‹(Bloomberg Engineering)å†³å®šé‡‡ç”¨æ‰“å­—ç¨¿ä½œä¸ºä¸€ç§ä¸€æµçš„æ”¯æŒè¯­è¨€ã€‚è¿™ç¯‡æ–‡ç« åˆ†äº«äº†æˆ‘ä»¬åœ¨è¿™æ®µæ—…ç¨‹ä¸­å­¦åˆ°çš„ä¸€äº›è§è§£å’Œæ•™è®­ã€‚</p><p> The headline is that we found TypeScript to be a strong net positive! Please keep that in mind when reading about some of the surprising corners we explored. As engineers, we are naturally attracted to seeing, solving and sharing problems, even when weâ€™re having a good time ğŸ˜‰</p><p>æ ‡é¢˜æ˜¯ï¼Œæˆ‘ä»¬å‘ç°æ‰“å­—ç¨¿æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„å‡€å€¼ï¼åœ¨é˜…è¯»æˆ‘ä»¬æ¢ç´¢çš„ä¸€äº›ä»¤äººæƒŠè®¶çš„è§’è½æ—¶ï¼Œè¯·è®°ä½è¿™ä¸€ç‚¹ã€‚ä½œä¸ºå·¥ç¨‹å¸ˆï¼Œæˆ‘ä»¬è‡ªç„¶ä¼šè¢«å‘ç°ã€è§£å†³å’Œåˆ†äº«é—®é¢˜æ‰€å¸å¼•ï¼Œå³ä½¿æˆ‘ä»¬åœ¨ğŸ˜‰ä¸Šç©å¾—å¾ˆå¼€å¿ƒã€‚</p><p>    Bloomberg already had a colossal investment in JavaScript before TypeScript even existed â€“ more than 50 million lines of JS code. Our main product is the Bloomberg Terminal, which contains more than 10,000 apps. The variety of apps is huge, ranging from the display of intensive real-time financial data and news to interactive trading solutions and many forms of messaging. Back in 2005, the company started migrating those apps from Fortran and C/C++ to server-side JavaScript, with client-side JavaScript arriving around 2012. Today, we have more than 2,000 software engineers at the company writing JavaScript.</p><p>å½­åšåœ¨æ‰“å­—è„šæœ¬å‡ºç°ä¹‹å‰å°±å·²ç»å¯¹JavaScriptè¿›è¡Œäº†å·¨é¢æŠ•èµ„--è¶…è¿‡5000ä¸‡è¡ŒJSä»£ç ã€‚æˆ‘ä»¬çš„ä¸»è¦äº§å“æ˜¯å½­åšç»ˆç«¯ï¼Œå®ƒåŒ…å«1ä¸‡å¤šä¸ªåº”ç”¨ç¨‹åºã€‚åº”ç”¨ç¨‹åºç§ç±»ç¹å¤šï¼Œä»å¯†é›†å®æ—¶é‡‘èæ•°æ®å’Œæ–°é—»çš„æ˜¾ç¤ºï¼Œåˆ°äº¤äº’å¼äº¤æ˜“è§£å†³æ–¹æ¡ˆå’Œå¤šç§å½¢å¼çš„æ¶ˆæ¯ä¼ é€’ï¼Œåº”æœ‰å°½æœ‰ã€‚æ—©åœ¨2005å¹´ï¼Œè¯¥å…¬å¸å°±å¼€å§‹å°†è¿™äº›åº”ç”¨ç¨‹åºä»Fortranå’ŒC/C++è¿ç§»åˆ°æœåŠ¡å™¨ç«¯JavaScriptï¼Œå®¢æˆ·ç«¯JavaScriptå¤§çº¦åœ¨2012å¹´é—®ä¸–ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬å…¬å¸æœ‰2000å¤šåè½¯ä»¶å·¥ç¨‹å¸ˆåœ¨ç¼–å†™JavaScriptã€‚</p><p>    Transitioning this scale of codebase from plain JavaScript to TypeScript is a big deal. So we worked hard to ensure there was a thoughtful process that would keep us aligned with standards and preserve our existing capabilities to evolve and deploy our code quickly and safely.</p><p>å°†è¿™ç§è§„æ¨¡çš„ä»£ç åº“ä»æ™®é€šçš„JavaScriptè½¬æ¢åˆ°æ‰“å­—è„šæœ¬æ˜¯ä¸€ä»¶å¤§äº‹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åŠªåŠ›ç¡®ä¿æœ‰ä¸€ä¸ªæ·±æ€ç†Ÿè™‘çš„è¿‡ç¨‹ï¼Œä½¿æˆ‘ä»¬ä¸æ ‡å‡†ä¿æŒä¸€è‡´ï¼Œå¹¶ä¿æŒæˆ‘ä»¬ç°æœ‰çš„èƒ½åŠ›ï¼Œä»¥ä¾¿å¿«é€Ÿå®‰å…¨åœ°å‘å±•å’Œéƒ¨ç½²æˆ‘ä»¬çš„ä»£ç ã€‚</p><p> If youâ€™ve ever been part of a technology migration in a large company, you may be used to heavy-handed project management being used to force progress from reluctant teams who would rather be working on new features. We found that adopting TypeScript was something altogether different. Engineers were self-starting conversions and championing the process! When we launched the beta version of our TypeScript platform support, more than 200 projects opted into TypeScript in the first year alone. Zero projects went back.</p><p>å¦‚æœä½ æ›¾ç»å‚ä¸è¿‡ä¸€å®¶å¤§å…¬å¸çš„æŠ€æœ¯è¿ç§»ï¼Œä½ å¯èƒ½å·²ç»ä¹ æƒ¯äº†é«˜å‹çš„é¡¹ç›®ç®¡ç†è¢«ç”¨æ¥è¿«ä½¿ä¸æƒ…æ„¿çš„å›¢é˜Ÿå–å¾—è¿›å±•ï¼Œè¿™äº›å›¢é˜Ÿå®æ„¿ä»äº‹æ–°åŠŸèƒ½çš„å·¥ä½œã€‚æˆ‘ä»¬å‘ç°é‡‡ç”¨æ‰“å­—ç¨¿å®Œå…¨æ˜¯å¦ä¸€å›äº‹ã€‚å·¥ç¨‹å¸ˆä»¬æ­£åœ¨è‡ªè¡Œå¯åŠ¨è½¬æ¢ï¼Œå¹¶æ”¯æŒè¿™ä¸€è¿‡ç¨‹ï¼å½“æˆ‘ä»¬æ¨å‡ºæˆ‘ä»¬çš„TypeScriptå¹³å°æ”¯æŒçš„æµ‹è¯•ç‰ˆæ—¶ï¼Œä»…åœ¨ç¬¬ä¸€å¹´å°±æœ‰200å¤šä¸ªé¡¹ç›®é€‰æ‹©äº†Tyescriptã€‚é›¶ä¸ªé¡¹ç›®è¢«é€€å›ã€‚</p><p>  In addition to scale, something that makes this integration of TypeScript unique is that we have our own JavaScript runtime environment. This means that, in addition to well-known JavaScript host environments, such as browsers and Node, we also embed the V8 engine and Chromium directly to create our own JavaScript platform. The upside of this situation is that we can offer a simple developer experience in which TypeScript is supported directly by our platform and package ecosystem. Ryan Dahlâ€™s Deno pursues similar ideas by putting TypeScript compilation into the runtime, whereas we keep it in tooling that is versioned independently of the runtime. An interesting consequence is that we get to explore what itâ€™s like to exercise the TypeScript compiler in a standalone JS environment that spans both client and server and that does not use Node-specific conventions (e.g., there is no  node_modules directory).</p><p>é™¤äº†å¯ä¼¸ç¼©æ€§ä¹‹å¤–ï¼Œè¿™ç§TypeScripé›†æˆçš„ç‹¬ç‰¹ä¹‹å¤„åœ¨äºæˆ‘ä»¬æ‹¥æœ‰è‡ªå·±çš„JavaScriptè¿è¡Œæ—¶ç¯å¢ƒã€‚è¿™æ„å‘³ç€ï¼Œé™¤äº†ä¼—æ‰€å‘¨çŸ¥çš„JavaScriptä¸»æœºç¯å¢ƒ(å¦‚æµè§ˆå™¨å’ŒNode)ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜ç›´æ¥åµŒå…¥äº†V8å¼•æ“å’ŒChromiumæ¥åˆ›å»ºæˆ‘ä»¬è‡ªå·±çš„JavaScriptå¹³å°ã€‚è¿™ç§æƒ…å†µçš„å¥½å¤„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥æä¾›ä¸€ç§ç®€å•çš„å¼€å‘ä½“éªŒï¼Œåœ¨è¿™ç§ä½“éªŒä¸­ï¼Œæˆ‘ä»¬çš„å¹³å°å’ŒåŒ…ç”Ÿæ€ç³»ç»Ÿç›´æ¥æ”¯æŒTypeScriptã€‚Ryan Dahlçš„Denoè¿½æ±‚ç±»ä¼¼çš„ç†å¿µï¼Œå°†æ‰“å­—è„šæœ¬ç¼–è¯‘æ”¾å…¥è¿è¡Œæ—¶ï¼Œè€Œæˆ‘ä»¬å°†å…¶æ”¾åœ¨ç‹¬ç«‹äºè¿è¡Œæ—¶ç‰ˆæœ¬çš„å·¥å…·ä¸­ã€‚ä¸€ä¸ªæœ‰è¶£çš„ç»“æœæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥æ¢ç´¢åœ¨è·¨è¶Šå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¸”ä¸ä½¿ç”¨ç‰¹å®šäºèŠ‚ç‚¹çš„çº¦å®š(ä¾‹å¦‚ï¼Œæ²¡æœ‰NODE_MODULESç›®å½•)çš„ç‹¬ç«‹JSç¯å¢ƒä¸­ä½¿ç”¨ç±»å‹è„šæœ¬ç¼–è¯‘å™¨æ˜¯ä»€ä¹ˆæ„Ÿè§‰ã€‚</p><p> Our platform supports an internal ecosystem of packages that uses a common tooling and publishing system. This allows us to encourage and enforce best practices, such as defaulting to TypeScriptâ€™s â€œstrict mode,â€ as well as ensuring global invariants. For example, we guarantee that all published types are modular rather than global. It also means that engineers can focus on writing code rather than needing to figure out how to make TypeScript play nicely with a bundler or test framework. DevTools and error stacks use sourcemaps correctly. Tests can be written in TypeScript and code coverage is accurately expressed in terms of the original TypeScript code. It just works.</p><p>æˆ‘ä»¬çš„å¹³å°æ”¯æŒä½¿ç”¨é€šç”¨å·¥å…·å’Œå‘å¸ƒç³»ç»Ÿçš„åŒ…çš„å†…éƒ¨ç”Ÿæ€ç³»ç»Ÿã€‚è¿™å…è®¸æˆ‘ä»¬é¼“åŠ±å’Œå®æ–½æœ€ä½³å®è·µï¼Œä¾‹å¦‚é»˜è®¤ä½¿ç”¨TypeScripçš„â€œä¸¥æ ¼æ¨¡å¼â€ï¼Œä»¥åŠç¡®ä¿å…¨å±€ä¸å˜é‡ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¿è¯æ‰€æœ‰å‘å¸ƒçš„ç±»å‹éƒ½æ˜¯æ¨¡å—åŒ–çš„ï¼Œè€Œä¸æ˜¯å…¨å±€çš„ã€‚è¿™ä¹Ÿæ„å‘³ç€å·¥ç¨‹å¸ˆå¯ä»¥ä¸“æ³¨äºç¼–å†™ä»£ç ï¼Œè€Œä¸æ˜¯éœ€è¦æƒ³åŠæ³•è®©æ‰“å­—è„šæœ¬å¾ˆå¥½åœ°ä¸æ†ç»‘å™¨æˆ–æµ‹è¯•æ¡†æ¶é…åˆä½¿ç”¨ã€‚DevToolå’Œé”™è¯¯å †æ ˆæ­£ç¡®ä½¿ç”¨æºåœ°å›¾ã€‚æµ‹è¯•å¯ä»¥ç”¨æ‰“å­—è„šæœ¬ç¼–å†™ï¼Œä»£ç è¦†ç›–ç‡å¯ä»¥ç”¨åŸå§‹æ‰“å­—ä»£ç å‡†ç¡®åœ°è¡¨è¾¾å‡ºæ¥ã€‚åªæ˜¯èµ·ä½œç”¨äº†ã€‚</p><p> We aim for regular TypeScript files to be the single source of truth for our APIs, as opposed to maintaining handwritten declaration files. This means we have a lot of code leaning heavily on the TypeScript compilerâ€™s automatic generation of  .d.ts declaration files from TypeScript source code. So when declaration-emit is not ideal, we notice it, as you will see.</p><p>æˆ‘ä»¬çš„ç›®æ ‡æ˜¯è®©å¸¸è§„æ‰“å­—æ–‡ä»¶æˆä¸ºAPIçš„å”¯ä¸€çœŸå®æ¥æºï¼Œè€Œä¸æ˜¯ç»´æŠ¤æ‰‹å†™å£°æ˜æ–‡ä»¶ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬æœ‰å¾ˆå¤šä»£ç ä¸¥é‡ä¾èµ–äºTypeScriptç¼–è¯‘å™¨ä»TypeScriptæºä»£ç è‡ªåŠ¨ç”Ÿæˆ.d.tså£°æ˜æ–‡ä»¶ã€‚å› æ­¤ï¼Œå½“å£°æ˜å‘å‡ºä¸ç†æƒ³æ—¶ï¼Œæˆ‘ä»¬ä¼šæ³¨æ„åˆ°è¿™ä¸€ç‚¹ï¼Œæ­£å¦‚æ‚¨å°†çœ‹åˆ°çš„ã€‚</p><p>  âš–ï¸  Scalability: Development speed should be kept high as more packages adopt TypeScript. Time spent installing, compiling, and checking code should be minimized.</p><p>âš–ï¸å¯ä¼¸ç¼©æ€§ï¼šéšç€è¶Šæ¥è¶Šå¤šçš„åŒ…é‡‡ç”¨TypeScripï¼Œåº”è¯¥ä¿æŒè¾ƒé«˜çš„å¼€å‘é€Ÿåº¦ã€‚å®‰è£…ã€ç¼–è¯‘å’Œæ£€æŸ¥ä»£ç æ‰€èŠ±è´¹çš„æ—¶é—´åº”è¯¥æœ€å°åŒ–ã€‚</p><p>  ğŸ“œ  Standards Alignment: We want to stick with standards, such as ECMAScript, and be ready for where they might go next.</p><p>ğŸ“œæ ‡å‡†å¯¹é½ï¼šæˆ‘ä»¬å¸Œæœ›åšæŒä½¿ç”¨ECMAScriptç­‰æ ‡å‡†ï¼Œå¹¶ä¸ºå®ƒä»¬çš„ä¸‹ä¸€æ­¥å‘å±•åšå¥½å‡†å¤‡ã€‚</p><p> The discoveries that surprised us usually came down to cases where we werenâ€™t sure if we could preserve these principles.</p><p>ä»¤æˆ‘ä»¬æƒŠè®¶çš„å‘ç°é€šå¸¸å½’ç»“ä¸ºæˆ‘ä»¬ä¸ç¡®å®šæ˜¯å¦èƒ½ä¿ç•™è¿™äº›åŸåˆ™ã€‚</p><p>  Over the years, the TypeScript team has actively pursued the adoption of and alignment with standard ECMAScript syntax and runtime semantics. This leaves TypeScript to concentrate on providing a layer of type syntax and type-checking semantics on top of JavaScript. The responsibilities are clearly separated:  TypeScript = JavaScript + Types!</p><p>å¤šå¹´æ¥ï¼Œæ‰“å­—å›¢é˜Ÿä¸€ç›´åœ¨ç§¯æé‡‡ç”¨æ ‡å‡†ECMAScriptè¯­æ³•å’Œè¿è¡Œæ—¶è¯­ä¹‰ï¼Œå¹¶ä¸ä¹‹ä¿æŒä¸€è‡´ã€‚è¿™ä½¿å¾—TypeScriptä¸“æ³¨äºåœ¨JavaScriptä¹‹ä¸Šæä¾›ç±»å‹è¯­æ³•å’Œç±»å‹æ£€æŸ¥è¯­ä¹‰å±‚ã€‚èŒè´£æ˜¯æ˜ç¡®åˆ†å¼€çš„ï¼šç±»å‹è„šæœ¬=JavaScript+ç±»å‹ï¼</p><p> This is a wonderful model. It means that the compiler output is human-readable JavaScript, just like the programmer wrote. This makes debugging production code easy even if you donâ€™t have the original source code. It means you do not need to worry that choosing TypeScript might cut you off from future  ECMAScript features. It leaves the door open to runtimes, and maybe even future JavaScript engines, that can ignore the type syntax and therefore â€œrunâ€ TypeScript natively. A simpler developer experience is in sight!</p><p>è¿™æ˜¯ä¸€ä¸ªå¾ˆæ£’çš„æ¨¡å‹ã€‚è¿™æ„å‘³ç€ç¼–è¯‘å™¨çš„è¾“å‡ºæ˜¯äººç±»å¯è¯»çš„JavaScriptï¼Œå°±åƒç¨‹åºå‘˜å†™çš„é‚£æ ·ã€‚è¿™ä½¿å¾—è°ƒè¯•äº§å“ä»£ç å˜å¾—å®¹æ˜“ï¼Œå³ä½¿æ‚¨æ²¡æœ‰åŸå§‹æºä»£ç ã€‚è¿™æ„å‘³ç€æ‚¨ä¸å¿…æ‹…å¿ƒé€‰æ‹©TypeScripå¯èƒ½ä¼šåˆ‡æ–­æ‚¨ä¸æœªæ¥ECMAScriptåŠŸèƒ½çš„è”ç³»ã€‚å®ƒä¸ºè¿è¡Œæ—¶(ç”šè‡³æœªæ¥çš„JavaScriptå¼•æ“)æ•å¼€äº†å¤§é—¨ï¼Œè¿™äº›å¼•æ“å¯ä»¥å¿½ç•¥ç±»å‹è¯­æ³•ï¼Œä»è€Œåœ¨æœ¬åœ°â€œè¿è¡Œâ€ç±»å‹è„šæœ¬ã€‚ä¸€ç§æ›´ç®€å•çš„å¼€å‘ä½“éªŒå³å°†åˆ°æ¥ï¼</p><p> Along the way, TypeScript was extended with a small number of features that donâ€™t quite fit this model.  enum,  namespace,  parameter properties, and  experimental decoratorsÂ all have semantics that require them to be expanded into runtime code that, in all likelihood, will never be directly supported by JavaScript engines.</p><p>åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼ŒTypeScriptæ‰©å±•äº†ä¸€äº›ä¸å¤ªé€‚åˆè¿™ç§æ¨¡å¼çš„åŠŸèƒ½ã€‚æšä¸¾ã€å‘½åç©ºé—´ã€å‚æ•°å±æ€§å’Œå®éªŒæ€§ä¿®é¥°ç¬¦éƒ½å…·æœ‰éœ€è¦æ‰©å±•ä¸ºè¿è¡Œæ—¶ä»£ç çš„è¯­ä¹‰ï¼Œè€Œè¿™äº›ä»£ç å¾ˆå¯èƒ½æ°¸è¿œä¸ä¼šè¢«JavaScriptå¼•æ“ç›´æ¥æ”¯æŒã€‚</p><p>  This is not a big deal. The  TypeScript Design Goals articulate the need to avoid introducing more runtime features in the future. One member of the TypeScript team,  Orta, created a meme-slide to emphasize this recognition.</p><p>è¿™æ²¡ä»€ä¹ˆå¤§ä¸äº†çš„ã€‚Tyescript Designç›®æ ‡é˜æ˜äº†é¿å…åœ¨æœªæ¥å¼•å…¥æ›´å¤šè¿è¡Œæ—¶åŠŸèƒ½çš„å¿…è¦æ€§ã€‚æ‰“å­—å›¢é˜Ÿçš„ä¸€åæˆå‘˜å¥¥å°”å¡”(Orta)åˆ¶ä½œäº†ä¸€å¼ è¿·å› å¹»ç¯ç‰‡æ¥å¼ºè°ƒè¿™ç§è®¤å¯ã€‚</p><p>    Our toolchain addresses this set of undesirable features by preventing their use. This ensures that our growing TypeScript codebase is truly JS + Types.</p><p>æˆ‘ä»¬çš„å·¥å…·é“¾é€šè¿‡é˜»æ­¢ä½¿ç”¨è¿™äº›ä¸å—æ¬¢è¿çš„åŠŸèƒ½æ¥è§£å†³è¿™äº›é—®é¢˜ã€‚è¿™ç¡®ä¿äº†æˆ‘ä»¬ä¸æ–­å¢é•¿çš„æ‰“å­—ä»£ç åº“æ˜¯çœŸæ­£çš„JS+ç±»å‹ã€‚</p><p>   TypeScript evolves  rapidly. New versions of the language introduce new type-level features, add support for JavaScript features, improve performance and stability, as well as improve the type-checker to find more type errors. So thereâ€™s a lot of enticement to use new versions!</p><p>æ‰“å­—ç¨¿å‘å±•å¾ˆå¿«ã€‚è¯¥è¯­è¨€çš„æ–°ç‰ˆæœ¬å¼•å…¥äº†æ–°çš„ç±»å‹çº§åŠŸèƒ½ï¼Œå¢åŠ äº†å¯¹JavaScriptåŠŸèƒ½çš„æ”¯æŒï¼Œæé«˜äº†æ€§èƒ½å’Œç¨³å®šæ€§ï¼Œå¹¶æ”¹è¿›äº†ç±»å‹æ£€æŸ¥å™¨ä»¥å‘ç°æ›´å¤šç±»å‹é”™è¯¯ã€‚æ‰€ä»¥ä½¿ç”¨æ–°ç‰ˆæœ¬æœ‰å¾ˆå¤§çš„è¯±æƒ‘åŠ›ï¼</p><p> Whilst TypeScript strives to preserve compatibility, these type-checking improvements represent breaking changes to the build process as new errors are identified in codebases that previously appeared error-free. Upgrading TypeScript therefore requires some intervention to get these benefits.</p><p>è™½ç„¶TypeScriptåŠªåŠ›ä¿æŒå…¼å®¹æ€§ï¼Œä½†è¿™äº›ç±»å‹æ£€æŸ¥æ”¹è¿›ä»£è¡¨ç€æ„å»ºè¿‡ç¨‹çš„ç ´åæ€§æ›´æ”¹ï¼Œå› ä¸ºåœ¨ä»¥å‰çœ‹èµ·æ¥æ²¡æœ‰é”™è¯¯çš„ä»£ç åº“ä¸­å‘ç°äº†æ–°çš„é”™è¯¯ã€‚å› æ­¤ï¼Œå‡çº§æ‰“å­—ç¨¿éœ€è¦ä¸€äº›å¹²é¢„æ‰èƒ½è·å¾—è¿™äº›å¥½å¤„ã€‚</p><p> There is another form of compatibility to consider, which is inter-project compatibility. As both JavaScript and TypeScript syntaxes evolve, declaration files need to contain new syntax.</p><p>è¿˜æœ‰å¦ä¸€ç§å½¢å¼çš„å…¼å®¹æ€§éœ€è¦è€ƒè™‘ï¼Œé‚£å°±æ˜¯é¡¹ç›®é—´çš„å…¼å®¹æ€§ã€‚éšç€JavaScriptå’ŒTypeScriptè¯­æ³•çš„å‘å±•ï¼Œå£°æ˜æ–‡ä»¶éœ€è¦åŒ…å«æ–°çš„è¯­æ³•ã€‚</p><p> If a library upgrades TypeScript and starts producing modern declaration files with new syntax, application projects using that library will fail to compile if their version of TypeScript does not understand that syntax. An example of new declaration syntax is  the emit of getter/setter accessors in TypeScript 3.7. These are not understood by TypeScript 3.5 or earlier. This means that having an ecosystem of projects using different compiler versions is not ideal.</p><p>å¦‚æœåº“å‡çº§äº†TypeScriptå¹¶å¼€å§‹ç”Ÿæˆå¸¦æœ‰æ–°è¯­æ³•çš„ç°ä»£å£°æ˜æ–‡ä»¶ï¼Œåˆ™ä½¿ç”¨è¯¥åº“çš„åº”ç”¨ç¨‹åºé¡¹ç›®å°†æ— æ³•ç¼–è¯‘(å¦‚æœå®ƒä»¬çš„TypeScriptç‰ˆæœ¬ä¸ç†è§£è¯¥è¯­æ³•)ã€‚æ–°å£°æ˜è¯­æ³•çš„ä¸€ä¸ªä¾‹å­æ˜¯TypeScript3.7ä¸­çš„getter/setterè®¿é—®å™¨çš„å‘å‡ºã€‚è¿™äº›æ˜¯TypeScript3.5æˆ–æ›´æ—©ç‰ˆæœ¬æ— æ³•ç†è§£çš„ã€‚è¿™æ„å‘³ç€æ‹¥æœ‰ä¸€ä¸ªä½¿ç”¨ä¸åŒç¼–è¯‘å™¨ç‰ˆæœ¬çš„é¡¹ç›®ç”Ÿæ€ç³»ç»Ÿå¹¶ä¸ç†æƒ³ã€‚</p><p>  At Bloomberg, codebases are spread across various Git repositories that use common tooling. Despite not having a monorepo, we do have a centralized registry of TypeScript projects. This allowed us to create a Continuous Integration (CI) job to â€œbuild the worldâ€ and verify the build-time and run-time effects of compiler upgrades on every TypeScript project.</p><p>åœ¨å½­åšç¤¾ï¼Œä»£ç åº“åˆ†å¸ƒåœ¨ä½¿ç”¨é€šç”¨å·¥å…·çš„å„ç§Gitåº“ä¸­ã€‚å°½ç®¡æ²¡æœ‰Monorepoï¼Œä½†æˆ‘ä»¬æœ‰ä¸€ä¸ªé›†ä¸­çš„æ‰“å­—é¡¹ç›®æ³¨å†Œè¡¨ã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿåˆ›å»ºä¸€ä¸ªæŒç»­é›†æˆ(CI)ä½œä¸šæ¥â€œæ„å»ºä¸–ç•Œâ€ï¼Œå¹¶éªŒè¯æ¯ä¸ªTypeScripté¡¹ç›®ä¸Šçš„ç¼–è¯‘å™¨å‡çº§çš„æ„å»ºæ—¶å’Œè¿è¡Œæ—¶æ•ˆæœã€‚</p><p> This global checking is very powerful. We use this to assess Beta and RC releases of TypeScript to discover issues ahead of general release. Having a diverse corpus of real-world code means we also find edge cases. We use this system to guide fix-ups to projects ahead of the compiler upgrade, so that the upgrade itself is flawless. So far, this strategy has worked well and we have been able to keep the entire codebase on the latest version of TypeScript. This means we have not needed to employ mitigations such as  downlevelling DTS files.</p><p>è¿™ç§å…¨çƒæ£€æŸ¥éå¸¸å¼ºå¤§ã€‚æˆ‘ä»¬ä½¿ç”¨å®ƒæ¥è¯„ä¼°TypeScriptçš„Betaå’ŒRCç‰ˆæœ¬ï¼Œä»¥ä¾¿åœ¨æ­£å¼å‘å¸ƒä¹‹å‰å‘ç°é—®é¢˜ã€‚æ‹¥æœ‰ä¸åŒçš„çœŸå®ä»£ç è¯­æ–™åº“æ„å‘³ç€æˆ‘ä»¬è¿˜å¯ä»¥æ‰¾åˆ°è¾¹ç¼˜æ¡ˆä¾‹ã€‚åœ¨ç¼–è¯‘å™¨å‡çº§ä¹‹å‰ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªç³»ç»Ÿæ¥æŒ‡å¯¼å¯¹é¡¹ç›®çš„ä¿®è¡¥ï¼Œå› æ­¤å‡çº§æœ¬èº«æ˜¯å®Œç¾æ— ç¼ºçš„ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¿™ä¸€ç­–ç•¥è¿è¡Œè‰¯å¥½ï¼Œæˆ‘ä»¬èƒ½å¤Ÿå°†æ•´ä¸ªä»£ç åº“ä¿å­˜åœ¨æœ€æ–°ç‰ˆæœ¬çš„Tyescriptä¸Šã€‚è¿™æ„å‘³ç€æˆ‘ä»¬ä¸éœ€è¦é‡‡ç”¨è¯¸å¦‚é™çº§DTSæ–‡ä»¶ä¹‹ç±»çš„ç¼“è§£æªæ–½ã€‚</p><p>   Much of the flexibility provided by  tsconfig is to allow you to adapt TypeScript to your runtime platform. In an environment where all projects are targeting the same evergreen runtime, it turns out to be a hazard for each project to configure this separately.</p><p>Tsconfigæä¾›çš„å¾ˆå¤§ä¸€éƒ¨åˆ†çµæ´»æ€§æ˜¯å…è®¸æ‚¨æ ¹æ®è¿è¡Œæ—¶å¹³å°è°ƒæ•´ç±»å‹è„šæœ¬ã€‚åœ¨æ‰€æœ‰é¡¹ç›®éƒ½ä»¥ç›¸åŒçš„Evergreenè¿è¡Œæ—¶ä¸ºç›®æ ‡çš„ç¯å¢ƒä¸­ï¼Œäº‹å®è¯æ˜ï¼Œæ¯ä¸ªé¡¹ç›®å•ç‹¬é…ç½®å®ƒæ˜¯ä¸€ä»¶å±é™©çš„äº‹æƒ…ã€‚</p><p>  Therefore we made our toolchain responsible for generating  tsconfig at build time with â€œidealâ€ settings. For example,   &#34;strict&#34; mode is enabled by default to increase type-safety.   &#34;isolatedModules&#34; is enforced to ensure our code can be compiled quickly by simple transpilers that operate on a single file at a time.</p><p>å› æ­¤ï¼Œæˆ‘ä»¬è®©æˆ‘ä»¬çš„å·¥å…·é“¾è´Ÿè´£åœ¨æ„å»ºæ—¶ä½¿ç”¨â€œç†æƒ³â€è®¾ç½®ç”Ÿæˆtsconfigã€‚ä¾‹å¦‚ï¼Œé»˜è®¤æƒ…å†µä¸‹ä¼šå¯ç”¨ä¸¥æ ¼æ¨¡å¼ï¼Œä»¥æé«˜ç±»å‹å®‰å…¨æ€§ã€‚IsolatedModules&#34ï¼›æ˜¯å¼ºåˆ¶æ‰§è¡Œçš„ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬çš„ä»£ç å¯ä»¥é€šè¿‡ä¸€æ¬¡æ“ä½œä¸€ä¸ªæ–‡ä»¶çš„ç®€å•ä»£ç è½¬æ¢ç¨‹åºå¿«é€Ÿç¼–è¯‘ã€‚</p><p> A further benefit of treating  tsconfig as a generated file, rather than as a source file, is that it permits higher-level tooling to flexibly link together multi-project â€œworkspacesâ€ by taking responsibility for defining options such as   &#34;references&#34; and   &#34;paths&#34;.</p><p>å°†tsconfigè§†ä¸ºç”Ÿæˆçš„æ–‡ä»¶è€Œä¸æ˜¯æºæ–‡ä»¶çš„å¦ä¸€ä¸ªå¥½å¤„æ˜¯ï¼Œå®ƒå…è®¸é«˜çº§å·¥å…·é€šè¿‡è´Ÿè´£å®šä¹‰é€‰é¡¹(å¦‚å¼•ç”¨å’Œè·¯å¾„)ï¼Œçµæ´»åœ°å°†å¤šä¸ªé¡¹ç›®çš„â€œå·¥ä½œåŒºâ€é“¾æ¥åœ¨ä¸€èµ·ã€‚</p><p> There is some tension here, as a minority of projects wanted the ability to make customizations such as switching to looser modes to reduce the migration burden.</p><p>è¿™é‡Œå­˜åœ¨ä¸€äº›çŸ›ç›¾ï¼Œå› ä¸ºå°‘æ•°é¡¹ç›®å¸Œæœ›èƒ½å¤Ÿè¿›è¡Œå®šåˆ¶ï¼Œæ¯”å¦‚åˆ‡æ¢åˆ°æ›´å®½æ¾çš„æ¨¡å¼ä»¥å‡è½»è¿ç§»è´Ÿæ‹…ã€‚</p><p> Initially we tried to cater to these requests and gave access to a small number of options. Later we found that this resulted in inter-package conflicts, when declaration files built using one set of options were consumed by a package using different options. Hereâ€™s one example.</p><p>æœ€åˆï¼Œæˆ‘ä»¬è¯•å›¾è¿åˆè¿™äº›è¦æ±‚ï¼Œå¹¶æä¾›äº†å°‘é‡é€‰æ‹©ã€‚åæ¥æˆ‘ä»¬å‘ç°ï¼Œå½“ä½¿ç”¨ä¸€ç»„é€‰é¡¹æ„å»ºçš„å£°æ˜æ–‡ä»¶è¢«ä½¿ç”¨ä¸åŒé€‰é¡¹çš„åŒ…ä½¿ç”¨æ—¶ï¼Œè¿™ä¼šå¯¼è‡´åŒ…é—´å†²çªã€‚è¿™é‡Œæœ‰ä¸€ä¸ªä¾‹å­ã€‚</p><p> Itâ€™s possible to create a conditional type that is directed by the value of   &#34;strictNullChecks&#34;.</p><p>å¯ä»¥åˆ›å»ºç”±&#34ï¼›strictNullChecks&#34ï¼›çš„å€¼æŒ‡ç¤ºçš„æ¡ä»¶ç±»å‹ã€‚</p><p>    IfÂ  &#34;strictNullChecks&#34; are enabled, then A is a  number.Â If  &#34;strictNullChecks&#34; are disabled, then A is a  string.Â This code breaks if the package exporting this type is not using the same strictness settings as the package importing it.</p><p>å¦‚æœå¯ç”¨äº†ä¸¥æ ¼NullChecksï¼Œåˆ™Aæ˜¯ä¸€ä¸ªæ•°å­—ã€‚å¦‚æœç¦ç”¨äº†&#34ï¼›strictNullChecksï¼Œåˆ™Aæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚*å¦‚æœå¯¼å‡ºæ­¤ç±»å‹çš„åŒ…ä½¿ç”¨çš„æ˜¯ä¸å¯¼å…¥å®ƒçš„åŒ…ä¸åŒçš„ä¸¥æ ¼è®¾ç½®ï¼Œåˆ™æ­¤ä»£ç å°†ä¸­æ–­ã€‚</p><p> This is a simplified example of a real-life issue we faced.Â As a result, we chose to deprecate the flexibility on strictness modes in favour of having consistent configs for all projects.</p><p>è¿™æ˜¯æˆ‘ä»¬é¢ä¸´çš„ç°å®é—®é¢˜çš„ä¸€ä¸ªç®€åŒ–ä¾‹å­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€‰æ‹©ä¸æ”¯æŒä¸¥æ ¼æ¨¡å¼çš„çµæ´»æ€§ï¼Œè€Œæ˜¯æ”¯æŒä¸ºæ‰€æœ‰é¡¹ç›®æä¾›ä¸€è‡´çš„é…ç½®ã€‚</p><p>   We needed the ability to explicitly declare the location of our dependencies to TypeScript. This is because our ES module system does not rely on the Node file-system convention of finding dependencies by walking up a series of directories named  node_modules.</p><p>æˆ‘ä»¬éœ€è¦èƒ½å¤Ÿæ˜¾å¼å£°æ˜æˆ‘ä»¬å¯¹TypeScriptçš„ä¾èµ–å…³ç³»çš„ä½ç½®ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„ESæ¨¡å—ç³»ç»Ÿä¸ä¾èµ–äºNodeæ–‡ä»¶ç³»ç»Ÿçº¦å®šï¼Œå³é€šè¿‡éå†ä¸€ç³»åˆ—åä¸ºNODE_MODULESçš„ç›®å½•æ¥æŸ¥æ‰¾ä¾èµ–é¡¹ã€‚</p><p> We needed the ability to declare a mapping of bare-specifiers (e.g.,  &#34;lodash&#34;) to directory locations on disk ( &#34;c:\dependencies\lodash&#34;). This is similar to the problem that  import mapsÂ attempt to solve for the Web. At first, we tried using the   &#34;paths&#34; option in  tsconfig.</p><p>æˆ‘ä»¬éœ€è¦èƒ½å¤Ÿå£°æ˜å°†è£¸è¯´æ˜ç¬¦(ä¾‹å¦‚ï¼Œlodash)æ˜ å°„åˆ°ç£ç›˜ä¸Šçš„ç›®å½•ä½ç½®(&#34ï¼›cï¼š\Dependency\lowash&#34ï¼›)ã€‚è¿™ç±»ä¼¼äºå¯¼å…¥åœ°å›¾è¯•å›¾ä¸ºWebè§£å†³çš„é—®é¢˜ã€‚èµ·åˆï¼Œæˆ‘ä»¬å°è¯•ä½¿ç”¨tsconfigä¸­çš„è·¯å¾„é€‰é¡¹ã€‚</p><p>    This worked great for nearly all use cases. However, we discovered this degraded the quality of generated declaration files. The TypeScript compiler necessarily injects synthetic import statements into declaration files to allow for composite types â€“ where types can depend on types from other modules. When the synthetic imports reference types in dependencies, we found the  &#34;paths&#34; approach injected a relative path ( import(&#34;../../dependencies/lodash&#34;)) rather than preserving the bare-specifier ( import &#34;lodash&#34;). For our system, the relative location of external package typings is an implementation detail that may change, so this was unacceptable.</p><p>è¿™å¯¹å‡ ä¹æ‰€æœ‰ç”¨ä¾‹éƒ½å¾ˆæœ‰æ•ˆã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å‘ç°è¿™é™ä½äº†ç”Ÿæˆçš„å£°æ˜æ–‡ä»¶çš„è´¨é‡ã€‚ç±»å‹è„šæœ¬ç¼–è¯‘å™¨å¿…é¡»å°†åˆæˆçš„å¯¼å…¥è¯­å¥æ³¨å…¥å£°æ˜æ–‡ä»¶ä¸­ï¼Œä»¥æ”¯æŒå¤åˆç±»å‹-å…¶ä¸­ç±»å‹å¯ä»¥ä¾èµ–äºæ¥è‡ªå…¶ä»–æ¨¡å—çš„ç±»å‹ã€‚å½“åˆæˆå¯¼å…¥å¼•ç”¨ä¾èµ–é¡¹ä¸­çš„ç±»å‹æ—¶ï¼Œæˆ‘ä»¬å‘ç°è·¯å¾„æ–¹æ³•æ³¨å…¥äº†ç›¸å¯¹è·¯å¾„(å¯¼å…¥(&#34ï¼›../../Dependations/lodash&#34ï¼›)ï¼Œè€Œä¸æ˜¯ä¿ç•™è£¸è¯´æ˜ç¬¦(import&#34ï¼›lodash&#34ï¼›)ã€‚å¯¹äºæˆ‘ä»¬çš„ç³»ç»Ÿæ¥è¯´ï¼Œå¤–éƒ¨åŒ…ç±»å‹çš„ç›¸å¯¹ä½ç½®æ˜¯ä¸€ä¸ªå¯èƒ½ä¼šæ”¹å˜çš„å®ç°ç»†èŠ‚ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸å¯æ¥å—çš„ã€‚</p><p>  // ambient-modules.d.ts declare  module  &#34;lodash&#34;  {  export  *  from  &#34;../../dependencies/lodash&#34; ;  export  default  from  &#34;../../dependencies/lodash&#34; ; }</p><p>//ç¯å¢ƒ-æ¨¡å—.d.tså£°æ˜æ¨¡å—&#34ï¼›loash&#34ï¼›{ä»&#34ï¼›../../Dependations/Lotash&#34ï¼›ï¼›å¯¼å‡º*ä»&#34ï¼›../../Dependents/lowash&#34ï¼›ï¼›ä¸­å¯¼å‡ºé»˜è®¤å€¼}ã€‚</p><p>  Ambient Modules are special. TypeScriptâ€™s declaration-emit preserves references to them rather than converting them to a relative path.</p><p>ç¯å¢ƒæ¨¡å—æ˜¯ç‰¹æ®Šçš„ã€‚TypeScriptçš„å£°æ˜-emitä¿ç•™å¯¹å®ƒä»¬çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯å°†å®ƒä»¬è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„ã€‚</p><p>   App performance is critical, so we try to minimize the volume of JS that apps load at runtime. Our platform ensures that only one version of a package is used at runtime. This de-duplication of versions means that a given package cannot â€œfreezeâ€ or â€œpinâ€ their dependencies. Consequently, this means packages must preserve compatibility over time.</p><p>åº”ç”¨ç¨‹åºçš„æ€§èƒ½éå¸¸å…³é”®ï¼Œå› æ­¤æˆ‘ä»¬å°è¯•å°†åº”ç”¨ç¨‹åºåœ¨è¿è¡Œæ—¶åŠ è½½çš„JSæ•°é‡é™è‡³æœ€ä½ã€‚æˆ‘ä»¬çš„å¹³å°ç¡®ä¿åœ¨è¿è¡Œæ—¶åªä½¿ç”¨åŒ…çš„ä¸€ä¸ªç‰ˆæœ¬ã€‚ç‰ˆæœ¬çš„è¿™ç§å»é‡å¤æ„å‘³ç€ç»™å®šçš„åŒ…ä¸èƒ½â€œå†»ç»“â€æˆ–â€œå›ºå®šâ€å®ƒä»¬çš„ä¾èµ–å…³ç³»ã€‚å› æ­¤ï¼Œè¿™æ„å‘³ç€åŒ…å¿…é¡»éšæ—¶é—´ä¿æŒå…¼å®¹æ€§ã€‚</p><p> We wanted to provide the same â€œexactly-oneâ€ guarantee for types to ensure that, for a given compilation of a project, the type-check would only ever consider one single version of a packageâ€™s dependencies. In addition to compile-time efficiency, the motivation was to ensure the type-checked world better reflects the runtime world. We specifically wanted to avoid staleness issues and â€œnominality hell,â€ in which two incompatible versions of nominal types are imported via a â€œdiamond patternâ€. This is a hazard that will likely grow as ecosystem adoption of nominal types increases.</p><p>æˆ‘ä»¬å¸Œæœ›ä¸ºç±»å‹æä¾›ç›¸åŒçš„â€œåªæœ‰ä¸€ä¸ªâ€çš„ä¿è¯ï¼Œä»¥ç¡®ä¿å¯¹äºç»™å®šçš„é¡¹ç›®ç¼–è¯‘ï¼Œç±»å‹æ£€æŸ¥å°†åªè€ƒè™‘åŒ…çš„ä¾èµ–é¡¹çš„ä¸€ä¸ªç‰ˆæœ¬ã€‚é™¤äº†ç¼–è¯‘æ—¶çš„æ•ˆç‡ï¼Œå…¶åŠ¨æœºæ˜¯ç¡®ä¿ç±»å‹æ£€æŸ¥ä¸–ç•Œæ›´å¥½åœ°åæ˜ è¿è¡Œæ—¶ä¸–ç•Œã€‚æˆ‘ä»¬ç‰¹åˆ«å¸Œæœ›é¿å…é™ˆæ—§é—®é¢˜å’Œâ€œåä¹‰åœ°ç‹±â€ï¼Œå³é€šè¿‡â€œé’»çŸ³æ¨¡å¼â€å¯¼å…¥ä¸¤ä¸ªä¸å…¼å®¹çš„åä¹‰ç±»å‹ç‰ˆæœ¬ã€‚è¿™æ˜¯ä¸€ç§å±é™©ï¼Œéšç€ç”Ÿæ€ç³»ç»Ÿå¯¹åä¹‰ç±»å‹çš„é‡‡ç”¨å¢åŠ ï¼Œè¿™ç§å±é™©å¯èƒ½ä¼šå¢åŠ ã€‚</p><p>   We wrote a deterministic resolver that selects exactly one version of each dependency to type against based on the declared version constraints of the package being built.</p><p>æˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªç¡®å®šæ€§è§£æå™¨ï¼Œè¯¥è§£æå™¨æ ¹æ®æ­£åœ¨æ„å»ºçš„åŒ…çš„å£°æ˜ç‰ˆæœ¬çº¦æŸï¼Œé€‰æ‹©æ¯ä¸ªä¾èµ–é¡¹çš„ä¸€ä¸ªç‰ˆæœ¬ä½œä¸ºè¾“å…¥ä¾æ®ã€‚</p><p>   This means the graph of type dependencies is dynamically assembled â€“ it is not frozen. Whilst this unpinned dependency approach provides benefits and avoids some hazards, we later learned that it can introduce a different hazard due to subtle behavior in the TypeScript compiler. See   9.  Generated declarations can inline types from dependenciesÂ to learn more.</p><p>è¿™æ„å‘³ç€ç±»å‹ä¾èµ–å…³ç³»å›¾æ˜¯åŠ¨æ€ç»„è£…çš„-å®ƒä¸æ˜¯å†»ç»“çš„ã€‚è™½ç„¶è¿™ç§æœªå›ºå®šçš„ä¾èµ–é¡¹æ–¹æ³•æä¾›äº†å¥½å¤„å¹¶é¿å…äº†ä¸€äº›å±é™©ï¼Œä½†æˆ‘ä»¬åæ¥äº†è§£åˆ°ï¼Œç”±äºç±»å‹è„šæœ¬ç¼–è¯‘å™¨ä¸­çš„å¾®å¦™è¡Œä¸ºï¼Œå®ƒå¯èƒ½ä¼šå¼•å…¥ä¸åŒçš„å±é™©ã€‚å‚è§9.ç”Ÿæˆçš„å£°æ˜å¯ä»¥å†…è”ä¾èµ–é¡¹ä¸­çš„ç±»å‹ï¼Œä»¥äº†è§£æ›´å¤šä¿¡æ¯ã€‚</p><p> These trade-offs and choices are not specific to our platform. They apply equally to anyone publishing to DefinitelyTyped/npm, and are determined by the aggregate effect of each packageâ€™s version constraints expressed in package.json  &#34;dependencies&#34;.</p><p>è¿™äº›æƒè¡¡å’Œé€‰æ‹©å¹¶ä¸æ˜¯æˆ‘ä»¬çš„å¹³å°æ‰€ç‰¹æœ‰çš„ã€‚å®ƒä»¬åŒæ ·é€‚ç”¨äºå‘å¸ƒåˆ°DefinitelyTyped/npmçš„ä»»ä½•äººï¼Œå¹¶ç”±Package.json&#34ï¼›ä¾èµ–é¡¹ä¸­è¡¨ç¤ºçš„æ¯ä¸ªåŒ…çš„ç‰ˆæœ¬çº¦æŸçš„èšåˆæ•ˆæœå†³å®šã€‚</p><p>   Itâ€™s easy to introduce global types in TypeScript. Itâ€™s even easier to depend on global types. If left unchecked, this means it is possible for hidden coupling to occur between distant packages. The TypeScript Handbook calls this out as being  â€œsomewhat dangerous.â€</p><p>åœ¨Tyescriptä¸­å¼•å…¥å…¨å±€ç±»å‹å¾ˆå®¹æ˜“ã€‚ä¾èµ–å…¨å±€ç±»å‹ç”šè‡³æ›´å®¹æ˜“ã€‚å¦‚æœä¸é€‰ä¸­ï¼Œè¿™æ„å‘³ç€å¯èƒ½ä¼šåœ¨è¿œç¨‹åŒ…ä¹‹é—´å‘ç”Ÿéšè—è€¦åˆã€‚ã€Šæ‰“å­—æ‰‹å†Œã€‹(Tyescript Handbook)ç§°è¿™ç§åšæ³•â€œæœ‰äº›å±é™©â€ã€‚</p><p>  // A declaration that injects global types declare  global {  interface  String {  fancyFormat(opts?: StringFormatOptions): string;  } } // Somewhere in a file far, far away... String.fancyFormat();  // no error!</p><p>//æ³¨å…¥å…¨å±€ç±»å‹çš„å£°æ˜å£°æ˜å…¨å±€{æ¥å£å­—ç¬¦ä¸²{FancyFormat(optsï¼Ÿï¼šStringFormatOptions)ï¼šå­—ç¬¦ä¸²ï¼›}}//åœ¨ä¸€ä¸ªå¾ˆè¿œå¾ˆè¿œçš„æ–‡ä»¶é‡Œçš„æŸä¸ªåœ°æ–¹...String.fancyFormat()ï¼›//æ²¡æœ‰é”™è¯¯ï¼</p><p>  The solution to this is well-known: prefer explicit dependencies over global state. TypeScript has provided support for ECMAScript  import and  export statements for a long time, which achieve this goal.</p><p>è¿™ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ¡ˆæ˜¯ä¼—æ‰€å‘¨çŸ¥çš„ï¼šæ¯”èµ·å…¨å±€çŠ¶æ€ï¼Œæ›´å–œæ¬¢æ˜¾å¼ä¾èµ–å…³ç³»ã€‚é•¿æœŸä»¥æ¥ï¼ŒTypeScriptä¸€ç›´æ”¯æŒECMAScript IMPORTå’ŒEXPORTè¯­å¥ï¼Œä»è€Œå®ç°äº†è¿™ä¸€ç›®æ ‡ã€‚</p><p> So the only remaining need was to prevent accidental creation of global types. Thankfully, it is possible to statically detect each of the cases where TypeScript permits the introduction of global types. So, we were able to update our toolchain to detect and error in the cases where these are used. This means we can safely rely on the fact that importing a packageâ€™s types is a side-effect-free operation.</p><p>å› æ­¤ï¼Œå‰©ä¸‹çš„å”¯ä¸€éœ€è¦æ˜¯é˜²æ­¢æ„å¤–åˆ›å»ºå…¨å±€ç±»å‹ã€‚å€¼å¾—åº†å¹¸çš„æ˜¯ï¼Œå¯ä»¥é™æ€åœ°æ£€æµ‹TypeScripå…è®¸å¼•å…¥å…¨å±€ç±»å‹çš„æ¯ä¸€ç§æƒ…å†µã€‚å› æ­¤ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ›´æ–°æˆ‘ä»¬çš„å·¥å…·é“¾ï¼Œä»¥ä¾¿åœ¨ä½¿ç”¨è¿™äº›å·¥å…·çš„æƒ…å†µä¸‹æ£€æµ‹å¹¶å‡ºé”™ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥æ”¾å¿ƒåœ°ç›¸ä¿¡ï¼Œå¯¼å…¥åŒ…çš„ç±»å‹æ˜¯ä¸€ç§æ— å‰¯ä½œç”¨çš„æ“ä½œã€‚</p><p>   Not all declaration files are equal. A declaration file operates in  one of three modes, depending on the content; specifically the usage of  import and  export keywords.</p><p>å¹¶ä¸æ˜¯æ‰€æœ‰çš„å£°æ˜æ–‡ä»¶éƒ½æ˜¯å¹³ç­‰çš„ã€‚å£°æ˜æ–‡ä»¶ä»¥ä¸‰ç§æ¨¡å¼ä¹‹ä¸€è¿è¡Œï¼Œå…·ä½“å–å†³äºå†…å®¹ï¼Œç‰¹åˆ«æ˜¯å¯¼å…¥å’Œå¯¼å‡ºå…³é”®å­—çš„ä½¿ç”¨ã€‚</p><p> global â€” A declaration file with no usage of  import or  export will be considered to be  global.Â Top-level declarations are globally exported.</p><p>å…¨å±€-æœªä½¿ç”¨å¯¼å…¥æˆ–å¯¼å‡ºçš„å£°æ˜æ–‡ä»¶å°†è¢«è§†ä¸ºå…¨å±€æ–‡ä»¶ã€‚é¡¶çº§å£°æ˜å°†è¢«å…¨å±€å¯¼å‡ºã€‚</p><p> module â€” A declaration file with at least one  export declaration will be considered to be a module. Only the  export declarations are exported and no globals are defined.</p><p>æ¨¡å—-è‡³å°‘åŒ…å«ä¸€ä¸ªå¯¼å‡ºå£°æ˜çš„å£°æ˜æ–‡ä»¶å°†è¢«è§†ä¸ºæ¨¡å—ã€‚åªå¯¼å‡ºå¯¼å‡ºå£°æ˜ï¼Œæ²¡æœ‰å®šä¹‰å…¨å±€å˜é‡ã€‚</p><p> implicit exports â€” A declaration file that has no  export declarations, but does use  import will trigger defined-yet-undocumented behaviour. This means that top-level declarations are treated as named  export declarations and no globals are defined.</p><p>éšå¼å¯¼å‡º-æ²¡æœ‰å¯¼å‡ºå£°æ˜ä½†ä½¿ç”¨å¯¼å…¥çš„å£°æ˜æ–‡ä»¶å°†è§¦å‘å·²å®šä¹‰ä½†æœªè®°å½•çš„è¡Œä¸ºã€‚è¿™æ„å‘³ç€é¡¶çº§å£°æ˜è¢«è§†ä¸ºå‘½åçš„å¯¼å‡ºå£°æ˜ï¼Œå¹¶ä¸”æ²¡æœ‰å®šä¹‰å…¨å±€å˜é‡ã€‚</p><p> We do not use the first mode. Our toolchain prevents global declaration files (see previous section:   6.  Implicit Type Dependencies should be avoided). This means all declaration files use ES module syntax.</p><p>æˆ‘ä»¬ä¸ä½¿ç”¨ç¬¬ä¸€ç§æ¨¡å¼ã€‚æˆ‘ä»¬çš„å·¥å…·é“¾é˜»æ­¢å…¨å±€å£°æ˜æ–‡ä»¶(å‚è§ä¸Šä¸€èŠ‚ï¼š6.åº”é¿å…éšå¼ç±»å‹ä¾èµ–)ã€‚è¿™æ„å‘³ç€æ‰€æœ‰å£°æ˜æ–‡ä»¶éƒ½ä½¿ç”¨ESæ¨¡å—è¯­æ³•ã€‚</p><p>    Perhaps surprisingly, we found the slightly-spooky third-mode to be useful. By adding just a single-line self-import to the top of ambient declaration files, you can prevent them from polluting the global namespace:  import {} from &#34;./&lt;my-own-name&gt;&#34;;. This one-liner made it trivial to convert third-party declarations, such as  lib.dom.d.ts, to be modular and avoided the need to maintain a more complex fork.</p><p>æˆ–è®¸ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œæˆ‘ä»¬å‘ç°ç•¥æ˜¾è¯¡å¼‚çš„ç¬¬ä¸‰æ¨¡å¼å¾ˆæœ‰ç”¨ã€‚åªéœ€åœ¨ç¯å¢ƒå£°æ˜æ–‡ä»¶çš„é¡¶éƒ¨æ·»åŠ ä¸€è¡Œè‡ªå¯¼å…¥ï¼Œå°±å¯ä»¥é˜²æ­¢å®ƒä»¬æ±¡æŸ“å…¨å±€å‘½åç©ºé—´ï¼šImport{}from&#34ï¼›./&ltï¼›my-own-name&gtï¼›&#34ï¼›ï¼›ã€‚è¿™ä¸ªä¸€è¡Œä»£ç ä½¿å¾—å°†ç¬¬ä¸‰æ–¹å£°æ˜(å¦‚lib.dom.d.ts)è½¬æ¢ä¸ºæ¨¡å—åŒ–å˜å¾—ç®€å•ï¼Œå¹¶é¿å…äº†ç»´æŠ¤æ›´å¤æ‚çš„åˆ†æ”¯çš„éœ€è¦ã€‚</p><p> The TypeScript team  do not seem to love the third-mode, so consider avoiding it where possible.</p><p>æ‰“å­—å›¢é˜Ÿä¼¼ä¹ä¸å–œæ¬¢ç¬¬ä¸‰ç§æ¨¡å¼ï¼Œå› æ­¤è¯·è€ƒè™‘åœ¨å¯èƒ½çš„æƒ…å†µä¸‹é¿å…ä½¿ç”¨ç¬¬ä¸‰ç§æ¨¡å¼ã€‚</p><p>   As explained earlier (in   5. De-duplicating types can be important), our use of unpinned dependencies means it is important for our packages to preserve not only runtime-compatibility, but also type-compatibility over time. Thatâ€™s a challenge, so to make this preservation of compatibility practical, we have to really understand which types are exposed and must be constrained in this way. A first step is to explicitly differentiate public vs. private modules.</p><p>æ­£å¦‚å‰é¢æ‰€è§£é‡Šçš„(åœ¨5.æ¶ˆé™¤é‡å¤ç±»å‹å¯èƒ½å¾ˆé‡è¦)ï¼Œæˆ‘ä»¬ä½¿ç”¨éå›ºå®šä¾èµ–å…³ç³»æ„å‘³ç€æˆ‘ä»¬çš„åŒ…ä¸ä»…è¦ä¿æŒè¿è¡Œæ—¶å…¼å®¹æ€§ï¼Œè€Œä¸”è¦éšç€æ—¶é—´çš„æ¨ç§»ä¿æŒç±»å‹å…¼å®¹æ€§ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦ã€‚è¿™æ˜¯ä¸€ä¸ªæŒ‘æˆ˜ï¼Œæ‰€ä»¥è¦ä½¿å…¼å®¹æ€§çš„ä¿æŒå˜å¾—å®ç”¨ï¼Œæˆ‘ä»¬å¿…é¡»çœŸæ­£äº†è§£å“ªäº›ç±»å‹æ˜¯å…¬å¼€çš„ï¼Œå¹¶ä¸”å¿…é¡»ä»¥è¿™ç§æ–¹å¼è¿›è¡Œçº¦æŸã€‚ç¬¬ä¸€æ­¥æ˜¯æ˜ç¡®åŒºåˆ†å…¬å…±æ¨¡å—å’Œç§æœ‰æ¨¡å—ã€‚</p><p> Node recently gained this capability in the form of  the package.json  &#34;exports&#34; field. This defines an encapsulation boundary by explicitly listing the files that are accessible from outside the package.</p><p>Nodeæœ€è¿‘ä»¥Package.jsonï¼›Exportså­—æ®µçš„å½¢å¼è·å¾—äº†è¿™ä¸€åŠŸèƒ½ã€‚è¿™é€šè¿‡æ˜¾å¼åˆ—å‡ºå¯ä»åŒ…å¤–éƒ¨è®¿é—®çš„æ–‡ä»¶æ¥å®šä¹‰å°è£…è¾¹ç•Œã€‚</p><p> Today, TypeScript is not aware of  package exports and so does not have the concept of which files within a dependency are considered public or not. This becomes a problem during declaration generation, when TypeScript synthesizes import statements to transitive types in the emitted  .d.ts file. It is not acceptable for our  .d.ts files to reference private files in other packages. Hereâ€™s an example of it going wrong.</p><p>ç°åœ¨ï¼ŒTypeScriptä¸çŸ¥é“åŒ…å¯¼å‡ºï¼Œå› æ­¤ä¸çŸ¥é“ä¾èµ–é¡¹ä¸­çš„å“ªäº›æ–‡ä»¶è¢«è®¤ä¸ºæ˜¯å…¬å…±çš„ã€‚åœ¨å£°æ˜ç”ŸæˆæœŸé—´ï¼Œå½“TypeScriptå°†å¯¼å…¥è¯­å¥åˆæˆä¸ºå‘å‡ºçš„.d.tsæ–‡ä»¶ä¸­çš„å¯ä¼ é€’ç±»å‹æ—¶ï¼Œè¿™ä¼šæˆä¸ºä¸€ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬çš„.d.tsæ–‡ä»¶å¼•ç”¨å…¶ä»–åŒ…ä¸­çš„ç§æœ‰æ–‡ä»¶æ˜¯ä¸å¯æ¥å—çš„ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªå‡ºé”™çš„ä¾‹å­ã€‚</p><p>        This is bad because  &#34;another-package/private&#34; is not part of that packageâ€™s compatibility promise, so might be moved or renamed without a SemVer major bump.Â TypeScript today has no way of knowing it generated a fragile import.</p><p>è¿™å¾ˆç³Ÿç³•ï¼Œå› ä¸º&#34ï¼›Another-Package/Private&#34ï¼›ä¸æ˜¯è¯¥ç¨‹åºåŒ…å…¼å®¹æ€§æ‰¿è¯ºçš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤å¯èƒ½ä¼šè¢«ç§»åŠ¨æˆ–é‡å‘½åï¼Œè€Œä¸ä¼šå‡ºç°SemVerå¤§æ•…éšœã€‚ä»Šå¤©çš„æ‰“å­—ç¨¿æ— æ³•çŸ¥é“å®ƒç”Ÿæˆäº†ä¸€ä¸ªè„†å¼±çš„å¯¼å…¥ã€‚</p><p>   1. Our toolchain informs the TypeScript resolver of the intentionally-public bare-specifier paths that point to dependencies (e.g.,  &#34;lodash/public1&#34;,  &#34;lodash/public2&#34;). We ensure TypeScript knows about the full set of legitimate dependency entry-points by silently adding type-only import statements to the bottom of the TypeScript files just before they flow into the compiler.</p><p>1.æˆ‘ä»¬çš„å·¥å…·é“¾å°†æŒ‡å‘ä¾èµ–é¡¹çš„æœ‰æ„å…¬å¼€çš„è£¸è¯´æ˜ç¬¦è·¯å¾„é€šçŸ¥ç»™æ–‡æœ¬è§£æå™¨(ä¾‹å¦‚ï¼Œ&#34ï¼›loash/Public 1&34ï¼›ï¼Œ&#34ï¼›loash/Public 2&34ï¼›)ã€‚æˆ‘ä»¬é€šè¿‡åœ¨ç±»å‹è„šæœ¬æ–‡ä»¶æµå…¥ç¼–è¯‘å™¨ä¹‹å‰å°†ä»…ç±»å‹çš„å¯¼å…¥è¯­å¥é™é»˜åœ°æ·»åŠ åˆ°ç±»å‹è„šæœ¬æ–‡ä»¶çš„åº•éƒ¨æ¥ç¡®ä¿ç±»å‹è„šæœ¬çŸ¥é“å…¨éƒ¨åˆæ³•çš„ä¾èµ–é¡¹å…¥å£ç‚¹ã€‚</p><p>  // user&#39;s source code // injected by toolchain to assist declaration emit import  type  *  as  __fake_name_1  from  &#34;lodash/public1&#34; ; import  type  *  as  __fake_name_2  from  &#34;lodash/public2&#34; ;</p><p>//ç”¨æˆ·æºä»£ç //å·¥å…·é“¾æ³¨å…¥è¾…åŠ©å£°æ˜å‘å‡ºä»&#34ï¼›lowash/Public 1&#34ï¼›å¯¼å…¥ç±»å‹*AS__FAKE_NAME_1ï¼›ä»&#34ï¼›loash/Public 2&#34ï¼›å¯¼å…¥ç±»å‹*AS__FAKE_NAME_2ï¼›</p><p>  When generating references to inferred transitive types, TypeScriptâ€™s declaration emit will prefer to use these existing namespace identifiers rather than synthesizing imports to private files.</p><p>åœ¨ç”Ÿæˆå¯¹æ¨æ–­çš„å¯ä¼ é€’ç±»å‹çš„å¼•ç”¨æ—¶ï¼ŒTyescriptçš„å£°æ˜å‘å‡ºå°†æ›´å–œæ¬¢ä½¿ç”¨è¿™äº›ç°æœ‰çš„åç§°ç©ºé—´æ ‡è¯†ç¬¦ï¼Œè€Œä¸æ˜¯å°†å¯¼å…¥åˆæˆåˆ°ç§æœ‰æ–‡ä»¶ã€‚</p><p> 2. Our toolchain generates errors if TypeScript generates a path to a file in a dependency that we know is private. This is analogous to the existing TypeScript errors emitted when TypeScript realizes that it is generating a potentially hazardous path to a dependency.</p><p>2.å¦‚æœTypeScriptåœ¨æˆ‘ä»¬çŸ¥é“æ˜¯ç§æœ‰çš„ä¾èµ–é¡¹ä¸­ç”Ÿæˆæ–‡ä»¶çš„è·¯å¾„ï¼Œæˆ‘ä»¬çš„å·¥å…·é“¾å°±ä¼šäº§ç”Ÿé”™è¯¯ã€‚è¿™ç±»ä¼¼äºå½“TypeScriptæ„è¯†åˆ°å®ƒæ­£åœ¨ç”Ÿæˆé€šå¾€ä¾èµ–é¡¹çš„æ½œåœ¨å±é™©è·¯å¾„æ—¶å‘å‡ºçš„ç°æœ‰æ‰“å­—é”™è¯¯ã€‚</p><p>  error TS2742 : The inferred type of  &#39; ... &#39; cannot be named without a reference to  &#39; ... &#39; .This is likely not portable . A type annotation is necessary .</p><p>é”™è¯¯TS2742ï¼šåœ¨æ²¡æœ‰å¼•ç”¨&#39ï¼›...&#39ï¼›çš„æƒ…å†µä¸‹ï¼Œæ— æ³•å‘½åæ¨æ–­çš„&#39ï¼›...&#39ï¼›ç±»å‹ã€‚è¿™å¯èƒ½ä¸æ˜¯ä¾¿æºçš„ã€‚ç±»å‹æ‰¹æ³¨æ˜¯å¿…éœ€çš„ã€‚</p><p>  This informs the user to work around the issue, by explicitly annotating their exports. Or, in some cases, they need to update the dependency to publicise internal types by directly exporting them from a public package entrypoint.</p><p>è¿™ä¼šé€šçŸ¥ç”¨æˆ·é€šè¿‡æ˜¾å¼æ³¨é‡Šå…¶å¯¼å‡ºæ¥è§£å†³æ­¤é—®é¢˜ã€‚æˆ–è€…ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒä»¬éœ€è¦æ›´æ–°ä¾èµ–é¡¹ä»¥é€šè¿‡ç›´æ¥ä»å…¬å…±åŒ…å…¥å£ç‚¹å¯¼å‡ºæ¥å…¬å¼€å†…éƒ¨ç±»å‹ã€‚</p><p>  We look forward to TypeScript gaining first-class support for entrypoints so that workarounds like this are unnecessary.</p><p>æˆ‘ä»¬æœŸå¾…ç€Tyescriptè·å¾—å…¥å£ç‚¹çš„ä¸€æµæ”¯æŒï¼Œè¿™æ ·å°±ä¸éœ€è¦åƒè¿™æ ·çš„å˜é€šæ–¹æ³•äº†ã€‚</p><p>   Packages need to export  .d.ts declarations so that users can consume them. We choose to use the TypeScript  declaration option to generate  .d.ts files from the original  .ts files. Whilst itâ€™s possible to hand-write and maintain  .d.ts sibling files alongside regular code, this is less preferable because it is a hazard to keep them synchronized.</p><p>åŒ…éœ€è¦å¯¼å‡º.d.tså£°æ˜ï¼Œä»¥ä¾¿ç”¨æˆ·å¯ä»¥ä½¿ç”¨å®ƒä»¬ã€‚æˆ‘ä»¬é€‰æ‹©ä½¿ç”¨ç±»å‹è„šæœ¬å£°æ˜é€‰é¡¹ä»åŸå§‹çš„.tsæ–‡ä»¶ç”Ÿæˆ.d.tsæ–‡ä»¶ã€‚è™½ç„¶æ‰‹å†™å’Œç»´æŠ¤.d.tsåŒçº§æ–‡ä»¶å’Œå¸¸è§„ä»£ç æ˜¯å¯èƒ½çš„ï¼Œä½†è¿™æ ·åšä¸å¤ªå¯å–ï¼Œå› ä¸ºä¿æŒå®ƒä»¬åŒæ­¥æ˜¯ä¸€ç§å±é™©ã€‚</p><p> TypeScriptâ€™s declaration emit works well most of the time. One issue we found was that  sometimes TypeScript will inline types from a dependency into the generated types (#37151). This means the type definition is relocated and potentially duplicated, rather than being referenced via an import statement. With structural typing, the compiler is not compelled to ensure types are referenced from one definition site â€“ duplication of these types can be ok.</p><p>TypeScripçš„å£°æ˜åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹éƒ½å·¥ä½œå¾—å¾ˆå¥½ã€‚æˆ‘ä»¬å‘ç°çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œæœ‰æ—¶TypeScriptä¼šå°†ä¾èµ–é¡¹ä¸­çš„ç±»å‹å†…è”åˆ°ç”Ÿæˆçš„ç±»å‹ä¸­(#37151)ã€‚è¿™æ„å‘³ç€ç±»å‹å®šä¹‰è¢«é‡æ–°å®šä½å¹¶å¯èƒ½é‡å¤ï¼Œè€Œä¸æ˜¯é€šè¿‡IMPORTè¯­å¥å¼•ç”¨ã€‚ä½¿ç”¨ç»“æ„åŒ–ç±»å‹ï¼Œç¼–è¯‘å™¨ä¸å¿…ç¡®ä¿ç±»å‹æ˜¯ä»ä¸€ä¸ªå®šä¹‰ç«™ç‚¹å¼•ç”¨çš„-å¤åˆ¶è¿™äº›ç±»å‹æ˜¯å¯ä»¥çš„ã€‚</p><p> We have seen  extreme cases where this duplication has inflated declaration files from 7KB to 700KB.Â Thatâ€™s quite a lot of redundant code to download and parse.</p><p>æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†æç«¯çš„æƒ…å†µï¼Œè¿™ç§é‡å¤ä½¿å£°æ˜æ–‡ä»¶ä»7KBè†¨èƒ€åˆ°700KBã€‚è¿™æ˜¯ç›¸å½“å¤šçš„å†—ä½™ä»£ç ï¼Œéœ€è¦ä¸‹è½½å’Œè§£æã€‚</p><p>  Inlining of types within a package is not an ecosystem problem, because it is not externally visible. It becomes problematic when types are inlined across package boundaries, because it couples those two specific versions together. In our unpinned package system, packages can evol</p><p>åŒ…ä¸­ç±»å‹çš„å†…è”ä¸æ˜¯ç”Ÿæ€ç³»ç»Ÿé—®é¢˜ï¼Œå› ä¸ºå®ƒåœ¨å¤–éƒ¨ä¸å¯è§ã€‚å½“ç±»å‹è·¨åŒ…è¾¹ç•Œå†…è”æ—¶å°±ä¼šå‡ºç°é—®é¢˜ï¼Œå› ä¸ºå®ƒä¼šå°†è¿™ä¸¤ä¸ªç‰¹å®šç‰ˆæœ¬è€¦åˆåœ¨ä¸€èµ·ã€‚åœ¨æˆ‘ä»¬çš„éå›ºå®šåŒ…è£¹ç³»ç»Ÿä¸­ï¼ŒåŒ…è£¹å¯ä»¥ã€‚</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.techatbloomberg.com/blog/10-insights-adopting-typescript-at-scale/">https://www.techatbloomberg.com/blog/10-insights-adopting-typescript-at-scale/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/é‡‡ç”¨/">#é‡‡ç”¨</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/adopting/">#adopting</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ç±»å‹/">#ç±»å‹</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¾å›½/">#ç¾å›½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¨‹åº/">#ç¨‹åº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>