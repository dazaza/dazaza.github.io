<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>“面向对象”反模式</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">“面向对象”反模式</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-05-28 14:21:13</div><div class="page_narrow text-break page_content"><p>对于那些只读以上内容的人：我不是说所有的面向对象都是坏的！OOP，特别是经典的多态OOP，在实际代码中有一个当之无愧的位置。我要谈一谈我经常看到的一个非常具体的反模式：对应该是简单的自由函数的东西使用类。</p><p>我最初在Code Review StackExchange(2018年2月)上写了关于这段特定代码的文章。2018年4月，我根据同样的材料做了一次无录音的闪电演讲。</p><p>如果这类东西对你有吸引力，我建议你尽可能买一本Kernighan和Plauger的“编程风格的元素”(1974,1978年再版)。</p><p>在特定的学术环境中学习过C++的学生通常会抱着“一切都是对象”的心态来对待它。假设分配给他们的任务是计算值，那么他们的第一步是使用成员函数vc.culteResult()创建一个ValueComputer对象。</p><p>例如：一名学生被要求使用动态编程来计算一个矩形的不同多米诺骨牌拼图的数量。学生写道：</p><p>int main(){DominoTilingCounter tc(4，7)；//在4x7矩形std：：cout&lt；&lt；tc.count()&lt；&lt；&#39；\n&#39；；}。</p><p>在框定问题之后，他们继续实现DominoTilingCounter类。聪明的学生甚至添加了Mememory，这样count()成员函数在第二次调用时就不会太慢：</p><p>class DominoTilingCounter{int Height，width；bool Done=false；int tilingCount；int ComputeCount(int h，int w，std：：string_view prevedRow，int rowIdx){[.递归解决方案省略.]}public：显式DominoTilingCounter(int h，int w)：Height(H)，width(W){if(h=0||w=0||(w*h)%2！=0){。}}int count(){if(！Done){tilingCount=ComputeCount(Height，Width，&#34；&#34；，0)；Done=true；}return tilingCount；}}；</p><p>不幸的是，这段代码没有通过常量正确性测试：count()成员函数听起来应该是非修改的，但实际上它需要更新成员数据，因此不能是常量。</p><p>看：当您构造DominoTilingCounter对象TC时，它专门用于计算tc.count()，对吗？TC没有其他用途了？</p><p>再说一次：当您构造DominoTilingCounter对象时，它专门用于计算tc.count()。</p><p>class DominoTilingCounter{int Height，width；int tilingCount；int ComputeCount(int h，int w，std：：string_view prevedRow，int rowIdx){[.递归解决方案省略.]}public：显式DominoTilingCounter(int h，int w)：Height(H)，width(W){if(h=0||w=0||w=0||(w*h)%2！=0){tilingCount=0。}}int count()const{return tilingCount；}}；</p><p>它消除了Done数据成员，其全部目的是跟踪该空状态。(在C++17中，我们可能会为此使用std：：Optional；但是现在我们不必这样做了！)。</p><p>事实上，私有数据成员Height和Width现在也未使用。事实证明，我们使用它们只是为了将数据从构造函数传递到count()方法中的计算；现在计算在构造函数中进行，我们不再需要这些数据成员。我们的代码急剧缩减。</p><p>在原始代码中，学生的ComputeCount成员函数碰巧接受w，并且具有函数参数，而不是从Height和Width数据成员中读取它们。这是一个幸运的意外：ComputeCount没有使用DominoTilingCounter对象的任何数据成员，因此我们可以将其标记为静态。我们的代码现在如下所示：</p><p>class DominoTilingCounter{int tilingCount；static int culteCount(int h，int w，std：：string_view prevRow，int rowIdx){if(h==0||w==0|(w*h)%2！=0){return 0；}[.递归解决方案省略.]}public：显式DominoTilingCounter(int h，int w){tilingCount=ComputeCount(h，w，&#</p><p>最后一步是观察到整个类除了将赋值包装到int之外什么也不做！</p><p>int countDominoTilingsImpl(int h，int w，std：：string_view premisRow，int rowIdx){if(h==0||w==0|(w*h)%2！=0){return 0；}[.递归解决方案省略.]}int countDominoTilings(int h，int w){return countDominoTilingsImpl(h，w，&#34；&#34；，0。tc&lt；&lt；&39；\n&39；；}。</p><p>不再上课，不再担心Const，不再担心记忆(不管是好是坏，这都成了学生的问题)。我们最初的DominoTilingCounter对象不是线程安全的，但是现在我们也不必担心这一点。我们的代码大约短了十几行。</p><p>再说一次，这并不是说所有的课程都不好！事实上，这里讨论的反模式与生成器模式非常接近，生成器模式没有什么问题--只要需要，就是这样。我要说的是：</p><p>当您必须计算值时，不要编写ValueComputer类。改为编写COMPUTE_VALUE函数。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://quuxplusone.github.io/blog/2020/05/28/oo-antipattern/">https://quuxplusone.github.io/blog/2020/05/28/oo-antipattern/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/面向对象/">#面向对象</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/oo/">#oo</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/int/">#int</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>