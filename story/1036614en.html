<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Strï¼šå¦ä¸€ä¸ªCè¯­è¨€å­—ç¬¦ä¸²åº“Str: Yet another string library for C language</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Str: Yet another string library for C language<br/>Strï¼šå¦ä¸€ä¸ªCè¯­è¨€å­—ç¬¦ä¸²åº“</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-26 05:27:11</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/b4a39ad6c2e54c1a59c8a9dc7f845916.png"><img src="http://img2.diglog.com/img/2020/11/b4a39ad6c2e54c1a59c8a9dc7f845916.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Bored with developing the same functionality over and over again, unsatisfiedwith existing libraries, so decided to make the right one, once and forever.  ğŸ™‚</p><p>åŒå€¦äº†ä¸€æ¬¡åˆä¸€æ¬¡åœ°å¼€å‘ç›¸åŒçš„åŠŸèƒ½ï¼Œå¯¹ç°æœ‰çš„åº“ä¸æ»¡æ„ï¼Œå› æ­¤å†³å®šæ°¸ä¹…åœ°é€‰æ‹©åˆé€‚çš„åº“ã€‚ ğŸ™‚</p><p>    Just clone the project and copy (or symlink) the files  str.h and  str.c into your project,but please respect the  license.</p><p>    åªéœ€å…‹éš†é¡¹ç›®å¹¶å°†æ–‡ä»¶str.hå’Œstr.cå¤åˆ¶ï¼ˆæˆ–ç¬¦å·é“¾æ¥ï¼‰åˆ°æ‚¨çš„é¡¹ç›®ä¸­ï¼Œä½†æ˜¯è¯·éµå®ˆè®¸å¯ã€‚</p><p>   str s = str_null; str_join(&amp;s, str_lit(  &#34;,  &#34;), str_lit(  &#34;Here &#34;), str_lit(  &#34;there &#34;), str_lit(  &#34;and everywhere &#34;)); str_cat(&amp;s, s, str_lit(  &#34;... &#34;)); assert(str_eq(s, str_lit(  &#34;Here, there, and everywhere... &#34;))); str_free(s);</p><p>   str s = str_null; str_joinï¼ˆï¼†sï¼Œstr_litï¼ˆâ€œï¼Œâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ Hereâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ thereâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ and Anywhereâ€ï¼‰ï¼‰; str_catï¼ˆï¼†sï¼Œsï¼Œstr_litï¼ˆâ€œ ...â€ï¼‰ï¼‰; assertï¼ˆstr_eqï¼ˆsï¼Œstr_litï¼ˆâ€œåœ¨è¿™é‡Œï¼Œåˆ°å¤„éƒ½æœ‰...â€ï¼‰ï¼‰ï¼‰; str_freeï¼ˆsï¼‰;</p><p>  FILE*  const stream = fopen(...); int err = str_join(stream, str_lit(  &#34;,  &#34;),  str_lit(  &#34;Here &#34;), str_lit(  &#34;there &#34;), str_lit(  &#34;and everywhere... &#34;)); if(err !=  0) {   /* handle the error  */ }</p><p>  FILE * const stream = fopenï¼ˆ...ï¼‰; int err = str_joinï¼ˆstreamï¼Œstr_litï¼ˆâ€œï¼Œâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ Hereâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ thereâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ and Anywhere ...â€ï¼‰ï¼‰; ifï¼ˆerrï¼= 0ï¼‰{/ *å¤„ç†é”™è¯¯* /}</p><p>  Disclaimer: This is the good old C language, not C++ or Rust, so nothing can be enforcedon the language level, and certain discipline is required to make sure there is no corruptor leaked memory resulting from using this library.</p><p>  å…è´£å£°æ˜ï¼šè¿™æ˜¯ä¸€ç§å¾ˆå¥½çš„æ—§Cè¯­è¨€ï¼Œä¸æ˜¯C ++æˆ–Rustï¼Œå› æ­¤åœ¨è¯­è¨€çº§åˆ«ä¸Šä¸èƒ½å¼ºåˆ¶æ‰§è¡Œä»»ä½•æ“ä½œï¼Œå¹¶ä¸”éœ€è¦æŸäº›çºªå¾‹ä»¥ç¡®ä¿ä¸ä¼šç”±äºä½¿ç”¨æ­¤åº“è€Œå¯¼è‡´ç ´åè€…æ³„æ¼çš„å†…å­˜ã€‚</p><p> A string is represented by the type  str that maintains a pointer to some memory containingthe actual string. Objects of type  str are small enough (a struct of a  const char* and a  size_t)to be cheap to create, copy (pass by value), and move. The  str structure should be treatedas opaque (i.e., do not attempt to directly access or modify the fields in this structure).The strings are assumed to be immutable, like those in Java or Go, but only by means of  const char*pointers, so it is actually possible to write to such a string, although the required typecast to  char* offers at least some (mostly psychological) protection from modifying a stringby mistake.</p><p> å­—ç¬¦ä¸²ç”±ç±»å‹strè¡¨ç¤ºï¼Œè¯¥ç±»å‹ç»´æŠ¤æŒ‡å‘åŒ…å«å®é™…å­—ç¬¦ä¸²çš„æŸäº›å†…å­˜çš„æŒ‡é’ˆã€‚ strç±»å‹çš„å¯¹è±¡è¶³å¤Ÿå°ï¼ˆä¸€ä¸ªconst char *å’Œsize_tçš„ç»“æ„ï¼‰ï¼Œå¯ä»¥ä¾¿å®œåœ°åˆ›å»ºï¼Œå¤åˆ¶ï¼ˆæŒ‰å€¼ä¼ é€’ï¼‰å’Œç§»åŠ¨ã€‚åº”è¯¥å°†strç»“æ„è§†ä¸ºä¸é€æ˜çš„ï¼ˆå³ï¼Œä¸è¦å°è¯•ç›´æ¥è®¿é—®æˆ–ä¿®æ”¹æ­¤ç»“æ„ä¸­çš„å­—æ®µï¼‰ã€‚å‡å®šå­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„ï¼Œå°±åƒJavaæˆ–Goä¸­çš„å­—ç¬¦ä¸²ä¸€æ ·ï¼Œä½†åªèƒ½é€šè¿‡const char * pointerè¿›è¡Œï¼Œå› æ­¤å®é™…ä¸Šå¯ä»¥å†™å…¥è¿™æ ·çš„å­—ç¬¦ä¸²ï¼Œå°½ç®¡å¯¹char *çš„å¿…éœ€ç±»å‹è½¬æ¢è‡³å°‘æä¾›äº†ä¸€äº›ï¼ˆä¸»è¦æ˜¯å¿ƒç†ä¸Šçš„ï¼‰ä¿æŠ¤ï¼Œä»¥é˜²æ­¢é”™è¯¯ä¿®æ”¹å­—ç¬¦ä¸²ã€‚</p><p>  All string objects must be initialised. Uninitialised objects will causeundefined behaviour. Use the provided constructors, or  str_null for empty strings.</p><p>  æ‰€æœ‰å­—ç¬¦ä¸²å¯¹è±¡éƒ½å¿…é¡»åˆå§‹åŒ–ã€‚æœªåˆå§‹åŒ–çš„å¯¹è±¡å°†å¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚ä½¿ç”¨æä¾›çš„æ„é€ å‡½æ•°ï¼Œæˆ–å°†str_nullç”¨äºç©ºå­—ç¬¦ä¸²ã€‚</p><p> There are two kinds of  str objects: those actually owning the memory they point to, andnon-owning references. This property can be queried using  str_is_owner and  str_is_reffunctions, otherwise such objects are indistinguishable.</p><p>æœ‰ä¸¤ç§strå¯¹è±¡ï¼šé‚£äº›å®é™…ä¸Šæ‹¥æœ‰å®ƒä»¬æŒ‡å‘çš„å†…å­˜çš„å¯¹è±¡ï¼Œä»¥åŠæ²¡æœ‰æ‰€æœ‰è€…çš„å¼•ç”¨ã€‚å¯ä»¥ä½¿ç”¨str_is_ownerå’Œstr_is_reffunctionsæŸ¥è¯¢æ­¤å±æ€§ï¼Œå¦åˆ™æ­¤ç±»å¯¹è±¡æ˜¯æ— æ³•åŒºåˆ†çš„ã€‚</p><p> Non-owning string objects are safe to copy and assign to each other, as long as the memorythey refer to is valid. They do not need to be freed.  str_free is a no-op for referenceobjects. A reference object can be cheaply created from a C string, a string literal,or from a range of bytes.</p><p> åªè¦å®ƒä»¬æ‰€å¼•ç”¨çš„å†…å­˜æœ‰æ•ˆï¼Œéæ‰€æœ‰å­—ç¬¦ä¸²å¯¹è±¡å°±å¯ä»¥å®‰å…¨åœ°ç›¸äº’å¤åˆ¶å’Œåˆ†é…ã€‚ä»–ä»¬ä¸éœ€è¦è¢«é‡Šæ”¾ã€‚ str_freeæ˜¯å¯¹å¼•ç”¨å¯¹è±¡çš„ç¦æ­¢æ“ä½œã€‚å¼•ç”¨å¯¹è±¡å¯ä»¥å»‰ä»·åœ°ä»Cå­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²æ–‡å­—æˆ–å­—èŠ‚èŒƒå›´å†…åˆ›å»ºã€‚</p><p>  It is a good idea to have only one owning object per each allocated string, but sucha string can have many references to its underlying string, as long as those references do notoutlive the owning object.Sometimes this rule may be relaxed for code clarity, like in the above example wherethe owning object is passed directly to a function, but only if the function does notstore or release the object. When in doubt pass such an object via  str_ref.</p><p>  ä¸€ä¸ªå¥½ä¸»æ„æ˜¯æ¯ä¸ªåˆ†é…çš„å­—ç¬¦ä¸²ä¸­åªæœ‰ä¸€ä¸ªæ‹¥æœ‰å¯¹è±¡ï¼Œä½†æ˜¯è¿™æ ·çš„å­—ç¬¦ä¸²å¯ä»¥å¯¹å…¶åŸºç¡€å­—ç¬¦ä¸²å…·æœ‰è®¸å¤šå¼•ç”¨ï¼Œåªè¦è¿™äº›å¼•ç”¨ä¸è¶…è¿‡å…¶æ‹¥æœ‰å¯¹è±¡å³å¯ã€‚æœ‰æ—¶ï¼Œä¸ºäº†ç®€åŒ–ä»£ç ï¼Œå¯ä»¥æ”¾å®½æ­¤è§„åˆ™ï¼Œä¾‹å¦‚åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæ‹¥æœ‰å¯¹è±¡ç›´æ¥ä¼ é€’ç»™å‡½æ•°ï¼Œä½†å‰ææ˜¯è¯¥å‡½æ•°ä¸å­˜å‚¨æˆ–é‡Šæ”¾è¯¥å¯¹è±¡ã€‚å¦‚æœ‰ç–‘é—®ï¼Œè¯·é€šè¿‡str_refä¼ é€’æ­¤ç±»å¯¹è±¡ã€‚</p><p> Direct assignments (like  s2 = s1;) to owning objects will certainly leak memory, use str_assign function instead. In fact, this function can assign to any string object,owning or not, so it can be used everywhere, just to avoid any doubt.</p><p> å¯¹æ‹¥æœ‰å¯¹è±¡çš„ç›´æ¥åˆ†é…ï¼ˆä¾‹å¦‚s2 = s1;ï¼‰è‚¯å®šä¼šæ³„æ¼å†…å­˜ï¼Œè¯·æ”¹ç”¨str_assignå‡½æ•°ã€‚å®é™…ä¸Šï¼Œæ­¤å‡½æ•°å¯ä»¥åˆ†é…ç»™ä»»ä½•æ‹¥æœ‰æˆ–ä¸å…·æœ‰çš„å­—ç¬¦ä¸²å¯¹è±¡ï¼Œå› æ­¤å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨å®ƒï¼Œä»¥å…äº§ç”Ÿä»»ä½•ç–‘é—®ã€‚</p><p> There is no automatic memory management in C, so every owning object must be released atsome point, either directly by using  str_free function, or indirectly by assignment from str_assign or a similar function.</p><p> Cè¯­è¨€æ²¡æœ‰è‡ªåŠ¨å†…å­˜ç®¡ç†åŠŸèƒ½ï¼Œå› æ­¤å¿…é¡»åœ¨æŸä¸ªæ—¶å€™é‡Šæ”¾æ¯ä¸ªæ‹¥æœ‰çš„å¯¹è±¡ï¼Œç›´æ¥é€šè¿‡ä½¿ç”¨str_freeå‡½æ•°æˆ–é€šè¿‡ä»str_assignæˆ–ç±»ä¼¼å‡½æ•°è¿›è¡Œèµ‹å€¼æ¥é—´æ¥é‡Šæ”¾ã€‚</p><p> An owning object can be passed over to another location by using  str_move function. Thefunction resets its source object to an empty string.</p><p> å¯ä»¥ä½¿ç”¨str_moveå‡½æ•°å°†æ‹¥æœ‰çš„å¯¹è±¡ä¼ é€’åˆ°å¦ä¸€ä¸ªä½ç½®ã€‚è¯¥å‡½æ•°å°†å…¶æºå¯¹è±¡é‡ç½®ä¸ºç©ºå­—ç¬¦ä¸²ã€‚</p><p> It is technically possible to create a reference to a string that is notnull-terminated. The library accepts strings without null-terminators, but every new stringallocated by the library is guaranteed to be null-terminated.</p><p> ä»æŠ€æœ¯ä¸Šè®²ï¼Œå¯ä»¥åˆ›å»ºå¯¹éç©ºç»ˆæ­¢å­—ç¬¦ä¸²çš„å¼•ç”¨ã€‚è¯¥åº“æ¥å—æ²¡æœ‰ç©ºç»ˆæ­¢ç¬¦çš„å­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¿è¯åº“åˆ†é…çš„æ¯ä¸ªæ–°å­—ç¬¦ä¸²éƒ½ä»¥ç©ºç»ˆæ­¢ã€‚</p><p>  A string object can be constructed form any C string, string literal, or a range of bytes.The provided constructors are computationally cheap to apply. Depending on the constructor,the new object can either own the actual string it refers to, or be a non-owning reference.Constructors themselves do not allocate any memory.</p><p>å­—ç¬¦ä¸²å¯¹è±¡å¯ä»¥ç”±ä»»ä½•Cå­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²æ–‡å­—æˆ–ä¸€å®šèŒƒå›´çš„å­—èŠ‚æ„é€ ã€‚æä¾›çš„æ„é€ å‡½æ•°åœ¨è®¡ç®—ä¸Šä¾¿å®œã€‚æ ¹æ®æ„é€ å‡½æ•°çš„ä¸åŒï¼Œæ–°å¯¹è±¡å¯ä»¥æ‹¥æœ‰å…¶å¼•ç”¨çš„å®é™…å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥æ˜¯éæ‰€æœ‰è€…å¼•ç”¨ã€‚æ„é€ å‡½æ•°æœ¬èº«ä¸åˆ†é…ä»»ä½•å†…å­˜ã€‚</p><p>  Querying a property of a string object (like the length of the string via  str_len) is acheap operation.</p><p>  æŸ¥è¯¢å­—ç¬¦ä¸²å¯¹è±¡çš„å±æ€§ï¼ˆå¦‚é€šè¿‡str_lençš„å­—ç¬¦ä¸²é•¿åº¦ï¼‰æ˜¯acheapæ“ä½œã€‚</p><p>  C language does not allow for operator overloading, so this library provides a function str_assign that takes a string object and assigns it to the destination object, freeingany memory owned by the destination. It is generally recommended to use this functioneverywhere outside object initialisation.</p><p>  Cè¯­è¨€ä¸å…è®¸æ“ä½œç¬¦é‡è½½ï¼Œå› æ­¤è¯¥åº“æä¾›äº†str_assignå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—å­—ç¬¦ä¸²å¯¹è±¡å¹¶å°†å…¶åˆ†é…ç»™ç›®æ ‡å¯¹è±¡ï¼Œä»è€Œé‡Šæ”¾ç›®æ ‡æ‹¥æœ‰çš„æ‰€æœ‰å†…å­˜ã€‚é€šå¸¸å»ºè®®åœ¨å¤–éƒ¨å¯¹è±¡åˆå§‹åŒ–çš„ä»»ä½•åœ°æ–¹éƒ½ä½¿ç”¨æ­¤åŠŸèƒ½ã€‚</p><p> An existing object can be moved over to another location via  str_move function.The function resets the source object to  str_null to guarantee the correct move semantics.The value returned by  str_move may be either used to initialise a new object, orassigned to an existing object using  str_assign.</p><p> å¯ä»¥é€šè¿‡str_moveå‡½æ•°å°†ç°æœ‰å¯¹è±¡ç§»åŠ¨åˆ°å¦ä¸€ä¸ªä½ç½®ã€‚è¯¥å‡½æ•°å°†æºå¯¹è±¡é‡ç½®ä¸ºstr_nullï¼Œä»¥ç¡®ä¿æ­£ç¡®çš„ç§»åŠ¨è¯­ä¹‰ã€‚str_moveè¿”å›çš„å€¼å¯ä»¥ç”¨äºåˆå§‹åŒ–æ–°å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨åˆ†é…ç»™ç°æœ‰å¯¹è±¡str_assignã€‚</p><p>  String composition  functions can write their results to differentdestinations, depending on the  type of their  dest parameter:</p><p>  å­—ç¬¦ä¸²ç»„åˆå‡½æ•°å¯ä»¥å°†å…¶ç»“æœå†™å…¥ä¸åŒçš„ç›®çš„åœ°ï¼Œå…·ä½“å–å†³äºå…¶destå‚æ•°çš„ç±»å‹ï¼š</p><p> str*: result is written to allocated memory and the reference to it is stored in the string object;</p><p> str *ï¼šå°†ç»“æœå†™å…¥åˆ†é…çš„å†…å­˜ä¸­ï¼Œå¹¶å°†å¯¹å®ƒçš„å¼•ç”¨å­˜å‚¨åœ¨å­—ç¬¦ä¸²å¯¹è±¡ä¸­ï¼›</p><p> The composition functions return 0 on success, or the value of  errno as retrieved at the pointof failure (including  ENOMEM on memory allocation error).</p><p> ç»„åˆå‡½æ•°åœ¨æˆåŠŸæ—¶è¿”å›0ï¼Œæˆ–è€…åœ¨å¤±è´¥æ—¶è¿”å›errnoçš„å€¼ï¼ˆåŒ…æ‹¬åœ¨å†…å­˜åˆ†é…é”™è¯¯æ—¶è¿”å›çš„ENOMEMï¼‰ã€‚</p><p>  Just to make things more clear, here is the same code as in the example above, but with comments:</p><p>ä¸ºäº†ä½¿äº‹æƒ…æ›´æ¸…æ¥šï¼Œè¿™é‡Œçš„ä»£ç ä¸ä¸Šé¢çš„ç¤ºä¾‹ç›¸åŒï¼Œä½†å¸¦æœ‰æ³¨é‡Šï¼š</p><p> // declare a variable and initialise it with an empty stringstr s = str_null;  // join the given string literals around the separator (second parameter),  // storing the result in object &#34;s&#34; (first parameter); in this example we do not check  // the return values of the composition functions, thus ignoring memory allocation failures,  // which is probably not the best idea in general. str_join(&amp;s, str_lit(  &#34;,  &#34;), str_lit(  &#34;Here &#34;), str_lit(  &#34;there &#34;), str_lit(  &#34;and everywhere &#34;));  // create a new string concatenating &#34;s&#34; and a literal; the function does not modify its  // destination object &#34;s&#34; before the result is computed, also freeing the destination  // before the assignment, so it is safe to use &#34;s&#34; as both a parameter and a destination.  // note: we pass a copy of the owning object &#34;s&#34; as the second parameter, and here it is  // safe to do so because this particular function does not store or release its arguments. str_cat(&amp;s, s, str_lit(  &#34;... &#34;));  // check that we have got the expected result assert(str_eq(s, str_lit(  &#34;Here, there, and everywhere... &#34;)));  // finally, free the memory allocated for the string str_free(s);</p><p> //å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œå¹¶ç”¨ä¸€ä¸ªç©ºå­—ç¬¦ä¸²åˆå§‹åŒ–å®ƒs = str_null; //åœ¨åˆ†éš”ç¬¦ï¼ˆç¬¬äºŒä¸ªå‚æ•°ï¼‰å‘¨å›´åŠ å…¥ç»™å®šçš„å­—ç¬¦ä¸²æ–‡å­—ï¼Œ//å°†ç»“æœå­˜å‚¨åœ¨å¯¹è±¡â€œ sâ€ï¼ˆç¬¬ä¸€ä¸ªå‚æ•°ï¼‰ä¸­ï¼›åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä¸æ£€æŸ¥//ç»„åˆå‡½æ•°çš„è¿”å›å€¼ï¼Œå› æ­¤å¿½ç•¥äº†å†…å­˜åˆ†é…å¤±è´¥ï¼Œ//é€šå¸¸è¿™ä¸æ˜¯æœ€å¥½çš„ä¸»æ„ã€‚ str_joinï¼ˆï¼†sï¼Œstr_litï¼ˆâ€œï¼Œâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ Hereâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ thereâ€ï¼‰ï¼Œstr_litï¼ˆâ€œ and Anywhereâ€ï¼‰ï¼‰; //åˆ›å»ºä¸€ä¸ªæ–°å­—ç¬¦ä¸²ï¼Œå°†â€œ sâ€å’Œæ–‡å­—è¿æ¥èµ·æ¥ï¼›è¯¥å‡½æ•°ä¸ä¼šåœ¨è®¡ç®—ç»“æœä¹‹å‰ä¿®æ”¹//ç›®æ ‡å¯¹è±¡â€œ sâ€ï¼Œä¹Ÿä¸ä¼šåœ¨èµ‹å€¼ä¹‹å‰é‡Šæ”¾ç›®æ ‡//ï¼Œå› æ­¤å¯ä»¥å®‰å…¨åœ°å°†â€œ sâ€ç”¨ä½œå‚æ•°å’Œç›®æ ‡ã€‚ //æ³¨æ„ï¼šæˆ‘ä»¬å°†æ‹¥æœ‰å¯¹è±¡â€œ sâ€çš„å‰¯æœ¬ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ä¼ é€’ï¼Œåœ¨è¿™é‡Œ//æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºæ­¤ç‰¹å®šå‡½æ•°ä¸ä¼šå­˜å‚¨æˆ–é‡Šæ”¾å…¶å‚æ•°ã€‚ str_catï¼ˆï¼†sï¼Œsï¼Œstr_litï¼ˆâ€œ ...â€ï¼‰ï¼‰; //æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦è·å¾—äº†é¢„æœŸçš„ç»“æœassertï¼ˆstr_eqï¼ˆsï¼Œstr_litï¼ˆâ€œåœ¨è¿™é‡Œï¼Œåˆ°å¤„éƒ½æ˜¯...â€ï¼‰ï¼‰ï¼‰; //æœ€åï¼Œé‡Šæ”¾åˆ†é…ç»™å­—ç¬¦ä¸²str_freeï¼ˆsï¼‰çš„å†…å­˜ï¼›</p><p>     size_t str_len(const str s) Returns the number of bytes in the string referenced by the object.</p><p>     size_t str_lenï¼ˆconst str sï¼‰è¿”å›å¯¹è±¡å¼•ç”¨çš„å­—ç¬¦ä¸²ä¸­çš„å­—èŠ‚æ•°ã€‚</p><p> const char* str_ptr(const str s) Returns a pointer to the first byte of the string referenced by the object. The pointer is never NULL.</p><p> const char * str_ptrï¼ˆconst str sï¼‰è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘å¯¹è±¡å¼•ç”¨çš„å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ã€‚æŒ‡é’ˆæ°¸è¿œä¸ä¼šä¸ºNULLã€‚</p><p> const char* str_end(const str s) Returns a pointer to the next byte past the end of the string referenced by the object.The pointer is never NULL, but it is not guaranteed to point to any valid byte or location.For C strings it points to the terminating null character. For any given string  s the followingcondition is always satisfied:  str_end(s) == str_ptr(s) + str_len(s).</p><p> const char * str_endï¼ˆconst str sï¼‰è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘å¯¹è±¡æ‰€å¼•ç”¨çš„å­—ç¬¦ä¸²æœ«å°¾ä¹‹åçš„ä¸‹ä¸€ä¸ªå­—èŠ‚ã€‚è¯¥æŒ‡é’ˆæ°¸è¿œä¸ä¼šä¸ºNULLï¼Œä½†ä¸èƒ½ä¿è¯æŒ‡å‘ä»»ä½•æœ‰æ•ˆçš„å­—èŠ‚æˆ–ä½ç½®ã€‚å®ƒæŒ‡å‘ç»ˆæ­¢çš„ç©ºå­—ç¬¦ã€‚å¯¹äºä»»ä½•ç»™å®šçš„å­—ç¬¦ä¸²sï¼Œå§‹ç»ˆæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼šstr_endï¼ˆsï¼‰== str_ptrï¼ˆsï¼‰+ str_lenï¼ˆsï¼‰ã€‚</p><p>  bool str_is_owner(const str s) Returns &#34;true&#34; if the string object is the owner of the memory it references.</p><p>  bool str_is_ownerï¼ˆconst str sï¼‰å¦‚æœå­—ç¬¦ä¸²å¯¹è±¡æ˜¯å…¶å¼•ç”¨çš„å†…å­˜çš„æ‰€æœ‰è€…ï¼Œåˆ™è¿”å›â€œ trueâ€ã€‚</p><p> bool str_is_ref(const str s) Returns &#34;true&#34; if the string object does not own the memory it references.</p><p> bool str_is_refï¼ˆconst str sï¼‰å¦‚æœå­—ç¬¦ä¸²å¯¹è±¡ä¸æ‹¥æœ‰å…¶å¼•ç”¨çš„å†…å­˜ï¼Œåˆ™è¿”å›â€œ trueâ€ã€‚</p><p>   str str_ref(s) Constructs a non-owning object from either a null-terminated C string, or another  str object.Implemented as a macro.</p><p>str str_refï¼ˆsï¼‰ä»ä»¥nullç»ˆæ­¢çš„Cå­—ç¬¦ä¸²æˆ–å¦ä¸€ä¸ªstrå¯¹è±¡æ„é€ ä¸€ä¸ªéæ‰€æœ‰è€…å¯¹è±¡ã€‚å®ç°ä¸ºå®ã€‚</p><p> str str_ref_chars(const char* const s, const size_t n) Constructs a non-owning object referencing the given range of bytes.</p><p> str str_ref_charsï¼ˆconst char * const sï¼Œconst size_t nï¼‰æ„é€ ä¸€ä¸ªå¼•ç”¨ç»™å®šå­—èŠ‚èŒƒå›´çš„éæ‰€æœ‰è€…å¯¹è±¡ã€‚</p><p> str str_acquire_chars(const char* const s, const size_t n) Constructs an owning object for the specified range of bytes. The range should be safeto pass to  free(3) function.</p><p> str str_acquire_charsï¼ˆconst char * const sï¼Œconst size_t nï¼‰ä¸ºæŒ‡å®šçš„å­—èŠ‚èŒƒå›´æ„é€ ä¸€ä¸ªæ‹¥æœ‰å¯¹è±¡ã€‚è¯¥èŒƒå›´åº”è¯¥å¯ä»¥å®‰å…¨åœ°ä¼ é€’ç»™freeï¼ˆ3ï¼‰å‡½æ•°ã€‚</p><p> str str_acquire(const char* const s) Constructs an owning object from the given C string. The string should be safe to pass to free(3) function.</p><p> str str_acquireï¼ˆconst char * const sï¼‰ä»ç»™å®šçš„Cå­—ç¬¦ä¸²æ„é€ ä¸€ä¸ªæ‹¥æœ‰çš„å¯¹è±¡ã€‚è¯¥å­—ç¬¦ä¸²åº”è¯¥å¯ä»¥å®‰å…¨åœ°ä¼ é€’ç»™freeï¼ˆ3ï¼‰å‡½æ•°ã€‚</p><p>  void str_assign(str* const ps, const str s) Assigns the object  s to the object pointed to by  ps. Any memory owned by the targetobject is freed before the assignment.</p><p>  void str_assignï¼ˆstr * const psï¼Œconst str sï¼‰å°†å¯¹è±¡såˆ†é…ç»™psæŒ‡å‘çš„å¯¹è±¡ã€‚ç›®æ ‡å¯¹è±¡æ‹¥æœ‰çš„æ‰€æœ‰å†…å­˜åœ¨åˆ†é…å‰éƒ½ä¼šé‡Šæ”¾ã€‚</p><p> str str_move(str* const ps) Saves the given object to a temporary, resets the source object to  str_null, and thenreturns the saved object.</p><p> str str_moveï¼ˆstr * const psï¼‰å°†ç»™å®šå¯¹è±¡ä¿å­˜åˆ°ä¸´æ—¶å¯¹è±¡ï¼Œå°†æºå¯¹è±¡é‡ç½®ä¸ºstr_nullï¼Œç„¶åè¿”å›ä¿å­˜çš„å¯¹è±¡ã€‚</p><p> void str_clear(str* const ps) Sets the target object to  str_null after freeing any memory owned by the target.</p><p> void str_clearï¼ˆstr * const psï¼‰åœ¨é‡Šæ”¾ç›®æ ‡æ‹¥æœ‰çš„æ‰€æœ‰å†…å­˜ä¹‹åï¼Œå°†ç›®æ ‡å¯¹è±¡è®¾ç½®ä¸ºstr_nullã€‚</p><p>  int str_from_file(str* const dest, const char* const file_name) Reads the entire file (of up to 64MB by default, configuarable via  STR_MAX_FILE_SIZE) intothe destination string. Returns 0 on success, or the value of  errno on error.</p><p>int str_from_fileï¼ˆstr * const destï¼Œconst char * const file_nameï¼‰å°†æ•´ä¸ªæ–‡ä»¶ï¼ˆé»˜è®¤æƒ…å†µä¸‹æœ€å¤§ä¸º64MBï¼Œå¯é€šè¿‡STR_MAX_FILE_SIZEé…ç½®ï¼‰è¯»å…¥ç›®æ ‡å­—ç¬¦ä¸²ã€‚æˆåŠŸè¿”å›0ï¼Œé”™è¯¯è¿”å›errnoçš„å€¼ã€‚</p><p>  int str_cmp(const str s1, const str s2) Lexicographically compares the two string objects, with usual semantics.</p><p>  int str_cmpï¼ˆconst str s1ï¼Œconst str s2ï¼‰ç”¨é€šå¸¸çš„è¯­ä¹‰ä»å­—å…¸ä¸Šæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²å¯¹è±¡ã€‚</p><p>    bool str_has_prefix(const str s, const str prefix) Tests if the given string  s starts with the specified prefix.</p><p>    bool str_has_prefixï¼ˆconst str sï¼Œconst str prefixï¼‰æµ‹è¯•ç»™å®šçš„å­—ç¬¦ä¸²sæ˜¯å¦ä»¥æŒ‡å®šçš„å‰ç¼€å¼€å¤´ã€‚</p><p> bool str_has_suffix(const str s, const str suffix) Tests if the given string  s ends with the specified suffix.</p><p> bool str_has_suffixï¼ˆconst str sï¼Œconst str suffixï¼‰æµ‹è¯•ç»™å®šçš„å­—ç¬¦ä¸²sæ˜¯å¦ä»¥æŒ‡å®šçš„åç¼€ç»“å°¾ã€‚</p><p>  int str_cpy(dest, const str src) Copies the source string referenced by  src to the generic destination  dest. Returns 0 on success,or the value of  errno on failure.</p><p>  int str_cpyï¼ˆdestï¼Œconst str srcï¼‰å°†srcå¼•ç”¨çš„æºå­—ç¬¦ä¸²å¤åˆ¶åˆ°é€šç”¨ç›®æ ‡destã€‚å¦‚æœæˆåŠŸï¼Œåˆ™è¿”å›0ï¼›å¦‚æœå¤±è´¥ï¼Œåˆ™è¿”å›errnoçš„å€¼ã€‚</p><p> int str_cat_range(dest, const str* src, size_t count) Concatenates  count strings from the array starting at address  src, and writesthe result to the  generic destination  dest.Returns 0 on success, or the value of  errno on failure.</p><p> int str_cat_rangeï¼ˆdestï¼Œconst str * srcï¼Œsize_t countï¼‰ä»åœ°å€srcå¼€å§‹è¿æ¥æ•°ç»„ä¸­çš„è®¡æ•°å­—ç¬¦ä¸²ï¼Œå¹¶å°†ç»“æœå†™å…¥é€šç”¨ç›®æ ‡destã€‚æˆåŠŸè¿”å›0ï¼Œå¤±è´¥åˆ™è¿”å›errnoçš„å€¼ã€‚</p><p> int str_cat(dest, ...) Concatenates a variable list of  str arguments, and writes the result to the generic destination  dest.Returns 0 on success, or the value of  errno on failure.</p><p> int str_catï¼ˆdestï¼Œ...ï¼‰è¿æ¥ä¸€ä¸ªç”±strå‚æ•°ç»„æˆçš„å˜é‡åˆ—è¡¨ï¼Œå¹¶å°†ç»“æœå†™å…¥é€šç”¨ç›®æ ‡destã€‚æˆåŠŸåˆ™è¿”å›0ï¼Œå¤±è´¥åˆ™è¿”å›errnoçš„å€¼ã€‚</p><p> int str_join_range(dest, const str sep, const str* src, size_t count) Joins around  sep the  count strings from the array starting at address  src, and writesthe result to the  generic destination  dest.Returns 0 on success, or the value of  errno on failure.</p><p>int str_join_rangeï¼ˆdestï¼Œconst str sepï¼Œconst str * srcï¼Œsize_t countï¼‰ä»åœ°å€srcå¤„å¼€å§‹å°†æ•°ç»„ä¸­çš„è®¡æ•°å­—ç¬¦ä¸²è¿æ¥åˆ°sepå¤„ï¼Œå¹¶å°†ç»“æœå†™å…¥é€šç”¨ç›®æ ‡destã€‚æˆåŠŸè¿”å›0æˆ–errnoçš„å€¼å¤±è´¥ã€‚</p><p> int str_join(dest, sep, ...) Joins around  sep the variable list of  str arguments, and writes the result to the generic destination  dest.Returns 0 on success, or the value of  errno on failure.</p><p> int str_joinï¼ˆdestï¼Œsepï¼Œ...ï¼‰åœ¨sepé™„è¿‘åŠ å…¥strå‚æ•°çš„å˜é‡åˆ—è¡¨ï¼Œå¹¶å°†ç»“æœå†™å…¥é€šç”¨ç›®æ ‡destã€‚æˆåŠŸåˆ™è¿”å›0ï¼Œå¤±è´¥åˆ™è¿”å›errnoçš„å€¼ã€‚</p><p>  void str_sort_range(const str_cmp_func cmp, str* const array, const size_t count) Sorts the given array of  str objects using the given comparison function. A numberof typically used comparison functions is also provided:</p><p>  void str_sort_rangeï¼ˆconst str_cmp_func cmpï¼Œstr * const arrayï¼Œconst size_t countï¼‰ä½¿ç”¨ç»™å®šçš„æ¯”è¾ƒå‡½æ•°å¯¹ç»™å®šçš„strå¯¹è±¡æ•°ç»„è¿›è¡Œæ’åºã€‚è¿˜æä¾›äº†è®¸å¤šé€šå¸¸ä½¿ç”¨çš„æ¯”è¾ƒåŠŸèƒ½ï¼š</p><p>  const str* str_search_range(const str key, const str* const array, const size_t count) Binary search for the given key. The input array must be sorted using  str_order_asc.Returns a pointer to the string matching the key, or NULL.</p><p>  const str * str_search_rangeï¼ˆconst str keyï¼Œconst str * const arrayï¼Œconst size_t countï¼‰äºŒè¿›åˆ¶æœç´¢ç»™å®šçš„é”®ã€‚è¾“å…¥æ•°ç»„å¿…é¡»ä½¿ç”¨str_order_ascæ’åºã€‚è¿”å›æŒ‡å‘ä¸é”®åŒ¹é…çš„å­—ç¬¦ä¸²çš„æŒ‡é’ˆï¼Œå³NULLã€‚</p><p> size_t str_partition_range(bool (*pred)(const str), str* const array, const size_t count) Reorders the string objects in the given range in such a way that all elements for whichthe predicate  pred returns &#34;true&#34; precede the elements for which predicate  predreturns &#34;false&#34;. Returns the number of preceding objects.</p><p> size_t str_partition_rangeï¼ˆboolï¼ˆ* predï¼‰ï¼ˆconst strï¼‰ï¼Œstr * const arrayï¼Œconst size_t countï¼‰å¯¹ç»™å®šèŒƒå›´å†…çš„å­—ç¬¦ä¸²å¯¹è±¡é‡æ–°æ’åºï¼Œä»¥ä½¿è°“è¯predè¿”å›å…¶â€œ trueâ€çš„æ‰€æœ‰å…ƒç´ åœ¨è¦æ›¿æ¢å…¶çš„å…ƒç´ ä¹‹å‰è°“è¯predreturnsè¿”å›â€œ falseâ€ã€‚è¿”å›å…ˆå‰å¯¹è±¡çš„æ•°é‡ã€‚</p><p> size_t str_unique_range(str* const array, const size_t count) Reorders the string objects in the given range in such a way that there are two partitions:one where each object is unique within the input range, and another partition with all theremaining objects. The unique partition is stored at the beginning of the array, and issorted in ascending order, followed by the partition with all remaining objects.Returns the number of unique objects.</p><p> size_t str_unique_rangeï¼ˆstr * const arrayï¼Œconst size_t countï¼‰ä»¥ç»™å®šèŒƒå›´å†…çš„å­—ç¬¦ä¸²å¯¹è±¡é‡æ–°æ’åºçš„æ–¹å¼ï¼Œä½¿å…¶å…·æœ‰ä¸¤ä¸ªåˆ†åŒºï¼šä¸€ä¸ªåˆ†åŒºï¼Œæ¯ä¸ªå¯¹è±¡åœ¨è¾“å…¥èŒƒå›´å†…æ˜¯å”¯ä¸€çš„ï¼Œå¦ä¸€ä¸ªåˆ†åŒºåŒ…å«æ‰€æœ‰å‰©ä½™çš„å¯¹è±¡ã€‚å”¯ä¸€åˆ†åŒºå­˜å‚¨åœ¨æ•°ç»„çš„å¼€å¤´ï¼Œå¹¶æŒ‰å‡åºæ’åºï¼Œç„¶åæ˜¯å¸¦æœ‰æ‰€æœ‰å‰©ä½™å¯¹è±¡çš„åˆ†åŒºã€‚è¿”å›å”¯ä¸€å¯¹è±¡çš„æ•°é‡ã€‚</p><p>  for_each_codepoint(var_name, src_string) A macro that expands to a loop iterating over the given string  src_string (of type  str) by UTF-32code points. On each iteration the variable  var_name (of type  char32_t) is assignedthe value of the next valid UTF-32 code point from the source string. Upon exit from the loop thevariable has one on the following values:</p><p>  for_each_codepointï¼ˆvar_nameï¼Œsrc_stringï¼‰ä¸€ä¸ªå®ï¼Œæ‰©å±•ä¸ºå¾ªç¯ï¼Œä»¥UTF-32codeç‚¹éå†ç»™å®šå­—ç¬¦ä¸²src_stringï¼ˆç±»å‹ä¸ºstrï¼‰çš„å¾ªç¯ã€‚åœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼Œå°†å˜é‡var_nameï¼ˆç±»å‹ä¸ºchar32_tï¼‰åˆ†é…ç»™æºå­—ç¬¦ä¸²ä¸­ä¸‹ä¸€ä¸ªæœ‰æ•ˆUTF-32ä»£ç ç‚¹çš„å€¼ã€‚ä»å¾ªç¯é€€å‡ºåï¼Œå˜é‡åœ¨ä»¥ä¸‹å€¼ä¸­å…·æœ‰ä¸€ä¸ªï¼š</p><p>  The source string is expected to be encoded in the  current program locale, as set by the mostrecent call to  setlocale(3).</p><p>å¦‚æœ€è¿‘å¯¹setlocaleï¼ˆ3ï¼‰çš„è°ƒç”¨æ‰€è®¾ç½®çš„ï¼Œæºå­—ç¬¦ä¸²åº”åœ¨å½“å‰ç¨‹åºåŒºåŸŸè®¾ç½®ä¸­ç¼–ç ã€‚</p><p>  # include   &lt;uchar.h &gt;...str s = ...... char32_t c;	  // variable to receive UTF-32 values on each iteration for_each_codepoint(c, s){	  /* process c  */} if(c != CPI_END_OF_STRING){	  /* handle error  */}</p><p>  ï¼ƒinclude  ... str s = ...... char32_t c; //ç”¨äºåœ¨æ¯æ¬¡è¿­ä»£ä¸­æ¥æ”¶UTF-32å€¼çš„å˜é‡for_each_codepointï¼ˆcï¼Œsï¼‰{/ *å¤„ç†c * /} ifï¼ˆcï¼= CPI_END_OF_STRINGï¼‰{/ *å¤„ç†é”™è¯¯* /}</p><p>   file-to-str: The script takes a file (text or binary) and a C variable name, andwrites to  stdout C source code where the variable (of type  str) is definedand initialised with the content of the file.</p><p>   file-to-strï¼šè„šæœ¬ä½¿ç”¨ä¸€ä¸ªæ–‡ä»¶ï¼ˆæ–‡æœ¬æˆ–äºŒè¿›åˆ¶æ–‡ä»¶ï¼‰å’Œä¸€ä¸ªCå˜é‡åç§°ï¼Œå¹¶å†™å…¥æ ‡å‡†è¾“å‡ºCæºä»£ç ï¼Œå…¶ä¸­å®šä¹‰äº†å˜é‡ï¼ˆç±»å‹ä¸ºstrï¼‰å¹¶ä½¿ç”¨æ–‡ä»¶çš„å†…å®¹è¿›è¡Œåˆå§‹åŒ–ã€‚</p><p> gen-char-class: Generates character classification functions that do the same as their isw*() counterparts under the current locale as specified by  LC_ALL environment variable.Run  tools/gen-char-class --help for further details, or  tools/gen-char-class --spaceto see an example of its output.</p><p> gen-char-classï¼šç”Ÿæˆå­—ç¬¦åˆ†ç±»å‡½æ•°ï¼Œå…¶åŠŸèƒ½ä¸LC_ALLç¯å¢ƒå˜é‡æŒ‡å®šçš„å½“å‰è¯­è¨€ç¯å¢ƒä¸‹çš„isw *ï¼ˆï¼‰å¯¹åº”å‡½æ•°ç›¸åŒã€‚è¿è¡Œtools / gen-char-class --helpäº†è§£æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œæˆ–è€…è¿è¡Œtools / gen-char-class --spaceæŸ¥çœ‹å…¶è¾“å‡ºç¤ºä¾‹ã€‚</p><p>  The library requires at least a C11 compiler. So far has been tested on Linux Mint 19.3 and 20,with  gcc versions up to 9.3.0, and  clang versions up to 10.0.0; and on ALT Linux 9.1 forElbrus, with  lcc version 1.25.09.</p><p>  è¯¥åº“è‡³å°‘éœ€è¦ä¸€ä¸ªC11ç¼–è¯‘å™¨ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå·²ç»åœ¨Linux Mint 19.3å’Œ20ä¸Šè¿›è¡Œäº†æµ‹è¯•ï¼Œgccç‰ˆæœ¬æœ€é«˜ä¸º9.3.0ï¼Œclangç‰ˆæœ¬æœ€é«˜ä¸º10.0.0ï¼›åœ¨ALT Linux 9.1 forElbrusä¸Šï¼Œä»¥åŠlccç‰ˆæœ¬1.25.09ã€‚</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/maxim2266/str">https://github.com/maxim2266/str</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/å­—ç¬¦ä¸²/">#å­—ç¬¦ä¸²</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/string/">#string</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/str/">#str</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>