<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>å¦‚ä½•é‡æ–°è®¡ç®—ç”µå­è¡¨æ ¼</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">å¦‚ä½•é‡æ–°è®¡ç®—ç”µå­è¡¨æ ¼</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 04:44:45</div><div class="page_narrow text-break page_content"><p>Letâ€™s say Iâ€™m ordering burritos for my two friends while they quar up in Jersey City, and want to calculate the total price of my order:</p><p>å‡è®¾æˆ‘æ­£åœ¨ä¸ºæˆ‘çš„ä¸¤ä¸ªæœ‹å‹åœ¨æ³½è¥¿åŸæ’é˜Ÿæ—¶ç‚¹ç‰ç±³ç…é¥¼ï¼Œå¹¶æƒ³è¦è®¡ç®—æˆ‘ç‚¹çš„æ€»ä»·ï¼š</p><p>  Itâ€™s a little confusing to follow the flow of data in a spreadsheet when itâ€™s written like that, so I hope you donâ€™t mind this equivalent diagram that represents it as a graph:</p><p>åœ¨è¿™æ ·ç¼–å†™çš„ç”µå­è¡¨æ ¼ä¸­è·Ÿè¸ªæ•°æ®æµæœ‰ç‚¹ä»¤äººå›°æƒ‘ï¼Œæ‰€ä»¥æˆ‘å¸Œæœ›æ‚¨ä¸ä»‹æ„å°†å…¶è¡¨ç¤ºä¸ºå›¾å½¢çš„ç­‰ä»·å›¾ï¼š</p><p>  Weâ€™re rounding the cost of an El Farolito super vegi burrito to $8, so assuming the per-burrito delivery toll remains at just $2 per burrito, it looks like the total for our two burritos will be $20.</p><p>æˆ‘ä»¬æŠŠEl Farolitoè¶…çº§ç´ é£Ÿç‰ç±³ç…é¥¼çš„ä»·æ ¼å››èˆäº”å…¥åˆ°8ç¾å…ƒï¼Œæ‰€ä»¥å‡è®¾æ¯ä¸ªç‰ç±³ç…é¥¼çš„é€è´§è´¹ç”¨ä»ç„¶åªæœ‰2ç¾å…ƒï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸¤ä¸ªç‰ç±³ç…é¥¼çš„æ€»ä»·çœ‹èµ·æ¥å°†æ˜¯20ç¾å…ƒã€‚</p><p> Oh no, I completely forgot! One of my friends loves to wolf down multiple burritos at a time, so I actually want to place an order for three burritos. If I update  Num Burritos, a naÃ¯ve spreadsheet engine might recompute the entire document, recalculating first the cells with no inputs, and then recalculating any cell whose inputs are ready until weâ€™ve finished every cell. In this case, weâ€™d first calculate  Burrito Price and  Num Burritos, then  Burrito Price w Ship, and then a new final  Total of $30.</p><p>å“¦ï¼Œä¸ï¼Œæˆ‘å®Œå…¨å¿˜äº†ï¼æˆ‘çš„ä¸€ä¸ªæœ‹å‹å–œæ¬¢ä¸€æ¬¡ç‹¼åè™å’½åœ°åƒä¸‹å¤šä¸ªç‰ç±³ç…é¥¼ï¼Œæ‰€ä»¥æˆ‘çœŸçš„æƒ³ç‚¹ä¸‰ä¸ªç‰ç±³ç…é¥¼ã€‚å¦‚æœæˆ‘æ›´æ–°num Burritosï¼Œä¸€ä¸ªå¹¼ç¨šçš„ç”µå­è¡¨æ ¼å¼•æ“å¯èƒ½ä¼šé‡æ–°è®¡ç®—æ•´ä¸ªæ–‡æ¡£ï¼Œé¦–å…ˆé‡æ–°è®¡ç®—æ²¡æœ‰è¾“å…¥çš„å•å…ƒæ ¼ï¼Œç„¶åé‡æ–°è®¡ç®—è¾“å…¥å‡†å¤‡å°±ç»ªçš„ä»»ä½•å•å…ƒæ ¼ï¼Œç›´åˆ°æˆ‘ä»¬å®Œæˆæ¯ä¸ªå•å…ƒæ ¼ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆè®¡ç®—ç‰ç±³ç…é¥¼ä»·æ ¼å’Œç‰ç±³ç…é¥¼æ•°é‡ï¼Œç„¶åè®¡ç®—ç‰ç±³ç…é¥¼ä»·æ ¼wèˆ¹ï¼Œç„¶åè®¡ç®—æ–°çš„æœ€ç»ˆæ€»è®¡30ç¾å…ƒã€‚</p><p>  This simple strategy of recalculating the whole document may sound wasteful, but itâ€™s actually already  better than VisiCalc, the first spreadsheet software ever made, and the first so-called â€œkiller appâ€, responsible for popularizing the Apple II. VisiCalc would repeatedly recalculate cells from left-to-right and top-to-bottom, sweeping over them again and again until none of them changed. Despite this â€œinterestingâ€ algorithm, VisiCalc remained the dominant spreadsheet software for four years. Its reign ended in 1983, when Lotus 1-2-3 swept the market with â€œnatural-order recalculationâ€,  as described by Tracy Robnett Licklider in Byte Magazine:</p><p>è¿™ç§ç®€å•çš„é‡æ–°è®¡ç®—æ•´ä¸ªæ–‡æ¡£çš„ç­–ç•¥å¬èµ·æ¥å¯èƒ½å¾ˆæµªè´¹ï¼Œä½†å®é™…ä¸Šå·²ç»æ¯”VisiCalcæ›´å¥½äº†ã€‚VisiCalcæ˜¯æœ‰å²ä»¥æ¥ç¬¬ä¸€æ¬¾ç”µå­è¡¨æ ¼è½¯ä»¶ï¼Œä¹Ÿæ˜¯ç¬¬ä¸€æ¬¾æ‰€è°“çš„â€œæ€æ‰‹çº§åº”ç”¨â€ï¼Œè´Ÿè´£æ¨å¹¿Apple IIã€‚VisiCalcä¼šä»å·¦åˆ°å³ã€ä»ä¸Šåˆ°ä¸‹åå¤é‡æ–°è®¡ç®—å•å…ƒæ ¼ï¼Œä¸€éåˆä¸€éåœ°æ‰«æï¼Œç›´åˆ°å®ƒä»¬éƒ½æ²¡æœ‰æ”¹å˜ã€‚å°½ç®¡æœ‰è¿™ç§â€œæœ‰è¶£â€çš„ç®—æ³•ï¼ŒVisiCalcåœ¨å››å¹´çš„æ—¶é—´é‡Œä»ç„¶æ˜¯å ä¸»å¯¼åœ°ä½çš„ç”µå­è¡¨æ ¼è½¯ä»¶ã€‚å®ƒçš„ç»Ÿæ²»åœ¨1983å¹´ç»“æŸï¼Œå½“æ—¶è²èŠ±1-2-3ä»¥â€œè‡ªç„¶é¡ºåºé‡æ–°è®¡ç®—â€å¸­å·å¸‚åœºï¼Œæ­£å¦‚Tracy Robnett Licklideråœ¨Byte Magazineä¸­æ‰€æè¿°çš„é‚£æ ·ï¼š</p><p> Lotus 1-2-3 exploited natural-order recalculation, although it also supported VisiCalcâ€™s row- and column-order modes. Natural-order recalculation maintained a cell dependency list and recalculated a cell before recalculating cells that depended on it.</p><p>Lotus1-2-3åˆ©ç”¨äº†è‡ªç„¶é¡ºåºé‡æ–°è®¡ç®—ï¼Œå°½ç®¡å®ƒä¹Ÿæ”¯æŒVisiCalcçš„è¡Œé¡ºåºå’Œåˆ—é¡ºåºæ¨¡å¼ã€‚è‡ªç„¶é¡ºåºé‡æ–°è®¡ç®—ç»´æŠ¤äº†ä¸€ä¸ªå•å…ƒæ ¼ä¾èµ–åˆ—è¡¨ï¼Œå¹¶åœ¨é‡æ–°è®¡ç®—ä¾èµ–äºè¯¥å•å…ƒæ ¼çš„å•å…ƒæ ¼ä¹‹å‰é‡æ–°è®¡ç®—è¯¥å•å…ƒæ ¼ã€‚</p><p> Lotus 1-2-3 implemented the â€œrecalculate everythingâ€ strategy weâ€™ve shown above, and for the first decade of spreadsheets, that was as good as it got. Yes, we recalculate every cell in the document, but at least we only recalculate every cell once.</p><p>Lotus1-2-3å®ç°äº†æˆ‘ä»¬ä¸Šé¢å±•ç¤ºçš„â€œé‡æ–°è®¡ç®—æ‰€æœ‰å†…å®¹â€ç­–ç•¥ï¼Œå¯¹äºç”µå­è¡¨æ ¼çš„ç¬¬ä¸€ä¸ªåå¹´æ¥è¯´ï¼Œè¿™å·²ç»æ˜¯æœ€å¥½çš„ç»“æœäº†ã€‚æ˜¯çš„ï¼Œæˆ‘ä»¬é‡æ–°è®¡ç®—æ–‡æ¡£ä¸­çš„æ¯ä¸ªå•å…ƒæ ¼ï¼Œä½†è‡³å°‘æˆ‘ä»¬åªé‡æ–°è®¡ç®—æ¯ä¸ªå•å…ƒæ ¼ä¸€æ¬¡ã€‚</p><p>  Great point, header 2. In my three burrito example thereâ€™s no reason to recompute  Burrito Price w Ship, because changing the number of burritos we order canâ€™t possibly influence the per-burrito price. In 1989, one of Lotusâ€™ competitors realized this, and created SuperCalc5, presumably naming it after the theory of super burritos at the core of this algorithm. SuperCalc5 recalculated â€œonly cells dependent on changed cellsâ€, which would make updating the burrito count look more like this:</p><p>å¾ˆå¥½ï¼Œæ ‡é¢˜2ã€‚åœ¨æˆ‘çš„ä¸‰ä¸ªç‰ç±³ç…é¥¼ä¾‹å­ä¸­ï¼Œæ²¡æœ‰ç†ç”±é‡æ–°è®¡ç®—ç‰ç±³ç…é¥¼çš„ä»·æ ¼ï¼Œå› ä¸ºæ”¹å˜æˆ‘ä»¬è®¢è´­çš„ç‰ç±³ç…é¥¼çš„æ•°é‡ä¸å¯èƒ½å½±å“æ¯ä¸ªç‰ç±³ç…é¥¼çš„ä»·æ ¼ã€‚1989å¹´ï¼Œè²èŠ±çš„ä¸€ä¸ªç«äº‰å¯¹æ‰‹æ„è¯†åˆ°äº†è¿™ä¸€ç‚¹ï¼Œäºæ˜¯åˆ›é€ äº†SuperCalc5ï¼Œå¤§æ¦‚æ˜¯æ ¹æ®è¯¥ç®—æ³•æ ¸å¿ƒçš„è¶…çº§ç‰ç±³ç…é¥¼ç†è®ºå‘½åçš„ã€‚SuperCalc5é‡æ–°è®¡ç®—äº†â€œåªæœ‰ç»†èƒä¾èµ–äºæ”¹å˜çš„ç»†èƒâ€ï¼Œè¿™ä½¿å¾—ç‰ç±³ç…é¥¼çš„æ›´æ–°æ•°é‡çœ‹èµ·æ¥æ›´åƒè¿™æ ·ï¼š</p><p>  By only updating a cell when one of its inputs changes, we can avoid recalculating  Burrito Price w Ship. In this case, it saves just a single addition, but on larger spreadsheets it can save quite a bit of time! Unfortunately, we now have another problem. Letâ€™s say my friends now want meat burritos, which cost a dollar more, and simultaneously El Farolito adds a $2 fee paid per-order, regardless of how many burritos you order. Before any formula outputs are recalculated, our graph might look like this:</p><p>é€šè¿‡åªåœ¨å•å…ƒæ ¼çš„ä¸€ä¸ªè¾“å…¥å‘ç”Ÿå˜åŒ–æ—¶æ›´æ–°å•å…ƒæ ¼ï¼Œæˆ‘ä»¬å¯ä»¥é¿å…é‡æ–°è®¡ç®—ç‰ç±³ç…é¥¼ä»·æ ¼w Shipã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒåªèŠ‚çœäº†ä¸€æ¬¡æ·»åŠ ï¼Œä½†åœ¨è¾ƒå¤§çš„ç”µå­è¡¨æ ¼ä¸­ï¼Œå®ƒå¯ä»¥èŠ‚çœç›¸å½“å¤šçš„æ—¶é—´ï¼ä¸å¹¸çš„æ˜¯ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰äº†å¦ä¸€ä¸ªé—®é¢˜ã€‚æ¯”æ–¹è¯´ï¼Œæˆ‘çš„æœ‹å‹ç°åœ¨æƒ³è¦è‚‰ç‰ç±³ç…é¥¼ï¼Œä»·æ ¼é«˜å‡ºä¸€ç¾å…ƒï¼ŒåŒæ—¶El Farolitoè¿˜å¢åŠ äº†æ¯å•2ç¾å…ƒçš„è´¹ç”¨ï¼Œæ— è®ºä½ ç‚¹äº†å¤šå°‘ç‰ç±³ç…é¥¼ã€‚åœ¨é‡æ–°è®¡ç®—ä»»ä½•å…¬å¼è¾“å‡ºä¹‹å‰ï¼Œæˆ‘ä»¬çš„å›¾è¡¨å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š</p><p>  Since there are two updated cells here, we have a problem. Should we recalculate  Burrito Price first, or  Total? Ideally, we first calculate  Burrito Price, notice that its output has changed, then recalculate  Burrito Price w Ship, and finally recalculate  Total. However, if we instead recalculate  Total first, weâ€™ll have to recalculate it a second time once the new $9 burrito price propagates down. If we donâ€™t calculate cells in the right order, this algorithm isnâ€™t better than recalculating the whole document. In some cases, itâ€™s as slow as VisiCalc!</p><p>å› ä¸ºè¿™é‡Œæœ‰ä¸¤ä¸ªæ›´æ–°çš„å•å…ƒæ ¼ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰é—®é¢˜ã€‚æˆ‘ä»¬åº”è¯¥å…ˆé‡æ–°è®¡ç®—ç‰ç±³ç…é¥¼ä»·æ ¼ï¼Œè¿˜æ˜¯æ€»ä»·ï¼Ÿç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬é¦–å…ˆè®¡ç®—ç‰ç±³ç…é¥¼ä»·æ ¼ï¼Œæ³¨æ„å®ƒçš„äº§é‡å‘ç”Ÿäº†å˜åŒ–ï¼Œç„¶åé‡æ–°è®¡ç®—ç‰ç±³ç…é¥¼ä»·æ ¼wèˆ¹ï¼Œæœ€åé‡æ–°è®¡ç®—æ€»ä»·æ ¼ã€‚ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬é¦–å…ˆé‡æ–°è®¡ç®—Totalï¼Œé‚£ä¹ˆä¸€æ—¦æ–°çš„9ç¾å…ƒç‰ç±³ç…é¥¼ä»·æ ¼å‘ä¸‹ä¼ æ’­ï¼Œæˆ‘ä»¬å°†ä¸å¾—ä¸é‡æ–°è®¡ç®—å®ƒã€‚å¦‚æœæˆ‘ä»¬æ²¡æœ‰æŒ‰æ­£ç¡®çš„é¡ºåºè®¡ç®—å•å…ƒæ ¼ï¼Œè¿™ä¸ªç®—æ³•å¹¶ä¸æ¯”é‡æ–°è®¡ç®—æ•´ä¸ªæ–‡æ¡£æ›´å¥½ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒçš„é€Ÿåº¦å’ŒVisiCalcä¸€æ ·æ…¢ï¼</p><p> Clearly, itâ€™s important for us to figure out the right order to update our cells. Broadly, there are two solutions to this problem: dirty marking and topological sorting.</p><p>æ˜¾ç„¶ï¼Œæ‰¾å‡ºæ›´æ–°ç»†èƒçš„æ­£ç¡®é¡ºåºå¯¹æˆ‘ä»¬æ¥è¯´å¾ˆé‡è¦ã€‚å¤§ä½“ä¸Šï¼Œè¿™ä¸ªé—®é¢˜æœ‰ä¸¤ç§è§£å†³æ–¹æ¡ˆï¼šè„æ ‡è®°å’Œæ‹“æ‰‘æ’åºã€‚</p><p> This first solution involves marking all cells downstream from an edit as dirty. For instance, when we update  Burrito Price, we would mark the downstream cells  Burrito Price w Ship and  Total as dirty, even before doing any recalculations:</p><p>ç¬¬ä¸€ä¸ªè§£å†³æ–¹æ¡ˆæ¶‰åŠå°†ç¼–è¾‘ä¸‹æ¸¸çš„æ‰€æœ‰å•å…ƒæ ¼æ ‡è®°ä¸ºè„ã€‚ä¾‹å¦‚ï¼Œå½“æˆ‘ä»¬æ›´æ–°Burrito Priceæ—¶ï¼Œç”šè‡³åœ¨æ‰§è¡Œä»»ä½•é‡æ–°è®¡ç®—ä¹‹å‰ï¼Œæˆ‘ä»¬éƒ½ä¼šå°†ä¸‹æ¸¸å•å…ƒæ ¼Burrito Price w Shipå’ŒTotalæ ‡è®°ä¸ºè„ï¼š</p><p>  Then, in a loop, we find a dirty cell that has no dirty inputs, and recalculate it. When there are no dirty cells left, weâ€™re done! This solves our ordering problem. Thereâ€™s one downside though â€” if a cell is recalculated and we find its new output to be the same as its previous output, weâ€™ll still recalculate downstream cells! A little bit of extra logic can avoid actually running the formula trouble in this case, but we unfortunately still waste time marking and unmarking a lot of cells as dirty.</p><p>ç„¶åï¼Œåœ¨å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªæ²¡æœ‰è„è¾“å…¥çš„è„å•å…ƒæ ¼ï¼Œå¹¶é‡æ–°è®¡ç®—å®ƒã€‚å½“æ²¡æœ‰è‚®è„çš„ç‰¢æˆ¿æ—¶ï¼Œæˆ‘ä»¬å°±å®Œäº†ï¼è¿™è§£å†³äº†æˆ‘ä»¬çš„æ’åºé—®é¢˜ã€‚ä¸è¿‡ï¼Œè¿™ä¹Ÿæœ‰ä¸€ä¸ªç¼ºç‚¹--å¦‚æœé‡æ–°è®¡ç®—äº†ä¸€ä¸ªå•å…ƒæ ¼ï¼Œè€Œæˆ‘ä»¬å‘ç°å®ƒçš„æ–°è¾“å‡ºä¸ä¹‹å‰çš„è¾“å‡ºç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»ç„¶ä¼šé‡æ–°è®¡ç®—ä¸‹æ¸¸çš„å•å…ƒæ ¼ï¼åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¨å¾®å¢åŠ ä¸€ç‚¹é€»è¾‘å°±å¯ä»¥é¿å…å®é™…è¿è¡Œå…¬å¼çš„éº»çƒ¦ï¼Œä½†ä¸å¹¸çš„æ˜¯ï¼Œæˆ‘ä»¬ä»ç„¶æµªè´¹æ—¶é—´å°†è®¸å¤šå•å…ƒæ ¼æ ‡è®°å’Œå–æ¶ˆæ ‡è®°ä¸ºè„çš„ã€‚</p><p> The second solution is topological sorting. If a cell has no inputs, we mark its height as 0. If a cell has inputs, we mark its height as the maximum of the heights of its inputs, plus one. This guarantees all cells have a greater height than any of their inputs, so we just keep track of all cells with a changed input, always choosing the cell with the lowest height to recalculate first:</p><p>ç¬¬äºŒç§è§£å†³æ–¹æ¡ˆæ˜¯æ‹“æ‰‘æ’åºã€‚å¦‚æœå•å…ƒæ ¼æ²¡æœ‰è¾“å…¥ï¼Œæˆ‘ä»¬å°†å…¶é«˜åº¦æ ‡è®°ä¸º0ã€‚å¦‚æœå•å…ƒæ ¼æœ‰è¾“å…¥ï¼Œæˆ‘ä»¬å°†å…¶é«˜åº¦æ ‡è®°ä¸ºå…¶è¾“å…¥é«˜åº¦çš„æœ€å¤§å€¼åŠ 1ã€‚è¿™ç¡®ä¿äº†æ‰€æœ‰å•å…ƒæ ¼çš„é«˜åº¦éƒ½å¤§äºå®ƒä»¬çš„ä»»ä½•è¾“å…¥ï¼Œå› æ­¤æˆ‘ä»¬åªè·Ÿè¸ªè¾“å…¥å‘ç”Ÿæ›´æ”¹çš„æ‰€æœ‰å•å…ƒæ ¼ï¼Œå§‹ç»ˆé¦–å…ˆé€‰æ‹©é«˜åº¦æœ€ä½çš„å•å…ƒæ ¼è¿›è¡Œé‡æ–°è®¡ç®—ï¼š</p><p>  In our double-update example,  Burrito Price and  Total would be initially added to the recalculation heap.  Burrito Price has lesser height, and would be recalculated first. Since its output changes, we then would add  Burrito Price w Ship to the recalculation heap, and since it too has less height than  Total, it would be recalculated before we finally recalculate  Total.</p><p>åœ¨æˆ‘ä»¬çš„åŒé‡æ›´æ–°ç¤ºä¾‹ä¸­ï¼ŒBurrito Priceå’ŒTotalæœ€åˆå°†è¢«æ·»åŠ åˆ°é‡æ–°è®¡ç®—å †ä¸­ã€‚ç‰ç±³ç…é¥¼ä»·æ ¼è¾ƒä½ï¼Œå°†é¦–å…ˆé‡æ–°è®¡ç®—ã€‚ç”±äºå®ƒçš„è¾“å‡ºå‘ç”Ÿäº†å˜åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å°†æŠŠBurrito Price w Shipæ·»åŠ åˆ°é‡æ–°è®¡ç®—å †ä¸­ï¼Œå¹¶ä¸”ç”±äºå®ƒçš„é«˜åº¦ä¹Ÿå°äºTotalï¼Œå› æ­¤åœ¨æˆ‘ä»¬æœ€ç»ˆé‡æ–°è®¡ç®—Totalä¹‹å‰å°†é‡æ–°è®¡ç®—å®ƒã€‚</p><p> This has a big advantage over the first solution: no cell is ever marked dirty unless one of its inputs actually change. However, it requires we keep all cells pending recalculation in sorted order. If we use a heap, this results in an  O(n log n) slowdown, so in the worst case, asymptotically slower than Lotus 1-2-3â€™s strategy of recalculating everything.</p><p>ä¸ç¬¬ä¸€ç§è§£å†³æ–¹æ¡ˆç›¸æ¯”ï¼Œè¿™æœ‰ä¸€ä¸ªå¾ˆå¤§çš„ä¼˜åŠ¿ï¼šä»»ä½•ç»†èƒéƒ½ä¸ä¼šè¢«æ ‡è®°ä¸ºè„çš„ï¼Œé™¤éå®ƒçš„ä¸€ä¸ªè¾“å…¥ç¡®å®å‘ç”Ÿäº†å˜åŒ–ã€‚ä½†æ˜¯ï¼Œå®ƒè¦æ±‚æˆ‘ä»¬å°†æ‰€æœ‰ç­‰å¾…é‡æ–°è®¡ç®—çš„å•å…ƒæ ¼æŒ‰æ’åºé¡ºåºä¿å­˜ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨å †ï¼Œè¿™å°†å¯¼è‡´O(Nlogn)å‡æ…¢ï¼Œå› æ­¤åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæ¯”Lotus 1-2-3çš„é‡æ–°è®¡ç®—ä¸€åˆ‡çš„ç­–ç•¥æ¸è¿‘æ…¢ã€‚</p><p> Modern-day Excel uses  a combination of dirty marking and topological sorting, which you can read more about in their docs.</p><p>ç°ä»£çš„Excelä½¿ç”¨è„æ ‡è®°å’Œæ‹“æ‰‘æ’åºçš„ç»„åˆï¼Œä½ å¯ä»¥åœ¨ä»–ä»¬çš„æ–‡æ¡£ä¸­é˜…è¯»æ›´å¤šå…³äºè¿™ä¸€ç‚¹çš„å†…å®¹ã€‚</p><p>  Weâ€™ve now more or less reached the algorithms used in modern-day spreadsheet recalculation. Unfortunately, I suspect there is basically no business case to be made for ever improving it further. The few people with the problem â€œmy Excel spreadsheet is too slowâ€ have already written enough Excel formulas that migration to any other platform is impossible. Fortunately, I have no understanding of business, and so weâ€™re going to look at further improvements anyway.</p><p>æˆ‘ä»¬ç°åœ¨æˆ–å¤šæˆ–å°‘å·²ç»è¾¾åˆ°äº†ç°ä»£ç”µå­è¡¨æ ¼é‡æ–°è®¡ç®—ä¸­ä½¿ç”¨çš„ç®—æ³•ã€‚ä¸å¹¸çš„æ˜¯ï¼Œæˆ‘æ€€ç–‘åŸºæœ¬ä¸Šæ²¡æœ‰ä»»ä½•å•†ä¸šç†ç”±å¯ä»¥ç»§ç»­æ”¹è¿›å®ƒã€‚æœ‰â€œæˆ‘çš„Excelç”µå­è¡¨æ ¼å¤ªæ…¢â€é—®é¢˜çš„å°‘æ•°äººå·²ç»ç¼–å†™äº†è¶³å¤Ÿå¤šçš„Excelå…¬å¼ï¼Œä»¥è‡³äºä¸å¯èƒ½ç§»æ¤åˆ°ä»»ä½•å…¶ä»–å¹³å°ã€‚å¹¸è¿çš„æ˜¯ï¼Œæˆ‘å¯¹å•†ä¸šä¸€æ— æ‰€çŸ¥ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— è®ºå¦‚ä½•éƒ½è¦è€ƒè™‘è¿›ä¸€æ­¥çš„æ”¹è¿›ã€‚</p><p> Beyond caching, one of the cool aspects of a spreadsheet-style computation graph is we can only calculate the cells that weâ€™re interested in. This is sometimes called lazy computation, or demand-driven computation. As a more concrete example, hereâ€™s a slightly expanded burrito spreadsheet graph. This example is the same as before, but weâ€™ve added what is best described as â€œsalsa calculationsâ€. Each burrito contains 40 grams of salsa, and we perform a quick multiplication to know how much salsa is in our entire order. In this case, since our order has three burritos, thereâ€™s a total of 120 grams of salsa in our entire order.</p><p>é™¤äº†ç¼“å­˜ä¹‹å¤–ï¼Œç”µå­è¡¨æ ¼æ ·å¼çš„è®¡ç®—å›¾çš„ä¸€ä¸ªå¾ˆé…·çš„æ–¹é¢æ˜¯ï¼Œæˆ‘ä»¬åªèƒ½è®¡ç®—æˆ‘ä»¬æ„Ÿå…´è¶£çš„å•å…ƒæ ¼ã€‚è¿™æœ‰æ—¶è¢«ç§°ä¸ºæ‡’æƒ°è®¡ç®—ï¼Œæˆ–éœ€æ±‚é©±åŠ¨è®¡ç®—ã€‚ä½œä¸ºä¸€ä¸ªæ›´å…·ä½“çš„ä¾‹å­ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªç•¥å¾®æ‰©å±•çš„ç‰ç±³ç…é¥¼ç”µå­è¡¨æ ¼å›¾è¡¨ã€‚è¿™ä¸ªç¤ºä¾‹ä¸å‰é¢çš„ç›¸åŒï¼Œä½†æ˜¯æˆ‘ä»¬æ·»åŠ äº†æœ€æ°å½“çš„æè¿°ä¸ºâ€œsalsaè®¡ç®—â€ã€‚æ¯ä¸ªå¢¨è¥¿å“¥ç‰ç±³ç…é¥¼å«æœ‰40å…‹è¨å°”è¨é…±ï¼Œæˆ‘ä»¬è¿›è¡Œå¿«é€Ÿä¹˜æ³•ï¼Œä»¥çŸ¥é“æˆ‘ä»¬æ•´ä¸ªè®¢å•ä¸­æœ‰å¤šå°‘è¨å°”è¨é…±ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå› ä¸ºæˆ‘ä»¬ç‚¹çš„æ˜¯ä¸‰ä¸ªç‰ç±³ç…é¥¼ï¼Œæ‰€ä»¥æˆ‘ä»¬æ•´ä¸ªè®¢å•æ€»å…±æœ‰120å…‹è¾£é…±ã€‚</p><p>  Of course, astute readers will have spotted the problem here already: knowing the total weight of salsa in an order is a pretty useless measurement. Who cares that itâ€™s 120 grams? What am I supposed to do with this information?? Unfortunately, a regular spreadsheet would waste cycles calculating  Salsa In Order, even if we donâ€™t want it recalculated most of the time.</p><p>å½“ç„¶ï¼Œç²¾æ˜çš„è¯»è€…å¯èƒ½å·²ç»åœ¨è¿™é‡Œå‘ç°äº†é—®é¢˜ï¼šçŸ¥é“ä¸€ä»½è®¢å•ä¸­è¨å°”è¨çš„æ€»é‡é‡æ˜¯ä¸€ä¸ªç›¸å½“æ— ç”¨çš„è¡¡é‡æ ‡å‡†ã€‚è°ä¼šåœ¨ä¹å®ƒæœ‰120å…‹å‘¢ï¼Ÿæˆ‘è¯¥æ€ä¹ˆå¤„ç†è¿™äº›ä¿¡æ¯ï¼Ÿï¼Ÿä¸å¹¸çš„æ˜¯ï¼Œä¸€ä¸ªå¸¸è§„çš„ç”µå­è¡¨æ ¼ä¼šæµªè´¹æŒ‰é¡ºåºè®¡ç®—Salsaçš„å‘¨æœŸï¼Œå³ä½¿æˆ‘ä»¬ä¸å¸Œæœ›å®ƒåœ¨å¤§éƒ¨åˆ†æ—¶é—´å†…é‡æ–°è®¡ç®—ã€‚</p><p> This is where demand-driven recalculation can help. If we could somehow specify that weâ€™re only interested in the output of  Total, we could only recompute that cell and its dependencies, and skip touching  Salsa In Order and  Salsa Per Burrito. Letâ€™s call  Total an  observed cell, since weâ€™re trying to look at its output. We can also call both  Total and its three dependencies  necessary cells, since theyâ€™re necessary to compute some observed cell.  Salsa In Order and  Salsa Per Burrito would be aptly described as  unnecessary.</p><p>è¿™å°±æ˜¯éœ€æ±‚é©±åŠ¨çš„é‡æ–°è®¡ç®—å¯ä»¥æä¾›å¸®åŠ©çš„åœ°æ–¹ã€‚å¦‚æœæˆ‘ä»¬èƒ½ä»¥æŸç§æ–¹å¼æŒ‡å®šæˆ‘ä»¬åªå¯¹Totalçš„è¾“å‡ºæ„Ÿå…´è¶£ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½é‡æ–°è®¡ç®—è¯¥å•å…ƒæ ¼åŠå…¶ä¾èµ–é¡¹ï¼Œå¹¶è·³è¿‡æŒ‰é¡ºåºè§¦åŠSalsaå’ŒæŒ‰ç‰ç±³ç…é¥¼è§¦åŠSalsaã€‚è®©æˆ‘ä»¬ç§°Totalä¸ºè§‚å¯Ÿåˆ°çš„å•å…ƒæ ¼ï¼Œå› ä¸ºæˆ‘ä»¬è¯•å›¾æŸ¥çœ‹å®ƒçš„è¾“å‡ºã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ç§°TotalåŠå…¶ä¸‰ä¸ªä¾èµ–é¡¹ä¸ºå¿…éœ€å•å…ƒï¼Œå› ä¸ºå®ƒä»¬æ˜¯è®¡ç®—æŸäº›è§‚å¯Ÿåˆ°çš„å•å…ƒæ‰€å¿…éœ€çš„ã€‚é¡ºåºæ²™æ‹‰å’Œç‰ç±³ç…é¥¼æ²™æ‹‰æ°å¦‚å…¶åˆ†åœ°è¢«æè¿°ä¸ºä¸å¿…è¦çš„ã€‚</p><p> Some folks on the Rust team created the  Salsa framework to solve this problem, clearly naming it after the unnecessary salsa calculations their computers were wasting cycles on. Salsa is really cool, and Iâ€™m sure  they can explain how it works better than I can. Very roughly, they use revision numbers to track whether a cell needs recalculation. Any mutation to a formula or input increments the global revision number, and every cell tracks two revisions:  verified_at to track the revision its output was last brought up-to-date, and  changed_at to track the revision its output last actually changed.</p><p>Rustå›¢é˜Ÿä¸­çš„ä¸€äº›äººåˆ›å»ºäº†Salsaæ¡†æ¶æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ˜¾ç„¶æ˜¯æ ¹æ®ä»–ä»¬çš„è®¡ç®—æœºæµªè´¹å‘¨æœŸè¿›è¡Œçš„ä¸å¿…è¦çš„Salsaè®¡ç®—æ¥å‘½åçš„ã€‚è¨å°”è¨èˆçœŸçš„å¾ˆé…·ï¼Œæˆ‘ç›¸ä¿¡ä»–ä»¬èƒ½æ¯”æˆ‘è§£é‡Šå¾—æ›´å¥½ã€‚ç²—ç•¥åœ°è¯´ï¼Œä»–ä»¬ä½¿ç”¨ä¿®è®¢å·æ¥è·Ÿè¸ªå•å…ƒæ ¼æ˜¯å¦éœ€è¦é‡æ–°è®¡ç®—ã€‚å…¬å¼æˆ–è¾“å…¥çš„ä»»ä½•å˜åŒ–éƒ½ä¼šå¢åŠ å…¨å±€ä¿®è®¢å·ï¼Œæ¯ä¸ªå•å…ƒæ ¼éƒ½ä¼šè·Ÿè¸ªä¸¤ä¸ªä¿®è®¢ï¼šverized_atè·Ÿè¸ªå…¶è¾“å‡ºä¸Šä¸€æ¬¡æ›´æ–°çš„ä¿®è®¢ï¼ŒChanged_atè·Ÿè¸ªå…¶è¾“å‡ºä¸Šä¸€æ¬¡å®é™…æ›´æ”¹çš„ä¿®è®¢ã€‚</p><p>  When the user indicates theyâ€™d like a fresh value for  Total, weâ€™d first recursively recalculate any cell necessary to  Total, skipping cells if their  last_updated revision is equal to the global revision. Once the dependencies of  Total are up-to-date, we only rerun the actual formula in  Total if either  Burrito Price w Ship or  Num Burrito have a  changed_at revision greater than the  verified_at revision of  Total. This is great for Salsaâ€™s purposes in the rust-analyzer, where simplicity is important and each cell takes a significant amount of time to compute. However, we can see the disadvantages in our burrito graph above â€” if  Salsa Per Burrito constantly changes, our global revision number will frequently tick up. This will make each observation of  Total walk the three cells necessary to it, even though none of those cells have actually changed. No formulas will be recalculated, but if the graph is large, repeatedly walking all of a cellâ€™s dependencies could get expensive.</p><p>å½“ç”¨æˆ·è¡¨ç¤ºä»–ä»¬æƒ³è¦ä¸€ä¸ªæ–°çš„Totalå€¼æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆé€’å½’åœ°é‡æ–°è®¡ç®—Totalæ‰€éœ€çš„ä»»ä½•å•å…ƒæ ¼ï¼Œå¦‚æœå•å…ƒæ ¼çš„LAST_UPDATEDä¿®è®¢ç‰ˆç­‰äºå…¨å±€ä¿®è®¢ç‰ˆï¼Œåˆ™è·³è¿‡è¯¥å•å…ƒæ ¼ã€‚ä¸€æ—¦Totalçš„ç›¸å…³æ€§æ˜¯æœ€æ–°çš„ï¼Œå¦‚æœBurrito Price w Shipæˆ–Num Burritoçš„Changed_atç‰ˆæœ¬å¤§äºTotalçš„VERIFIED_ATç‰ˆæœ¬ï¼Œæˆ‘ä»¬åªä¼šé‡æ–°è¿è¡ŒTotalä¸­çš„å®é™…å…¬å¼ã€‚è¿™å¯¹äºSASAåœ¨é”ˆèš€åˆ†æä»ªä¸­çš„ç”¨é€”éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºç®€å•å¾ˆé‡è¦ï¼Œæ¯ä¸ªç»†èƒéƒ½éœ€è¦å¤§é‡çš„æ—¶é—´æ¥è®¡ç®—ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸Šé¢çš„ç‰ç±³ç…é¥¼å›¾è¡¨ä¸­çœ‹åˆ°ç¼ºç‚¹--å¦‚æœæ¯ä¸ªç‰ç±³ç…é¥¼çš„è¨å°”è¨ä¸æ–­å˜åŒ–ï¼Œæˆ‘ä»¬çš„å…¨çƒä¿®è®¢å·å°†é¢‘ç¹ä¸Šå‡ã€‚è¿™å°†ä½¿é“è¾¾å°”çš„æ¯ä¸€æ¬¡è§‚å¯Ÿéƒ½èµ°åˆ°å®ƒæ‰€å¿…éœ€çš„ä¸‰ä¸ªç»†èƒä¸­ï¼Œå³ä½¿è¿™äº›ç»†èƒå®é™…ä¸Šéƒ½æ²¡æœ‰æ”¹å˜ã€‚ä¸ä¼šé‡æ–°è®¡ç®—å…¬å¼ï¼Œä½†å¦‚æœå›¾è¡¨å¾ˆå¤§ï¼Œé‡å¤éå†ä¸€ä¸ªå•å…ƒæ ¼çš„æ‰€æœ‰ä¾èµ–é¡¹å¯èƒ½ä¼šå¾ˆæ˜‚è´µã€‚</p><p>  Instead of inventing new algorithms for demand-driven spreadsheets, what if we instead draw from the two classical spreadsheet algorithms mentioned earlier: dirty marking and topological sorting? As you might imagine, a demand-driven model complicates both of these, but both are still viable.</p><p>ä¸å…¶ä¸ºéœ€æ±‚é©±åŠ¨çš„ç”µå­è¡¨æ ¼å‘æ˜æ–°çš„ç®—æ³•ï¼Œä¸å¦‚å€Ÿé‰´å‰é¢æåˆ°çš„ä¸¤ç§ç»å…¸ç”µå­è¡¨æ ¼ç®—æ³•ï¼šè„æ ‡è®°å’Œæ‹“æ‰‘æ’åºã€‚æ­£å¦‚ä½ å¯èƒ½æƒ³è±¡çš„é‚£æ ·ï¼Œéœ€æ±‚é©±åŠ¨çš„æ¨¡å¼ä½¿è¿™ä¸¤ç§æ¨¡å¼éƒ½å˜å¾—å¤æ‚ï¼Œä½†è¿™ä¸¤ç§æ¨¡å¼ä»ç„¶å¯è¡Œã€‚</p><p> Letâ€™s first look at dirty marking. As before, when we change a cellâ€™s formula, we mark all downstream cells as dirty. So if we update  Salsa Per Burrito, it would look something like this:</p><p>è®©æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹è‚®è„çš„æ ‡è®°ã€‚ä¸ä»¥å‰ä¸€æ ·ï¼Œå½“æˆ‘ä»¬æ›´æ”¹å•å…ƒæ ¼çš„å…¬å¼æ—¶ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰ä¸‹æ¸¸å•å…ƒæ ¼æ ‡è®°ä¸ºè„ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æŒ‰ç‰ç±³ç…é¥¼æ›´æ–°Salsaï¼Œå®ƒå°†å¦‚ä¸‹æ‰€ç¤ºï¼š</p><p>  However, instead of immediately recomputing  all cells that are dirty, we wait for the user to observe a cell. Then we run Salsaâ€™s algorithm on the observed cell, but instead of reverifying dependencies with outdated  verified_at revision numbers, we instead only reverify cells marked as dirty. This is the technique used by  Adapton. Youâ€™ll note that when we observe  Total, weâ€™ll find it isnâ€™t dirty, and so we can skip the graph walk that Salsa would have performed!</p><p>ç„¶è€Œï¼Œæˆ‘ä»¬å¹¶ä¸æ˜¯ç«‹å³é‡æ–°è®¡ç®—æ‰€æœ‰è„çš„ç»†èƒï¼Œè€Œæ˜¯ç­‰å¾…ç”¨æˆ·è§‚å¯Ÿä¸€ä¸ªç»†èƒã€‚ç„¶åï¼Œæˆ‘ä»¬åœ¨è§‚å¯Ÿåˆ°çš„å•å…ƒæ ¼ä¸Šè¿è¡ŒSalsaçš„ç®—æ³•ï¼Œä½†ä¸æ˜¯ç”¨è¿‡æ—¶çš„VERIFIED_ATä¿®è®¢å·æ¥éªŒè¯ä¾èµ–å…³ç³»ï¼Œè€Œæ˜¯åªéªŒè¯æ ‡è®°ä¸ºè„çš„å•å…ƒæ ¼ã€‚è¿™æ˜¯Adaptonä½¿ç”¨çš„æŠ€æœ¯ã€‚æ‚¨ä¼šæ³¨æ„åˆ°ï¼Œå½“æˆ‘ä»¬è§‚å¯ŸTotalæ—¶ï¼Œæˆ‘ä»¬ä¼šå‘ç°å®ƒå¹¶ä¸è„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è·³è¿‡Salsaæ‰§è¡Œçš„å›¾å½¢éå†ï¼</p><p> If we instead decide to observe  Salsa In Order, weâ€™ll find it  is marked as dirty, and so weâ€™ll reverify and recompute both  Salsa Per Burrito and  Salsa In Order. Even here, there are benefits over using just revision numbers, since weâ€™ll be able to skip a recursive walk on the still-clean  Num Burritos cell.</p><p>å¦‚æœæˆ‘ä»¬å†³å®šæŒ‰é¡ºåºè§‚å¯ŸSalsaï¼Œæˆ‘ä»¬ä¼šå‘ç°å®ƒè¢«æ ‡è®°ä¸ºè„çš„ï¼Œå› æ­¤æˆ‘ä»¬å°†é‡æ–°æ£€æŸ¥å¹¶é‡æ–°è®¡ç®—æ¯ç‰ç±³ç…é¥¼çš„Salsaå’ŒæŒ‰é¡ºåºè®¡ç®—çš„Salsaã€‚å³ä½¿åœ¨è¿™é‡Œï¼Œåªä½¿ç”¨ä¿®è®¢å·ä¹Ÿæœ‰å¥½å¤„ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥è·³è¿‡åœ¨ä»ç„¶å¹²å‡€çš„Num Burritoså•å…ƒæ ¼ä¸Šçš„é€’å½’éå†ã€‚</p><p> Demand-driven dirty marking performs fantastically when the set of cells weâ€™re trying to observe changes frequently. Unfortunately, this has the same downsides as the dirty marking algorithm from before. If a cell with many downstream cells changes, we may waste a lot of time marking and unmarking cells as dirty, even if their inputs wonâ€™t actually have changed when we go to recalculate them. In the worst case, each changes causes us to mark the entire graph as dirty, which would give us the same ~order of magnitude performance as Salsaâ€™s algorithm.</p><p>å½“æˆ‘ä»¬è¯•å›¾è§‚å¯Ÿçš„ä¸€ç»„ç»†èƒé¢‘ç¹å˜åŒ–æ—¶ï¼Œéœ€æ±‚é©±åŠ¨çš„è„æ ‡è®°è¡¨ç°å‡ºæƒŠäººçš„æ•ˆæœã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ä»¥å‰çš„è„æ ‡è®°ç®—æ³•æœ‰ç›¸åŒçš„ç¼ºç‚¹ã€‚å¦‚æœä¸€ä¸ªåŒ…å«è®¸å¤šä¸‹æ¸¸å•å…ƒçš„å•å…ƒå‘ç”Ÿå˜åŒ–ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæµªè´¹å¤§é‡æ—¶é—´æ¥æ ‡è®°å’Œå–æ¶ˆæ ‡è®°ä¸ºè„çš„å•å…ƒï¼Œå³ä½¿å½“æˆ‘ä»¬é‡æ–°è®¡ç®—å®ƒä»¬æ—¶ï¼Œå®ƒä»¬çš„è¾“å…¥å®é™…ä¸Šå¹¶æ²¡æœ‰æ”¹å˜ã€‚åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæ¯ä¸€æ¬¡æ›´æ”¹éƒ½ä¼šå¯¼è‡´æˆ‘ä»¬å°†æ•´ä¸ªå›¾æ ‡è®°ä¸ºè„çš„ï¼Œè¿™å°†ç»™æˆ‘ä»¬å¸¦æ¥ä¸Salsaç®—æ³•ç›¸åŒçš„~æ•°é‡çº§çš„æ€§èƒ½ã€‚</p><p> Moving on from dirty marking, we can also adapt topological sorting for demand-driven computations. This is the technique used by Jane Streetâ€™s  Incremental library, and requires  major tricks to get right. Before we added demand-driven computations, our topological sorting algorithm used a heap to determine which cell would be recomputed next. But now, we only want to recompute cells that are  necessary. How? We donâ€™t want to walk the entire tree from our observed cells like Adapton, since a complete tree walk defeats the entire purpose of topological sorting, and would give us performance characteristics similar to Adapton.</p><p>é™¤äº†è‚®è„çš„æ ‡è®°ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è°ƒæ•´æ‹“æ‰‘æ’åºä»¥é€‚åº”éœ€æ±‚é©±åŠ¨çš„è®¡ç®—ã€‚è¿™æ˜¯Jane Streetçš„å¢é‡å›¾ä¹¦é¦†ä½¿ç”¨çš„æŠ€æœ¯ï¼Œéœ€è¦ä¸€äº›é‡è¦æŠ€å·§æ‰èƒ½æ­£ç¡®ä½¿ç”¨ã€‚åœ¨æ·»åŠ éœ€æ±‚é©±åŠ¨çš„è®¡ç®—ä¹‹å‰ï¼Œæˆ‘ä»¬çš„æ‹“æ‰‘æ’åºç®—æ³•ä½¿ç”¨å †æ¥ç¡®å®šä¸‹ä¸€æ­¥å°†é‡æ–°è®¡ç®—å“ªä¸ªå•å…ƒã€‚ä½†ç°åœ¨ï¼Œæˆ‘ä»¬åªæƒ³é‡æ–°è®¡ç®—å¿…è¦çš„å•å…ƒæ ¼ã€‚å¤šä¹ˆ?ã€‚æˆ‘ä»¬ä¸æƒ³ä»Adaptonè¿™æ ·çš„è§‚å¯Ÿåˆ°çš„å•å…ƒéå†æ•´æ£µæ ‘ï¼Œå› ä¸ºå®Œæ•´çš„æ ‘éå†è¿èƒŒäº†æ‹“æ‰‘æ’åºçš„å…¨éƒ¨ç›®çš„ï¼Œå¹¶ä¸”ä¼šç»™å‡ºä¸Adaptonç±»ä¼¼çš„æ€§èƒ½ç‰¹å¾ã€‚</p><p> Instead, Incremental maintains a set of cells that the user has marked  observed, as well as the set of cells that are  necessary to any observed cell. Whenever a cell is marked observed or unobserved, Incremental walks that cellâ€™s dependencies to make sure the necessary marks are applied correctly. Then, we only add cells to the recalculation heap if theyâ€™re marked necessary. In our burrito graph, if only  Total is part of the observed set, changing  Salsa in Order would not result in any walking of the graph, since only necessary cells are recomputed:</p><p>ç›¸åï¼Œå¢é‡ç»´æŠ¤ä¸€ç»„ç”¨æˆ·å·²æ ‡è®°ä¸ºè§‚å¯Ÿåˆ°çš„å•å…ƒæ ¼ï¼Œä»¥åŠä»»ä½•è§‚å¯Ÿåˆ°çš„å•å…ƒæ ¼æ‰€å¿…éœ€çš„ä¸€ç»„å•å…ƒæ ¼ã€‚æ¯å½“å•å…ƒæ ¼è¢«æ ‡è®°ä¸ºè§‚å¯Ÿåˆ°æˆ–æœªè§‚å¯Ÿåˆ°æ—¶ï¼Œå¢é‡éå†è¯¥å•å…ƒæ ¼çš„ä¾èµ–é¡¹ä»¥ç¡®ä¿æ­£ç¡®åº”ç”¨å¿…è¦çš„æ ‡è®°ã€‚ç„¶åï¼Œæˆ‘ä»¬åªåœ¨å•å…ƒæ ¼è¢«æ ‡è®°ä¸ºå¿…éœ€æ—¶æ‰å°†å…¶æ·»åŠ åˆ°é‡æ–°è®¡ç®—å †ä¸­ã€‚åœ¨æˆ‘ä»¬çš„ç‰ç±³ç…é¥¼å›¾ä¸­ï¼Œå¦‚æœåªæœ‰Totalæ˜¯è§‚å¯Ÿé›†çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™æŒ‰é¡ºåºæ›´æ”¹Salsaä¸ä¼šå¯¼è‡´å›¾çš„ä»»ä½•éå†ï¼Œå› ä¸ºåªé‡æ–°è®¡ç®—å¿…è¦çš„å•å…ƒæ ¼ï¼š</p><p>  This solves our problem without eagerly walking the graph to mark cells as dirty! We still have to remember that  Salsa per Burrito is dirty, since if it later becomes necessary, we will need to recompute it. But unlike Adaptonâ€™s algorithm, we donâ€™t need to push this single dirty mark down the entire graph.</p><p>è¿™è§£å†³äº†æˆ‘ä»¬çš„é—®é¢˜ï¼Œè€Œæ— éœ€æ€¥äºéå†å›¾è¡¨å°†å•å…ƒæ ¼æ ‡è®°ä¸ºè„ï¼æˆ‘ä»¬ä»ç„¶å¿…é¡»è®°ä½ï¼Œæ¯ç‰ç±³ç…é¥¼çš„è¨å°”è¨æ˜¯è‚®è„çš„ï¼Œå› ä¸ºå¦‚æœä»¥åæœ‰å¿…è¦çš„è¯ï¼Œæˆ‘ä»¬å°†éœ€è¦é‡æ–°è®¡ç®—å®ƒã€‚ä½†ä¸Adaptonçš„ç®—æ³•ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦åœ¨æ•´ä¸ªå›¾è¡¨ä¸­å‹ä¸‹è¿™ä¸ªå•ä¸€çš„æ±¡ç‚¹ã€‚</p><p>  Both Adapton and Incremental walk the graph, even when not recomputing cells. Incremental walks the graph upstream when the set of observed cells changes, and Adapton walks the graph downstream when a formula changes. With these small graphs, it may not be immediately apparent that this graph walking is expensive. However, if your graph is large and your cells are relatively cheap to compute â€” often the case with spreadsheets â€” youâ€™ll find that most of your costs come from wasted graph walking! When cells are cheap, marking a bit on a cell can cost roughly the same as just recomputing the cell from scratch. So ideally, if we want our algorithm to be substantially faster than computing from scratch, weâ€™ve got to avoid unnecessarily walking the graph as best we can.</p><p>Adaptonå’ŒIncrementaléƒ½åœ¨å›¾ä¸­èµ°åŠ¨ï¼Œå³ä½¿ä¸é‡æ–°è®¡ç®—å•å…ƒã€‚å½“è§‚å¯Ÿåˆ°çš„å•å…ƒæ ¼é›†åˆæ”¹å˜æ—¶ï¼Œå¢é‡éå†å›¾å½¢çš„ä¸Šæ¸¸ï¼Œè€Œå½“å…¬å¼æ”¹å˜æ—¶ï¼ŒAdaptonéå†å›¾å½¢çš„ä¸‹æ¸¸ã€‚ä½¿ç”¨è¿™äº›å°å›¾è¡¨ï¼Œå¯èƒ½ä¸ä¼šç«‹å³çœ‹å‡ºè¿™ç§å›¾è¡¨éå†æ˜¯æ˜‚è´µçš„ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨çš„å›¾è¡¨å¾ˆå¤§ï¼Œè€Œå•å…ƒæ ¼çš„è®¡ç®—æˆæœ¬ç›¸å¯¹è¾ƒä½(é€šå¸¸æ˜¯ç”µå­è¡¨æ ¼çš„æƒ…å†µ)ï¼Œæ‚¨ä¼šå‘ç°å¤§éƒ¨åˆ†æˆæœ¬æ¥è‡ªæµªè´¹çš„å›¾è¡¨éå†ï¼å½“ç”µæ± ä»·æ ¼ä¾¿å®œæ—¶ï¼Œåœ¨ç”µæ± ä¸Šæ‰“ä¸Šä¸€ç‚¹è®°å·çš„æˆæœ¬ä¸ä»é›¶å¼€å§‹é‡æ–°è®¡ç®—ç”µæ± çš„æˆæœ¬å¤§è‡´ç›¸åŒã€‚å› æ­¤ï¼Œç†æƒ³æƒ…å†µä¸‹ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›æˆ‘ä»¬çš„ç®—æ³•æ¯”ä»å¤´å¼€å§‹è®¡ç®—çš„é€Ÿåº¦å¿«å¾—å¤šï¼Œæˆ‘ä»¬å¿…é¡»å°½å¯èƒ½é¿å…ä¸å¿…è¦çš„éå†å›¾å½¢ã€‚</p><p> The more I thought about the problem, the more I realized that they waste time walking the graph in roughly opposite situations. In our burrito graph, letâ€™s imagine cell formulas rarely change, but we rapidly switch between first observing  Total, and then observing  Salsa in Order.</p><p>æˆ‘è¶Šæ˜¯æ€è€ƒè¿™ä¸ªé—®é¢˜ï¼Œå°±è¶Šæ˜¯æ„è¯†åˆ°ä»–ä»¬æµªè´¹æ—¶é—´åœ¨å¤§ç›¸å¾„åº­çš„æƒ…å†µä¸‹èµ°é©¬è§‚èŠ±ã€‚åœ¨æˆ‘ä»¬çš„ç‰ç±³ç…é¥¼å›¾ä¸­ï¼Œè®©æˆ‘ä»¬è®¾æƒ³ç»†èƒå…¬å¼å‡ ä¹ä¸ä¼šæ”¹å˜ï¼Œä½†æˆ‘ä»¬ä¼šåœ¨é¦–å…ˆè§‚å¯ŸTotalï¼Œç„¶åæŒ‰é¡ºåºè§‚å¯ŸSalsaä¹‹é—´å¿«é€Ÿåˆ‡æ¢ã€‚</p><p>  In this case, Adapton will never walk the tree. No inputs are changing, and so we never need to mark anything as dirty. Since nothing is dirty, each observation is cheap as well, since we can simply return the cached value from a clean cell immediately. However, Incremental performs poorly in this example. Even though no values are ever recomputed, Incremental will repeatedly mark and unmark many cells as necessary and unnecessary.</p><p>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒAdaptonå°†æ°¸è¿œä¸ä¼šåœ¨æ ‘ä¸Šè¡Œèµ°ã€‚æ²¡æœ‰ä»»ä½•è¾“å…¥ä¼šæ”¹å˜ï¼Œå› æ­¤æˆ‘ä»¬æ°¸è¿œä¸éœ€è¦å°†ä»»ä½•ä¸œè¥¿æ ‡è®°ä¸ºè„çš„ã€‚å› ä¸ºæ²¡æœ‰ä¸œè¥¿æ˜¯è„çš„ï¼Œæ‰€ä»¥æ¯ä¸ªè§‚å¯Ÿä¹Ÿå¾ˆä¾¿å®œï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€ä»å¹²å‡€çš„å•å…ƒæ ¼ç«‹å³è¿”å›ç¼“å­˜å€¼ã€‚ä½†æ˜¯ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œå¢é‡çš„æ€§èƒ½å¾ˆå·®ã€‚å³ä½¿ä¸é‡æ–°è®¡ç®—ä»»ä½•å€¼ï¼Œå¢é‡ä¹Ÿä¼šåå¤æ ‡è®°å’Œå–æ¶ˆæ ‡è®°è®¸å¤šå¿…è¦å’Œä¸å¿…è¦çš„å•å…ƒæ ¼ã€‚</p><p> In the opposite case, letâ€™s imagine a graph where our formulas are rapidly changing, but we donâ€™t change which cells weâ€™re observing. For instance, we could imagine weâ€™re observing  Total while rapidly changing  Burrito Price from  4+4 to  2*4.</p><p>åœ¨ç›¸åçš„æƒ…å†µä¸‹ï¼Œè®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸ªå›¾è¡¨ï¼Œå…¶ä¸­æˆ‘ä»¬çš„å…¬å¼æ­£åœ¨è¿…é€Ÿæ”¹å˜ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰æ”¹å˜æˆ‘ä»¬æ­£åœ¨è§‚å¯Ÿçš„ç»†èƒã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³è±¡æˆ‘ä»¬æ­£åœ¨è§‚å¯ŸTotalï¼ŒåŒæ—¶å°†ç‰ç±³ç…é¥¼ä»·æ ¼ä»4+4å¿«é€Ÿè°ƒæ•´ä¸º2*4ã€‚</p><p>  Just like the previous example, we arenâ€™t really recomputing many cells.  4+4 and  2*4 both equal  8, so ideally we only recompute that one bit of arithmetic when the user makes this change. However, unlike the previous example, Incremental is now the library that avoids tree walking. With Incremental, weâ€™ve cached the fact that  Burrito Price is a necessary cell, and so when it changes, we can recalculate it without walking the graph. With Adapton, we waste time marking  Burrito Price w Ship and  Total as dirty, even though the output of  Burrito Price wonâ€™t have changed.</p><p>å°±åƒå‰é¢çš„ä¾‹å­ä¸€æ ·ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰çœŸæ­£é‡æ–°è®¡ç®—å¾ˆå¤šå•å…ƒã€‚4+4å’Œ2*4éƒ½ç­‰äº8ï¼Œæ‰€ä»¥ç†æƒ³æƒ…å†µä¸‹ï¼Œå½“ç”¨æˆ·è¿›è¡Œæ­¤æ›´æ”¹æ—¶ï¼Œæˆ‘ä»¬åªé‡æ–°è®¡ç®—ä¸€ä½ç®—æœ¯ã€‚ç„¶è€Œï¼Œä¸å‰ä¸€ä¸ªç¤ºä¾‹ä¸åŒçš„æ˜¯ï¼Œå¢é‡ç°åœ¨æ˜¯é¿å…æ ‘éå†çš„åº“ã€‚ä½¿ç”¨Incrementalï¼Œæˆ‘ä»¬ç¼“å­˜äº†è¿™æ ·ä¸€ä¸ªäº‹å®ï¼Œå³Burrito Priceæ˜¯ä¸€ä¸ªå¿…è¦çš„å•å…ƒæ ¼ï¼Œå› æ­¤å½“å®ƒå‘ç”Ÿå˜åŒ–æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°è®¡ç®—å®ƒï¼Œè€Œä¸éœ€è¦éå†å›¾è¡¨ã€‚ä½¿ç”¨Adaptonï¼Œæˆ‘ä»¬æµªè´¹æ—¶é—´å°†Burrito Price w Shipå’ŒTotalæ ‡è®°ä¸ºè„ï¼Œå³ä½¿Burrito Priceçš„è¾“å‡ºä¸ä¼šæ”¹å˜ã€‚</p><p> Given each algorithm performs well in the otherâ€™s degenerate cases, wouldnâ€™t it be ideal if we could just detect those degenerate cases, and switch to the faster algorithm? This is what I have attempted to do with my own library,  Anchors. Anchors runs both algorithms simultaneously on the same graph! If this sounds wild and unnecessary and overly complicated, thatâ€™s probably because it is.</p><p>è€ƒè™‘åˆ°æ¯ç§ç®—æ³•åœ¨å½¼æ­¤é€€åŒ–çš„æƒ…å†µä¸‹éƒ½è¡¨ç°è‰¯å¥½ï¼Œå¦‚æœæˆ‘ä»¬åªæ£€æµ‹é‚£äº›é€€åŒ–çš„æƒ…å†µï¼Œç„¶ååˆ‡æ¢åˆ°é€Ÿåº¦æ›´å¿«çš„ç®—æ³•ï¼Œé‚£ä¸æ˜¯å¾ˆç†æƒ³å—ï¼Ÿè¿™å°±æ˜¯æˆ‘è¯•å›¾ç”¨æˆ‘è‡ªå·±çš„å›¾ä¹¦é¦†Anchorsåšçš„äº‹æƒ…ã€‚Anchorsåœ¨åŒä¸€å¼ å›¾ä¸ŠåŒæ—¶è¿è¡Œè¿™ä¸¤ç§ç®—æ³•ï¼å¦‚æœè¿™å¬èµ·æ¥å¾ˆç–¯ç‹‚ã€ä¸å¿…è¦è€Œä¸”è¿‡äºå¤æ‚ï¼Œé‚£å¾ˆå¯èƒ½æ˜¯å› ä¸ºå®ƒç¡®å®å¦‚æ­¤ã€‚</p><p> In many cases, Anchors follows Incrementalâ€™s algorithm exactly, which avoids Adaptonâ€™s degenerate case above. But when cells are marked as unobserved, its behavior diverges slightly. Letâ€™s look at what happens. We start with marking  Total as observed:</p><p>åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼ŒAnchorså®Œå…¨éµå¾ªIncrementalçš„ç®—æ³•ï¼Œé¿å…äº†Adaptonçš„ä¸Šè¿°é€€åŒ–æƒ…å†µã€‚ä½†å½“ç»†èƒè¢«æ ‡è®°ä¸ºæœªè¢«è§‚å¯Ÿåˆ°æ—¶ï¼Œå…¶è¡Œä¸ºç•¥æœ‰ä¸åŒã€‚è®©æˆ‘ä»¬æ¥çœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆã€‚æˆ‘ä»¬é¦–å…ˆå°†Totalæ ‡è®°ä¸ºè§‚å¯Ÿåˆ°çš„ï¼š</p><p>  If we then mark  Total as unobserved and  Salsa in Order as observed, the traditional Incremental algorithm would alter the graph to look like this, walking through every cell in the process:</p><p>å¦‚æœæˆ‘ä»¬éšåå°†Totalæ ‡è®°ä¸ºæœªè§‚å¯Ÿåˆ°ï¼Œå¹¶å°†Salsaæ ‡è®°ä¸ºè§‚å¯Ÿåˆ°çš„é¡ºåºï¼Œåˆ™ä¼ ç»Ÿçš„å¢é‡ç®—æ³•ä¼šå°†å›¾è¡¨æ›´æ”¹ä¸ºå¦‚ä¸‹æ‰€ç¤ºï¼Œéå†è¿‡ç¨‹ä¸­çš„æ¯ä¸ªå•å…ƒæ ¼ï¼š</p><p>  Anchors also walks every cell for this change, but instead produces a graph that looks like this:</p><p>é”šç‚¹è¿˜ä¼šéå†æ­¤æ›´æ”¹çš„æ¯ä¸ªå•å…ƒæ ¼ï¼Œä½†ä¼šç”Ÿæˆå¦‚ä¸‹æ‰€ç¤ºçš„å›¾å½¢ï¼š</p><p>  Note the â€œcleanâ€ flags! When a cell is no longer necessary, we mark it as â€œcleanâ€. Letâ€™s look at what happens when we switch from observing  Salsa in Order to  Total:</p><p>æ³¨æ„â€œå¹²å‡€â€çš„æ——å¸œï¼å½“ä¸€ä¸ªç»†èƒä¸å†éœ€è¦æ—¶ï¼Œæˆ‘ä»¬å°†å…¶æ ‡è®°ä¸ºâ€œå¹²å‡€â€ã€‚è®©æˆ‘ä»¬çœ‹çœ‹ä»è§‚å¯ŸSalsaè½¬æ¢åˆ°Totalæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼š</p><p>  Thatâ€™s right â€” our graph now has  no necessary cells. If a cell has a â€œcleanâ€ flag, we never mark it as observed. At this point, no matter what cell we mark as observed or unobserved, Anchors will never waste time walking the graph â€” it knows that none of the inputs have changed.</p><p>æ²¡é”™ï¼Œæˆ‘ä»¬çš„å›¾è¡¨ç°åœ¨æ²¡æœ‰å¿…è¦çš„å•å…ƒæ ¼ã€‚å¦‚æœä¸€ä¸ªå•å…ƒæ ¼æœ‰ä¸€ä¸ªâ€œå¹²å‡€â€çš„æ ‡å¿—ï¼Œæˆ‘ä»¬æ°¸è¿œä¸ä¼šæŠŠå®ƒæ ‡è®°ä¸ºè§‚å¯Ÿåˆ°çš„ã€‚æ­¤æ—¶ï¼Œæ— è®ºæˆ‘ä»¬å°†å“ªä¸ªå•å…ƒæ ¼æ ‡è®°ä¸ºè§‚å¯Ÿåˆ°æˆ–æœªè§‚å¯Ÿåˆ°ï¼ŒAnchorséƒ½ä¸ä¼šæµªè´¹æ—¶é—´éå†å›¾è¡¨-å®ƒçŸ¥é“æ‰€æœ‰è¾“å…¥éƒ½æ²¡æœ‰æ›´æ”¹ã€‚</p><p> Looks like thereâ€™s a discount at El Farolito! Letâ€™s drop  Burrito Price by a dollar. How does Anchors know  Total needs to be recomputed? Before we recompute any formulas, letâ€™s look at how Anchors will see the graph right after we change just  Burrito Price, before recomputing anything:</p><p>çœ‹æ¥El Farolitoæœ‰æŠ˜æ‰£ï¼æˆ‘ä»¬æŠŠå¢¨è¥¿å“¥å·é¥¼é™ä»·ä¸€ç¾å…ƒå§ã€‚ä¸»æ’­å¦‚ä½•çŸ¥é“éœ€è¦é‡æ–°è®¡ç®—æ€»æ•°ï¼Ÿåœ¨é‡æ–°è®¡ç®—ä»»ä½•å…¬å¼ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆçœ‹çœ‹Anchorsåœ¨æˆ‘ä»¬åªæ›´æ”¹äº†Burrito Priceä¹‹åï¼Œåœ¨é‡æ–°è®¡ç®—ä»»ä½•ä¸œè¥¿ä¹‹å‰å°†å¦‚ä½•æŸ¥çœ‹å›¾è¡¨ï¼š</p><p>  If a cell has a clean flag, we run the traditional Adapton algorithm on it, eagerly marking downstream cells as dirty. When we later run the Incremental algorithm, we can quickly tell that there is an observed cell marked as dirty, and know we need to recompute its dependencies. After thatâ€™s finished, the final graph will look like this:</p><p>å¦‚æœå•å…ƒæ ¼æœ‰å¹²å‡€æ ‡å¿—ï¼Œæˆ‘ä»¬å°±ä¼šå¯¹å…¶è¿è¡Œä¼ ç»Ÿçš„Adaptonç®—æ³•ï¼Œæ€¥åˆ‡åœ°å°†ä¸‹æ¸¸å•å…ƒæ ¼æ ‡è®°ä¸ºè„çš„ã€‚å½“æˆ‘ä»¬ç¨åè¿è¡Œå¢é‡ç®—æ³•æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¿«é€Ÿåˆ¤æ–­å‡ºæœ‰ä¸€ä¸ªè§‚å¯Ÿåˆ°çš„å•å…ƒæ ¼è¢«æ ‡è®°ä¸ºè„ï¼Œå¹¶ä¸”çŸ¥é“æˆ‘ä»¬éœ€è¦é‡æ–°è®¡ç®—å®ƒçš„ä¾èµ–é¡¹ã€‚å®Œæˆåï¼Œæœ€ç»ˆçš„å›¾å½¢å°†å¦‚ä¸‹æ‰€ç¤ºï¼š</p><p>  We only recompute cells if theyâ€™re necessary, so whenever we recompute a dirty cell, we also mark it as necessary. At a high level, you can imagine these three cell states form a looping state machine:</p><p>æˆ‘ä»¬åªåœ¨å¿…è¦çš„æ—¶å€™é‡æ–°è®¡ç®—å•å…ƒæ ¼ï¼Œæ‰€ä»¥æ¯å½“æˆ‘ä»¬é‡æ–°è®¡ç®—è„ä¹±çš„å•å…ƒæ ¼æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå°†å…¶æ ‡è®°ä¸ºå¿…è¦çš„ã€‚åœ¨è¾ƒé«˜çº§åˆ«ä¸Šï¼Œæ‚¨å¯ä»¥æƒ³è±¡è¿™ä¸‰ä¸ªå•å…ƒçŠ¶æ€å½¢æˆä¸€ä¸ªå¾ªç¯çŠ¶æ€æœºï¼š</p><p>  On necessary cells, we run the Incrementalâ€™s topological sorting algorithm. On unnecessary cells, we run the Adapton algorithm.</p><p>å¯¹äºéœ€è¦çš„å•å…ƒæ ¼ï¼Œæˆ‘ä»¬è¿è¡Œå¢é‡çš„æ‹“æ‰‘æ’åºç®—æ³•ã€‚å¯¹äºä¸å¿…è¦çš„å•å…ƒæ ¼ï¼Œæˆ‘ä»¬è¿è¡ŒAdaptonç®—æ³•ã€‚</p><p>  Iâ€™d like to finish up by answering a final question: so far, weâ€™re been discussing the many problems the demand-driven model causes for our recomputation strategy. But the problems arenâ€™t just for the algorithm: there are syntactic problems to solve too. For instance, letâ€™s make a spreadsheet to select a burrito emoji for our customer. Weâ€™d write an  IF statement in the spreadsheet like this:</p><p>æœ€åï¼Œæˆ‘æƒ³å›ç­”æœ€åä¸€ä¸ªé—®é¢˜ï¼šåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨è®¨è®ºéœ€æ±‚é©±åŠ¨æ¨¡å¼ç»™æˆ‘ä»¬çš„é‡æ–°è®¡ç®—ç­–ç•¥å¸¦æ¥çš„è®¸å¤šé—®é¢˜ã€‚ä½†é—®é¢˜ä¸ä»…ä»…åœ¨äºç®—æ³•ï¼šè¿˜æœ‰è¯­æ³•é—®é¢˜éœ€è¦è§£å†³ã€‚ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬åˆ¶ä½œä¸€ä¸ªç”µå­è¡¨æ ¼ï¼Œä¸ºæˆ‘ä»¬çš„å®¢æˆ·é€‰æ‹©ä¸€ä¸ªç‰ç±³ç…é¥¼è¡¨æƒ…ç¬¦å·ã€‚æˆ‘ä»¬ä¼šåœ¨ç”µå­è¡¨æ ¼ä¸­ç¼–å†™ä¸€æ¡ifè¯­å¥ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p><p>  Because traditional spreadsheets arenâ€™t demand-driven, we can compute  B1,  B2, and  B3 in any order, so long as we compute our  IF cell after all three inputs are ready. In a demand-driven world however, if we can calculate the value of  B1 first, we can peek at the value to know which of  B2 or  B3 we need to recalculate. Unfortunately, a traditional spreadsheetâ€™s  IF has no way to express this!</p><p>å› ä¸ºä¼ ç»Ÿçš„ç”µå­è¡¨æ ¼ä¸æ˜¯éœ€æ±‚é©±åŠ¨çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŒ‰ä»»ä½•é¡ºåºè®¡ç®—B1ã€B2å’ŒB3ï¼Œåªè¦æˆ‘ä»¬åœ¨æ‰€æœ‰ä¸‰ä¸ªè¾“å…¥éƒ½å‡†å¤‡å¥½ä¹‹åè®¡ç®—IFå•å…ƒå³å¯ã€‚ç„¶è€Œï¼Œåœ¨ä¸€ä¸ªéœ€æ±‚é©±åŠ¨çš„ä¸–ç•Œé‡Œï¼Œå¦‚æœæˆ‘ä»¬èƒ½å…ˆè®¡ç®—B1çš„å€¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥çª¥è§†å®ƒçš„å€¼ï¼Œä»è€ŒçŸ¥é“æˆ‘ä»¬éœ€è¦é‡æ–°è®¡ç®—B2æˆ–B3ä¸­çš„å“ªä¸€ä¸ªã€‚ä¸å¹¸çš„æ˜¯ï¼Œä¼ ç»Ÿç”µå­è¡¨æ ¼çš„IFæ— æ³•è¡¨è¾¾è¿™ä¸€ç‚¹ï¼</p><p> The problem:  B2 simultaneously references cell  B2 and retrieves its value, ğŸ¥¦. Most demand-driven libraries mentioned in this post instead explicitly distinguish between a reference to a cell and the act of retrieving its actual value. In Anchors, we call this cell reference an  Anchor. Much like a burrito in real life wraps a bunch of ingredients together, the  Anchor&lt;T&gt; type wraps  T â€” which I suppose makes our vegi burrito cell  Anchor&lt;Burrito&gt;, a sort of ridiculous burrito of burritos. Functions can pass around our  Anchor&lt;Burrito&gt; as much as theyâ€™d like â€” itâ€™s only when they actually unwrap the burrito to access the  Burrito inside that we create a dependency edge in our graph, indicating to the recomputation algorithm that the cell may be necessary and need recomputing.</p><p>é—®é¢˜ï¼šB2åŒæ—¶å¼•ç”¨å•å…ƒæ ¼B2å¹¶æ£€ç´¢å…¶å€¼ğŸ¥¦ã€‚è¿™ç¯‡æ–‡ç« ä¸­æåˆ°çš„å¤§å¤šæ•°éœ€æ±‚é©±åŠ¨åº“éƒ½æ˜ç¡®åŒºåˆ†äº†å¯¹å•å…ƒçš„å¼•ç”¨å’Œæ£€ç´¢å…¶å®é™…å€¼çš„è¡Œä¸ºã€‚åœ¨Anchorsä¸­ï¼Œæˆ‘ä»¬å°†æ­¤å•å…ƒæ ¼å¼•ç”¨ç§°ä¸ºAnchorã€‚å°±åƒç°å®ç”Ÿæ´»ä¸­çš„ç‰ç±³ç…é¥¼ä¸€æ ·ï¼ŒAnchor&ltï¼›T&gtï¼›Tå‹ç‰ç±³ç…é¥¼åŒ…è£¹ç€T--æˆ‘æƒ³è¿™å°±æ˜¯æˆ‘ä»¬çš„ç´ é£Ÿç‰ç±³ç…é¥¼ç»†èƒAncho&ltï¼›Burrito&gtï¼›ï¼Œä¸€ç§å¯ç¬‘çš„ç‰ç±³ç…é¥¼ã€‚å‡½æ•°å¯ä»¥éšå¿ƒæ‰€æ¬²åœ°ä¼ é€’Anchor&ltï¼›Burrito&&gt;-åªæœ‰å½“å®ƒä»¬çœŸæ­£æ‰“å¼€ç‰ç±³ç…é¥¼ä»¥è®¿é—®å…¶ä¸­çš„ç‰ç±³ç…é¥¼æ—¶ï¼Œæˆ‘ä»¬æ‰ä¼šåœ¨å›¾ä¸­åˆ›å»ºä¾èµ–è¾¹ï¼Œå‘é‡æ–°è®¡ç®—ç®—æ³•è¡¨æ˜è¯¥å•å…ƒæ ¼å¯èƒ½æ˜¯å¿…éœ€çš„ï¼Œéœ€è¦é‡æ–°è®¡ç®—ã€‚</p><p> The approach taken by Salsa and Adapton is to use function calls and normal control flow as a way to unwrap these values. For instance, in Adapton, we might write our â€œBurrito for Customerâ€ cell something like this:</p><p>Salsaå’ŒAdaptoné‡‡å–çš„æ–¹æ³•æ˜¯ä½¿ç”¨å‡½æ•°è°ƒç”¨å’Œæ­£å¸¸æ§åˆ¶æµä½œä¸ºå±•å¼€è¿™äº›å€¼çš„ä¸€ç§æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œåœ¨Adaptonä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå°†â€œBurrito for Customerâ€å•å…ƒæ ¼å†™æˆè¿™æ ·ï¼š</p><p>  By distinguishing between a cell reference ( vegi_burrito here) and the act of unwrapping its value ( get!), Adapton can piggy-back on top of Rustâ€™s control flow operators like  if. This is a great solution! However, a little bit of magical global state is needed to correctly connect the  get! calls to the  cell! that needs recomputing when  is_vegetarian changes. The approach Iâ€™ve taken with Anchors, inspired by Incremental, is a slightly less magical system. Similar to a pre-async/await  Future, Anchors allows you to use operations like  map and  then on an  Anchor&lt;T&gt;. For instance,</p><p>é€šè¿‡åŒºåˆ†å•å…ƒæ ¼å¼•ç”¨(è¿™é‡Œæ˜¯vegi_burrito)å’Œå±•å¼€å…¶å€¼çš„è¡Œä¸º(getï¼)ï¼ŒAdaptonå¯ä»¥åˆ©ç”¨Rustçš„æ§åˆ¶æµè¿ç®—ç¬¦(å¦‚if)ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆæ£’çš„è§£å†³æ–¹æ¡ˆï¼ç„¶è€Œï¼Œéœ€è¦ä¸€ç‚¹ç¥å¥‡çš„å…¨å±€çŠ¶æ€æ‰èƒ½æ­£ç¡®è¿æ¥GETï¼ç»™æ‰‹æœºæ‰“ç”µè¯ï¼å½“ç´ é£Ÿæ”¹å˜æ—¶ï¼Œè¿™éœ€è¦é‡æ–°è®¡ç®—ã€‚æˆ‘å¯¹Anchorsé‡‡å–çš„æ–¹æ³•ï¼Œçµæ„Ÿæ¥è‡ªå¢é‡ï¼Œæ˜¯ä¸€ä¸ªç¨å¾®ä¸é‚£ä¹ˆç¥å¥‡çš„ç³»ç»Ÿã€‚ä¸é¢„å¼‚æ­¥/ç­‰å¾…æœªæ¥ç±»ä¼¼ï¼ŒAnchorså…è®¸æ‚¨ä½¿ç”¨MAPç­‰æ“ä½œï¼Œç„¶ååœ¨Anchor&ltï¼›T&gtï¼›ä¸Šä½¿ç”¨ã€‚ä¾‹å¦‚,ã€‚</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://lord.io/blog/2020/spreadsheets/">https://lord.io/blog/2020/spreadsheets/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/è®¡ç®—/">#è®¡ç®—</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/å•å…ƒæ ¼/">#å•å…ƒæ ¼</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033135.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a866e392e404a3752e927e6b0eb2142a.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033135.html">åŸºäºçŸ³å¢¨çƒ¯çš„å­˜å‚¨ç”µé˜»å™¨åœ¨åŸºäºå¤§è„‘çš„è®¡ç®—ä¸­æ˜¾ç¤ºå‡ºå¸Œæœ›</a></div><span class="my_story_list_date">2020-11-4 15:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032753.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b7667a830f6856680ac19a31ff719691.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032753.html">è¦†ç›†å­PI 400</a></div><span class="my_story_list_date">2020-11-2 17:43</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032748.html"><img src="http://img2.diglog.com/img/2020/11/thumb_b7667a830f6856680ac19a31ff719691.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032748.html">è¦†ç›†å­PI 400</a></div><span class="my_story_list_date">2020-11-2 17:1</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029769.html"><img src="http://img2.diglog.com/img/2020/10/thumb_2b6ad8c176f8976f889d1f4a26d8f66d.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029769.html">æ–°çš„Raspberry Piè®¡ç®—æ¨¡å—4å›é¡¾å’ŒåŸºå‡†</a></div><span class="my_story_list_date">2020-10-19 20:0</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¾å›½/">#ç¾å›½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¨‹åº/">#ç¨‹åº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>