<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>å…³äºä½¿ç”¨Haskellè¿›è¡Œå¯åŠ¨çš„æ€è€ƒ Reflections on Using Haskell for My Startup</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Reflections on Using Haskell for My Startup<br/>å…³äºä½¿ç”¨Haskellè¿›è¡Œå¯åŠ¨çš„æ€è€ƒ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-19 16:06:37</div><div class="page_narrow text-break page_content"><p>Almost exactly one year ago I quit my job to create a Haskell startup as a solo developer. I had about 20 ideas, but eventually settled on the idea of dependency project health tracking with  Deadpendency.</p><p>å‡ ä¹æ°å¥½ä¸€å¹´å‰ï¼Œæˆ‘é€€å‡ºäº†æˆ‘çš„ä½œä¸šï¼Œä»¥åˆ›å»ºä¸€ä¸ªå“ˆå…‹å°”å¯åŠ¨ä½œä¸ºç‹¬å¥å¼€å‘äººå‘˜ã€‚æˆ‘æœ‰å¤§çº¦20ä¸ªæƒ³æ³•ï¼Œä½†æœ€ç»ˆè§£å†³äº†ä¾èµ–é¡¹ç›®å¥åº·è·Ÿè¸ªçš„ç†å¿µï¼Œè‡´å‘½çš„æ­»äº¡ã€‚</p><p>    Since about 2016 I have had a strong  obsession love of Haskell. Prior to learning Haskell, I was an experienced OO style developer but I didnâ€™t really know how to keep improving my raw programming ability. Haskell introduced me to the world of functional programming (FP) which has an almost infinite depth of concepts to learn, which do actually help improve code quality and application architecture.</p><p>    è‡ªä»å¤§çº¦2016å¹´ä»¥æ¥ï¼Œæˆ‘å¯¹Haskellæœ‰ä¸€ä¸ªå¼ºçƒˆçš„ç—´è¿·ã€‚åœ¨å­¦ä¹ Haskellä¹‹å‰ï¼Œæˆ‘æ˜¯ä¸€åç»éªŒä¸°å¯Œçš„OOé£æ ¼çš„å¼€å‘äººå‘˜ï¼Œä½†æˆ‘å¹¶ä¸çœŸæ­£çŸ¥é“å¦‚ä½•ç»§ç»­æé«˜æˆ‘çš„åŸå§‹ç¼–ç¨‹èƒ½åŠ›ã€‚ Haskellå‘æˆ‘æ¨å‡ºäº†åŠŸèƒ½è§„åˆ’ï¼ˆFPï¼‰çš„ä¸–ç•Œï¼Œå®ƒå…·æœ‰å‡ ä¹æ— é™çš„æ¦‚å¿µæ¥å­¦ä¹ ï¼Œå…¶å®é™…ä¸Šæœ‰åŠ©äºæé«˜ä»£ç è´¨é‡å’Œåº”ç”¨æ¶æ„ã€‚</p><p>  Haskell is challenging to learn, but extremely fun to write. For my own learning and pleasure, if my startup succeeds, I want to be doing Haskell.</p><p>  HaskellæŒ‘æˆ˜äº†è§£ï¼Œä½†éå¸¸æœ‰è¶£ã€‚ä¸ºäº†æˆ‘è‡ªå·±çš„å­¦ä¹ å’Œä¹è¶£ï¼Œå¦‚æœæˆ‘çš„åˆåˆ›å…¬å¸æˆåŠŸï¼Œæˆ‘æƒ³åšå“ˆå…‹å°”ã€‚</p><p> Additionally, I think Haskell is the best general purpose programming language (that you can use in production). In particular, Haskell excels at writing â€˜boringâ€™ business applications which is typically what I work on.  â€˜Why Haskell For Productionâ€™ goes into more detail on the benefits Haskell offers.</p><p> æ­¤å¤–ï¼Œæˆ‘è®¤ä¸ºHaskellæ˜¯æœ€å¥½çš„é€šç”¨ç¼–ç¨‹è¯­è¨€ï¼ˆæ‚¨å¯ä»¥åœ¨ç”Ÿäº§ä¸­ä½¿ç”¨ï¼‰ã€‚ç‰¹åˆ«æ˜¯ï¼ŒHaskellæ“…é•¿å†™ä½œâ€œæ— èŠâ€çš„ä¸šåŠ¡åº”ç”¨ç¨‹åºï¼Œé€šå¸¸æ˜¯æˆ‘çš„å·¥ä½œæ–¹å¼ã€‚ 'ä¸ºä»€ä¹ˆHaskellç”Ÿäº§'å¯¹Haskellä¼˜æƒ çš„å¥½å¤„æœ‰æ›´å¤šç»†èŠ‚ã€‚</p><p>   Probably the most challenging part was building out a skeleton architecture to hang my business logic on. I decided to go with, even within Haskell, fairly advanced libraries of   servant and   fused-effects.</p><p>   å¯èƒ½æ˜¯æœ€å…·æŒ‘æˆ˜æ€§çš„éƒ¨åˆ†ï¼Œå»ºç«‹äº†ä¸€ä¸ªéª¨æ¶æ¶æ„ï¼Œä»¥æ‚¬æŒ‚æˆ‘çš„ä¸šåŠ¡é€»è¾‘ã€‚æˆ‘å†³å®šåœ¨Haskellï¼Œå…¬å¹³çš„ä»†äººå’Œèåˆæ•ˆæœçš„å…¬å¹³å›¾ä¹¦é¦†ã€‚</p><p> I spent a fair amount of time banging my head against a wall trying to get these libraries to work nicely together. This was primarily from a lack of Haskell ability on my part. I had prepared as best I could, but Haskell is deep and I needed to learn more to work day to day with it. I was lucky enough to eventually find  an example that marries these two libraries together, which was a life saver. Iâ€™m sure I would have gotten there eventually, but I was in a bit over my head at that point.</p><p> æˆ‘èŠ±äº†å¾ˆå°‘çš„æ—¶é—´æ•²å‡»æˆ‘çš„è„‘è¢‹ï¼Œè¯•å›¾è®©è¿™äº›å›¾ä¹¦é¦†é½å¿ƒååŠ›åœ°å·¥ä½œã€‚è¿™ä¸»è¦æ˜¯ç¼ºä¹ç¼ºä¹å“ˆæ–¯å…‹å°”èƒ½åŠ›çš„èƒ½åŠ›ã€‚æˆ‘å°½æˆ‘æ‰€èƒ½å‡†å¤‡ï¼Œä½†å“ˆæ–¯å…‹å°”æ·±å¤„ï¼Œæˆ‘éœ€è¦å­¦ä¹ æ›´å¤šçš„æ—¶é—´æ¥ä¸å®ƒä¸€èµ·å·¥ä½œã€‚æˆ‘å¾ˆå¹¸è¿ï¼Œæœ€ç»ˆæ‰¾åˆ°ä¸€ä¸ªå©šå§»ä¸è¿™ä¸¤ä¸ªå›¾ä¹¦é¦†ä¸€èµ·ç»“å©šçš„ä¾‹å­ï¼Œè¿™æ˜¯ä¸€ä¸ªæ•‘ç”Ÿå‘˜ã€‚æˆ‘ç›¸ä¿¡æˆ‘æœ€ç»ˆä¼šå¾—åˆ°é‚£é‡Œçš„é‚£ä¸ªï¼Œä½†åœ¨é‚£ä¸€ç‚¹ä¸Šæˆ‘æœ‰ç‚¹ç›¯ç€æˆ‘ã€‚</p><p>  Haskell is awesome, but like most languages there is cruft and legacy to be avoided. Haskell has a standard library known as   base which unfortunately has a fair amount of unsafe or unperformant functions included. As such I went with an alternative standard library   relude that builds on and improves  base. On top of this, there are many core libraries that are not part of the standard library I wanted to use and have nice patterns around.</p><p>  Haskellå¾ˆæ£’ï¼Œä½†ä¸å¤§å¤šæ•°è¯­è¨€ä¸€æ ·æœ‰Cruftå’Œé—ç•™é—äº§ã€‚ Haskellæœ‰ä¸€ä¸ªæ ‡å‡†åº“ï¼Œç§°ä¸ºé—è¿¹ï¼Œé—æ†¾çš„æ˜¯ï¼ŒåŒ…æ‹¬åŒ…æ‹¬çš„ä¸å®‰å…¨æˆ–ä¸è§„åˆ™çš„åŠŸèƒ½ã€‚å› æ­¤ï¼Œæˆ‘ä¸å¦ç±»æ ‡å‡†åº“ä¸­çš„æ›¿ä»£æ ‡å‡†åº“ä¸­å»ºç«‹å¹¶æ”¹å–„äº†åŸºç¡€ã€‚åœ¨æ­¤ä¹‹ä¸Šï¼Œæœ‰è®¸å¤šæ ¸å¿ƒåº“æ˜¯æˆ‘æƒ³è¦ä½¿ç”¨çš„æ ‡å‡†åº“çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶ä¸”å‘¨å›´æœ‰å¾ˆå¥½çš„æ¨¡å¼ã€‚ </p><p> Additionally, I was  deploying to google cloud and so needed to figure out good patterns for that integration from Haskell.</p><p>æ­¤å¤–ï¼Œæˆ‘æ­£åœ¨éƒ¨ç½²åˆ°Google Cloudï¼Œå› æ­¤éœ€è¦ä»Haskellæ‰¾å‡ºå®ç°é›†æˆçš„è‰¯å¥½æ¨¡å¼ã€‚</p><p> This setup effort was quite challenging. I spent most of it squinting at compiler errors. Yet it only took about 2 weeks to have a good foundation of code to start building my business logic upon.</p><p> è®¾ç½®å·¥ä½œéå¸¸å…·æœ‰æŒ‘æˆ˜æ€§ã€‚æˆ‘èŠ±äº†å¤§éƒ¨åˆ†æ—¶é—´çœ‹ç€ç¼–è¯‘å™¨é”™è¯¯ã€‚ä½†æ˜¯ï¼ŒåªèŠ±äº†å¤§çº¦2å‘¨çš„æ—¶é—´ä¾¿æœ‰äº†ä¸€ä¸ªè‰¯å¥½çš„ä»£ç åŸºç¡€å°±å¯ä»¥å¼€å§‹æ„å»ºæˆ‘çš„ä¸šåŠ¡é€»è¾‘ã€‚</p><p>  This is when it started to get really fun. I had my core patterns set out and I could focus on building a pipeline. The day in day out of writing out my logic as small pure functions that I composed together was very nice.</p><p>  è¿™æ˜¯å¼€å§‹å˜å¾—éå¸¸æœ‰è¶£çš„æ—¶å€™ã€‚æˆ‘è®¾å®šäº†æ ¸å¿ƒæ¨¡å¼ï¼Œå¯ä»¥ä¸“æ³¨äºå»ºç«‹ç®¡é“ã€‚æ—¥å¤ä¸€æ—¥åœ°å°†æˆ‘çš„é€»è¾‘å†™æˆæˆ‘ç»„æˆçš„å°å‹çº¯å‡½æ•°éå¸¸å¥½ã€‚</p><p> Haskell has such impressive auto-magic code generation techniques that you spend much more time focused on the interesting logic of your application rather than boilerplate.</p><p> Haskellå…·æœ‰ä»¤äººå°è±¡æ·±åˆ»çš„è‡ªåŠ¨é­”æœ¯ä»£ç ç”ŸæˆæŠ€æœ¯ï¼Œä»¥è‡³äºæ‚¨èŠ±è´¹æ›´å¤šçš„æ—¶é—´ä¸“æ³¨äºåº”ç”¨ç¨‹åºæœ‰è¶£çš„é€»è¾‘ä¸Šï¼Œè€Œä¸æ˜¯æ ·æ¿ä¸Šã€‚</p><p> data  HappinessLevel  =  Miserable  |  Sad  |  Average  |  Happy  |  HaskellDeveloper  deriving  ( Show ,  Eq ,  Ord ,  Bounded ,  Enum ,  ToJSON ,  FromJSON )  -- magic code generation -- ok not really magic, think &#39;convention over configuration&#39; -- where you can have generated sane defaults, or customise if you like</p><p> æ•°æ®HappinessLevel =æ‚²æƒ¨|ä¼¤å¿ƒ|å¹³å‡å¿«ä¹HaskellDeveloperæ´¾ç”Ÿï¼ˆShowï¼ŒEqï¼ŒOrdï¼ŒBoundedï¼ŒEnumï¼ŒToJSONï¼ŒFromJSONï¼‰-ç¥å¥‡çš„ä»£ç ç”Ÿæˆ-å¯ä»¥ï¼Œè¿™ä¸æ˜¯çœŸæ­£çš„ç¥å¥‡ï¼Œè¯·è€ƒè™‘å¯¹é…ç½®çš„å¸¸è§„-æ‚¨å¯ä»¥åœ¨å…¶ä¸­ç”Ÿæˆåˆç†çš„é»˜è®¤å€¼ï¼Œæˆ–è€…æ ¹æ®éœ€è¦è¿›è¡Œè‡ªå®šä¹‰</p><p>   A lot of the logic of Deadpendency is parsing. Either parsing dependency files or parsing various API responses. Haskell has many excellent parsing libraries, most notably   aeson for JSON.</p><p>   Deadpendencyçš„è®¸å¤šé€»è¾‘æ­£åœ¨è§£æã€‚è§£æä¾èµ–æ–‡ä»¶æˆ–è§£æå„ç§APIå“åº”ã€‚ Haskellæœ‰è®¸å¤šå‡ºè‰²çš„è§£æåº“ï¼Œæœ€è‘—åçš„æ˜¯aeson for JSONã€‚</p><p> Why is this nice in Haskell? The â€˜monadâ€™ abstraction is excellent for dealing with code with a lot of failure conditions (ie. parsing) and avoids â€˜pyramid of doomâ€™ type code. Haskell worked out really well in this key area.</p><p> ä¸ºä»€ä¹ˆåœ¨Haskellè¿™ä¹ˆå¥½ï¼Ÿ â€œ monadâ€æŠ½è±¡éå¸¸é€‚åˆå¤„ç†å…·æœ‰å¾ˆå¤šå¤±è´¥æ¡ä»¶ï¼ˆä¾‹å¦‚ï¼Œè§£æï¼‰çš„ä»£ç ï¼Œå¹¶ä¸”é¿å…äº†â€œé‡‘å­—å¡”å„è¿â€ç±»å‹çš„ä»£ç ã€‚ Haskellåœ¨è¿™ä¸€å…³é”®é¢†åŸŸçš„è¡¨ç°éå¸¸å‡ºè‰²ã€‚ </p><p>   Another strong positive for writing Deadpendency was testing. Haskell has a lesser-known style of testing libraries that do â€˜property based testingâ€™ (PBT).</p><p>ç¼–å†™ã€Š Deadpendencyã€‹çš„å¦ä¸€ä¸ªå¼ºé¡¹æ˜¯æµ‹è¯•ã€‚ Haskellå…·æœ‰é²œä¸ºäººçŸ¥çš„æµ‹è¯•åº“æ ·å¼ï¼Œå¯ä»¥æ‰§è¡Œâ€œåŸºäºå±æ€§çš„æµ‹è¯•â€ï¼ˆPBTï¼‰ã€‚</p><p> PBT allows you to write value generators for your data types, which you use to generate 100s or 1000s of test cases. Then, you run these generated values against some function and check that certain properties hold.</p><p> PBTå…è®¸æ‚¨ä¸ºæ•°æ®ç±»å‹ç¼–å†™å€¼ç”Ÿæˆå™¨ï¼Œç”¨äºç”Ÿæˆ100æˆ–1000sæµ‹è¯•ç”¨ä¾‹ã€‚ç„¶åï¼Œå¯¹æŸäº›å‡½æ•°è¿è¡Œè¿™äº›ç”Ÿæˆçš„å€¼ï¼Œå¹¶æ£€æŸ¥æŸäº›å±æ€§æ˜¯å¦æˆç«‹ã€‚</p><p> For example, part of the Deadpendency logic is generating an HTML report at the end. I had some  toHtml :: Report -&gt; HTML function that I wanted to test. So I wrote a  fromHtml :: HTML -&gt; Report function where it goes the other way (ok writing that was pretty painful). Then my PBT test will generate 100s of  Report values and check that  report == fromHtml (toHtml report) (this is known as â€˜roundtrip testingâ€™). With this single test I was able to find many edge case bugs with my HTML report generation logic.</p><p> ä¾‹å¦‚ï¼ŒDeadpendencyé€»è¾‘çš„ä¸€éƒ¨åˆ†æ˜¯åœ¨æœ€åç”ŸæˆHTMLæŠ¥å‘Šã€‚æˆ‘æœ‰ä¸€äº›toHtml :: Report->æˆ‘è¦æµ‹è¯•çš„HTMLå‡½æ•°ã€‚æ‰€ä»¥æˆ‘å†™äº†ä¸€ä¸ªfromHtml :: HTML->æŠ¥å‘ŠåŠŸèƒ½çš„å¦ä¸€ç§æ–¹å¼ï¼ˆå¥½çš„ç¼–å†™å¾ˆç—›è‹¦ï¼‰ã€‚ç„¶åï¼Œæˆ‘çš„PBTæµ‹è¯•å°†ç”Ÿæˆ100ä¸ªReportå€¼ï¼Œå¹¶æ£€æŸ¥report == fromHtmlï¼ˆtoHtmlæŠ¥å‘Šï¼‰ï¼ˆç§°ä¸ºâ€œå¾€è¿”æµ‹è¯•â€ï¼‰ã€‚é€šè¿‡æ­¤æµ‹è¯•ï¼Œæˆ‘å¯ä»¥ä½¿ç”¨HTMLæŠ¥å‘Šç”Ÿæˆé€»è¾‘æ‰¾åˆ°è®¸å¤šè¾¹ç¼˜æ¡ˆä¾‹é”™è¯¯ã€‚</p><p>  PBT exists in some other languages, but it originated (I believe?) in Haskell so the libraries are excellent.</p><p>  PBTè¿˜å­˜åœ¨å…¶ä»–ä¸€äº›è¯­è¨€ï¼Œä½†å®ƒèµ·æºäºHaskellï¼ˆæˆ‘ç›¸ä¿¡å—ï¼Ÿï¼‰ï¼Œå› æ­¤è¿™äº›åº“éå¸¸å‡ºè‰²ã€‚</p><p>  A big challenge of working with Haskell was the lack of well-maintained libraries. Ironically, of the 75 (!) packages I depend upon 19 are flagged by Deadpendency as unhealthy (deprecated or inactive). This means I often donâ€™t have the luxury of asking library maintainers to fix bugs. Even if I PR a fix, sometimes that PR will be ignored for months.</p><p>  ä¸Haskellåˆä½œçš„ä¸€å¤§æŒ‘æˆ˜æ˜¯ç¼ºå°‘ç»´æŠ¤è‰¯å¥½çš„åº“ã€‚å…·æœ‰è®½åˆºæ„å‘³çš„æ˜¯ï¼Œåœ¨æˆ‘ä¾èµ–çš„19ä¸ª75ï¼ˆï¼ï¼‰è½¯ä»¶åŒ…ä¸­ï¼ŒDeadpendencyå°†å…¶æ ‡è®°ä¸ºä¸å¥åº·ï¼ˆå·²å¼ƒç”¨æˆ–ä¸æ´»åŠ¨ï¼‰ã€‚è¿™æ„å‘³ç€æˆ‘ç»å¸¸æ²¡æœ‰è¦æ±‚å›¾ä¹¦é¦†ç»´æŠ¤è€…ä¿®å¤é”™è¯¯çš„å¥¢ä¾ˆè¡Œä¸ºã€‚å³ä½¿æˆ‘PRäº†ä¿®å¤ç¨‹åºï¼Œæœ‰æ—¶è¯¥PRä¹Ÿå°†è¢«å¿½ç•¥æ•°æœˆã€‚</p><p> This I think is the reality of using a niche language like Haskell. To be clear, I do not think library developers owe me anything, but it is nonetheless a downside when compared to more popular languages.</p><p> æˆ‘è®¤ä¸ºè¿™æ˜¯ä½¿ç”¨åƒHaskellè¿™æ ·çš„å°ä¼—è¯­è¨€çš„ç°å®ã€‚æ˜ç¡®åœ°è¯´ï¼Œæˆ‘è®¤ä¸ºå›¾ä¹¦é¦†å¼€å‘äººå‘˜ä¸æ¬ æˆ‘ä»»ä½•ä¸œè¥¿ï¼Œä½†æ˜¯ä¸æ›´æµè¡Œçš„è¯­è¨€ç›¸æ¯”ï¼Œè¿™æ˜¯ä¸åˆ©çš„ã€‚</p><p>  Thankfully Haskell build tools have good support for loading a package from git. This means you can PR some bug fix or feature and immediately use your fork to work around the problem.</p><p>  å€¼å¾—åº†å¹¸çš„æ˜¯ï¼ŒHaskellæ„å»ºå·¥å…·ä¸ºä»gitåŠ è½½è½¯ä»¶åŒ…æä¾›äº†è‰¯å¥½çš„æ”¯æŒã€‚è¿™æ„å‘³ç€æ‚¨å¯ä»¥PRä¸€äº›é”™è¯¯ä¿®å¤æˆ–åŠŸèƒ½ï¼Œç„¶åç«‹å³ä½¿ç”¨forkæ¥è§£å†³æ­¤é—®é¢˜ã€‚ </p><p>  I thought Iâ€™d call this out as it is a common complaint I see around Haskell. I followed some  good advice which kept compilation fast (aside from  one interesting edge case I resolved).</p><p>æˆ‘ä»¥ä¸ºå¯ä»¥è¿™æ ·ç§°å‘¼ï¼Œå› ä¸ºè¿™æ˜¯æˆ‘åœ¨Haskellå‘¨å›´ç»å¸¸çœ‹åˆ°çš„æŠ•è¯‰ã€‚æˆ‘éµå¾ªäº†ä¸€äº›å¾ˆå¥½çš„å»ºè®®ï¼Œè¿™äº›å»ºè®®å¯ä»¥ä½¿ç¼–è¯‘ä¿æŒå¿«é€Ÿï¼ˆé™¤äº†æˆ‘è§£å†³çš„ä¸€ä¸ªæœ‰è¶£çš„æç«¯æƒ…å†µï¼‰ã€‚</p><p> Dell 9570 XPS Laptop - (Hex core - 8th-gen Intel Core i7-8750H CPU), 32GB memory</p><p> Dell 9570 XPSç¬”è®°æœ¬ç”µè„‘-ï¼ˆHexæ ¸å¿ƒ-ç¬¬å…«ä»£Intel Core i7-8750H CPUï¼‰ï¼Œ32GBå†…å­˜</p><p>    This is compiling all application dependencies, which needs to be done before you can compile your application code. Rebuilding all from scratch rarely happens as both my dev machines and CI will cache and only rebuild what has changed.</p><p>    è¿™æ˜¯åœ¨ç¼–è¯‘æ‰€æœ‰åº”ç”¨ç¨‹åºä¾èµ–é¡¹ï¼Œè¿™éœ€è¦åœ¨ç¼–è¯‘åº”ç”¨ç¨‹åºä»£ç ä¹‹å‰å®Œæˆã€‚ä»å¤´å¼€å§‹é‡å»ºæ‰€æœ‰å†…å®¹çš„æƒ…å†µå¾ˆå°‘å‘ç”Ÿï¼Œå› ä¸ºæˆ‘çš„å¼€å‘æœºå™¨å’ŒCIéƒ½å°†ç¼“å­˜å¹¶ä¸”ä»…é‡å»ºå·²æ›´æ”¹çš„å†…å®¹ã€‚</p><p> You do sometimes update a very core package which triggers a lot of dependent packages to recompile which can take a while. Although, I usually do dependency updates at the start of the day while Iâ€™m sipping my coffee, so usually donâ€™t notice.</p><p> æœ‰æ—¶æ‚¨ç¡®å®ä¼šæ›´æ–°ä¸€ä¸ªéå¸¸æ ¸å¿ƒçš„è½¯ä»¶åŒ…ï¼Œè¿™ä¼šè§¦å‘è®¸å¤šä¾èµ–çš„è½¯ä»¶åŒ…é‡æ–°ç¼–è¯‘ï¼Œè¿™å¯èƒ½éœ€è¦ä¸€æ®µæ—¶é—´ã€‚è™½ç„¶ï¼Œæˆ‘é€šå¸¸åœ¨å–å’–å•¡çš„ç¬¬ä¸€å¤©å¼€å§‹æ—¶è¿›è¡Œä¾èµ–æ›´æ–°ï¼Œæ‰€ä»¥é€šå¸¸ä¸ä¼šæ³¨æ„åˆ°ã€‚</p><p>   Likewise, due to caching a full recompilation rarely happens. As such, most code edits do not trigger many modules to be recompiled and it is fast.</p><p>   åŒæ ·ï¼Œç”±äºç¼“å­˜ï¼Œå¾ˆå°‘å‘ç”Ÿå®Œå…¨é‡æ–°ç¼–è¯‘ã€‚å› æ­¤ï¼Œå¤§å¤šæ•°ä»£ç ç¼–è¾‘ä¸ä¼šè§¦å‘è®¸å¤šæ¨¡å—è¿›è¡Œé‡æ–°ç¼–è¯‘ï¼Œè€Œä¸”é€Ÿåº¦å¾ˆå¿«ã€‚</p><p> Additionally, Haskell has nice â€˜continuous compilationâ€™ tools that fire on save. Usually by the time I actually look at my terminal compilation is already done.</p><p> æ­¤å¤–ï¼ŒHaskellå…·æœ‰ä¸é”™çš„â€œè¿ç»­ç¼–è¯‘â€å·¥å…·ï¼Œå¯åœ¨ä¿å­˜æ—¶è§¦å‘ã€‚é€šå¸¸ï¼Œåˆ°æˆ‘å®é™…æŸ¥çœ‹ç»ˆç«¯ç¼–è¯‘æ—¶ä¸ºæ­¢ã€‚</p><p>    This typically runs in CI. It runs in parallel with a host of other checks such as running my tests, which also take a few minutes. Due to this, the time doesnâ€™t really impact the build + deploy time too much.</p><p>    è¿™é€šå¸¸åœ¨CIä¸­è¿è¡Œã€‚å®ƒä¸è®¸å¤šå…¶ä»–æ£€æŸ¥ï¼ˆä¾‹å¦‚è¿è¡Œæˆ‘çš„æµ‹è¯•ï¼‰å¹¶è¡Œè¿è¡Œï¼Œè¿™ä¹Ÿéœ€è¦å‡ åˆ†é’Ÿã€‚å› æ­¤ï¼Œæ—¶é—´å¹¶ä¸ä¼šçœŸæ­£å½±å“æ„å»ºå’Œéƒ¨ç½²æ—¶é—´ã€‚ </p><p>   Deadpendency is relatively simple in what it does, but there is a lot of hidden complexity to the problem. Which is to say, it is like 99% of applications ğŸ˜‰. When developing it I was constantly realising I had modelled things a bit too simplistically and would need to refactor.</p><p>æš‚æŒ‚æ–¹å¼çš„å·¥ä½œç›¸å¯¹ç®€å•ï¼Œä½†æ˜¯è¿™ä¸ªé—®é¢˜æœ‰å¾ˆå¤šéšè—çš„å¤æ‚æ€§ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒå åº”ç”¨ç¨‹åºçš„99ï¼…ã€‚åœ¨å¼€å‘å®ƒæ—¶ï¼Œæˆ‘ä¸€ç›´åœ¨æ„è¯†åˆ°è‡ªå·±å¯¹æ¨¡å‹çš„å»ºæ¨¡è¿‡äºç®€å•äº†ï¼Œéœ€è¦è¿›è¡Œé‡æ„ã€‚</p><p> Haskell is very safe to refactor thanks to the type safety the compiler brings, which is probably the most important thing. However, Haskell does not have great tools to help with refactoring, at least in terms of the restructuring changes I kept making. The  existing  tools seem more geared towards complex rewriting of common code, not restructuring modules or renaming identifiers.</p><p> ç”±äºç¼–è¯‘å™¨å…·æœ‰ç±»å‹å®‰å…¨æ€§ï¼ŒHaskellçš„é‡æ„éå¸¸å®‰å…¨ï¼Œè¿™å¯èƒ½æ˜¯æœ€é‡è¦çš„ã€‚ä½†æ˜¯ï¼ŒHaskellå¹¶æ²¡æœ‰å¼ºå¤§çš„å·¥å…·æ¥å¸®åŠ©é‡æ„ï¼Œè‡³å°‘åœ¨æˆ‘ä¸æ–­è¿›è¡Œçš„é‡ç»„æ–¹é¢ã€‚ç°æœ‰å·¥å…·ä¼¼ä¹æ›´é€‚åˆäºé€šç”¨ä»£ç çš„å¤æ‚é‡å†™ï¼Œè€Œä¸æ˜¯é‡æ„æ¨¡å—æˆ–é‡å‘½åæ ‡è¯†ç¬¦ã€‚</p><p> As such I did it all manually with text search replace, or just change something and fix all the new compiler errors. This was a bit of a grind and it caused me to delay needed refactoring sometimes.</p><p> è¿™æ ·ï¼Œæˆ‘é€šè¿‡æ›¿æ¢æ–‡æœ¬æœç´¢æ‰‹åŠ¨å®Œæˆäº†æ‰€æœ‰æ“ä½œï¼Œæˆ–è€…åªæ˜¯æ›´æ”¹äº†æŸäº›å†…å®¹å¹¶ä¿®å¤äº†æ‰€æœ‰æ–°çš„ç¼–è¯‘å™¨é”™è¯¯ã€‚è¿™æœ‰ç‚¹è´¹åŠ²ï¼Œæœ‰æ—¶ä½¿æˆ‘å»¶è¿Ÿäº†æ‰€éœ€çš„é‡æ„ã€‚</p><p> Itâ€™s a pity Haskell doesnâ€™t have the refactoring tools to help in this situation. The dream would be these tools integrated into an IDE.</p><p> å¯æƒœHaskellæ²¡æœ‰é‡æ„å·¥å…·æ¥è§£å†³è¿™ç§æƒ…å†µã€‚æ¢¦æƒ³æ˜¯å°†è¿™äº›å·¥å…·é›†æˆåˆ°IDEä¸­ã€‚</p><p>   Having said that, it should be noted that Haskell does have an excellent IDE now in the form of  Haskell Language Server (HLS). The momentum around the project is insane and I applaud the developers. One fixed pain point from HLS is it does auto imports now, which used to greatly contribute to the friction of working with Haskell. Iâ€™m sure Haskell will get there eventually.</p><p>   è¯è™½å¦‚æ­¤ï¼Œåº”è¯¥æŒ‡å‡ºçš„æ˜¯ï¼ŒHaskellç°åœ¨ç¡®å®å…·æœ‰å‡ºè‰²çš„IDEï¼Œå…¶å½¢å¼ä¸ºHaskell Language Serverï¼ˆHLSï¼‰ã€‚è¯¥é¡¹ç›®çš„å‘å±•åŠ¿å¤´ä»¤äººå‘ç–¯ï¼Œæˆ‘ä¸ºå¼€å‘äººå‘˜ç§°èµã€‚ HLSçš„ä¸€ä¸ªå›ºå®šçš„ç—›ç‚¹æ˜¯å®ƒç°åœ¨è¦è¿›è¡Œè‡ªåŠ¨å¯¼å…¥ï¼Œè¿™æ›¾ç»å¤§å¤§åŠ å‰§äº†ä¸Haskellåˆä½œçš„éº»çƒ¦ã€‚æˆ‘ç¡®å®šHaskellæœ€ç»ˆä¼šåˆ°è¾¾é‚£é‡Œã€‚</p><p>  This is mostly me complaining for the sake of it, but as someone pretty obsessed with both new shiny versions of things and Haskell, waiting for new GHC (GHC is the Haskell compiler) versions to be usable has been painful. There is a long tail of libraries and platforms that need to be updated before I can use a new GHC version. Sometimes these updates can drag a lot.</p><p>  è¿™ä¸»è¦æ˜¯æˆ‘ä¸ºæ­¤è€ŒæŠ±æ€¨çš„ï¼Œä½†æ˜¯å½“æŸä¸ªäººéå¸¸ç—´è¿·äºäº‹ç‰©çš„æ–°é—ªäº®ç‰ˆæœ¬å’ŒHaskellæ—¶ï¼Œç­‰å¾…æ–°çš„GHCï¼ˆGHCæ˜¯Haskellç¼–è¯‘å™¨ï¼‰ç‰ˆæœ¬å¯ç”¨ä¸€ç›´å¾ˆç—›è‹¦ã€‚åœ¨ä½¿ç”¨æ–°çš„GHCç‰ˆæœ¬ä¹‹å‰ï¼Œéœ€è¦æ›´æ–°å¾ˆå¤šåº“å’Œå¹³å°ã€‚æœ‰æ—¶ï¼Œè¿™äº›æ›´æ–°å¯èƒ½ä¼šæ‹–ç´¯å¾ˆå¤šã€‚</p><p> For example GHC 9 was just released, but I still havenâ€™t been able to upgrade to GHC 8.10 yet which was first released in March 2020.</p><p> ä¾‹å¦‚ï¼ŒGHC 9åˆšåˆšå‘å¸ƒï¼Œä½†æˆ‘ä»æ— æ³•å‡çº§åˆ°2020å¹´3æœˆé¦–æ¬¡å‘å¸ƒçš„GHC 8.10ã€‚ </p><p>   So after about 8 months of work I was ready to start getting users. I slowly soft launched, promoting it in a few small channels. How did my Haskell fair in prod?</p><p>æ‰€ä»¥åœ¨å¤§çº¦8ä¸ªæœˆçš„å·¥ä½œåï¼Œæˆ‘å‡†å¤‡å¼€å§‹è®©ç”¨æˆ·ã€‚æˆ‘æ…¢æ…¢å‘å°„ï¼Œåœ¨å‡ ä¸ªå°æ¸ é“ä¸­æ¨å¹¿å®ƒã€‚æˆ‘çš„Haskellåšè§ˆä¼šæ˜¯å¦‚ä½•åœ¨åˆºæ¿€ï¼Ÿ</p><p>  My core Haskell had very few logic bugs. This is because Haskell is very safe by default and I had opted into strict types that help catch edge cases.</p><p>  æˆ‘çš„æ ¸å¿ƒHaskellå¾ˆå°‘æœ‰é€»è¾‘é”™è¯¯ã€‚è¿™æ˜¯å› ä¸ºé»˜è®¤æƒ…å†µä¸‹ï¼ŒHaskelléå¸¸å®‰å…¨ï¼Œæˆ‘é€‰æ‹©äº†å®Œå…¨çš„ç±»å‹ï¼Œæœ‰åŠ©äºæ•è·è¾¹ç¼˜æ¡ˆä¾‹ã€‚</p><p> For example, I was using a lot of   NonEmpty lists which the compiler will guarantee is not empty. To use them you must specify how to handle the empty case. ie. what do I do if Deadpendency canâ€™t find any dependencies to check?</p><p> ä¾‹å¦‚ï¼Œæˆ‘ä½¿ç”¨äº†å¾ˆå¤šéç©ºçš„åˆ—è¡¨ï¼Œç¼–è¯‘å™¨ä¿è¯ä¸ä¸ºç©ºã€‚è¦ä½¿ç”¨å®ƒä»¬ï¼Œæ‚¨å¿…é¡»æŒ‡å®šå¦‚ä½•å¤„ç†ç©ºçš„æƒ…å†µã€‚ IEã€‚å¦‚æœæ­»äººæ— æ³•æ‰¾åˆ°ä»»ä½•ä¾èµ–å…³ç³»ï¼Œæˆ‘è¯¥æ€ä¹ˆåŠï¼Ÿ</p><p> And of course, I had many tests as the compiler cannot find all the bugs.. yet..</p><p> å½“ç„¶ï¼Œæˆ‘æœ‰å¾ˆå¤šæµ‹è¯•ï¼Œå› ä¸ºç¼–è¯‘å™¨æ‰¾ä¸åˆ°æ‰€æœ‰çš„é”™è¯¯..è¿˜æ˜¯......</p><p>   A big pain point was the package registry APIs had a lot of inconsistency on how they are structured (especially  NPM). For example, for an  NPM package you can get the latest version by getting  dist-tags -&gt; latest. What about a package that has no release? Well you get  dist-tags: {}, except that it turns out that some packages donâ€™t even have the  dist-tags key at all.</p><p>   ä¸€ä¸ªå¤§çš„ç—›ç‚¹æ˜¯åŒ…æ³¨å†Œæœºå™¨APIå¯¹å®ƒä»¬çš„ç»“æ„ï¼ˆç‰¹åˆ«æ˜¯NPMï¼‰çš„å­˜åœ¨å¾ˆå¤šä¸ä¸€è‡´ã€‚ä¾‹å¦‚ï¼Œå¯¹äºNPMåŒ…ï¼Œæ‚¨å¯ä»¥é€šè¿‡è·å–DISTæ ‡è®° - ï¼†gtæ¥è·å–æœ€æ–°ç‰ˆæœ¬ã€‚æœ€æ–°çš„ã€‚é‚£ä¸ªæ²¡æœ‰é‡Šæ”¾çš„åŒ…æ€ä¹ˆæ ·ï¼Ÿå—¯ï¼Œä½ å¾—åˆ°äº†distæ ‡ç­¾ï¼š{}ï¼Œé™¤äº†å®ƒç»“æœç”šè‡³æ ¹æœ¬æ²¡æœ‰distæ ‡ç­¾é”®ã€‚</p><p> I quickly realised I would need to gracefully handle parse failures like these as there was so much variance in structure.</p><p> æˆ‘å¾ˆå¿«æ„è¯†åˆ°æˆ‘éœ€è¦ä¼˜é›…åœ°å¤„ç†åƒè¿™æ ·çš„è§£æå¤±è´¥ï¼Œå› ä¸ºç»“æ„æ–¹å·®å¦‚æ­¤å¤šã€‚</p><p> This issue sounds like a classic argument against static typing, but  dynamic type systems are not inherently better at dealing with unexpected data. Dynamically typed languages may more gracefully ignore, or delay the failure, but I prefer the Haskell philosophy of immediately failing when data is an unexpected shape.</p><p> æ­¤é—®é¢˜å¬èµ·æ¥åƒå¯¹é™æ€é”®å…¥çš„ç»å…¸è®ºç‚¹ï¼Œä½†æ˜¯åœ¨å¤„ç†æ„å¤–æ•°æ®æ—¶ï¼ŒåŠ¨æ€ç±»å‹ç³»ç»Ÿå¹¶ä¸æ›´å¥½ã€‚åŠ¨æ€ç±»å‹çš„è¯­è¨€å¯èƒ½æ›´ä¼˜é›…åœ°å¿½ç•¥æˆ–å»¶è¿Ÿå¤±è´¥ï¼Œä½†æ˜¯å½“æ•°æ®æ˜¯æ„å¤–çš„å½¢çŠ¶æ—¶ï¼Œæˆ‘æ›´å–œæ¬¢ç«‹å³å¤±è´¥çš„Haskellå“²å­¦ã€‚ </p><p>   The other big pain point was memory usage. I was using  Google Cloud Run which is sort of like AWS Lambda where you can specify how much memory you need. To keep things cheap and to better understand the memory needs of my app, I went with the minimum of 256MB. This amount seemed fine until I went to prod and Deadpendency was trying to check a wider variety of packages.</p><p>å¦ä¸€ä¸ªå¤§ç—›ç‚¹æ˜¯å†…å­˜ä½¿ç”¨ç‡ã€‚æˆ‘ä½¿ç”¨çš„æ˜¯Google Cloud Runï¼Œæœ‰ç‚¹åƒAWS Lambdaï¼Œæ‚¨å¯ä»¥åœ¨å…¶ä¸­æŒ‡å®šæ‰€éœ€çš„å†…å­˜é‡ã€‚ä¸ºäº†ä¿æŒä¾¿å®œå¹¶æ›´å¥½åœ°äº†è§£åº”ç”¨ç¨‹åºçš„å†…å­˜éœ€æ±‚ï¼Œæˆ‘è‡³å°‘ä½¿ç”¨äº†256MBã€‚ç›´åˆ°æˆ‘å»ç”Ÿäº§å¹¶ä¸”Deadpendencyè¯•å›¾æ£€æŸ¥æ›´å¤šç§ç±»çš„åŒ…è£…ä¹‹å‰ï¼Œè¿™ä¸ªæ•°ç›®ä¼¼ä¹è¿˜ä¸é”™ã€‚</p><p> The core issue was.. NPM again had some rare packages that have huge JSON payloads, the  worst case being 84MB uncompressed. It turns out that   aeson will convert all the JSON into an  AST first, before it then attempts to parse it to your type. This is fine when the JSON is small, or you are loading most of the contents of the JSON. In my case the AST (or the parsing?) apparently took about 20x the amount of memory of the raw JSON, when I only needed a tiny amount of the data.</p><p> æ ¸å¿ƒé—®é¢˜æ˜¯.. NPMå†æ¬¡å…·æœ‰ä¸€äº›ç½•è§çš„ç¨‹åºåŒ…ï¼Œè¿™äº›ç¨‹åºåŒ…å…·æœ‰å·¨å¤§çš„JSONæœ‰æ•ˆè´Ÿè½½ï¼Œæœ€åçš„æƒ…å†µæ˜¯æœªå‹ç¼©çš„84MBã€‚äº‹å®è¯æ˜ï¼Œaesonä¼šå…ˆå°†æ‰€æœ‰JSONè½¬æ¢ä¸ºASTï¼Œç„¶åå†å°è¯•å°†å…¶è§£æä¸ºæ‚¨çš„ç±»å‹ã€‚å½“JSONå°æˆ–æ‚¨æ­£åœ¨åŠ è½½JSONçš„å¤§éƒ¨åˆ†å†…å®¹æ—¶ï¼Œè¿™å¾ˆå¥½ã€‚åœ¨æˆ‘çš„æƒ…å†µä¸‹ï¼Œå½“æˆ‘åªéœ€è¦å°‘é‡æ•°æ®æ—¶ï¼ŒASTï¼ˆæˆ–è§£æï¼Ÿï¼‰çš„å†…å­˜æ˜¾ç„¶æ˜¯åŸå§‹JSONçš„20å€ã€‚</p><p> Eventually I realised I should use a  library designed to parse in constant memory and all was well. I can parse the 84MB file and only see 84MB used. I could take this even further and stream the response, but for now it is working fine as is.</p><p> æœ€ç»ˆï¼Œæˆ‘æ„è¯†åˆ°æˆ‘åº”è¯¥ä½¿ç”¨ä¸€ä¸ªæ—¨åœ¨è§£ææ’å®šå†…å­˜çš„åº“ï¼Œä¸€åˆ‡éƒ½å¾ˆå¥½ã€‚æˆ‘å¯ä»¥è§£æ84MBçš„æ–‡ä»¶ï¼Œä½†åªèƒ½çœ‹åˆ°ä½¿ç”¨äº†84MBã€‚æˆ‘å¯ä»¥æ›´è¿›ä¸€æ­¥ï¼Œæµå¼ä¼ è¾“å“åº”ï¼Œä½†ç°åœ¨å®ƒå¯ä»¥æ­£å¸¸å·¥ä½œã€‚</p><p>   As a lazy language, Haskell is known to have memory issues due to unevaluated expressions accumulating in unexpected ways. Thankfully I have avoided these issues so far.</p><p>   ä½œä¸ºä¸€ç§æ‡’æƒ°çš„è¯­è¨€ï¼ŒHaskellç”±äºæœªè¯„ä¼°çš„è¡¨è¾¾å¼ä»¥æ„å¤–çš„æ–¹å¼ç§¯ç´¯è€Œå¯¼è‡´å†…å­˜é—®é¢˜ã€‚å¹¸è¿çš„æ˜¯ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘å·²ç»é¿å…äº†è¿™äº›é—®é¢˜ã€‚</p><p> I did this by making my types strict by default with the   StrictData extension. Additionally, Haskell has lazy linked lists as the default list type. Instead I used a  strict list type.</p><p> æˆ‘é€šè¿‡ä½¿ç”¨StrictDataæ‰©å±•åå°†æˆ‘çš„ç±»å‹é»˜è®¤è®¾ç½®ä¸ºä¸¥æ ¼æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚æ­¤å¤–ï¼ŒHaskellå…·æœ‰æƒ°æ€§é“¾æ¥åˆ—è¡¨ä½œä¸ºé»˜è®¤åˆ—è¡¨ç±»å‹ã€‚ç›¸åï¼Œæˆ‘ä½¿ç”¨äº†ä¸¥æ ¼çš„åˆ—è¡¨ç±»å‹ã€‚</p><p>  In a bit over a year I was able to build Deadpendency supporting 11 languages (and set up a bunch of cloud junk around it ğŸ˜‰). At this point I think it is actually pretty stable. I consider the project a big success.</p><p>  åœ¨ä¸€å¹´å¤šçš„æ—¶é—´é‡Œï¼Œæˆ‘èƒ½å¤Ÿæ„å»ºæ”¯æŒ11ç§è¯­è¨€çš„Deadpendencyï¼ˆå¹¶åœ¨å®ƒå‘¨å›´è®¾ç½®äº†è®¸å¤šäº‘åƒåœ¾ğŸ˜‰ï¼‰ã€‚åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘è®¤ä¸ºå®ƒå®é™…ä¸Šæ˜¯ç›¸å½“ç¨³å®šçš„ã€‚æˆ‘è®¤ä¸ºè¯¥é¡¹ç›®éå¸¸æˆåŠŸã€‚</p><p> A huge part of this has been due to Haskell and its excellent ecosystem. Of course, prior to my startup I spent 4 years dabbling with Haskell to learn it, but once skilled up it is super effective. I do believe any developer can learn Haskell and even learn it quickly in the right environment.</p><p> å…¶ä¸­å¾ˆå¤§ä¸€éƒ¨åˆ†å½’å› äºHaskellåŠå…¶å‡ºè‰²çš„ç”Ÿæ€ç³»ç»Ÿã€‚å½“ç„¶ï¼Œåœ¨æˆ‘åˆ›ä¸šä¹‹å‰ï¼Œæˆ‘èŠ±äº†4å¹´çš„æ—¶é—´ä¸Haskellè¿›è¡Œå­¦ä¹ ï¼Œä½†æ˜¯ä¸€æ—¦ç†Ÿç»ƒäº†ï¼Œå®ƒå°±ä¼šéå¸¸æœ‰æ•ˆã€‚æˆ‘ç¡®å®ç›¸ä¿¡ä»»ä½•å¼€å‘äººå‘˜éƒ½å¯ä»¥å­¦ä¹ Haskellï¼Œç”šè‡³å¯ä»¥åœ¨é€‚å½“çš„ç¯å¢ƒä¸­å¿«é€Ÿå­¦ä¹ å®ƒã€‚ </p><p> Whatâ€™s next? I am working on promoting  Deadpendency and I hope to get more users and  feedback. Have I spent too much time geeking out on Haskell and not enough time thinking about the idea? I guess we will see ğŸ˜Š. Either way, I have learnt a lot and had a lot of fun, so I will consider the experience worth it.</p><p>ä¸‹ä¸€æ­¥æ˜¯ä»€ä¹ˆï¼Ÿ æˆ‘æ­£åœ¨åŠªåŠ›æ¨å¹¿Deadpendencyï¼Œå¹¶å¸Œæœ›è·å¾—æ›´å¤šçš„ç”¨æˆ·å’Œåé¦ˆã€‚ æˆ‘æ˜¯å¦èŠ±äº†å¤ªå¤šæ—¶é—´æ¥ç ”ç©¶Haskellï¼Œè€Œæ²¡æœ‰è¶³å¤Ÿçš„æ—¶é—´è€ƒè™‘è¿™ä¸ªæƒ³æ³•ï¼Ÿ æˆ‘æƒ³æˆ‘ä»¬ä¼šçœ‹åˆ°ğŸ˜Šã€‚ æ— è®ºå“ªç§æ–¹å¼ï¼Œæˆ‘éƒ½å­¦åˆ°äº†å¾ˆå¤šä¸œè¥¿ï¼Œç©å¾—å¾ˆå¼€å¿ƒï¼Œæ‰€ä»¥æˆ‘è®¤ä¸ºå€¼å¾—çš„ç»å†ã€‚ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://alistairb.dev/reflections-on-haskell-for-startup/">https://alistairb.dev/reflections-on-haskell-for-startup/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/haskell/">#haskell</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>