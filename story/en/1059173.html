<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ç›’å­é‡Œæœ‰ä»€ä¹ˆä¸œè¥¿ï¼Ÿ What's in the Box?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What's in the Box?<br/>ç›’å­é‡Œæœ‰ä»€ä¹ˆä¸œè¥¿ï¼Ÿ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-19 23:34:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/99194f67e5542018f2c1c325832cade0.png"><img src="http://img2.diglog.com/img/2021/4/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The first, is that the advice is very rarely heeded, and instead, whoever Ijust said it to disappears for two days, emerging victorious, basking in theknowledge that, YES, the compiler  could inline that, if it wanted to.</p><p>é¦–å…ˆï¼Œè¿™ä¸€å»ºè®®å¾ˆå°‘è§åˆ°ï¼Œè€Œä¸”ï¼Œæ— è®ºè°è¯´ï¼Œè°éƒ½è¯´å®ƒä¼šæ¶ˆå¤±ä¸¤å¤©ï¼Œæ‰€ä»¥èƒœåˆ©ï¼Œæ˜¯å› ä¸ºå®ƒï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šåœ¨çº¿ï¼Œå¦‚æœå®ƒæƒ³è¦ã€‚</p><p> And the second is that, without a  lot of context, this sentence is utternonsense if you don&#39;t have a working knowledge of Rust. As a Java developer,you may be wondering if we&#39;re trying to turn numbers into objects (we arenot). In fact, even as a Rust developer, you may have just accepted that boxingis just a fact of life.</p><p> ç¬¬äºŒï¼Œå¦‚æœæ²¡æœ‰å¾ˆå¤šèƒŒæ™¯ï¼Œå¦‚æœä½ æ²¡æœ‰å·¥ä½œçŸ¥è¯†ï¼Œå°±æ²¡æœ‰å¾ˆå¤šèƒŒæ™¯ï¼Œè¿™å¥è¯æ˜¯Utternonsenseã€‚ä½œä¸ºJavaå¼€å‘äººå‘˜ï¼Œæ‚¨å¯èƒ½ä¼šæƒ³çŸ¥é“æˆ‘ä»¬æ˜¯å¦å°è¯•å°†æ•°å­—è½¬æ¢ä¸ºå¯¹è±¡ï¼ˆæˆ‘ä»¬çš„arenotï¼‰ã€‚äº‹å®ä¸Šï¼Œå³ä½¿æ˜¯ä½œä¸ºé“é”ˆå¼€å‘å•†ï¼Œæ‚¨ä¹Ÿå¯èƒ½åˆšåˆšæ¥å—äº†æ‹³å‡»åªæ˜¯ä¸€ä¸ªç”Ÿå‘½çš„äº‹å®ã€‚</p><p> It&#39;s just a thing we have to do sometimes, so the compiler stops being mad atus, and things just  suddenly start working. That&#39;s not necessarily a badthing. That&#39;s just  how good compiler diagnostics are, that it can just tellyou &#34;hold on there friend, I really think you want to box it&#34;, and you can copyand paste the solution, and the puzzle is cracked.</p><p> å®ƒï¼†ï¼ƒ39;åªæ˜¯æˆ‘ä»¬æœ‰æ—¶è¦åšçš„ä¸€ä»¶äº‹ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨åœæ­¢ç–¯ç‹‚çš„atusï¼Œçªç„¶å¼€å§‹å·¥ä½œã€‚é‚£ä¸ªï¼†ï¼ƒ39;ä¸ä¸€å®šæ˜¯ä¸€ä¸ªåè¯ã€‚ ï¼†ï¼ƒ39; såªæ˜¯å¦‚ä½•è‰¯å¥½çš„ç¼–è¯‘å™¨è¯Šæ–­ï¼Œå®ƒå¯ä»¥åªæ˜¯tellyouï¼†ï¼ƒ34;åœ¨é‚£é‡ŒæŠ±ç€æœ‹å‹ï¼Œæˆ‘çœŸçš„è®¤ä¸ºä½ æƒ³è¦ç›’å­ï¼†ï¼ƒ34;ï¼Œä½ å¯ä»¥å¤åˆ¶å’Œç²˜è´´è§£å†³æ–¹æ¡ˆï¼Œæ‹¼å›¾æ˜¯ç ´è§£ã€‚</p><p> But! Just because we can get by for a very long time without knowing what itmeans, doesn&#39;t mean I can resist the sweet sweet temptation of explaining inexcruciating details what it actually means, and so, that&#39;s exactly whatwe&#39;re going to do in this article.</p><p> ä½†ï¼ä»…ä»…å› ä¸ºæˆ‘ä»¬å¯ä»¥åœ¨ä¸çŸ¥é“å®ƒçš„æƒ…å†µä¸‹è·å¾—å¾ˆé•¿ä¸€æ®µæ—¶é—´ï¼Œè€Œä¸æ˜¯æ„å‘³ç€æˆ‘å¯ä»¥æŠµæŠ—ç”œèœœçš„ç”œèœœè¯±æƒ‘ï¼Œè§£é‡Šè§£é‡Šçš„ç”œèœœç”œèœœçš„ç»†èŠ‚å®ƒå®é™…æ„å‘³ç€ä»€ä¹ˆï¼Œæ‰€ä»¥ï¼†ï¼ƒ39;ç©¶ç«Ÿæ˜¯ä»€ä¹ˆï¼†ï¼ƒ39 ;é‡ç”³åœ¨è¿™ç¯‡æ–‡ç« ä¸­ã€‚</p><p> Before we do that, though, let&#39;s look at a simple example where we might beenjoined by a well-intentioned colleague to, as it were, &#34;just box it&#34;.</p><p> ç„¶è€Œï¼Œåœ¨æˆ‘ä»¬è¿™æ ·åšä¹‹å‰ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè¢«ä¸€ä½å–„æ„çš„åŒäº‹ä»¬æ‰€åšçš„ï¼Œå› ä¸ºå®ƒï¼Œï¼†ï¼ƒ34;åªæ˜¯æ¡†ï¼†ï¼ƒ34;</p><p>  Whenever  cargo new is invoked, it generates a simple &#34;hello world&#34;application, that looks like this:</p><p>  æ¯å½“è°ƒç”¨è´§ç‰©æ–°å»ºæ—¶ï¼Œå®ƒä¼šç”Ÿæˆä¸€ä¸ªç®€å•çš„ï¼†ï¼ƒ34;ä½ å¥½ä¸–ç•Œï¼†ï¼ƒ34;åº”ç”¨ç¨‹åºï¼Œçœ‹èµ·æ¥åƒè¿™æ ·ï¼š</p><p>  It is pure, and innocent, and devoid of things that can fail, which is great.</p><p>  å®ƒæ˜¯çº¯æ´çš„ï¼Œæ— è¾œçš„ï¼Œæ²¡æœ‰ä»»ä½•å¯èƒ½å¤±è´¥çš„ä¸œè¥¿ï¼Œè¿™å¾ˆå¥½ã€‚ </p><p> $ cargo run Compiling whatbox v0.1.0 (/home/amos/ftl/whatbox) Finished dev [unoptimized + debuginfo] target(s) in 0.47s Running `target/debug/whatbox`Hello, world!</p><p>$ Cargo Runç¼–è¯‘Whatbox V0.1.0ï¼ˆ/ home / amos / ftl / whatboxï¼‰å®Œæˆçš„dev [æœªé€šè¿‡+ debuginfo] target 0.47sè¿è¡Œ`target / debug / whatbox`helloï¼Œworldï¼</p><p>     read_to_string can fail! And that&#39;s why it returns a  Result&lt;String, E&gt;and not just a  String.</p><p>     read_to_stringå¯èƒ½ä¼šå¤±è´¥ï¼å¹¶ä¸”å®ƒä¸ºä»€ä¹ˆå®ƒè¿”å›ç»“æœï¼†lt; stringï¼Œeï¼†gt;è€Œä¸ä»…ä»…æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚</p><p> And that&#39;s also why we need to call  .unwrap() on it, to go from Result&lt;String, E&gt; to either:</p><p> è€Œä¸”ï¼Œå®ƒä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦è°ƒç”¨.unwrapï¼ˆï¼‰ï¼Œä»ç»“æœï¼†lt; stringï¼Œeï¼†gt;è¦ä¹ˆï¼š</p><p>  $ cargo run --quietthread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: &#34;No such file or directory&#34; }&#39;, src/main.rs:2:59note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</p><p>  $è´§ç‰©è¿è¡Œ--quietthreadï¼†ï¼ƒ39; mainï¼†ï¼ƒ39;é—¹å‰§ï¼†ï¼ƒ39;è¢«å«`ç»“æœ:: unwrapï¼ˆï¼‰`åœ¨`err` valueï¼šore {ä»£ç ï¼š2ï¼Œç§ç±»ï¼šnotfoundï¼Œmessageï¼šï¼†ï¼ƒ34;æ²¡æœ‰è¿™æ ·çš„æ–‡ä»¶æˆ–ç›®å½•ï¼†ï¼ƒ34; }ï¼†ï¼ƒ39;ï¼Œsrc / main.rsï¼š2ï¼š59æ³¨æ„ï¼šä½¿ç”¨`rust_backtrace = 1`ç¯å¢ƒå˜é‡æ¥æ˜¾ç¤ºå›æº¯</p><p>   But let&#39;s say we want to read a string  inside a function. Our own function.</p><p>   ä½†æ˜¯ï¼Œå‡è®¾æˆ‘ä»¬æƒ³åœ¨å‡½æ•°å†…è¯»å–ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚æˆ‘ä»¬è‡ªå·±çš„åŠŸèƒ½ã€‚</p><p>     But that&#39;s not really the code we want. See, the  read_issue function feelslike &#34;library code&#34;. Right now, it&#39;s in our application, but I could seemyself splitting that function into its own crate, maybe a crate named linux-info or something, because it could be useful to other applications.</p><p>     ä½†å®ƒä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ä»£ç ã€‚è¯·å‚é˜…ï¼ŒRead_issueå‡½æ•°Feelslikeï¼†ï¼ƒ34;å›¾ä¹¦é¦†ä»£ç ï¼†ï¼ƒ34;ç°åœ¨ï¼Œå®ƒåœ¨æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä¸­ï¼Œä½†æˆ‘å¯ä»¥çœ‹åˆ°å‡½æ•°åˆ†æˆè‡ªå·±çš„ç®±å­ï¼Œä¹Ÿè®¸æ˜¯ä¸€ä¸ªåå«Linux-Infoæˆ–å…¶ä»–ä¸œè¥¿çš„ç®±å­ï¼Œå› ä¸ºå®ƒå¯¹å…¶ä»–åº”ç”¨ç¨‹åºæœ‰ç”¨ã€‚</p><p> And so, even though it&#39;s in the same crate as the  main function, I don&#39;t feelcomfortable causing a panic in  read_issue, the way I felt comfortable causinga panic  at the disco in  main.</p><p> æ‰€ä»¥ï¼Œå³ä½¿å®ƒåœ¨ä¸ä¸»è¦åŠŸèƒ½ç›¸åŒçš„ç®±å­ä¸­ï¼Œæˆ‘ä¹Ÿä¸ä¼šåœ¨read_issueä¸­å¼•èµ·ææ…Œçš„ï¼Œæˆ‘åœ¨è¿ªæ–¯ç§‘èˆå…ä¸­æ„Ÿåˆ°èˆ’é€‚åœ°å¼•èµ·ææ…Œã€‚ </p><p> Instead, I think I want  read_issue to return a  Result, too. Because Result&lt;T, E&gt; is an enum, that can represent two things: the operation hassucceeded (and we get a  T), or it failed (and we get an  E).</p><p>ç›¸åï¼Œæˆ‘æƒ³æˆ‘ä¹Ÿå¸Œæœ›read_issueè¿”å›ç»“æœã€‚å› ä¸ºç»“æœï¼†lt; tï¼Œeï¼†gt;æ˜¯ä¸€ä¸ªæšä¸¾ï¼Œå¯ä»¥ä»£è¡¨ä¸¤ä»¶äº‹ï¼šhassucceededçš„æ“ä½œï¼ˆæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªtï¼‰ï¼Œæˆ–è€…å®ƒå¤±è´¥äº†ï¼ˆæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªeï¼‰ã€‚</p><p>  And we know that when the operation succeeds, we get a  String, so we knowwhat to pick for  T. But the question is: what do we pick for  E?</p><p>  æˆ‘ä»¬çŸ¥é“ï¼Œå½“æ“ä½œæˆåŠŸæ—¶ï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰€ä»¥æˆ‘ä»¬çŸ¥é“è¦é€‰æ‹©T.ä½†é—®é¢˜æ˜¯ï¼šæˆ‘ä»¬é€‰æ‹©äº†ä»€ä¹ˆï¼Ÿ</p><p> fn  main ( ) {  println ! ( &#34;{}&#34;, read_issue ( ).unwrap ( ) )} // what is `E` supposed to be? ğŸ‘‡ fn  read_issue ( ) -&gt;  Result &lt; String,  E &gt; { std ::fs :: read_to_string ( &#34;/etc/issue&#34; )}</p><p> fn mainï¼ˆï¼‰{printlnï¼ ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼Œread_issueï¼ˆï¼‰.unwrapï¼ˆï¼‰ï¼‰} //æ˜¯ä»€ä¹ˆæ˜¯`E`åº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ ğŸ‘‡fn read_issueï¼ˆï¼‰ - ï¼†gt;ç»“æœï¼†lt;å­—ç¬¦ä¸²ï¼ŒEï¼†gt; {std :: fs :: read_to_stringï¼ˆï¼†ï¼ƒ34; / etc /é—®é¢˜ï¼†ï¼ƒ34;ï¼‰}</p><p> And that problem, that specific problem, is not something we really have toworry about in some other languages, like for instance... ECMAScript! I mean,JavaScript!</p><p> é‚£ä¸ªé—®é¢˜ï¼Œé‚£ä¸ªå…·ä½“çš„é—®é¢˜ï¼Œä¸æ˜¯æˆ‘ä»¬çœŸæ­£æ‹¥æœ‰çš„ä¸€äº›å…¶ä»–è¯­è¨€çš„ä¸œè¥¿ï¼Œæ¯”å¦‚...... ECMAScriptï¼æˆ‘çš„æ„æ€æ˜¯ï¼Œjavascriptï¼</p><p>  import  {  readFileSync  }  from  &#34;fs&#34; ; function  main ( )  {  let  issue  =  readIssue ( ) ;  console . log ( ` ${ issue }` ) ; } function  readIssue ( )  {  readFileSync ( &#34;/etc/i-do-not-exist&#34; ) ; } main ( ) ;</p><p>  ä»ï¼†ï¼ƒ34å¯¼å…¥{readfilesync}; fsï¼†ï¼ƒ34; ; function mainï¼ˆï¼‰{leté—®é¢˜= readissueï¼ˆï¼‰;å®‰æ…° ã€‚æ—¥å¿—ï¼ˆ`$ {é—®é¢˜}`ï¼‰; }å‡½æ•°readissueï¼ˆï¼‰{readfilesyncï¼ˆï¼†ï¼ƒ34; / etc / i-do-not-witt-wittsï¼†ï¼ƒ34;ï¼‰; } ä¸»è¦çš„ ï¼ˆ ï¼‰ ;</p><p> $ node js/index.mjs node:fs:505 handleErrorFromBinding(ctx); ^Error: ENOENT: no such file or directory, open &#39;/etc/i-do-not-exist&#39; at Object.openSync (node:fs:505:3) at readFileSync (node:fs:401:35) at readIssue (file:///home/amos/ftl/whatbox/js/index.mjs:9:5) at main (file:///home/amos/ftl/whatbox/js/index.mjs:4:17) at file:///home/amos/ftl/whatbox/js/index.mjs:12:1 at ModuleJob.run (node:internal/modules/esm/module_job:154:23) at async Loader.import (node:internal/modules/esm/loader:177:24) at async Object.loadESM (node:internal/process/esm_loader:68:5) { errno: -2, syscall: &#39;open&#39;, code: &#39;ENOENT&#39;, path: &#39;/etc/i-do-not-exist&#39;}</p><p> $èŠ‚ç‚¹js / index.mjsèŠ‚ç‚¹ï¼šFSï¼š505 HanderErrorfrombinIningï¼ˆCTXï¼‰; ^é”™è¯¯ï¼šEnoentï¼šæ²¡æœ‰è¿™æ ·çš„æ–‡ä»¶æˆ–ç›®å½•ï¼Œæ‰“å¼€ï¼†ï¼ƒ39; / etc / i-do-not-wittsï¼†ï¼ƒ39;åœ¨Readfilesyncï¼ˆnodeï¼šfsï¼š401ï¼š35ï¼‰åœ¨Readissueï¼ˆæ–‡ä»¶ï¼š///home/amos/ftl/whatbox/js/index.mjsï¼š9ï¼š5ï¼‰åœ¨ä¸»è¦ï¼ˆæ–‡ä»¶ï¼š//home/amos/ftl/whatbox/js/index.mjsï¼š4ï¼š17ï¼‰æ–‡ä»¶ï¼š///home/amos/ftl/whatbox/js/index.mjsï¼š12ï¼š1åœ¨modulejob.runï¼ˆèŠ‚ç‚¹ï¼šå†…éƒ¨/æ¨¡å—/ ESM / module_jobï¼š154ï¼š23ï¼‰åœ¨Async Loader.importï¼ˆNeutsï¼šModules / ESM / Loaderï¼š177ï¼š24ï¼‰åœ¨Async Object.LoadMä¸­ï¼ˆèŠ‚ç‚¹ï¼šå†…éƒ¨/æµç¨‹/ ESM_Loaderï¼š68ï¼š5ï¼‰{errnoï¼š-2ï¼Œsyscallï¼šï¼†ï¼ƒ39;æ‰“å¼€ï¼†ï¼ƒ39;ï¼Œä»£ç ï¼šï¼†ï¼ƒ39; enoentï¼†ï¼ƒ39;ï¼Œè·¯å¾„ï¼šï¼†ï¼ƒ39; / etc / i-do-not-idesï¼† ï¼ƒ39;}</p><p> And we don&#39;t  have to worry whether  readIssue can or cannot throw when wecall it:</p><p> æˆ‘ä»¬ä¸å¿…æ‹…å¿ƒé˜…è¯»æ˜¯å¦å¯ä»¥æ‹…å¿ƒé˜…è¯»å¯ä»¥æˆ–ä¸èƒ½æŠ›å‡ºï¼š </p><p>  Well, maybe we should! Maybe we should wrap it in a try-catch, just so we canrecover from any exceptions thrown. But we don&#39;t  have to. Our programfollows the happy path happily.</p><p>å¥½å§ï¼Œä¹Ÿè®¸æˆ‘ä»¬åº”è¯¥ï¼ä¹Ÿè®¸æˆ‘ä»¬åº”è¯¥åœ¨ä¸€ä¸ªå°è¯•ä¸­åŒ…è£…å®ƒï¼Œåªéœ€ä»ä»»ä½•æŠ›å‡ºçš„ä»»ä½•ä¾‹å¤–éƒ½å¯ä»¥é‡Šæ”¾ã€‚ä½†æˆ‘ä»¬ä¸å¾—ä¸ã€‚æˆ‘ä»¬çš„ç¼–ç¨‹æ„‰å¿«åœ°æ„‰å¿«åœ°æ•£æ­¥ã€‚</p><p> In Go, there&#39;s no exceptions, but there is usually an indication that afunction can fail in its signature.</p><p> åœ¨Goï¼Œæ²¡æœ‰ä¾‹å¤–ï¼Œä½†é€šå¸¸æœ‰ä¸€ä¸ªæŒ‡ç¤ºåœ¨å…¶ç­¾åä¸­å¯èƒ½ä¼šå¤±è´¥ã€‚</p><p> package main import (	 &#34;log&#34;	 &#34;os&#34;) func  main() {	 issue  :=  readIssue()	 log. Printf( &#34;issue = %v&#34;,  issue)} func  readIssue()  string {	 bs,  _  :=  os. ReadFile( &#34;&#34;)	 return  string( bs)}</p><p> åŒ…ä¸»è¦å¯¼å…¥ï¼ˆï¼†ï¼ƒ34; logï¼†ï¼ƒ34;ï¼†ï¼ƒ34; osï¼†ï¼ƒ34;ï¼‰func mainï¼ˆï¼‰{é—®é¢˜ï¼š= readissueï¼ˆï¼‰æ—¥å¿—ã€‚ printfï¼ˆï¼†ï¼ƒ34;é—®é¢˜=ï¼…vï¼†ï¼ƒ34;é—®é¢˜ï¼‰} func readissueï¼ˆï¼‰å­—ç¬¦ä¸²{bsï¼Œ_ï¼š=æ“ä½œç³»ç»Ÿã€‚ ReadFileï¼ˆï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼‰è¿”å›å­—ç¬¦ä¸²ï¼ˆBSï¼‰}</p><p>   package main import (	 &#34;log&#34;	 &#34;os&#34;) func  main() {	 // we get two values out of readIssue, including `err`	 issue,  err  :=  readIssue()	 // ...which we should check for nil-ness	 if  err  !=  nil {		 // ...and handle		 log. Fatalf( &#34;fatal error: %+v&#34;,  err)	}	 log. Printf( &#34;issue = %v&#34;,  issue)} func  readIssue() ( string,  error) {	 bs,  err  :=  os. ReadFile( &#34;&#34;)	 // same here, `ReadFile` does a multi-valued return, so we need	 // to check `err` first:	 if  err  !=  nil {		 return  &#34;&#34;,  err	}	 // and only here do we know reading the file actually succeeded:	 return  string( bs),  nil}</p><p>   åŒ…ä¸»è¦å¯¼å…¥ï¼ˆï¼†ï¼ƒ34; logï¼†ï¼ƒ34;ï¼†ï¼ƒ34; OSï¼†ï¼ƒ34;ï¼‰func mainï¼ˆï¼‰{//æˆ‘ä»¬è·å¾—äº†ä¸¤ä¸ªå€¼ï¼ŒåŒ…æ‹¬`err`é—®é¢˜ï¼Œerrï¼š= readissueï¼ˆï¼‰// ...å¦‚æœerrï¼= nil {// ......å¹¶å¤„ç†æ—¥å¿—ï¼Œæˆ‘ä»¬åº”è¯¥æ£€æŸ¥nil-nessã€‚ Fatalfï¼ˆï¼†ï¼ƒ34;è‡´å‘½é”™è¯¯ï¼šï¼…+ vï¼†ï¼ƒ34;ï¼Œerrï¼‰}æ—¥å¿—ã€‚ printfï¼ˆï¼†ï¼ƒ34;é—®é¢˜=ï¼…vï¼†ï¼ƒ34;é—®é¢˜ï¼‰} func Readissueï¼ˆï¼‰ï¼ˆå­—ç¬¦ä¸²ï¼Œé”™è¯¯ï¼‰{bsï¼Œerrï¼š=æ“ä½œç³»ç»Ÿã€‚ ReadFileï¼ˆï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼‰//åŒæ ·ï¼Œ'readfile`æ˜¯ä¸€ä¸ªå¤šä»·å€¼çš„è¿”å›ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦//é¦–å…ˆæ£€æŸ¥`err`ï¼šå¦‚æœerrï¼= nil {è¿”å›ï¼†ï¼ƒ34;ï¼† ï¼ƒ34;ï¼Œerr} //åªæœ‰åœ¨è¿™é‡Œæˆ‘ä»¬çŸ¥é“è¯»å–æ–‡ä»¶å®é™…ä¸ŠæˆåŠŸï¼šè¿”å›å­—ç¬¦ä¸²ï¼ˆBSï¼‰ï¼Œnil}</p><p>  $ go run go/main.go2021/04/17 20:47:37 fatal error: open : no such file or directoryexit status 1</p><p>  $ goè¿è¡Œgo / main.go2021 / 04/17 20:47:37è‡´å‘½é”™è¯¯ï¼šæ‰“å¼€ï¼šæ²¡æœ‰è¿™æ ·çš„æ–‡ä»¶æˆ–directoryexitçŠ¶æ€1</p><p> However, note that it does not tell us  where in the code the erroroccurred, whereas the JavaScript/Node.js version did.</p><p> ä½†æ˜¯ï¼Œè¯·æ³¨æ„ï¼Œå®ƒæ²¡æœ‰å‘Šè¯‰æˆ‘ä»¬åœ¨ä»£ç ä¸­çš„ä½•å¤„æ˜¯é”™è¯¯çš„ï¼Œè€ŒJavaScript / node.jsç‰ˆæœ¬ã€‚</p><p> There&#39;s  a solution to that, but bydefault, out of the box, Go errors do not capture stack traces.</p><p> åœ¨é‚£é‡Œæœ‰ä¸€ä¸ªè§£å†³æ–¹æ¡ˆï¼Œä½†æ˜¯bydefaultå¼€ç®±å³ç”¨ï¼Œgoé”™è¯¯ä¸ä¼šæ•è·å †æ ˆç—•è¿¹ã€‚ </p><p> And then there&#39;s Rust, which is the most strict of the three, that forces usto declare that a function can fail, forces us to handle any error that mayhave occurred in a function, but also forces us to describe &#34;what possibleerror values are there&#34;.</p><p>ç„¶åæ˜¯é‚£é‡Œçš„ç”Ÿé”ˆï¼Œè¿™æ˜¯ä¸‰è€…ä¸­æœ€ä¸¥æ ¼çš„rustï¼Œè¿«ä½¿USTOå£°æ˜ä¸€ä¸ªå‡½æ•°å¯ä»¥å¤±è´¥ï¼Œå¼ºè¿«æˆ‘ä»¬å¤„ç†å¯èƒ½åœ¨å‡½æ•°ä¸­å‘ç”Ÿçš„ä»»ä½•é”™è¯¯ï¼Œä½†ä¹Ÿè¿«ä½¿æˆ‘ä»¬æè¿°ï¼†ï¼ƒ34 ;æœ‰å¯èƒ½çš„é”™è¯¯å€¼æ˜¯æœ‰å¯èƒ½çš„ã€‚</p><p>    $ node js/index.mjsnode:internal/process/esm_loader:74 internalBinding(&#39;errors&#39;).triggerUncaughtException( ^woops(Use `node --trace-uncaught ...` to show where the exception was thrown)</p><p>    $ node js / index.mjsnodeï¼šå†…éƒ¨/è¿›ç¨‹/ ESM_LOADERï¼š74å†…éƒ¨å±éšœï¼ˆï¼†ï¼ƒ39;é”™è¯¯ï¼†ï¼ƒ39;ï¼‰ã€‚triggerung ackexceptionï¼ˆ^ woopsï¼ˆä½¿ç”¨`node -trace-undaught ...`æ¥æ˜¾ç¤ºå¼‚å¸¸çš„ä½ç½®æ‰”äº†ï¼‰</p><p> This is not a good idea. Mostly, because then we don&#39;t get a stack trace.</p><p> è¿™ä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå› ä¸ºé‚£ä¹ˆæˆ‘ä»¬ä¸ä¼šå¾—åˆ°å †æ ˆè¿¹è±¡ã€‚</p><p>      $ node js/index.mjs file:///home/amos/ftl/whatbox/js/index.mjs:7 throw new Error(&#34;woops&#34;); ^Error: woops at readIssue (file:///home/amos/ftl/whatbox/js/index.mjs:7:11) at main (file:///home/amos/ftl/whatbox/js/index.mjs:2:17) at file:///home/amos/ftl/whatbox/js/index.mjs:10:1 at ModuleJob.run (node:internal/modules/esm/module_job:154:23) at async Loader.import (node:internal/modules/esm/loader:177:24) at async Object.loadESM (node:internal/process/esm_loader:68:5)</p><p>      $èŠ‚ç‚¹js / index.mjsæ–‡ä»¶ï¼š///home/amos/ftl/whatbox/js/index.mjsï¼š7æŠ›å‡ºæ–°çš„é”™è¯¯ï¼ˆï¼†ï¼ƒ34; Woopsï¼†ï¼ƒ34;ï¼‰; ^é”™è¯¯ï¼šåœ¨Readissueï¼ˆæ–‡ä»¶ï¼š///home/amos/ftl/whatbox/js/index.mmsï¼š7ï¼š11ï¼‰åœ¨mainï¼ˆæ–‡ä»¶ï¼š///ä¸»é¡µ/ amos / ftl / whatbox / js / indexã€‚ MJSï¼š2ï¼š17ï¼‰ATæ–‡ä»¶ï¼š///home/amos/ftl/whatbox/js/index.mjsï¼š10ï¼š1åœ¨modulejob.runï¼ˆèŠ‚ç‚¹ï¼šå†…éƒ¨/ modules / Esm / module_jobï¼š154ï¼š23ï¼‰åœ¨å¼‚æ­¥Loader.importï¼ˆNodeï¼šå†…éƒ¨/æ¨¡å—/ ESM / LOADERï¼š177ï¼š24ï¼‰åœ¨ASYNC Object.LoadMSMï¼ˆèŠ‚ç‚¹ï¼šå†…éƒ¨/è¿›ç¨‹/ ESM_Loaderï¼š68ï¼š5ï¼‰</p><p> As for Go, well. You can&#39;t just say you&#39;re going to return an  error, andjust return a  string. That&#39;s good.</p><p> è‡³äºå»ã€‚ä½ å¯ä»¥ï¼†ï¼ƒ39; tåªæ˜¯è¯´ä½ ï¼†ï¼ƒ39;é‡æ–°è¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚é‚£ä¸ªï¼†ï¼ƒ39;å¥½ã€‚</p><p>  $ go run go/main.go# command-line-argumentsgo/main.go:17:13: cannot use &#34;woops&#34; (type string) as type error in return argument: string does not implement error (missing Error method)</p><p>  $ go / main.goï¼ƒå‘½ä»¤è¡Œ -  argipsge / main.goï¼š17ï¼š13ï¼šä¸èƒ½ä½¿ç”¨ï¼†ï¼ƒ34; woopsï¼†ï¼ƒ34; ï¼ˆç±»å‹å­—ç¬¦ä¸²ï¼‰ä½œä¸ºè¿”å›å‚æ•°ä¸­çš„ç±»å‹é”™è¯¯ï¼šå­—ç¬¦ä¸²ä¸å®ç°é”™è¯¯ï¼ˆç¼ºå°‘é”™è¯¯æ–¹æ³•ï¼‰</p><p> Whatever you return has to be of type  error, and there is a shorthandfor that:</p><p> æ— è®ºä½ è¿”å›ä»€ä¹ˆéƒ½æ˜¯é”™è¯¯çš„é”™è¯¯ï¼Œè€Œä¸”æœ‰ä¸€ä¸ªæ›¿ä»£æ–¹æ¡ˆï¼š </p><p>   // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func  New( text  string)  error {	 return  &amp; errorString{ text}}</p><p>// newè¿”å›æ ¼å¼ä¸ºç»™å®šæ–‡æœ¬çš„é”™è¯¯ã€‚ //å³ä½¿æ–‡æœ¬æ˜¯ç›¸åŒçš„ï¼Œæ¯ä¸ªå¯¹æ–°çš„å‘¼å«ä¹Ÿè¿”å›ä¸€ä¸ªä¸åŒçš„é”™è¯¯å€¼ã€‚ Func newï¼ˆæ–‡æœ¬å­—ç¬¦ä¸²ï¼‰é”™è¯¯{returnï¼†amp; errorstring {text}}</p><p>   That implements the  error interface. All the interface asks for is thatthere is an  Error() method that returns a  string:</p><p>   è¿™å®ç°äº†é”™è¯¯ç•Œé¢ã€‚æ‰€æœ‰æ¥å£éƒ½è¦æ±‚è¿”å›å­—ç¬¦ä¸²çš„é”™è¯¯ï¼ˆï¼‰æ–¹æ³•ï¼š</p><p>    Which is not to say that error handling in Go is a walk in the park.</p><p>    è¿™å¹¶ä¸æ˜¯è¯´å»çš„é”™è¯¯å¤„ç†æ˜¯åœ¨å…¬å›­æ•£æ­¥ã€‚</p><p> This first bit has been pointed out in almost every article that has eventhe slightest amount of feelings about Go: it&#39;s just way too easy to ignore,or &#34;forget to handle&#34; Go errors:</p><p> å‡ ä¹æ‰€æœ‰å…³äºGoçš„æ„Ÿè§‰å‡ ä¹æ‰€æœ‰æ–‡ç« éƒ½æŒ‡å‡ºäº†è¿™ä¸€æ¯”ç‰¹ï¼šå®ƒï¼†ï¼ƒ39;è™½ç„¶å¤ªå®¹æ˜“å¿½è§†äº†ï¼Œæˆ–è€…ï¼†ï¼ƒ34;å¿˜è®°å¤„ç†ï¼†ï¼ƒ34;å»é”™è¯¯ï¼š</p><p> func  readIssue() ( string,  error) {	 bs,  err  :=  os. ReadFile( &#34;/etc/issue&#34;)	 err  =  os. WriteFile( &#34;/tmp/issue-copy&#34;,  bs, 0o644)	 if  err  !=  nil {		 return  &#34;&#34;,  err	}	 return  string( bs),  nil}</p><p> Func Readissueï¼ˆï¼‰ï¼ˆå­—ç¬¦ä¸²ï¼Œé”™è¯¯ï¼‰{BSï¼ŒERRï¼š= OSã€‚ ReadFileï¼ˆï¼†ï¼ƒ34; / etc /é—®é¢˜ï¼†ï¼ƒ34;ï¼‰err = osã€‚ writefileï¼ˆï¼†ï¼ƒ34; / tmp / moss-copyï¼†ï¼ƒ34; bsï¼Œ0o644ï¼‰å¦‚æœerrï¼= nil {returnï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼Œerr} returnå­—ç¬¦ä¸²ï¼ˆbsï¼‰ï¼Œnil}</p><p> Woops! No warnings, no nothing. If we fail to read the file, that error isgone forever. The issue here is of course that Go returns &#34;multiple things&#34;:both the &#34;success value&#34; and the &#34;error value&#34;, and it&#39;s on you to pinky swear not to touch the success value, if you haven&#39;t checked the error value first.</p><p> Woopsï¼æ²¡æœ‰è­¦å‘Šï¼Œæ²¡æœ‰ä»€ä¹ˆã€‚å¦‚æœæˆ‘ä»¬æ— æ³•è¯»å–è¯¥æ–‡ä»¶ï¼Œé‚£ä¹ˆæ°¸è¿œé”™è¯¯åœ°é”™è¯¯ã€‚è¿™é‡Œçš„é—®é¢˜å½“ç„¶æ˜¯è¿”å›ï¼†ï¼ƒ34;å¤šä»¶äº‹ï¼†ï¼ƒ34;ï¼šï¼†ï¼ƒ34;æˆåŠŸä»·å€¼ï¼†ï¼ƒ34;å’Œï¼ƒ34;è¯¯å·®å€¼ï¼†ï¼ƒ34;å’Œå®ƒï¼†ï¼ƒ39;åœ¨ç²‰çº¢è‰²å‘èª“ä¸è¦è§¦æ‘¸æˆåŠŸä»·å€¼ï¼Œå¦‚æœä½ vervenï¼†ï¼ƒ39; tå…ˆæ£€æŸ¥äº†é”™è¯¯å€¼ã€‚</p><p> And that problem doesn&#39;t exist in a language with sum types â€” a Rust Resultis either  Result::Ok(T), or  Result::Err(E), never both.</p><p> å¹¶ä¸”è¿™ä¸ªé—®é¢˜å¹¶ä¸å­˜åœ¨äºä¸€ç§è¯­è¨€ä¸­çš„è¯­è¨€ - ä¸€ä¸ªç”Ÿé”ˆç»“æœï¼Œç»“æœ:: OKï¼ˆtï¼‰ï¼Œæˆ–ç»“æœ:: errï¼ˆeï¼‰ï¼Œä»ä¸å…¼è€Œæœ‰ä¹‹ã€‚ </p><p>    Then we can return it as an  error. Because  error is an interface, and *naughtyError has an  Error method that returns a string, everything fitstogether, boom, composition, alright!</p><p>ç„¶åæˆ‘ä»¬å¯ä»¥å°†å…¶ä½œä¸ºé”™è¯¯è¿”å›ã€‚å› ä¸ºé”™è¯¯æ˜¯ä¸€ä¸ªæ¥å£ï¼Œè€Œ* naugtyerroræœ‰ä¸€ä¸ªé”™è¯¯çš„æ–¹æ³•è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¸€åˆ‡éƒ½å¾ˆç´§èº«ï¼Œç¹è£ï¼Œç»„æˆï¼Œå¥½ï¼</p><p>   But if we accidentally return a value of type  *naughtyError, that justhappens to be  nil, well...</p><p>   ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ä¸å°å¿ƒè¿”å›äº†ä¸€ä¸ªç±»å‹çš„* naugtyerrorçš„ä»·å€¼ï¼Œé‚£ä¹ˆjusthappenså°±æ˜¯é›¶ï¼Œå¥½å§......</p><p> package main import (	 &#34;log&#34;) func  readIssue() ( string,  error) {	 var  err  * naughtyError	 log. Printf( &#34;(in readIssue) is err nil? %v&#34;,  err  ==  nil)	 return  &#34;&#34;,  err} func  main() {	 issue,  err  :=  readIssue()	 log. Printf( &#34;(in main) is err nil? %v&#34;,  err  ==  nil)	 if  err  !=  nil {		 log. Fatalf( &#34;fatal error: %+v&#34;,  err)	}	 log. Printf( &#34;issue = %v&#34;,  issue)} // type  naughtyError  struct{} func ( ne  * naughtyError)  Error()  string {	 return  &#34;oh no&#34;}</p><p> åŒ…ä¸»è¦å¯¼å…¥ï¼ˆï¼†ï¼ƒ34; logï¼†ï¼ƒ34;ï¼‰func Readissueï¼ˆï¼‰ï¼ˆå­—ç¬¦ä¸²ï¼Œé”™è¯¯ï¼‰{var Err * naughtyErroræ—¥å¿—ã€‚ Printfï¼ˆï¼†ï¼ƒ34;ï¼ˆåœ¨Readissuesä¸­ï¼‰æ˜¯é”™è¯¯çš„å—ï¼Ÿï¼…vï¼†ï¼ƒ34;ï¼Œerr == nilï¼‰è¿”å›ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼Œerr} func mainï¼ˆï¼‰{é—®é¢˜ï¼Œerrï¼š= readissueï¼ˆï¼‰æ—¥å¿—ã€‚å¦‚æœerrï¼= nil {logï¼Œprintfï¼ˆï¼†ï¼ƒ34;ï¼ˆä¸»è¦ï¼‰æ˜¯err nilï¼Ÿï¼…vï¼†ï¼ƒ34;ï¼Œerr == nilï¼‰ã€‚ Fatalfï¼ˆï¼†ï¼ƒ34;è‡´å‘½é”™è¯¯ï¼šï¼…+ vï¼†ï¼ƒ34;ï¼Œerrï¼‰}æ—¥å¿—ã€‚ printfï¼ˆï¼†ï¼ƒ34;é—®é¢˜=ï¼…vï¼†ï¼ƒ34;é—®é¢˜ï¼‰} //ç±»å‹naughtyerror struct {} funcï¼ˆne * naugtyerrorï¼‰é”™è¯¯ï¼ˆï¼‰å­—ç¬¦ä¸²{returnï¼†ï¼ƒ34; ob noï¼†ï¼ƒ34;}</p><p> $ go run go/main.go2021/04/17 21:08:08 (in readIssue) is err nil? true2021/04/17 21:08:08 (in main) is err nil? false2021/04/17 21:08:08 fatal error: oh noexit status 1</p><p> $ goè¿è¡Œgo / main.go2021 / 04/17 21:08:08ï¼ˆåœ¨Readissueï¼‰æ˜¯é”™è¯¯çš„å—ï¼Ÿ True2021 / 04/17 21:08:08ï¼ˆä¸»è¦ï¼‰æ˜¯é”™è¯¯å—ï¼Ÿ False2021 / 04/17 21:08:08è‡´å‘½é”™è¯¯ï¼šoh noxitçŠ¶æ€1</p><p>   The first issue, &#34;forgetting to check for nil&#34;, is easy to understand.  Wetold you where the error was. Just don&#39;t forget to check it. It&#39;s easy to fitinto one&#39;s mental model of Go, which is advertised as really really simple.</p><p>   ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œï¼†ï¼ƒ34;å¿˜è®°æ£€æŸ¥nilï¼†ï¼ƒ34;å¾ˆå®¹æ˜“ç†è§£ã€‚éŸ¦å°”æ‰˜ä½ é”™è¯¯çš„åœ°æ–¹ã€‚åªæ˜¯ä¸è¦å¿˜è®°æ£€æŸ¥ä¸€ä¸‹ã€‚å®ƒæ˜“äºFitinto Oneï¼†ï¼ƒ39; Goçš„å¿ƒç†æ¨¡å‹ï¼Œè¿™æ˜¯çœŸæ­£ç®€å•çš„å®£ä¼ ã€‚</p><p>    We have two  err values in our last, naughty sample program. One of themcompares equal to  nil, and the other does not.</p><p>    æˆ‘ä»¬ä¸Šæ¬¡é¡½çš®çš„ç¤ºä¾‹è®¡åˆ’ä¸­æœ‰ä¸¤ä¸ªé”™è¯¯çš„å€¼ã€‚å…¶ä¸­ä¸€ä¸ªæ¯”ä¾‹ç­‰äºnilï¼Œå¦ä¸€ä¸ªæ²¡æœ‰ã€‚</p><p>  package main import (	 &#34;log&#34;	 &#34;unsafe&#34;) func  readIssue() ( string,  error) {	 var  err  * naughtyError	 log. Printf( &#34;(in readIssue) nil? %v, size = %v&#34;,  err  ==  nil,  unsafe. Sizeof( err))	 return  &#34;&#34;,  err} func  main() {	 issue,  err  :=  readIssue()	 log. Printf( &#34;(in main) nil? %v, size = %v&#34;,  err  ==  nil,  unsafe. Sizeof( err))	 if  err  !=  nil {		 log. Fatalf( &#34;fatal error: %+v&#34;,  err)	}	 log. Printf( &#34;issue = %v&#34;,  issue)} // type  naughtyError  struct{} func ( ne  * naughtyError)  Error()  string {	 return  &#34;oh no&#34;}</p><p>  åŒ…ä¸»è¦å¯¼å…¥ï¼ˆï¼†ï¼ƒ34; logï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ä¸å®‰å…¨ï¼†ï¼ƒ34;ï¼‰func readissueï¼ˆï¼‰ï¼ˆå­—ç¬¦ä¸²ï¼Œé”™è¯¯ï¼‰{var err * naughtyerroræ—¥å¿—ã€‚ printfï¼ˆï¼†ï¼ƒ34;ï¼ˆreadissueeï¼‰nilï¼Ÿï¼…vï¼Œsize =ï¼…vï¼†ï¼ƒ34;ï¼Œerr == nilï¼Œä¸å®‰å…¨ã€‚sizeofï¼ˆé”™è¯¯ï¼‰ï¼‰è¿”å›ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼Œerr} func mainï¼ˆ ï¼‰{é—®é¢˜ï¼Œerrï¼š= readissueï¼ˆï¼‰æ—¥å¿—ã€‚ printfï¼ˆï¼†ï¼ƒ34;ï¼ˆä¸»è¦ï¼‰nilï¼Ÿï¼…vï¼Œsize =ï¼…vï¼†ï¼ƒ34;ï¼Œerr == nilï¼Œä¸å®‰å…¨ã€‚å¦‚æœerrï¼= nil {log {logã€‚ Fatalfï¼ˆï¼†ï¼ƒ34;è‡´å‘½é”™è¯¯ï¼šï¼…+ vï¼†ï¼ƒ34;ï¼Œerrï¼‰}æ—¥å¿—ã€‚ printfï¼ˆï¼†ï¼ƒ34;é—®é¢˜=ï¼…vï¼†ï¼ƒ34;é—®é¢˜ï¼‰} //ç±»å‹naughtyerror struct {} funcï¼ˆne * naugtyerrorï¼‰é”™è¯¯ï¼ˆï¼‰å­—ç¬¦ä¸²{returnï¼†ï¼ƒ34; ob noï¼†ï¼ƒ34;} </p><p> Packages that import unsafe may be non-portable and are not protected by theGo 1 compatibility guidelines.</p><p>è¿›å£ä¸å®‰å…¨çš„è½¯ä»¶åŒ…å¯èƒ½æ˜¯ä¸å¯ç§»æ¤çš„ï¼Œä¸å—å…¼å®¹æ€§æŒ‡å—çš„ä¿æŠ¤ã€‚</p><p> ...but what we&#39;re doing here is completely harmless. The important bit, as Iunderstand it, is that as a Go developer,  you&#39;re not supposed to care.</p><p> ......ä½†æˆ‘ä»¬åœ¨è¿™é‡Œåšä»€ä¹ˆæ˜¯å®Œå…¨æ— å®³çš„ã€‚é‡è¦çš„ä½ï¼Œæ­£å¦‚Iyunderstandï¼Œå°±æ˜¯ä½œä¸ºä¸€ä¸ªå»å¼€å‘äººå‘˜ï¼Œä½ ï¼†ï¼ƒ39;é‡ç”³ä¸åº”è¯¥å…³å¿ƒã€‚</p><p> You&#39;re not supposed to look at these things. Go is simple! Byte slices arestrings! Go has no pointer arithmetic! Who cares how large a type is!</p><p> ä½ ï¼†ï¼ƒ39;é‡ç”³ä¸åº”è¯¥çœ‹è¿™äº›ä¸œè¥¿ã€‚ Goå¾ˆç®€å•ï¼å­—èŠ‚åˆ‡ç‰‡arstringsï¼ Goæ²¡æœ‰æŒ‡é’ˆç®—æœ¯ï¼è°å…³å¿ƒä¸€ç§ç±»å‹çš„æ€åº¦ï¼</p><p> Until you do care, and then, well, you&#39;re on your own. And &#34;using unsafe&#34; isexactly what being on your own here. But it&#39;s okay. We&#39;re all on our owntogether.</p><p> ç›´åˆ°ä½ ç…§é¡¾ï¼Œç„¶åï¼Œå—¯ï¼Œä½ è‡ªå·±ï¼†ï¼ƒ39;ä»–ä»¬è‡ªå·±ã€‚å’Œï¼ƒ34;ä½¿ç”¨ä¸å®‰å…¨ï¼†ï¼ƒ34; isexactlyåœ¨è¿™é‡Œè‡ªè¡Œã€‚ä½†å®ƒï¼†ï¼ƒ39;å¥½å§ã€‚æˆ‘ä»¬ï¼†ï¼ƒ39;æ‰€æœ‰è¿™äº›éƒ½åœ¨æˆ‘ä»¬çš„å”¯ä¸€ã€‚</p><p>  $ go run go/main.go2021/04/17 21:19:12 (in readIssue) nil? true, size = 82021/04/17 21:19:12 (in main) nil? false, size = 162021/04/17 21:19:12 fatal error: oh noexit status 1</p><p>  $ goè¿è¡Œgo / main.go2021 / 04/17 21:19:12ï¼ˆåœ¨Readissueï¼‰nilï¼ŸçœŸå®çš„ï¼Œå¤§å°= 82021/04/17 21:19:12ï¼ˆä¸»è¦ï¼‰é›¶ï¼Ÿ FALSEï¼ŒSIZE = 162021/04/17 21:19:12è‡´å‘½é”™è¯¯ï¼šOH NoxitçŠ¶æ€1</p><p>  This is the kind of example that, given enough time, one could figure out thesolution all on their own. But when falling face to face with it, and when ithas been a while, it is... puzzling.</p><p>  è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œç»™å‡ºè¶³å¤Ÿçš„æ—¶é—´ï¼Œäººä»¬å¯ä»¥è‡ªå·±å¼„æ¸…æ¥šè‡ªå·±çš„é€‰æ‹©ã€‚ä½†æ˜¯å½“é¢å¯¹é¢å è½æ—¶ï¼Œå½“ä¼Šè¨å·²ç»æœ‰ä¸€æ®µæ—¶é—´æ—¶ï¼Œå®ƒå°±æ˜¯......ä»¤äººè´¹è§£çš„ã€‚</p><p>    The zero value of a pointer is  nil, so it&#39;s equal to  nil. And we&#39;re (well,I&#39;m) on 64-bit Linux, so the size of a pointer is 64 bits, or 8 bytes.</p><p>    æŒ‡é’ˆçš„é›¶å€¼ä¸ºnilï¼Œæ‰€ä»¥å®ƒç­‰äºnilã€‚å’Œæˆ‘ä»¬ï¼†ï¼ƒ39;åœ¨64ä½Linuxä¸Šï¼ˆäº•ï¼Œiï¼†ï¼ƒ39; mï¼‰ï¼Œå› æ­¤æŒ‡é’ˆçš„å¤§å°ä¸º64ä½æˆ–8ä¸ªå­—èŠ‚ã€‚ </p><p> If you&#39;re reading this from a machine whose byte isn&#39;t 8 bits, please,  please send a picture.</p><p>å¦‚æœä½ ï¼†ï¼ƒ39;ä»ä¸€å°byte isnï¼†ï¼ƒ39; t 8ä½çš„æœºå™¨è¯»å–è¿™ä¸€ç‚¹ï¼Œè¯·å‘ä¸€å¼ ç…§ç‰‡ã€‚</p><p> The second line is a lot more surprising â€” not only does it not equal  nil,but, it&#39;s also twice as large.</p><p> ç¬¬äºŒè¡Œæ›´ä»¤äººæƒŠè®¶ - ä¸ä»…å®ƒä¸ç­‰äºé›¶ï¼Œè€Œä¸”ï¼Œå®ƒä¹Ÿæ˜¯ä¸¤å€çš„ä¸¤å€ã€‚</p><p>  package main import (	 &#34;log&#34;) func  main() {	 var  err  error	 err  = ( * naughtyError)( nil)	 log. Printf( &#34;%v&#34;,  err)	 err  = ( * niceError)( nil)	 log. Printf( &#34;%v&#34;,  err)} type  naughtyError  struct{} func ( ne  * naughtyError)  Error()  string {	 return  &#34;oh no&#34;} type  niceError  struct{} func ( ne  * niceError)  Error()  string {	 return  &#34;ho ho ho!&#34;}</p><p>  åŒ…ä¸»è¦å¯¼å…¥ï¼ˆï¼†ï¼ƒ34; logï¼†ï¼ƒ34;ï¼‰func mainï¼ˆï¼‰{var erré”™è¯¯err =ï¼ˆ* naugtyerrorï¼‰ï¼ˆnilï¼‰æ—¥å¿—ã€‚ printfï¼ˆï¼†ï¼ƒ34;ï¼…vï¼†ï¼ƒ34; errï¼‰err =ï¼ˆ* niceErrorï¼‰ï¼ˆnilï¼‰æ—¥å¿—ã€‚ printfï¼ˆï¼†ï¼ƒ34;ï¼…vï¼†ï¼ƒ34; errï¼‰} type naugtyerror struct {} funcï¼ˆne * naugtyerrorï¼‰é”™è¯¯ï¼ˆï¼‰å­—ç¬¦ä¸²{returnï¼†ï¼ƒ34; obï¼†ï¼ƒ34;} type niceerror struct {} funcï¼ˆne * niceErrorï¼‰é”™è¯¯ï¼ˆï¼‰å­—ç¬¦ä¸²{è¿”å›ï¼†ï¼ƒ34;ä½•æµ©æµ©ï¼ï¼†ï¼ƒ34;}</p><p> What a nice holiday-themed error. We have two  nil values, and they bothprint different things!</p><p> å¤šä¹ˆæ„‰å¿«çš„å‡æœŸä¸»é¢˜é”™è¯¯ã€‚æˆ‘ä»¬æœ‰ä¸¤ä¸ªé›¶ä»·å€¼è§‚ï¼Œä»–ä»¬æ¶‰ç°ä¸åŒçš„ä¸œè¥¿ï¼</p><p>    Because these values are are both  nil! But uhhh when acting as an interfacevalue (for the  error interface), they behave differently!</p><p>    å› ä¸ºè¿™äº›å€¼éƒ½æ˜¯nilï¼ä½†æ˜¯ï¼Œuhhhå……å½“interfacevalueï¼ˆå¯¹äºé”™è¯¯ç•Œé¢ï¼‰ï¼Œå®ƒä»¬çš„è¡Œä¸ºæ–¹å¼ä¸åŒï¼</p><p>  And so the size of an  error interface value is 16 bytes because... there&#39;stwo pointers!</p><p>  å› æ­¤é”™è¯¯ç•Œé¢å€¼çš„å¤§å°æ˜¯16ä¸ªå­—èŠ‚ï¼Œå› ä¸º...æœ‰......ï¼†ï¼ƒ39; stwoæŒ‡é’ˆï¼</p><p>      To &#34;downcast&#34; it, ie. to go from the interface type, back to the concrete type:</p><p>      ï¼†ï¼ƒ34;æ‚²ä¼¤å’Œï¼ƒ34;å®ƒï¼Œå³ã€‚è¦ä»ç•Œé¢ç±»å‹è½¬åˆ°æ··å‡åœŸç±»å‹ï¼š </p><p> package main import (	 &#34;errors&#34;	 &#34;log&#34;) func  showType( err  error) {	 // ğŸ‘‡ downcasting action happens here	 if  _,  ok  :=  err.( * naughtyError);  ok {		 log. Printf( &#34;got a *naughtyError&#34;)	}  else  if  _,  ok  :=  err.( * niceError);  ok {		 log. Printf( &#34;got a *niceError&#34;)	}  else {		 log. Printf( &#34;got another kind of error&#34;)	}} func  main() {	 showType(( * naughtyError)( nil))	 showType(( * niceError)( nil))	 showType( errors. New( &#34;&#34;))} type  naughtyError  struct{} func ( ne  * naughtyError)  Error()  string {	 return  &#34;oh no&#34;} type  niceError  struct{} func ( ne  * niceError)  Error()  string {	 return  &#34;ho ho ho!&#34;}</p><p>åŒ…ä¸»è¦å¯¼å…¥ï¼ˆï¼†ï¼ƒ34;é”™è¯¯ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; logï¼†ï¼ƒ34;ï¼‰func showtypeï¼ˆé”™è¯¯é”™è¯¯ï¼‰{//ğŸ‘‡è¶Šéœ‡æƒŠçš„æ“ä½œå¦‚æœ_ï¼Œå¥½çš„è¯ï¼š= errã€‚ï¼ˆ* naughtyerrorï¼‰;å¥½çš„{logã€‚ printfï¼ˆï¼†ï¼ƒ34;æœ‰ä¸€ä¸ª* naugtyerrorï¼†ï¼ƒ34;ï¼‰}å¦‚æœ_ï¼Œå¥½çš„ï¼š= errã€‚ï¼ˆ* niceErrorï¼‰;å¥½çš„{logã€‚ printfï¼ˆï¼†ï¼ƒ34;å¾—åˆ°äº†ä¸€ä¸ª* niceErrorï¼†ï¼ƒ34;ï¼‰} else {logã€‚ printfï¼ˆï¼†ï¼ƒ34;å¾—åˆ°äº†å¦ä¸€ç§é”™è¯¯ï¼†ï¼ƒ34;ï¼‰} func mainï¼ˆï¼‰{showtypeï¼ˆï¼ˆ* naugtyerrorï¼‰ï¼ˆnilï¼‰ï¼‰showtypeï¼ˆï¼ˆ* niceErrorï¼‰ï¼ˆnilï¼‰ï¼‰showtypeï¼ˆé”™è¯¯ã€‚æ–°ï¼ˆï¼†ï¼ƒ 34;ï¼†ï¼ƒ34;ï¼‰ï¼‰} type naugtyerror struct {} funcï¼ˆne * naugtyerrorï¼‰é”™è¯¯ï¼ˆï¼‰å­—ç¬¦ä¸²{returnï¼†ï¼ƒ34; obï¼†ï¼ƒ34;} type nicereror struct {} funcï¼ˆne * niceErrorï¼‰é”™è¯¯ï¼ˆï¼‰å­—ç¬¦ä¸²{è¿”å›ï¼†ï¼ƒ34;ä½•æµ©æµ©ï¼ï¼†ï¼ƒ34;}</p><p> $ go run go/main.go2021/04/17 21:33:48 got a *naughtyError2021/04/17 21:33:48 got a *niceError2021/04/17 21:33:48 got another kind of error</p><p> $ go / main.go2021 / 04/17 21:33:48 GOT a * naugtyerror2021 / 04/17 21:33:48 GOT A * NiceError2021 / 04/17 21:33:48å¾—åˆ°äº†å¦ä¸€ç§é”™è¯¯</p><p> Ah, so mystery solved! One pointer for the value, one pointer for the type:8 bytes each, together, 16 bytes.</p><p> å•Šï¼Œæ‰€ä»¥ç¥ç§˜è§£å†³äº†ï¼ä¸€ä¸ªæŒ‡é’ˆçš„å€¼ï¼Œä¸€ä¸ªæŒ‡é’ˆä¸ºç±»å‹ï¼š8ä¸ªå­—èŠ‚ï¼Œæ¯ä¸ªï¼Œä¸€èµ·ï¼Œ16ä¸ªå­—èŠ‚ã€‚</p><p>        But... there is also a standard error type. Except in Rust, capitalizationdoes not mean &#34;private or public&#34; (there&#39;s a keyword for that). Instead, all types are capitalized, by convention, so it&#39;s not  error, it&#39;s Error.</p><p>        ä½†æ˜¯......è¿˜æœ‰ä¸€ä¸ªæ ‡å‡†é”™è¯¯ç±»å‹ã€‚é™¤äº†ç”Ÿé”ˆï¼Œèµ„æœ¬åŒ–å¹¶éæ„å‘³ç€ï¼†ï¼ƒ34;ç§äººæˆ–å…¬å…±å’Œï¼ƒ34; ï¼ˆé‚£é‡Œæœ‰å…³é”®å­—ï¼‰ã€‚ç›¸åï¼Œæ‰€æœ‰ç±»å‹çš„æ‰€æœ‰ç±»å‹éƒ½æ˜¯å¤§å†™çš„ï¼Œæ‰€ä»¥å®ƒï¼†ï¼ƒ39; sä¸æ˜¯é”™è¯¯ï¼Œå®ƒï¼†ï¼ƒ39; sé”™è¯¯ã€‚</p><p>   // ğŸ‘‡ we import it here use std ::error ::Error ; fn  main ( ) {  println ! ( &#34;{}&#34;, read_issue ( ).unwrap ( ) )} // and use it there ğŸ‘‡ fn  read_issue ( ) -&gt;  Result &lt; String,  Error &gt; { std ::fs :: read_to_string ( &#34;/etc/issue&#34; )}</p><p>   //ğŸ‘‡æˆ‘ä»¬åœ¨è¿™é‡Œå¯¼å…¥å®ƒä½¿ç”¨std ::é”™è¯¯::é”™è¯¯; fn mainï¼ˆï¼‰{printlnï¼ ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼Œread_issueï¼ˆï¼‰.unwrapï¼ˆï¼‰ï¼‰} //å¹¶ä½¿ç”¨å®ƒğŸ‘‡fn read_issueï¼ˆï¼‰ - ï¼†gt;ç»“æœï¼†lt;å­—ç¬¦ä¸²ï¼Œé”™è¯¯ï¼†gt; {std :: fs :: read_to_stringï¼ˆï¼†ï¼ƒ34; / etc /é—®é¢˜ï¼†ï¼ƒ34;ï¼‰}</p><p>  $ cargo run --quietwarning: trait objects without an explicit `dyn` are deprecated --&gt; src/main.rs:7:35 |7 | fn read_issue() -&gt; Result&lt;String, Error&gt; { | ^^^^^ help: use `dyn`: `dyn Error` | = note: `#[warn(bare_trait_objects)]` on by default(rest omitted)</p><p>  $è´§ç‰©è·‘æ­¥ -  Quietwarningï¼šæ²¡æœ‰æ˜ç¡®çš„â€œdyn`çš„ç‰¹è´¨ç‰©å“è¢«è´¬å€¼ - ï¼†gt; src / main.rsï¼š7ï¼š35 | 7 | fn read_issueï¼ˆï¼‰ - ï¼†gt;ç»“æœï¼†lt;å­—ç¬¦ä¸²ï¼Œé”™è¯¯ï¼†gt; {| ^^^^^^å¸®åŠ©ï¼šä½¿ç”¨`dyn`ï¼š`dyné”™è¯¯` =æ³¨æ„ï¼š`ï¼ƒ[warnï¼ˆbaren_trait_objectsï¼‰]`é»˜è®¤æƒ…å†µä¸‹ï¼ˆçœç•¥ä¼‘æ¯ï¼‰</p><p> Oh, no, a warning! It says to use the  dyn keyword. Alright, who am Ito object, let&#39;s use the  dyn keyword.</p><p> å“¦ï¼Œä¸ï¼Œè­¦å‘Šï¼å®ƒè¯´è¦ä½¿ç”¨dynå…³é”®å­—ã€‚å¥½å§ï¼Œè°æ˜¯ITOå¯¹è±¡ï¼Œè®©ï¼†ï¼ƒ39; sä½¿ç”¨dynå…³é”®å­—ã€‚ </p><p>   $ cargo run --quieterror[E0277]: the size for values of type `(dyn std::error::Error + &#39;static)` cannot be known at compilation time --&gt; src/main.rs:7:20 |7 | fn read_issue() -&gt; Result&lt;String, dyn Error&gt; { | ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn&#39;t have a size known at compile-time | ::: /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:241:20 |241 | pub enum Result&lt;T, E&gt; { | - required by this bound in `std::result::Result` | = help: the trait `Sized` is not implemented for `(dyn std::error::Error + &#39;static)`error: aborting due to previous error</p><p>$ Cargo Run --quieterror [E0277]ï¼šç±»å‹çš„å¤§å°ä¸º`ï¼ˆDyn STD ::é”™è¯¯:: error +ï¼†ï¼ƒ39;é™æ€ï¼‰`ä¸èƒ½åœ¨ç¼–è¯‘æ—¶å·²çŸ¥ - ï¼†gt; src / main.rsï¼š7ï¼š20 | 7 | fn read_issueï¼ˆï¼‰ - ï¼†gt;ç»“æœï¼†lt;å­—ç¬¦ä¸²ï¼Œdyn errorï¼†gt; {| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^ ^^ ^^ï¼†ï¼ƒ39; tåœ¨ç¼–è¯‘æ—¶å·²çŸ¥å°ºå¯¸| ::: /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:241:20 | 241 | PUBæšä¸¾ç»“æœï¼†lt; tï¼Œe> {| - åœ¨â€œSTD ::â€ç»“æœ::ç»“æœï¼šç»“æœç•Œå®šçš„ç•Œé™= helpï¼štrait`å¤§å°`æœªå®ç°`ï¼ˆdyn std :: serrer :: serror +ï¼†ï¼ƒ39;é™æ€ï¼‰`é”™è¯¯ï¼šç”±äºä¸Šä¸€ä¸ªé”™è¯¯è€Œä¸­æ­¢</p><p>       use std ::error ::Error ; fn  main ( ) {  println ! ( &#34;{}&#34;, read_issue ( ).unwrap ( ) )} // ğŸ‘‡ fn  read_issue ( ) -&gt;  Result &lt; String,  Box &lt; dyn  Error &gt; &gt; { std ::fs :: read_to_string ( &#34;/etc/issue&#34; )}</p><p>       ä½¿ç”¨std ::é”™è¯¯::é”™è¯¯; fn mainï¼ˆï¼‰{printlnï¼ ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼Œread_issueï¼ˆï¼‰.unwrapï¼ˆï¼‰ï¼‰} //ğŸ‘‡fn read_issueï¼ˆï¼‰ - ï¼†gt;ç»“æœï¼†lt;å­—ç¬¦ä¸²ï¼Œæ¡†ï¼†lt; Dyné”™è¯¯ï¼†gt; ï¼†gt; {std :: fs :: read_to_stringï¼ˆï¼†ï¼ƒ34; / etc /é—®é¢˜ï¼†ï¼ƒ34;ï¼‰}</p><p>  $ cargo run --quieterror[E0308]: mismatched types --&gt; src/main.rs:8:5 |7 | fn read_issue() -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; { | ------------------------------ expected `std::result::Result&lt;String, Box&lt;(dyn std::error::Error + &#39;static)&gt;&gt;` because of return type8 | std::fs::read_to_string(&#34;/etc/issue&#34;) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Box`, found struct `std::io::Error` | = note: expected enum `std::result::Result&lt;_, Box&lt;(dyn std::error::Error + &#39;static)&gt;&gt;` found enum `std::result::Result&lt;_, std::io::Error&gt;`error: aborting due to previous error</p><p>  $è´§ç‰©è¿è¡Œ -  quieterror [e0308]ï¼šæ— åŒ¹é…ç±»å‹ - ï¼†gt; src / main.rsï¼š8ï¼š5 | 7 | fn read_issueï¼ˆï¼‰ - ï¼†gt;ç»“æœï¼†lt;ä¸²ï¼Œæ¡†ï¼†lt; dynï¼†gt;ï¼†gt; {| ---------------------------------ç»“æœ::ç»“æœï¼†lt;ä¸²ï¼Œæ¡†ï¼†lt; :: errat +ï¼†ï¼ƒ39;é™æ€ï¼‰ï¼†gt;ï¼†gt;â€œå› ä¸ºè¿”å›type8 | std :: fs :: read_to_stringï¼ˆï¼†ï¼ƒ34; / etc /é—®é¢˜ï¼†ï¼ƒ34;ï¼‰| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^é¢„è®¡struct`box`ï¼Œæ‰¾åˆ°struct` std :: io ::é”™è¯¯'| =æ³¨æ„ï¼šé¢„æœŸenum`STD ::ç»“æœ::ç»“æœï¼†lt; _ï¼Œboxï¼†lt;ï¼ˆdyn std :: serr :: error +ï¼†ï¼ƒ39;é™æ€ï¼‰ï¼†gt;ï¼†gt;`æ‰¾åˆ°enum` std ::ç»“æœ::ç»“æœï¼†lt; _ï¼Œstd :: io ::é”™è¯¯ï¼†gt;`é”™è¯¯ï¼šç”±äºä¸Šä¸€ä¸ªé”™è¯¯è€Œä¸­æ­¢</p><p>    Theeeeeeere we go. Now we&#39;re even. This is the closest we&#39;ll get to theaforementioned Go code.</p><p>    æˆ‘ä»¬èµ°äº†ã€‚ç°åœ¨æˆ‘ä»¬ç”šè‡³æ˜¯reã€‚è¿™æ˜¯æœ€æ¥è¿‘çš„æˆ‘ä»¬ï¼†ï¼ƒ39; llåˆ°æ¥çš„å®ˆåˆ™ã€‚</p><p>   Well, for the time being, you can sort of think about it as a pointer.</p><p>   å¥½å§ï¼Œæš‚æ—¶ï¼Œä½ å¯ä»¥å¯¹å®ƒä½œä¸ºæŒ‡é’ˆè¿›è¡Œæ€è€ƒã€‚</p><p>   struct  MyError {  value:  u32,} fn  main ( ) {  let e =  MyError {  value:  32 } ;  let e_ptr:  * const  MyError =  &amp;e ;  print_error (e_ptr ) ;} fn  print_error ( e:  * const  MyError ) {  if e != std ::ptr :: null ( ) {  println ! ( &#34;MyError (value = {})&#34;,  unsafe {  (*e ).value } ) ; }}</p><p>   struct myereror {valueï¼šu32ï¼Œ} fn mainï¼ˆï¼‰{è®©e = myError {valueï¼š32};è®©e_ptrï¼š* const myError =ï¼†amp; e; print_errorï¼ˆe_ptrï¼‰;} fn print_errorï¼ˆeï¼š* const myErrorï¼‰{å¦‚æœeï¼= std :: ptr :: nullï¼ˆï¼‰{printlnï¼ ï¼ˆï¼†ï¼ƒ34; myErrorï¼ˆvalue = {}ï¼‰ï¼†ï¼ƒ34;ï¼Œä¸å®‰å…¨{ï¼ˆ* eï¼‰.value}; }}</p><p>   fn  print_error ( e:  * const  MyError ) {  if e != std ::ptr :: null ( ) {  // ğŸ‘‡  println ! ( &#34;MyError (value = {})&#34;,  unsafe {  (*e ).value } ) ; }}</p><p>   fn print_errorï¼ˆeï¼š* const myErrorï¼‰{å¦‚æœeï¼= std :: ptr :: nullï¼ˆï¼‰{//ğŸ‘‡printlnï¼ ï¼ˆï¼†ï¼ƒ34; myErrorï¼ˆvalue = {}ï¼‰ï¼†ï¼ƒ34;ï¼Œä¸å®‰å…¨{ï¼ˆ* eï¼‰.value}; }} </p><p> Why is dereferencing a pointer  unsafe? Well, because it might be null! Orit might point to an address that does not fall within an area that&#39;smeaningful for the currently running program, and that would cause asegmentation fault.</p><p>ä¸ºä»€ä¹ˆå–æ¶ˆå¼•ç”¨æŒ‡é’ˆä¸å®‰å…¨ï¼Ÿå¥½å§ï¼Œå› ä¸ºå®ƒå¯èƒ½æ˜¯ç©ºï¼ ORITå¯èƒ½æŒ‡å‘æ²¡æœ‰è½åœ¨ä¸€ä¸ªåŒºåŸŸå†…çš„åœ°å€;å¯¹äºå½“å‰æ­£åœ¨è¿è¡Œçš„ç¨‹åºè€Œè¨€ï¼Œå®ƒä¼šå¯¼è‡´ASEGING FOURTã€‚</p><p>   struct  MyError {  value:  u32,} fn  main ( ) {  let e =  MyError {  value:  32 } ;  let e_ptr:  * const  MyError =  &amp;e ;  // ğŸ‘‡ no unsafe!  dbg ! (std::mem::size_of_val (&amp;e_ptr ) ) ;  print_error (e_ptr ) ;} fn  print_error ( e:  * const  MyError ) {  if e != std ::ptr :: null ( ) {  println ! ( &#34;MyError (value = {})&#34;,  unsafe {  (*e ).value } ) ; }}</p><p>   struct myereror {valueï¼šu32ï¼Œ} fn mainï¼ˆï¼‰{è®©e = myError {valueï¼š32};è®©e_ptrï¼š* const myError =ï¼†amp; e; //ğŸ‘‡æ²¡æœ‰ä¸å®‰å…¨ï¼ DBGï¼ ï¼ˆstd :: mem :: size_of_valï¼ˆï¼†amp; e_ptrï¼‰ï¼‰; print_errorï¼ˆe_ptrï¼‰;} fn print_errorï¼ˆeï¼š* const myErrorï¼‰{å¦‚æœeï¼= std :: ptr :: nullï¼ˆï¼‰{printlnï¼ ï¼ˆï¼†ï¼ƒ34; myErrorï¼ˆvalue = {}ï¼‰ï¼†ï¼ƒ34;ï¼Œä¸å®‰å…¨{ï¼ˆ* eï¼‰.value}; }}</p><p>  And, as expected, the size of a pointer is 8 bytes, because I&#39;m  stillwriting this from Linux 64-bit.</p><p>  å¹¶ä¸”ï¼Œæ­£å¦‚æ‰€é¢„æœŸçš„é‚£æ ·ï¼ŒæŒ‡é’ˆçš„å¤§å°æ˜¯8å­—èŠ‚ï¼Œå› ä¸ºæˆ‘ï¼†ï¼ƒ39; m instwritingä»linux 64ä½ã€‚</p><p> But: if constructing a pointer value is safe, dereferencing it (reading fromthe memory it points to, or writing to it) is not.</p><p> ä½†æ˜¯ï¼šå¦‚æœæ„å»ºæŒ‡é’ˆå€¼æ˜¯å®‰å…¨çš„ï¼Œè¯·è§£é‡Šå®ƒï¼ˆä»å®ƒæŒ‡å‘çš„å†…å­˜è¯»å–æˆ–å†™å…¥å®ƒï¼‰ä¸æ˜¯ã€‚</p><p>   struct  MyError {  value:  u32,} fn  main ( ) {  let e =  MyError {  value:  32 } ;  let e_ref:  &amp; MyError =  &amp;e ;  dbg ! (std::mem::size_of_val (&amp;e_ref ) ) ;  print_error (e_ref ) ;} fn  print_error ( e:  &amp; MyError ) {  println ! ( &#34;MyError (value = {})&#34;,  (*e ).value ) ;}</p><p>   struct myereror {valueï¼šu32ï¼Œ} fn mainï¼ˆï¼‰{è®©e = myError {valueï¼š32};è®©e_refï¼šï¼†amp; myerror =ï¼†amp; e; DBGï¼ ï¼ˆstd :: mem :: size_of_valï¼ˆï¼†amp; e_refï¼‰ï¼‰; print_errorï¼ˆe_refï¼‰;} fn print_errorï¼ˆeï¼šï¼†amp; myErrorï¼‰{printlnï¼ ï¼ˆï¼†ï¼ƒ34; myErrorï¼ˆvalue = {}ï¼‰ï¼†ï¼ƒ34;ï¼ˆ* eï¼‰.valueï¼‰;}</p><p>   ...but they&#39;re also perfectly safe to dereference, because it is guaranteedthat they point to valid memory: in safe code, it is impossible to constructan invalid reference, or to keep a reference to some value after that valuehas been freed.</p><p>   ......ä½†å®ƒä»¬ä¹Ÿéå¸¸å®‰å…¨åœ°å¯¹è§£é™¤å¼•ç”¨ï¼Œå› ä¸ºå®ƒå¯ä»¥ä¿è¯å®ƒä»¬æŒ‡å‘æœ‰æ•ˆå†…å­˜ï¼šåœ¨å®‰å…¨çš„ä»£ç ä¸­ï¼Œæ— æ³•æ„å»ºæ— æ•ˆçš„å‚è€ƒï¼Œæˆ–è€…åœ¨é‡Šæ”¾ä¼°å€¼åä¿æŒå‚è€ƒä¸€äº›å€¼ã€‚</p><p> In fact, it&#39;s  so safe that we don&#39;t even need to use the  * operator todereference: we can just rely on &#34;autoderef&#34;:</p><p> äº‹å®ä¸Šï¼Œå®ƒå¦‚æ­¤å®‰å…¨ï¼Œæˆ‘ä»¬ç”šè‡³éœ€è¦ä½¿ç”¨*è¿è¥å•†æ‰èƒ½ä½¿ç”¨ï¼šæˆ‘ä»¬å¯ä»¥ä¾é ï¼†ï¼ƒ34; autoderefï¼†ï¼ƒ34 ;: </p><p>   And now, a quick note about safety: you&#39;ll notice that I just said &#34; insafe code, it is impossible to construct an invalid reference&#34;.</p><p>ç°åœ¨ï¼Œå…³äºå®‰å…¨çš„å¿«é€Ÿè®°å½•ï¼šä½ ï¼†ï¼ƒ39;è¯·æ³¨æ„ï¼Œæˆ‘åªæ˜¯è¯´ï¼†ï¼ƒ34; Insafeä»£ç ï¼Œæ— æ³•æ„å»ºæ— æ•ˆçš„å‚è€ƒæ–‡çŒ®ï¼†ï¼ƒ34;</p><p>  struct  MyError {  value:  u32,} fn  main ( ) {  let e:  * const  MyError = std ::ptr :: null ( ) ;  // ooooh no no no. crimes! ğŸ‘‡  let e_ref:  &amp; MyError =  unsafe {  &amp; *e } ;  dbg ! (std::mem::size_of_val (&amp;e_ref ) ) ;  print_error (e_ref ) ;} fn  print_error ( e:  &amp; MyError ) {  println ! ( &#34;MyError (value = {})&#34;, e.value ) ;}</p><p>  struct myerror {valueï¼šu32ï¼Œ} fn mainï¼ˆï¼‰{è®©eï¼š* const myError = std :: ptr :: nullï¼ˆï¼‰; // oooohå¦å¦ã€‚çŠ¯ç½ªï¼ ğŸ‘‡è®©e_refï¼šï¼†amp; myerror =ä¸å®‰å…¨{ï¼†amp; * e}; DBGï¼ ï¼ˆstd :: mem :: size_of_valï¼ˆï¼†amp; e_refï¼‰ï¼‰; print_errorï¼ˆe_refï¼‰;} fn print_errorï¼ˆeï¼šï¼†amp; myErrorï¼‰{printlnï¼ ï¼ˆï¼†ï¼ƒ34; myErrorï¼ˆvalue = {}ï¼‰ï¼†ï¼ƒ34;ï¼Œe.valueï¼‰;}</p><p>      The idea is that,  if all the unsafe code is sound, then all the safe codeis safe, too.</p><p>      è¿™ä¸ªæƒ³æ³•æ˜¯ï¼Œå¦‚æœæ‰€æœ‰ä¸å®‰å…¨çš„ä»£ç éƒ½æ˜¯å£°éŸ³ï¼Œé‚£ä¹ˆæ‰€æœ‰å®‰å…¨çš„ç å¤´éƒ½å®‰å…¨ã€‚</p><p> And you have a lot less &#34;unsafe&#34; code than you have &#34;safe&#34; code, which makesit a lot easier to audit. It&#39;s also very visible, with explicit  unsafeblocks,  unsafe traits and  unsafe functions, and so it&#39;s easy to statically determine where unsafe codeis â€” it&#39;s not just &#34;woops you importedthe forbidden package&#34;.</p><p> è€Œä¸”ä½ æœ‰å¾ˆå¤šå°‘é‡ï¼†ï¼ƒ34;ä¸å®‰å…¨ï¼†ï¼ƒ34;ä»£ç æ¯”ä½ ï¼†ï¼ƒ34;å®‰å…¨ï¼†ï¼ƒ34;ä»£ç ï¼Œè¿™ä½¿å¾—å®¡è®¡æ›´å®¹æ˜“ã€‚å®ƒä¹Ÿæ˜¯éå¸¸å¯è§çš„ï¼Œå…·æœ‰æ˜ç¡®çš„ä¸å®‰å…¨å—ï¼Œä¸å®‰å…¨çš„ç‰¹å¾å’Œä¸å®‰å…¨çš„å‡½æ•°ï¼Œæ‰€ä»¥å®ƒï¼†ï¼ƒ39;å¾ˆå®¹æ˜“é™æ€åœ°ç¡®å®šä¸å®‰å…¨çš„ç å¤´ - å®ƒï¼†ï¼ƒ39; sä¸åªæ˜¯ï¼†ï¼ƒ34;ä½ è¿›å£ç¦æ­¢åŒ…ï¼†ï¼ƒ34;ä½ è¿›å£ç¦æ­¢åŒ…ï¼†ï¼ƒ34 ï¼ƒ34;</p><p> Finally, there&#39;s tools like the  Miriinterpreter, that help with unsafe code,just like there&#39;s sanitizers for C/C++, which do not have that safe/unsafesplit.</p><p> æœ€åï¼Œåœ¨é‚£é‡Œçš„å·¥å…·å¦‚miri interpreterï¼Œé‚£å°±å¸®åŠ©äº†ä¸å®‰å…¨çš„ä»£ç ï¼Œå°±åƒé‚£é‡Œçš„c / c ++çš„æ¶ˆæ¯’è€…é‚£é‡Œï¼Œæ²¡æœ‰é‚£äº›å®‰å…¨/ unsafeplitã€‚</p><p>  So, we&#39;ve seen two kinds of &#34;pointers&#34; in Rust so far: raw pointers, aka *const T (and its sibling,  *mut T), and references ( &amp;T and  &amp;mut T).</p><p>  æ‰€ä»¥ï¼Œæˆ‘ä»¬çœ‹åˆ°ä¸¤ç§ï¼†ï¼ƒ34;æŒ‡é’ˆï¼†ï¼ƒ34;åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¿„ä»Šä¸ºæ­¢ï¼šåŸå§‹æŒ‡é’ˆï¼ŒAKA * const tï¼ˆåŠå…¶å…„å¼Ÿå§å¦¹ï¼Œ* mut tï¼‰å’Œå‚è€ƒï¼ˆï¼†amp; tå’Œï¼†amp; mut tï¼‰ã€‚</p><p>  In Go, when you get a pointer to an object, you can do anything with it. Youcan hold onto it as long as you want, you can shove it into a  map â€” even ifthat object was originally going to be freed, you, as a function thatreceives a pointer to that object, can extend the lifetim</p><p>  åœ¨Goï¼Œå½“æ‚¨å¯¹å¯¹è±¡çš„æŒ‡é’ˆæ—¶ï¼Œå¯ä»¥ä½¿ç”¨å®ƒã€‚ YouCanåªè¦ä½ æƒ³è¦ï¼Œä½ å°±å¯ä»¥æŠŠå®ƒæ¨åˆ°åœ°å›¾ä¸Š - å³ä½¿æ˜¯æœ€åˆæ˜¯é‡Šæ”¾çš„ï¼Œä½ ä¹Ÿæ˜¯ï¼Œä½ ä½œä¸ºä¸€ä¸ªå‡½æ•°ï¼Œä½ å¯ä»¥ä¼¸å‡ºä¸€ä¸ªæŒ‡å‘è¯¥å¯¹è±¡çš„æŒ‡é’ˆï¼Œå¯ä»¥æ‰©å±•å¯¿å‘½ </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/articles/whats-in-the-box">https://fasterthanli.me/articles/whats-in-the-box</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ç›’å­/">#ç›’å­</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/box/">#box</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/é”™è¯¯/">#é”™è¯¯</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>