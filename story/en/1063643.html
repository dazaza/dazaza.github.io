<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Zig 0.8.0å‘è¡Œè¯´æ˜ Zig 0.8.0 Release Notes</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Zig 0.8.0 Release Notes<br/>Zig 0.8.0å‘è¡Œè¯´æ˜ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-05 07:04:09</div><div class="page_narrow text-break page_content"><p>Zig is a general-purpose programming language and toolchain for maintaining  robust,  optimal, and  reusable software.</p><p>ZIGæ˜¯ä¸€ç§é€šç”¨ç¼–ç¨‹è¯­è¨€å’Œå·¥å…·é“¾ï¼Œç”¨äºç»´æŠ¤å¼ºå¤§ï¼Œæœ€ä½³å’Œå¯é‡å¤ä½¿ç”¨çš„è½¯ä»¶ã€‚</p><p>  Backed by the  Zig Software Foundation, the project is  financially sustainable and offers billable hours for core team members:</p><p>  è¯¥é¡¹ç›®æ”¯æŒZIGè½¯ä»¶åŸºé‡‘ä¼šï¼Œè¯¥é¡¹ç›®æ˜¯ç»æµå¯æŒç»­çš„ï¼Œä¸ºæ ¸å¿ƒå›¢é˜Ÿæˆå‘˜æä¾›æ»¡è¶³çš„æ—¶é—´ï¼š</p><p>      This release features  7 months of work and changes from  144 different contributors, spread among  2711 commits.</p><p>      æ­¤ç‰ˆæœ¬å…·æœ‰7ä¸ªæœˆçš„å·¥ä½œå’Œä»144ä¸ªä¸åŒçš„è´¡çŒ®è€…çš„å˜åŒ–ï¼Œåœ¨2711æ¬¡æäº¤ä¹‹é—´ä¼ æ’­ã€‚</p><p>          A green check mark (âœ…) indicates the target meets all the requirements for the support tier. The other icons indicate what is  preventing the target from reaching the support tier. In other words, the icons are  to-do items. If you find any wrong data here please  submit a pull request!</p><p>          ç»¿è‰²å¤é€‰æ ‡è®°ï¼ˆâœ…ï¼‰è¡¨ç¤ºç›®æ ‡ç¬¦åˆæ”¯æŒå±‚çš„æ‰€æœ‰è¦æ±‚ã€‚å¦ä¸€ä¸ªå›¾æ ‡æŒ‡ç¤ºå¯é˜²æ­¢ç›®æ ‡åˆ°è¾¾æ”¯æŒå±‚çš„å†…å®¹ã€‚æ¢å¥è¯è¯´ï¼Œå›¾æ ‡æ˜¯åšé¡¹ç›®ã€‚å¦‚æœæ‚¨åœ¨æ­¤å‘ç°æœ‰é”™è¯¯çš„æ•°æ®ï¼Œè¯·æäº¤æ‹‰åŠ¨è¯·æ±‚ï¼</p><p>    Not only can Zig generate machine code for these targets, but the standard library cross-platform abstractions have implementations for these targets.</p><p>    Zigä¸ä»…å¯ä»¥ä¸ºè¿™äº›ç›®æ ‡ç”Ÿæˆæœºå™¨ä»£ç ï¼Œä½†æ ‡å‡†åº“è·¨å¹³å°æŠ½è±¡å…·æœ‰è¿™äº›ç›®æ ‡çš„å®ç°ã€‚</p><p>    ğŸ“¦ The CI server automatically produces pre-built binaries for these targets, on every commit to master, and updates  the download page with links.</p><p>    ğŸ“¦CIServerè‡ªåŠ¨ä¸ºè¿™äº›ç›®æ ‡ç”Ÿæˆé¢„æ„å»ºçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œæ¯ä¸ªæäº¤å¯„å­˜å™¨ï¼Œå¹¶ä½¿ç”¨é“¾æ¥æ›´æ–°ä¸‹è½½é¡µé¢ã€‚</p><p>      ğŸ› All the behavior tests and applicable standard library tests pass for this target. All language features are known to work correctly. Experimental features do not count towards disqualifying an operating system or architecture from Tier 1.</p><p>      ğŸ›æ‰€æœ‰è¡Œä¸ºæµ‹è¯•å’Œé€‚ç”¨çš„æ ‡å‡†åº“æµ‹è¯•æ­¤ç›®æ ‡çš„ä¼ é€’ã€‚å·²çŸ¥æ‰€æœ‰è¯­è¨€åŠŸèƒ½éƒ½å¯ä»¥æ­£å¸¸å·¥ä½œã€‚å®éªŒç‰¹å¾ä¸è®¡å…¥ç­¾è®¢ç¬¬1å±‚çš„æ“ä½œç³»ç»Ÿæˆ–æ¶æ„ã€‚ </p><p>    ğŸ’€ If the Operating System is proprietary then the target is not marked deprecated by the vendor,  such as macos/x86.</p><p>ğŸ’€å¦‚æœæ“ä½œç³»ç»Ÿæ˜¯ä¸“æœ‰çš„ï¼Œåˆ™è¯¥ç›®æ ‡æœªè¢«ä¾›åº”å•†å¼ƒç”¨ï¼Œä¾‹å¦‚MacOS / X86ã€‚</p><p>      ğŸ“– The standard library supports this target, but it&#39;s possible that some APIs will give an &#34;Unsupported OS&#34; compile error. One can link with libc or other libraries to fill in the gaps in the standard library.</p><p>      ğŸ“–æ ‡å‡†å›¾ä¹¦é¦†æ”¯æŒæ­¤ç›®æ ‡ï¼Œä½†å®ƒå¯èƒ½ä¼šæä¾›ä¸€äº›APIå°†ç»™äºˆï¼†ï¼ƒ34;ä¸æ”¯æŒçš„OSï¼†ï¼ƒ34;ç¼–è¯‘é”™è¯¯ã€‚ä¸€ä¸ªå¯ä»¥é“¾æ¥ä¸libcæˆ–å…¶ä»–åº“æ¥å¡«è¡¥æ ‡å‡†åº“ä¸­çš„ç©ºç™½ã€‚</p><p>  ğŸ” These targets are known to work, but may not be automatically tested, so there are occasional regressions.</p><p>  ğŸ”å·²çŸ¥è¿™äº›ç›®æ ‡å·¥ä½œï¼Œä½†å¯èƒ½ä¸ä¼šè‡ªåŠ¨æµ‹è¯•ï¼Œå› æ­¤æœ‰å¶å°”çš„å›å½’ã€‚</p><p>  Some tests may be disabled for these targets as we work toward  Tier 1 Support.</p><p>  å½“æˆ‘ä»¬å¯¹ç¬¬1å±‚æ”¯æŒçš„å·¥ä½œæ—¶ï¼Œå¯èƒ½ä¼šå¯¹è¿™äº›ç›®æ ‡ç¦ç”¨æŸäº›æµ‹è¯•ã€‚</p><p>      These targets are not frequently tested; one will likely need to contribute to Zig in order to build for these targets.</p><p>      è¿™äº›ç›®æ ‡æ²¡æœ‰ç»å¸¸æµ‹è¯•;ä¸€ä¸ªå¯èƒ½éœ€è¦ä¸ºZigåšå‡ºè´¡çŒ®ï¼Œä»¥ä¾¿ä¸ºè¿™äº›ç›®æ ‡å»ºç«‹ã€‚</p><p>        If this target is provided by LLVM, LLVM may have the target as an experimental target, which means that you need to use Zig-provided binaries for the target to be available, or build LLVM from source with special configure flags.  zig targets will display the target if it is available.</p><p>        å¦‚æœLLVMæä¾›æ­¤ç›®æ ‡ï¼Œåˆ™LLVMå¯èƒ½å°†ç›®æ ‡ä½œä¸ºå®éªŒç›®æ ‡ï¼Œè¿™æ„å‘³ç€æ‚¨éœ€è¦ä½¿ç”¨Zigæä¾›çš„äºŒè¿›åˆ¶æ–‡ä»¶æ¥è·å¾—ç›®æ ‡çš„ç›®æ ‡ï¼Œæˆ–è€…ä»å…·æœ‰ç‰¹æ®Šé…ç½®æ ‡å¿—çš„æºæ„å»ºLLVMã€‚å¦‚æœå¯ç”¨ï¼Œåˆ™Zigç›®æ ‡å°†æ˜¾ç¤ºç›®æ ‡ã€‚</p><p>  This target may be considered deprecated by an official party,  such as macosx/i386 in which case this target will remain forever stuck in Tier 4.</p><p>  è¯¥ç›®æ ‡å¯ä»¥è¢«å®˜æ–¹èšä¼šå¼ƒç”¨ï¼Œä¾‹å¦‚MacOSX / I386ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ­¤ç›®æ ‡å°†ä¿æŒåœ¨ç¬¬4å±‚ä¸­æ°¸ä¹…ç²˜åœ¨ä¸€èµ·ã€‚ </p><p>  This target may only support  -femit-asm and cannot emit object files ( -fno-emit-bin enabled by default and cannot be overridden).</p><p>æ­¤ç›®æ ‡åªèƒ½æ”¯æŒ - ç¼©æ”¾ASMï¼Œæ— æ³•å‘å‡ºç›®æ ‡æ–‡ä»¶ï¼ˆé»˜è®¤å¯ç”¨ -  emno-emit-binï¼Œå¹¶ä¸”æ— æ³•è¢«è¦†ç›–ï¼‰ã€‚</p><p>    32-bit x86 macOS, 32-bit ARM macOS, powerpc32 and powerpc64 macOS, because Apple has officially dropped support for them.</p><p>    32ä½X86 MacOSï¼Œ32ä½ARM MacOSï¼ŒPowerPC32å’ŒPowerPC64 MacOSï¼Œå› ä¸ºAppleå·²æ­£å¼åˆ é™¤äº†å¯¹å®ƒä»¬çš„æ”¯æŒã€‚</p><p>      Avoid redundantly providing Windows TLS startup symbols when linking libc because they are already provided by libcrt.</p><p>      é“¾æ¥Libcæ—¶ï¼Œé¿å…å†—ä½™æä¾›Windows TLSå¯åŠ¨ç¬¦å·ï¼Œå› ä¸ºå®ƒä»¬å·²ç”±Libcrtæä¾›ã€‚</p><p>                          Implemented nt path conversion for windows. Fixes  . and  .. not working in  std.fs paths.</p><p>                          ä¸ºWindowså®ç°äº†NTè·¯å¾„è½¬æ¢ã€‚ä¿®å¤ã€‚å¹¶ä¸”..ä¸åœ¨STD.FSè·¯å¾„ä¸­å·¥ä½œã€‚</p><p>    Since Zig ships with  MinGW-w64, Zig can be used to compile C and C++ code on Windows without having MSVC installed. However, before this release, it was not obvious how to take advantage of this feature, since the default behavior was to integrate with MSVC.</p><p>    ç”±äºZigèˆ¹ç”¨MingW-W64ï¼ŒZigå¯ç”¨äºåœ¨Windowsä¸Šç¼–è¯‘Cå’ŒC ++ä»£ç è€Œä¸å®‰è£…MSVCã€‚ä½†æ˜¯ï¼Œåœ¨æ­¤ç‰ˆæœ¬ä¹‹å‰ï¼Œå®ƒä¸æ˜æ˜¾åˆ©ç”¨æ­¤åŠŸèƒ½ï¼Œå› ä¸ºé»˜è®¤è¡Œä¸ºæ˜¯ä¸MSVCé›†æˆã€‚</p><p>  In this release, the default behavior is to ignore MSVC and do everything based only on the Zig installation. This makes using Zig to compile C and C++ code on Windows an &#34;it just works&#34; experience.</p><p>  åœ¨æ­¤ç‰ˆæœ¬ä¸­ï¼Œé»˜è®¤è¡Œä¸ºæ˜¯å¿½ç•¥MSVCï¼Œå¹¶ä»…åŸºäºZigå®‰è£…æ‰§è¡Œæ‰€æœ‰æ“ä½œã€‚è¿™ä½¿å¾—ä½¿ç”¨Zigåœ¨Windows ANï¼†ï¼ƒ34ä¸Šç¼–è¯‘Cå’ŒC ++ä»£ç ;å®ƒåªæ˜¯æœ‰æ•ˆï¼†ï¼ƒ34;ç»éªŒã€‚</p><p>  MSVC integration can be achieved by using  -target native-native-msvc. Note that mingw-w64 is ABI-compatible with MSVC, so any build artifacts produced by one are consumable by the other. However the respective C header files are not always API-compatible, which is why there is still a use case for overriding the default.</p><p>  å¯ä»¥é€šè¿‡ä½¿ç”¨-targetæœ¬æœº - åŸç”Ÿ-MSVCæ¥å®ç°MSVCé›†æˆã€‚è¯·æ³¨æ„ï¼ŒMINGW-W64ä¸MSVCç›¸å…¼å®¹ï¼Œå› æ­¤ç”±ä¸€ä¸ªäº§ç”Ÿçš„ä»»ä½•æ„å»ºå·¥ä»¶éƒ½æ˜¯ç”±å¦ä¸€ä¸ªçš„æ¶ˆè€—å“ã€‚ä½†æ˜¯ï¼Œç›¸åº”çš„Cå¤´æ–‡ä»¶å¹¶ä¸æ€»æ˜¯APIå…¼å®¹ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä»ç„¶æ˜¯é»˜è®¤é»˜è®¤çš„ç”¨ä¾‹ã€‚ </p><p>      With the advent of the  Self-Hosted Linker, Zig is now able to generate well-formed and codesigned binaries on arm64 macOS (aka the Apple Silicon). It is also able to cross-compile C, C++, and Zig code to an arm64 and x86_64 macOS. Additionally, arm64 nightly binaries of Zig are automatically generated by our Continuous Integration service, meaning both arm64 and x86_64 macOS are now  Tier 1 targets.</p><p>éšç€è‡ªä¸»æ‰˜ç®¡é“¾æ¥å™¨çš„å‡ºç°ï¼ŒZigç°åœ¨èƒ½å¤Ÿåœ¨ARM64 MacOSï¼ˆAKA Apple Siliconï¼‰ä¸Šç”Ÿæˆè‰¯å¥½å½¢æˆçš„å’Œä»£å·çš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚å®ƒè¿˜èƒ½å¤Ÿå°†Cï¼ŒC ++å’ŒZigä»£ç äº¤å‰ç¼–è¯‘åˆ°ARM64å’ŒX86_64 MacOSã€‚æ­¤å¤–ï¼ŒARM64æ¯æ™šZigäºŒè¿›åˆ¶æ–‡ä»¶ç”±æˆ‘ä»¬çš„è¿ç»­é›†æˆæœåŠ¡è‡ªåŠ¨ç”Ÿæˆï¼Œè¿™æ„å‘³ç€ARM64å’ŒX86_64 MacOSéƒ½æ˜¯Tier 1ç›®æ ‡ã€‚</p><p>  To facilitate incremental linking, the self-hosted compiler is now by default generating   dSYM bundles which store DWARF debug information and debug symbols on macOS. This puts Zig on path of becoming a true replacement for the Xcode development environment.</p><p>  ä¸ºäº†ä¾¿äºå¢é‡é“¾æ¥ï¼Œè‡ªä¸»ä¸»æœºç¼–è¯‘å™¨ç°åœ¨é»˜è®¤ç”ŸæˆDSYMæ†ç»‘åŒ…ï¼Œå­˜å‚¨DWARFè°ƒè¯•ä¿¡æ¯å’Œåœ¨MACOä¸Šçš„è°ƒè¯•ç¬¦å·ã€‚è¿™å°†Zigæ”¾åœ¨Xcodeå¼€å‘ç¯å¢ƒä¸­æˆä¸ºçœŸæ­£æ›¿ä»£çš„è·¯å¾„ã€‚</p><p>  Finally, as a side experiment, Jakub added in  Zig Build System integration with  Darling (#8760), a translation layer of macOS syscalls to Linux, with the intention of being able to cross test MachO binaries and macOS specific tests directly on Linux simply by passing in an additional flag  -Denable-darling to  zig build test.</p><p>  æœ€åï¼Œä½œä¸ºä¸€ä¸ªä¾§é¢å®éªŒï¼Œjakubåœ¨Zigæ„å»ºç³»ç»Ÿé›†æˆä¸è¾¾ä»¤ï¼ˆï¼ƒ8760ï¼‰ï¼Œæ˜¯éº¦æ–¯ç§‘æ–¯å·Syscallsåˆ°Linuxçš„ç¿»è¯‘å±‚ï¼Œå…¶ç›®çš„æ˜¯èƒ½å¤Ÿç®€å•åœ°åœ¨Linuxä¸Šç›´æ¥äº¤å‰æµ‹è¯•MachoäºŒè¿›åˆ¶æ–‡ä»¶å’Œéº¦æ–¯ç§‘æ–¯ç‰¹å®šæµ‹è¯•åœ¨Zig Build Testä¸­ä¼ é€’é¢å¤–çš„æ——å¸œDadlingã€‚</p><p>  In 0.8.0, Zig provides libc header files for macOS, for both  x86_64-macos and  aarch64-macos, using the experimental  fetch-them-macos-headers project. There is a myth that Apple&#39;s C header files have an encumbered license, but that is not the case. They are licensed under the  Apple Public Source License which is in fact quite permissive.</p><p>  åœ¨0.8.0ä¸­ï¼ŒZigä½¿ç”¨å®éªŒçš„Fetch-Hom-MacOS-Rementsé¡¹ç›®ä¸ºX86_64-MacOSå’ŒAARCH64-MACOSæä¾›Libcæ ‡é¢˜æ–‡ä»¶ã€‚æœ‰ä¸€ä¸ªç¥è¯æ˜¯Appleï¼†ï¼ƒ39; s cå¤´æ–‡ä»¶çš„å ç”¨è®¸å¯è¯ï¼Œä½†è¿™ä¸æ˜¯è¿™ç§æƒ…å†µã€‚å®ƒä»¬åœ¨è‹¹æœå…¬å…±æºè®¸å¯è¯ä¸‹è®¸å¯ï¼Œå®é™…ä¸Šæ˜¯éå¸¸å®½å®¹çš„ã€‚</p><p>  Zig 0.8.0 relies on these headers even when compiling natively, as long as there are no system dependencies.  This makes Zig able to compile C and C++ code on macOS without XCode installed (#6773).</p><p>  Zig 0.8.0å³ä½¿åœ¨ç¼–è¯‘æ­¤æ—¶ï¼Œä¹Ÿä¾èµ–äºè¿™äº›æ ‡é¢˜ï¼Œåªè¦æ²¡æœ‰ç³»ç»Ÿä¾èµ–æ€§å³å¯ã€‚è¿™ä½¿å¾—Zigèƒ½å¤Ÿåœ¨æ²¡æœ‰å®‰è£…Xcodeçš„æƒ…å†µä¸‹ç¼–è¯‘Cå’ŒC ++ä»£ç ï¼ˆï¼ƒ6773ï¼‰ã€‚</p><p>      The  Self-Hosted Compiler gained a work-in-progress  WebAssembly Backend, which provides the ability for Zig to compile to wasm without  LLVM.</p><p>      è‡ªæ‰˜ç®¡ç¼–è¯‘å™¨è·å¾—äº†ä¸€ä¸ªè¿›å±•çš„webassemblyåç«¯ï¼Œå®ƒæä¾›äº†zigç¼–è¯‘ä¸ºæ²¡æœ‰llvmçš„wasmçš„èƒ½åŠ›ã€‚</p><p>  Zig now ships with  WASI libc and supports cross-compiling C code to WASI. This also makes Zig a tempting alternative to downloading and building  WASI libc and/or  WASI SDK manually (#8837).</p><p>  Zigç°åœ¨ä¸Wasi Libcä¸€èµ·èˆ¹èˆ¶ï¼Œå¹¶æ”¯æŒäº¤å‰ç¼–è¯‘Cä»£ç ã€‚è¿™ä¹Ÿä½¿Zigæˆä¸ºæ‰‹åŠ¨ä¸‹è½½å’Œæ„å»ºWASI LIBCå’Œ/æˆ–WASI SDKçš„è¯±æƒ‘æ›¿ä»£å“ï¼ˆï¼ƒ8837ï¼‰ã€‚ </p><p>    Just like every other target,  zig build-lib now builds a static archive for wasm, unless  -dynamic is specified.</p><p>å°±åƒæ¯ä¸ªå…¶ä»–ç›®æ ‡ä¸€æ ·ï¼ŒZig Build-libç°åœ¨ä¸ºWASMæ„å»ºäº†ä¸€ä¸ªé™æ€å­˜æ¡£ï¼Œé™¤éæŒ‡å®šäº†åŠ¨æ€ã€‚</p><p>    Al Hoang contributed some initial work to get Zig to run under  Haiku. Some things that are now working:</p><p>    Al Hoangè´¡çŒ®äº†ä¸€äº›åˆæ­¥çš„å·¥ä½œæ¥è®©Zigåœ¨Haikuä¸‹è¿è¡Œã€‚ä¸€äº›ç°åœ¨å·¥ä½œçš„ä¸œè¥¿ï¼š</p><p>        LLVM 12 brings in csky support.  glibc already supported csky, but Zig did not ship glibc header files for it since LLVM did not have a backend for it. Zig 0.8.0 additionally ships glibc header files for csky.</p><p>        LLVM 12å¸¦æ¥CSKYæ”¯æŒã€‚ Glibcå·²ç»æ”¯æŒCSKYï¼Œä½†Zigæ²¡æœ‰ä¸ºæ­¤å‘å‡ºGlibcå¤´æ–‡ä»¶ï¼Œå› ä¸ºLLVMæ²¡æœ‰å®ƒçš„åç«¯ã€‚ Zig 0.8.0å¦å¤–è¿˜ä¸ºCSKYåˆ’èˆ¹Glibcå¤´æ–‡ä»¶ã€‚</p><p>          Pass  -mthumb when compiling C/C++ code. The Clang driver requires this flag and ignores the target triple.</p><p>          åœ¨ç¼–è¯‘C / C ++ä»£ç æ—¶ä¼ é€’-MOUMBã€‚ Clangé©±åŠ¨ç¨‹åºéœ€è¦æ­¤æ ‡å¿—å¹¶å¿½ç•¥ç›®æ ‡ä¸‰å€ã€‚</p><p>                        Zig now has CI test coverage for  powerpc-linux-none and  powerpc-linux-musl. The issue blocking  glibc support is #4927.</p><p>                        Zigç°åœ¨å…·æœ‰PowerPC-Linux-Noneå’ŒPowerPC-Linux-Muslçš„CIæµ‹è¯•è¦†ç›–èŒƒå›´ã€‚é˜»æ­¢Glibcæ”¯æŒçš„é—®é¢˜æ˜¯ï¼ƒ4927ã€‚</p><p>      LemonBoy made progress working around #4926, preventing Zig from being able to build  glibc on  i386-linux-gnu. He got it working, and the tests passing, but it revealed a flaw (#8930) in the  Standard Library having to do with allocation alignments on all 32-bit targets. This issue is not solved in 0.8.0 but is planned to be addressed in the 0.8.1 bug fix release. After that, we expect to have test coverage for  i386-linux-gnu.</p><p>      Lemonboyåœ¨ï¼ƒ4926ä¸­å–å¾—è¿›å±•ï¼Œé˜²æ­¢Zigèƒ½å¤Ÿåœ¨I386-Linux-GNUä¸Šæ„å»ºGlibcã€‚ä»–å¾—åˆ°äº†å®ƒçš„å·¥ä½œï¼Œå¹¶ä¸”æµ‹è¯•é€šè¿‡ï¼Œä½†å®ƒæ­ç¤ºäº†æ ‡å‡†åº“ä¸­çš„æ¼æ´ï¼ˆï¼ƒ8930ï¼‰ä¸æ‰€æœ‰32ä½ç›®æ ‡ä¸Šçš„åˆ†é…å¯¹é½æœ‰å…³ã€‚æ­¤é—®é¢˜æœªåœ¨0.8.0ä¸­è§£å†³ï¼Œä½†è®¡åˆ’åœ¨0.8.1é”™è¯¯ä¿®å¤ç‰ˆæœ¬ä¸­è§£å†³ã€‚ä¹‹åï¼Œæˆ‘ä»¬æœŸæœ›å¯¹I386-Linux-GNUè¿›è¡Œæµ‹è¯•è¦†ç›–èŒƒå›´ã€‚</p><p>    During the 0.8.0 release cycle, Zig&#39;s MIPS support was greatly improved, gaining full test coverage for little-endian mips, including building  musl and  glibc.</p><p>    åœ¨0.8.0é‡Šæ”¾å‘¨æœŸæœŸé—´ï¼ŒZigï¼†ï¼ƒ39; Zigï¼†ï¼ƒ39; SIPSæ”¯æŒå¤§å¤§æé«˜ï¼Œä¸ºå°å‹MIPSè·å¾—äº†å…¨é¢çš„æµ‹è¯•è¦†ç›–èŒƒå›´ï¼ŒåŒ…æ‹¬å»ºç­‘ç‰©å’ŒGLIBCã€‚ </p><p>  However, all MIPS targets regressed with the release of  LLVM 12, despite having  an open release blocker bug filed. Not only this, but the fix has been in LLVM main branch for a whole month, as of the time of this writing, and yet the fix did not make it into 12.0.1-rc1, again despite the bug being marked as a 12.0.1 release blocker.</p><p>ç„¶è€Œï¼Œå°½ç®¡æäº¤äº†å¼€æ”¾å¼å‘å¸ƒé˜»æ­¢å™¨é”™è¯¯ï¼Œä½†æ‰€æœ‰MIPSç›®æ ‡éƒ½ä¼šéšç€LLVM 12çš„å‘å¸ƒè€Œé€€åŒ–ã€‚ä¸ä»…å¦‚æ­¤ï¼Œè€Œä¸”ä¿®å¤ç¨‹åºå·²ç»åœ¨LLVMä¸»åˆ†æ”¯æ•´ä¸ªæœˆï¼Œæˆªè‡³æœ¬æ–‡çš„æ—¶é—´ï¼Œç„¶è€Œï¼Œè§£å†³æ–¹æ¡ˆæ²¡æœ‰å°†å…¶æˆ12.0.1-RC1ï¼Œå°½ç®¡é”™è¯¯è¢«æ ‡è®°ä¸º12.0 .1é‡Šæ”¾é˜»æ­¢å™¨ã€‚</p><p>  As soon as LLVM releases a bug fix version which includes the fix, Zig can re-enable MIPS test coverage.</p><p>  ä¸€æ—¦LLVMå‘å¸ƒä¸€ä¸ªåŒ…å«ä¿®å¤çš„é”™è¯¯ä¿®å¤ç‰ˆæœ¬ï¼ŒZigå°±å¯ä»¥é‡æ–°å¯ç”¨MIPSæµ‹è¯•è¦†ç›–èŒƒå›´ã€‚</p><p>    The language reference is updated to reflect the changes to the language and standard library in this release cycle.</p><p>    æ›´æ–°è¯­è¨€å¼•ç”¨ï¼Œä»¥åæ˜ æ­¤å‘å¸ƒå‘¨æœŸä¸­è¯­è¨€å’Œæ ‡å‡†åº“çš„æ›´æ”¹ã€‚</p><p>                  docgen: use  std.Progress API so that we see a terminal progress bar when waiting for the docs to build.</p><p>                  DOCGENï¼šä½¿ç”¨STD.Progress APIï¼Œä»¥ä¾¿åœ¨ç­‰å¾…æ–‡æ¡£æ„å»ºæ—¶çœ‹åˆ°ç»ˆç«¯è¿›åº¦æ ã€‚</p><p>  Contributors: Andrew Kelley, Carlos ZÃºÃ±iga, Dave Gauer, Devin Bayer, Eleanor Bartle, Frank Denis, Jakub Konka, Jay Petacat, Jonas Carpay, Josh Holland, Josh Wolfe, LemonBoy, Martin Wickham, Mathieu Guay-Paquet, Matthew Borkowski, Ryan Liptak, Tadeo Kondrak, Veikka Tuominen, data-man, Jacob G-W, xackus</p><p>  è´¡çŒ®è€…ï¼šAndrew Kelleyï¼ŒCarlosZÃºÃ±igaï¼ŒDevin Gauerï¼Œå¾·å›½æ‹œè€³ï¼ŒåŸƒè‰è¯ºÂ·æ‹œè€³ï¼ŒJakub Konkaï¼ŒJay Petacatï¼ŒJonas Carpayï¼ŒJosh Hollandï¼ŒJosh Wolfeï¼ŒLemonboyï¼ŒMartin Wickhamï¼ŒMathieu Guay-Paquetï¼ŒMatthowe Borkowskiï¼ŒRyan Liptak ï¼ŒTadeo Kondrakï¼ŒVeikka Tuominenï¼ŒData-Manï¼ŒJacob Gwï¼ŒXackus</p><p>    Compared to other releases, the Zig language saw fewer changes this cycle, providing a relatively stable target for the  Self-Hosted Compiler implementation. Still, there were a few additions and breaking changes.</p><p>    ä¸å…¶ä»–ç‰ˆæœ¬ç›¸æ¯”ï¼ŒZigè¯­è¨€çœ‹åˆ°æ­¤å¾ªç¯çš„æ›´æ”¹æ›´æ”¹ï¼Œä¸ºè‡ªæ‰˜ç®¡ç¼–è¯‘å™¨å®ç°æä¾›ç›¸å¯¹ç¨³å®šçš„ç›®æ ‡ã€‚å°½ç®¡å¦‚æ­¤ï¼Œè¿˜æœ‰å‡ ç§æ·»åŠ å’Œç ´åå˜åŒ–ã€‚</p><p>    const A =  extern  enum { foo, bar }; const B =  packed  enum { foo, bar };</p><p>    const a = extern enum {fooï¼Œbar}; const b = packed enum {fooï¼Œbar}; </p><p>  test.zig:1:11:  error: enums do not support &#39;packed&#39; or &#39;extern&#39;; instead provide an explicit integer tag typeconst A = extern enum { foo, bar }; ^ test.zig:2:11:  error: enums do not support &#39;packed&#39; or &#39;extern&#39;; instead provide an explicit integer tag typeconst B = packed enum { foo, bar }; ^</p><p>test.zigï¼š1ï¼š11ï¼šé”™è¯¯ï¼šæšä¸¾ä¸æ”¯æŒï¼†ï¼ƒ39;åŒ…è£…ï¼†ï¼ƒ39;æˆ–ï¼†ï¼ƒ39; externï¼†ï¼ƒ39 ;;è€Œæ˜¯æä¾›ä¸€ä¸ªæ˜¾å¼æ•´æ•°æ ‡ç­¾Typeconst A = Extern Enum {fooï¼Œbar}; ^ test.zigï¼š2ï¼š11ï¼šé”™è¯¯ï¼šæšä¸¾ä¸æ”¯æŒï¼†ï¼ƒ39;åŒ…è£…ï¼†ï¼ƒ39;æˆ–ï¼†ï¼ƒ39; externï¼†ï¼ƒ39 ;;è€Œæ˜¯æä¾›ä¸€ä¸ªæ˜¾å¼æ•´æ•°æ ‡ç­¾TypeConst B = Packed Enum {fooï¼Œbar}; ^</p><p>  This error is caught by the  Self-Hosted Compiler (due to  Whole-File AST Lowering) but not yet caught by the  Bootstrap Compiler. Related proposal: #8970</p><p>  è‡ªæ‰˜ç®¡ç¼–è¯‘å™¨ï¼ˆç”±äºæ•´ä¸ªæ–‡ä»¶ASTé™ä½ï¼‰æ•è·æ­¤é”™è¯¯ï¼Œä½†å°šæœªç”±Bootstrapç¼–è¯‘å™¨æ•è·ã€‚ç›¸å…³ææ¡ˆï¼šï¼ƒ8970</p><p>                        Nameless tests are exempt from  --test-filter parameters, making it possible to use  --test-filter while still pointing  zig test at the root source file.</p><p>                        æ— åçš„æµ‹è¯•æ˜¯å…äº--Test-Filterå‚æ•°ï¼Œä½¿å¾—å¯ä»¥ä½¿ç”¨--Test-ilè¿‡æ»¤å™¨ï¼ŒåŒæ—¶ä»ç„¶æŒ‡å‘rootæºæ–‡ä»¶çš„Zigæµ‹è¯•ã€‚</p><p>          $ ./zig test a.zigb.test &#34;fail&#34;... FAIL (TestUnexpectedResult) /home/andy/Downloads/zig/lib/std/testing.zig:310:14: 0x24d54b in std.testing.expect (test) if (!ok) return error.TestUnexpectedResult; ^ /home/andy/Downloads/zig/build/b.zig:7:5: 0x2068b1 in b.test &#34;fail&#34; (test) try std.testing.expect(false); ^2 passed; 0 skipped; 1 failed.error: the following test command failed with exit code 1:zig-cache/o/577deb476721d8dde8bc782f2c61ed2f/test /home/andy/Downloads/zig/build/zig$ ./zig test a.zig --test-filter passAll 2 tests passed.</p><p>          $ ./zig test a.zigb.testï¼†ï¼ƒ34; failï¼†ï¼ƒ34; fail ...å¤±è´¥ï¼ˆtestunexpectedresultï¼‰/home/andy/downloads/zig/lib/std/testing.zigï¼š310:14ï¼š0x24d54båœ¨stdä¸­ã€‚ testing.expectï¼ˆæµ‹è¯•ï¼‰å¦‚æœï¼ˆï¼ç¡®å®šï¼‰è¿”å›é”™è¯¯.testunexpedresult; ^ /home/andy/downloads/zig/build/b.zigï¼š7:5ï¼š0x2068b1åœ¨b.tiestï¼†ï¼ƒ34;å¤±è´¥ï¼†ï¼ƒ34; ï¼ˆæµ‹è¯•ï¼‰å°è¯•std.testing.expectï¼ˆfalseï¼‰; ^ 2é€šè¿‡; 0è·³è¿‡; 1å¤±è´¥ã€‚é”™è¯¯2æµ‹è¯•é€šè¿‡äº†ã€‚</p><p>       const std =  @import( &#34;std&#34;); const Enum =  enum { one, two, three }; test  &#34;old code&#34; {  const T =  @TagType(Enum);  try std.testing.expectEqual( u2, T);}</p><p>       const std = @importï¼ˆï¼†ï¼ƒ34; stdï¼†ï¼ƒ34;ï¼‰; const enum =æšä¸¾{ä¸€ï¼Œä¸¤ä¸ªï¼Œä¸‰ä¸ª};æµ‹è¯•ï¼†ï¼ƒ34;æ—§ä»£ç ï¼†ï¼ƒ34; {const t = @tagtypeï¼ˆæšä¸¾ï¼‰;å°è¯•std.testing.Expectequalï¼ˆU2ï¼ŒTï¼‰;}</p><p>      const std =  @import( &#34;std&#34;); const Enum =  enum { one, two, three }; const TagType = std.meta.TagType; test  &#34;new code&#34; {  const T = TagType(Enum);  try std.testing.expectEqual( u2, T);}</p><p>      const std = @importï¼ˆï¼†ï¼ƒ34; stdï¼†ï¼ƒ34;ï¼‰; const enum =æšä¸¾{ä¸€ï¼Œä¸¤ä¸ªï¼Œä¸‰ä¸ª}; const tagtype = std.meta.tagtype;æµ‹è¯•ï¼†ï¼ƒ34;æ–°ä»£ç ï¼†ï¼ƒ34; {const t = tagtypeï¼ˆæšä¸¾ï¼‰;å°è¯•std.testing.Expectequalï¼ˆU2ï¼ŒTï¼‰;}</p><p>       nosuspend blocks now allow   resume inside their scope, because resuming a suspended async function call is actually a synchronous operation.</p><p>       nosuspendå—ç°åœ¨å…è®¸åœ¨å…¶èŒƒå›´å†…æ¢å¤ï¼Œå› ä¸ºæ¢å¤æš‚åœçš„å¼‚æ­¥å‡½æ•°è°ƒç”¨å®é™…ä¸Šæ˜¯ä¸€ä¸ªåŒæ­¥æ“ä½œã€‚ </p><p>  nosuspend blocks now allow   async function calls inside their scope, because starting an async function call is actually a synchronous operation, since the caller is not awaiting on the callee for a return value.</p><p>nosuspendå—ç°åœ¨å…è®¸å¼‚æ­¥å‡½æ•°è°ƒç”¨å®ƒä»¬çš„èŒƒå›´å†…ï¼Œå› ä¸ºå¯åŠ¨å¼‚æ­¥å‡½æ•°è°ƒç”¨å®é™…ä¸Šæ˜¯ä¸€ä¸ªåŒæ­¥æ“ä½œï¼Œå› ä¸ºå‘¼å«è€…åœ¨Calleeä¸Šä¸ç­‰å¾…è¿”å›å€¼ã€‚</p><p>      pub  const CallingConvention =  enum { Unspecified, C, Naked, Async, Inline, Interrupt, Signal, Stdcall, Fastcall, Vectorcall, Thiscall, APCS, AAPCS, AAPCSVFP, SysV,};</p><p>      Pub const callingConvention =æšä¸¾{æœªæŒ‡å®šï¼ŒCï¼Œè£¸ä½“ï¼Œå¼‚æ­¥ï¼Œå†…è”ï¼Œä¸­æ–­ï¼Œä¿¡å·ï¼Œstdcallï¼Œfastcallï¼ŒVectorCallï¼ŒThisCallï¼ŒAPCï¼ŒAAPCSï¼ŒAAPCSVFPï¼ŒSYSVï¼Œ};</p><p>     const std =  @import( &#34;std&#34;); const expect = std.testing.expect; const maxInt = std.math.maxInt; test  &#34;unsigned negation wrapping&#34; {  try testUnsignedNegationWrappingEval( 1);  comptime  try testUnsignedNegationWrappingEval( 1);} fn  testUnsignedNegationWrappingEval(x:  u16) ! void {  try expect(x ==  1);  const neg = -%x;  try expect(neg == maxInt( u16));}</p><p>     const std = @importï¼ˆï¼†ï¼ƒ34; stdï¼†ï¼ƒ34;ï¼‰; constæœŸæœ›= std.testing.expect; const maxint = std.math.maxint;æµ‹è¯•ï¼†ï¼ƒ34;æœªç­¾åçš„å¦å®šåŒ…è£…ï¼†ï¼ƒ34; {try testunsignednegationWrapptevalï¼ˆ1ï¼‰;ç¼–è¾‘å°è¯•testunsignednegationWrappingevalï¼ˆ1ï¼‰;} fn testunsignednegationWrapptevalï¼ˆxï¼šu16ï¼‰ï¼ void {å°è¯•æœŸå¾…ï¼ˆx == 1ï¼‰; const neg =  - ï¼…x;å°è¯•æœŸå¾…ï¼ˆneg == maxintï¼ˆu16ï¼‰ï¼‰;}</p><p>            const std =  @import( &#34;std&#34;); const builtin =  @import( &#34;builtin&#34;);  // &lt;--- look here test  &#34;old code&#34; {  const StackTrace = builtin.StackTrace;}</p><p>            const std = @importï¼ˆï¼†ï¼ƒ34; stdï¼†ï¼ƒ34;ï¼‰; const buildin = @importï¼ˆï¼†ï¼ƒ34;å†…ç½®ï¼†ï¼ƒ34;ï¼‰; //ï¼†lt; ---çœ‹è¿™é‡Œæµ‹è¯•ï¼†ï¼ƒ34;æ—§ä»£ç ï¼†ï¼ƒ34; {const stacktrace = buildin.stacktrace;}</p><p> $ zig test test.zig ./docgen_tmp/test.zig:5:31:  error:  container &#39;builtin&#39; has no member called &#39;StackTrace&#39; const StackTrace = builtin.StackTrace;  ^</p><p> $ zig test test.zig ./docgen_tmp/test.zigï¼š5:31ï¼šé”™è¯¯ï¼šå®¹å™¨ï¼†ï¼ƒ39;å†…ç½®ï¼†ï¼ƒ39;æ²¡æœ‰æˆå‘˜å«åšï¼†ï¼ƒ39; Stacktraceï¼†ï¼ƒ39; Const StackTrace = BuildIn.Stacktrace; ^</p><p>     const std =  @import( &#34;std&#34;); const builtin = std.builtin;  // &lt;--- look here test  &#34;new code&#34; {  const StackTrace = builtin.StackTrace;}</p><p>     const std = @importï¼ˆï¼†ï¼ƒ34; stdï¼†ï¼ƒ34;ï¼‰; const buildin = std.builtin; //ï¼†lt; ---çœ‹è¿™é‡Œæµ‹è¯•ï¼†ï¼ƒ34;æ–°ä»£ç ï¼†ï¼ƒ34; {const stacktrace = buildin.stacktrace;}</p><p>     const std =  @import( &#34;std&#34;); const builtin = std.builtin;  // &lt;--- look here test  &#34;deprecated code&#34; {  const native_arch = builtin.cpu.arch;  // deprecated!}</p><p>     const std = @importï¼ˆï¼†ï¼ƒ34; stdï¼†ï¼ƒ34;ï¼‰; const buildin = std.builtin; //ï¼†lt; ---çœ‹è¿™é‡Œæµ‹è¯•ï¼†ï¼ƒ34;å·²å¼ƒç”¨çš„ä»£ç ï¼†ï¼ƒ34; {const native_arch = buildin.cpu.arch; //å¼ƒç”¨ï¼} </p><p>     const std =  @import( &#34;std&#34;); const builtin =  @import( &#34;builtin&#34;);  // &lt;--- look here test  &#34;new code&#34; {  const native_arch = builtin.cpu.arch;  // OK}</p><p>const std = @importï¼ˆï¼†ï¼ƒ34; stdï¼†ï¼ƒ34;ï¼‰; const buildin = @importï¼ˆï¼†ï¼ƒ34;å†…ç½®ï¼†ï¼ƒ34;ï¼‰; //ï¼†lt; ---çœ‹è¿™é‡Œæµ‹è¯•ï¼†ï¼ƒ34;æ–°ä»£ç ï¼†ï¼ƒ34; {const native_arch = buildin.cpu.arch; // å¥½çš„}</p><p>     In the previous release, as well as this release, the main Zig compiler everybody uses is the bootstrap compiler, written in C++, also known as &#34;stage1&#34;. Despite the main focus of this release cycle being the  Self-Hosted Compiler, there were some improvements to stage1 as well.</p><p>     åœ¨ä¸Šä¸€ä¸ªç‰ˆæœ¬ä¸­ï¼Œä»¥åŠæ­¤ç‰ˆæœ¬ï¼Œæ¯ä¸ªäººéƒ½ä½¿ç”¨çš„ä¸»è¦Zigç¼–è¯‘å™¨æ˜¯Bootstrapç¼–è¯‘å™¨ï¼Œå†™åœ¨C ++ä¸­ï¼Œä¹Ÿç§°ä¸ºï¼†ï¼ƒ34; Stage1ï¼†ï¼ƒ34;å°½ç®¡æ­¤é‡Šæ”¾å‘¨æœŸçš„ä¸»è¦é‡ç‚¹æ˜¯è‡ªä¸»ä¸»æœºç¼–è¯‘å™¨ï¼Œä½†ä¹Ÿæœ‰ä¸€äº›æ”¹è¿›ã€‚</p><p>  Add architecture-specific clobbers to asm(). We&#39;re basically following Clang&#39;s lead, add the necessary clobbers to minimize the risk of generating wrong code.</p><p>  å°†ç‰¹å®šäºæ¶æ„çš„clobbersæ·»åŠ åˆ°ASMï¼ˆï¼‰ã€‚ Weï¼†ï¼ƒ39; ReåŸºæœ¬ä¸Šè¿½éšé“¿clï¼†ï¼ƒ39; sé“…ï¼Œæ·»åŠ å¿…è¦çš„clobbersï¼Œä»¥æœ€å¤§é™åº¦åœ°å‡å°‘ç”Ÿæˆé”™è¯¯ä»£ç çš„é£é™©ã€‚</p><p>          Emit a compile error instead of falling back to C for unsupported calling convention. (#6829)</p><p>          å‘å‡ºç¼–è¯‘é”™è¯¯ï¼Œè€Œä¸æ˜¯å€’å›Cä»¥è·å–ä¸å—æ”¯æŒçš„è°ƒç”¨çº¦å®šã€‚ ï¼ˆï¼ƒ6829ï¼‰</p><p>                        Allow variable capture for multi-prong switch arms, handling the multi-prong case as we do with range cases (#7188).</p><p>                        å…è®¸å¤šå‰å¼€å…³è‡‚çš„å¯å˜æ•è·ï¼Œåœ¨ä½¿ç”¨èŒƒå›´æ¡ˆä¾‹ï¼ˆï¼ƒ7188ï¼‰æ—¶å¤„ç†å¤šå‰å£³ã€‚</p><p>  Let LLVM legalize the overflowing ops on vectors, because it is smart enough to produce tight overflow checking sequences.</p><p>  è®©LLVMå°†æº¢å‡ºçš„OPSåˆæ³•åŒ–å‘é‡ä¸Šï¼Œå› ä¸ºå®ƒè¶³ä»¥äº§ç”Ÿç´§å¯†çš„æº¢å‡ºæ£€æŸ¥åºåˆ—ã€‚</p><p>                Apply LLVM ssp attributes globally instead of per-function. Otherwise LLVM asserts with: &#34;stack protected callee but caller requested no stack protector&#34;</p><p>                åœ¨å…¨å±€åº”ç”¨LLVM SSPå±æ€§è€Œä¸æ˜¯æ¯å‡½æ•°ã€‚å¦åˆ™LLVMä¼´éšç€ï¼šï¼†ï¼ƒ34;å †æ ˆå—ä¿æŠ¤çš„Calleeï¼Œä½†å‘¼å«è€…è¯·æ±‚æ²¡æœ‰å †æ ˆä¿æŠ¤å™¨ï¼†ï¼ƒ34; </p><p>                          Rework tokenizer to match  Self-Hosted Compiler. Mainly, this makes the stage1 and stage2 logic match each other, making it easier to maintain both at the same time. It is also a negligible memory usage improvement.</p><p>è¿”å›é”€ä»·åŒ¹é…è‡ªæ‰˜ç®¡ç¼–è¯‘å™¨ã€‚ä¸»è¦æ˜¯ï¼Œè¿™ä½¿å¾—Stage1å’ŒStage2é€»è¾‘å½¼æ­¤åŒ¹é…ï¼Œä½¿å¾—åŒæ—¶ä¿æŒä¸¤è€…ã€‚å®ƒä¹Ÿæ˜¯ä¸€ç§å¯å¿½ç•¥çš„å†…å­˜ä½¿ç”¨æƒ…å†µã€‚</p><p>  Store target info in the LLVM module for every function. This is needed to let LLVM (or, better, libLTO) produce code using the target options specified by the user (#8803).</p><p>  ä¸ºæ¯ä¸ªåŠŸèƒ½å­˜å‚¨LLVMæ¨¡å—ä¸­çš„ç›®æ ‡ä¿¡æ¯ã€‚è¿™æ˜¯éœ€è¦ä½¿ç”¨ç”¨æˆ·æŒ‡å®šçš„ç›®æ ‡é€‰é¡¹ï¼ˆï¼ƒ8803ï¼‰çš„ç›®æ ‡é€‰é¡¹æ¥ç”Ÿäº§ä»£ç æ‰€éœ€çš„è¿™ä¸€ç‚¹ã€‚</p><p>              Resolve builtin types and values via  std.builtin rather than via   @import( &#34;builtin&#34;). This helps avoid the need for   usingnamespace used in  builtin.zig or in  std.builtin.</p><p>              é€šè¿‡std.builtinè§£å†³å†…ç½®çš„ç±»å‹å’Œå€¼ï¼Œè€Œä¸æ˜¯é€šè¿‡@importï¼ˆï¼†ï¼ƒ34;å†…ç½®ï¼†ï¼ƒ34;ï¼‰ã€‚è¿™æœ‰åŠ©äºé¿å…åœ¨æ„å»ºä¸­ä½¿ç”¨çš„åç§°ç©ºé—´æˆ–åœ¨std.builtinä¸­ä½¿ç”¨ã€‚</p><p>  The good news here is that nearly all these fixes come with additional behavior tests, which we can use to verify the  Self-Hosted Compiler does not regress.</p><p>  è¿™é‡Œçš„å¥½æ¶ˆæ¯æ˜¯ï¼Œå‡ ä¹æ‰€æœ‰è¿™äº›ä¿®å¤éƒ½æœ‰é™„åŠ çš„è¡Œä¸ºæµ‹è¯•ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ¥éªŒè¯è‡ªæ‰˜ç®¡çš„ç¼–è¯‘å™¨ä¸ä¼šé€€åŒ–ã€‚</p><p>  One especially noteworthy change here is LemonBoy&#39;s fix to ask LLVM to produce compact code in -OReleaseSmall mode. Previously, using -OReleaseSmall sometimes resulted in larger output binaries than -OReleaseFast! (#7048, #7077)</p><p>  è¿™é‡Œçš„ä¸€ä¸ªç‰¹åˆ«å€¼å¾—æ³¨æ„çš„å˜åŒ–æ˜¯lemonboyï¼†ï¼ƒ39; s fixï¼Œä»¥ä¾¿åœ¨-oreleasemallæ¨¡å¼ä¸‹åœ¨-oreleasemallæ¨¡å¼ä¸‹ç”Ÿäº§ç´§å‡‘ç ã€‚ä»¥å‰ï¼Œä½¿ç”¨-OreleaseMallæœ‰æ—¶å¯¼è‡´è¾“å‡ºäºŒè¿›åˆ¶æ–‡ä»¶è¾ƒå¤§ï¼ ï¼ˆï¼ƒ7048ï¼Œï¼ƒ7077ï¼‰</p><p>  Big, big thanks to LemonBoy for solving so many stage1 bugs during this release cycle. This is high effort, low-appreciation, huge-impact work that he has been doing. But in reality he has been single-handedly keeping us afloat while we work towards finishing the  Self-Hosted Compiler.</p><p>  å¾ˆå¤§ï¼Œå¾ˆå¤§ï¼Œæ„Ÿè°¢Lemonboyåœ¨æ­¤å‘å¸ƒå‘¨æœŸä¸­è§£å†³è¿™ä¹ˆå¤šé˜¶æ®µ1é”™è¯¯ã€‚è¿™æ˜¯åŠªåŠ›ï¼Œä½ä¼°ï¼Œä»–ä¸€ç›´åœ¨åšçš„å·¨å¤§å½±å“åŠ›ã€‚ä½†å®é™…ä¸Šï¼Œä»–ä¸€ç›´åœ¨å•æ‰‹ä¸­è®©æˆ‘ä»¬æ¼‚æµ®åœ¨å®Œæˆè‡ªä¸»ä¸»åŠçš„ç¼–è¯‘å™¨æ—¶ã€‚</p><p>  Contributors: LemonBoy, Andrew Kelley, Koakuma, Veikka Tuominen, Tadeo Kondrak, Michael Dusan, Jakub Konka, frmdstryr, Mathieu Guay-Paquet, Sreehari S, Al Hoang, Alexandros Naskos, Isaac Freund, Jay Petacat, Josh Wolfe, Lee Cannon, Matthew Knight, Nathan Michaels, Sizhe Zhao, Timon Kruiper, Woze Parrot, Jacob G-W, lars, pfg, xackus</p><p>  è´¡çŒ®è€…ï¼šlemonboyï¼Œå®‰å¾·é²å…‹åˆ©ï¼Œè¨å¡ç©†å¡ï¼Œveikka tuominenï¼Œtadeo kondrakï¼Œè¿ˆå…‹å°”é“æ–¯Â·æ–¯å¡”å…‹ï¼Œé›…å…¸konkaï¼Œå¼—æ‹‰ç±³æ–¯ï¼Œéº¦å…‹é£ï¼Œå“ˆåº·ï¼Œäºšå†å±±å¤§å·è‰¾è¨å…‹Â·å¼—æ…ï¼Œæ°ä»€Â·ä½©ç½—ç‰¹ï¼Œå‰ä»€æ²ƒå°”å¤«ï¼Œæå¤§ç‚®ï¼Œé©¬ä¿®éª‘å£«ï¼Œå†…æ£®è¿ˆå…‹å°”æ–¯ï¼Œèµµå£®ï¼Œè’‚è’™å…‹é²å¥ˆï¼ŒWoze Parrotï¼ŒJacob Gwï¼ŒLarsï¼ŒPfgï¼ŒXackus </p><p>      This was a rough release cycle for downstream users of LLVM. During testing of the release candidates, we found and reported 7 regressions from LLVM 11. However, despite having reproducible regressions reported as release blockers, the LLVM project tagged release 12.0.0. Not only were there open regressions at this time, but the 12.0.0 tag did not even tag the tip of the release/12.x branch - so there were  fixes already committed into the release branch that did not make it into the tag.</p><p>è¿™æ˜¯LLVMä¸‹æ¸¸ç”¨æˆ·çš„ç²—ç•¥é‡Šæ”¾å¾ªç¯ã€‚åœ¨æµ‹è¯•é‡Šæ”¾å€™é€‰è€…æœŸé—´ï¼Œæˆ‘ä»¬å‘ç°å¹¶æŠ¥å‘Šäº†LLVM 11çš„7ä¸ªå›å½’ã€‚ç„¶è€Œï¼Œå°½ç®¡æŠ¥å‘Šäº†ä½œä¸ºé‡Šæ”¾é˜»æ»å‰‚çš„å¯å†ç”Ÿå›å½’ï¼Œä½†LLVMé¡¹ç›®æ ‡è®°ä¸º12.0.0ç‰ˆã€‚æ­¤æ—¶ä¸ä»…æœ‰å¼€æ”¾çš„å›å½’ï¼Œè€Œä¸”12.0.0æ ‡è®°ç”šè‡³æ²¡æœ‰æ ‡è®°é‡Šæ”¾/ 12.xåˆ†æ”¯çš„å°–ç«¯ - æ‰€ä»¥å·²ç»æäº¤åˆ°æ²¡æœ‰ä½¿å…¶è¿›å…¥æ ‡è®°çš„å‘å¸ƒåˆ†æ”¯çš„ä¿®å¤ç¨‹åºã€‚</p><p>  At the time of this writing, there are  31 open release blockers for 12.0.1, and yet LLVM has already tagged 12.0.1-rc1. As  MichaÅ‚ GÃ³rny puts it:</p><p>  åœ¨æœ¬å†™ä½œæ—¶ï¼Œæœ‰31ä¸ªæ‰“å¼€çš„é‡Šæ”¾é˜»æ»å‰‚12.0.1ï¼Œä½†LLVMå·²ç»æ ‡è®°äº†12.0.1 rc1ã€‚æ­£å¦‚MichaÅ‚GÃ³rnyæ‰€è¯´ï¼š</p><p>  I&#39;ve started testing, hit two bugs I&#39;ve already reported for 12.0.0 RCsand figured out I&#39;m wasting my time. It seems that LLVM reachedthe point where releases are pushed through just for the sake ofreleases and QA doesn&#39;t exist.</p><p>  æˆ‘å¼€å§‹æµ‹è¯•ï¼Œå‡»ä¸­äº†ä¸¤ä¸ªé”™è¯¯æˆ‘å·²ç»æŠ¥é“äº†12.0.0 rcsandå¼„æ¸…æ¥šäº†æˆ‘çš„æ—¶é—´ã€‚ä¼¼ä¹LLVMè¾¾åˆ°äº†é‡Šæ”¾çš„ç‚¹ï¼Œåªä¸ºç‚¸å¼¹é‡Šæ”¾ï¼Œå¹¶ä¸”QAä¸å­˜åœ¨QAï¼†ï¼ƒ39;</p><p>  I hope the LLVM project can step up and take releases and regressions more seriously.</p><p>  æˆ‘å¸Œæœ›LLVMé¡¹ç›®èƒ½å¤Ÿæ›´åŠ è®¤çœŸåœ°åŠ å¼ºå’Œé‡Šæ”¾é‡Šæ”¾å’Œå›å½’ã€‚</p><p>  Either way, it is starting to become clear that  transitioning LLVM to an optional dependency, and thereby providing an alternative to the LLVM monoculture, is becoming more and more of an attractive feature for the Zig project to offer. In this release you can see that we have broken ground on this front:  x86-64 Backend,  AArch64 Backend,  ARM Backend,  WebAssembly Backend,  RISC-V 64 Backend,  C Backend,  SPIR-V Backend</p><p>  æ— è®ºå“ªç§æ–¹å¼ï¼Œå®ƒå¼€å§‹æ¸…æ¥šåœ°å°†LLVMè½¬æ¢ä¸ºå¯é€‰çš„ä¾èµ–æ€§ï¼Œä»è€Œä¸ºLLVMå•ä¸€æ–‡åŒ–æä¾›æ›¿ä»£æ–¹æ¡ˆï¼Œæ­£åœ¨æˆä¸ºZIGé¡¹ç›®æä¾›çš„è¶Šæ¥è¶Šå¤šçš„ç‰¹å¾ã€‚åœ¨æ­¤ç‰ˆæœ¬ä¸­ï¼Œæ‚¨å¯ä»¥çœ‹åˆ°æˆ‘ä»¬åœ¨è¿™ä¸ªå‰é¢æ‰“ç ´äº†åœ°é¢ï¼šx86-64åç«¯ï¼Œaarch64åç«¯ï¼Œarmåç«¯ï¼Œwebassemblyåç«¯ï¼Œrisc-v 64åç«¯ï¼Œc backendï¼Œspir-våç«¯</p><p>    The main focus of this release cycle was the self-hosted compiler (also known as &#34;stage2&#34;).</p><p>    æ­¤é‡Šæ”¾å‘¨æœŸçš„ä¸»è¦é‡ç‚¹æ˜¯è‡ªä¸»ä¸»æœºç¼–è¯‘å™¨ï¼ˆä¹Ÿç§°ä¸ºï¼†ï¼ƒ34; Stage2ï¼†ï¼ƒ34;ï¼‰ã€‚</p><p>  Despite the fact that .zig source code by default is still compiled in this release using the  Bootstrap Compiler, the main driver code is already self-hosted, as well as many features, such as  zig cc,  C Translation, and  CPU Feature Detection. Improvements made to &#34;stage2&#34; in these areas do in fact affect the main Zig user experience.</p><p>  å°½ç®¡å¦‚æ­¤ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œé»˜è®¤æƒ…å†µä¸‹ä»ç„¶åœ¨æ­¤ç‰ˆæœ¬ä¸­ä½¿ç”¨Bootstrapç¼–è¯‘å™¨ç¼–è¯‘ï¼Œä¸»è¦é©±åŠ¨ç¨‹åºä»£ç å·²ç»æ˜¯è‡ªæ‰˜ç®¡çš„ï¼Œä»¥åŠè®¸å¤šåŠŸèƒ½ï¼Œå¦‚Zig CCï¼ŒCç¿»è¯‘å’ŒCPUåŠŸèƒ½æ£€æµ‹ã€‚å¯¹ï¼†ï¼ƒ34çš„æ”¹è¿›; Stage2ï¼†ï¼ƒ34;åœ¨è¿™äº›é¢†åŸŸå®é™…ä¸Šå½±å“äº†ä¸»è¦çš„Zigç”¨æˆ·ä½“éªŒã€‚ </p><p>    LemonBoy added a framework for host CPU detection on Linux based on parsing  /proc/cpuinfo, and implemented the model detection for  64-bit SPARC targets as proof of concept.</p><p>LemonboyåŸºäºè§£æ/ PROC / CPUInfoå¯¹Linuxä¸Šçš„ä¸»æœºCPUæ£€æµ‹æ·»åŠ äº†ä¸€ä¸ªæ¡†æ¶ï¼Œå¹¶å®ç°äº†64ä½SPARCç›®æ ‡ä½œä¸ºæ¦‚å¿µè¯æ˜çš„æ¨¡å‹æ£€æµ‹ã€‚</p><p>    The CPU detection code is nearly at feature parity with LLVM. We do support detecting the native CPU on Sparc systems and macOS, our ARM/AArch64 model list is quite comprehensive, and so is our PPC one. The only missing pieces are:</p><p>    CPUæ£€æµ‹ä»£ç å‡ ä¹å¤„äºå…·æœ‰LLVMçš„ç‰¹å¾å¥‡å¶æ ¡éªŒã€‚æˆ‘ä»¬ç¡®å®æ”¯æŒæ£€æµ‹SPARCç³»ç»Ÿå’Œéº¦å…‹æ–¯çš„æœ¬æœºCPUï¼Œæˆ‘ä»¬çš„ARM / AARCH64æ¨¡å‹åˆ—è¡¨éå¸¸å…¨é¢ï¼Œæˆ‘ä»¬çš„PPC Oneä¹Ÿæ˜¯å¦‚æ­¤ã€‚å”¯ä¸€ç¼ºå¤±çš„éƒ¨åˆ†æ˜¯ï¼š</p><p>  ARM32 detection on Darwin hosts (it is doubtful anybody is planning on running the compiler on a old-ass iPhone)</p><p>  ARM32å¯¹è¾¾å°”æ–‡ä¸»æœºçš„æ£€æµ‹ï¼ˆä»¤äººç–‘é—®çš„ä»»ä½•äººéƒ½è®¡åˆ’åœ¨Old-As iPhoneä¸Šè¿è¡Œç¼–è¯‘å™¨ï¼‰</p><p>  As a result of all this work, we dropped LLVM&#39;s host CPU detection method as a fallback. This is one less dependency that Zig has on LLVM, bringing us one step closer to making LLVM an optional extension rather than a required dependency.</p><p>  ç”±äºæ‰€æœ‰è¿™é¡¹å·¥ä½œï¼Œæˆ‘ä»¬ä¸¢å¼ƒäº†LLVMï¼†ï¼ƒ39;å°†ä¸»æœºCPUæ£€æµ‹æ–¹æ³•ä½œä¸ºå›é€€ã€‚è¿™æ˜¯Zigåœ¨LLVMä¸Šçš„ä¾èµ–æ€§è¾ƒå°‘ï¼Œä½¿æˆ‘ä»¬æ›´æ¥è¿‘ä½¿LLVMæˆä¸ºå¯é€‰çš„æ‰©å±•è€Œä¸æ˜¯æ‰€éœ€çš„ä¾èµ–æ€§ã€‚</p><p>    Zig&#39;s target CPU feature awareness is a superset of LLVM&#39;s, which means that for every target CPU feature Zig is aware of, it must know whether and how to map that to LLVM&#39;s target CPU feature.</p><p>    Zigï¼†ï¼ƒ39; Sç›®æ ‡CPUç‰¹å¾æ„è¯†æ˜¯LLVMï¼†ï¼ƒ39; sçš„è¶…é›†ï¼Œè¿™æ„å‘³ç€å¯¹äºæ¯ä¸ªç›®æ ‡CPUåŠŸèƒ½Zigéƒ½çŸ¥é“ï¼Œå®ƒå¿…é¡»çŸ¥é“æ˜¯å¦ä»¥åŠå¦‚ä½•å°†å…¶æ˜ å°„åˆ°LLVMï¼†ï¼ƒ39; Sç›®æ ‡CPUåŠŸèƒ½ã€‚</p><p>  For this purpose Andrew created the  update_cpu_features.zig tool. This tool generates .zig code that contains enums and data declarations for all the various CPUs that Zig is aware of.</p><p>  ä¸ºæ­¤ç›®çš„ï¼ŒAndrewåˆ›å»ºäº†update_cpu_features.zigå·¥å…·ã€‚æ­¤å·¥å…·ç”Ÿæˆ.zigä»£ç ï¼Œå…¶ä¸­åŒ…å«Zigæ‰€çŸ¥çš„æ‰€æœ‰å„ç§CPUçš„æšä¸¾å’Œæ•°æ®å£°æ˜ã€‚</p><p>      Before this release, updating target CPU features in response to LLVM updates was a manual process, in which it was too easy to introduce bugs.</p><p>      åœ¨æ­¤ç‰ˆæœ¬ä¹‹å‰ï¼Œæ›´æ–°ç›®æ ‡CPUåŠŸèƒ½å“åº”LLVMæ›´æ–°æ˜¯ä¸€ä¸ªæ‰‹åŠ¨è¿‡ç¨‹ï¼Œå…¶ä¸­å®ƒå¤ªå®¹æ˜“å¼•å…¥é”™è¯¯ã€‚ </p><p>  Now, the tool completely automates the process, and there are no longer any manual steps involved when LLVM updates, other than re-running the tool.</p><p>ç°åœ¨ï¼Œè¯¥å·¥å…·å®Œå…¨è‡ªåŠ¨åŒ–è¯¥è¿‡ç¨‹ï¼Œå¹¶ä¸”åœ¨LLVMæ›´æ–°æ—¶ä¸å†æ¶‰åŠçš„ä»»ä½•æ‰‹åŠ¨æ­¥éª¤ï¼Œè€Œä¸æ˜¯é‡æ–°è¿è¡Œè¯¥å·¥å…·ã€‚</p><p>  Additionally, Andrew improved it to parallelize work for each target, making it run much faster, despite wading through many megabytes of llvm-tblgen JSON dumps.</p><p>  æ­¤å¤–ï¼ŒAndrewæ”¹è¿›äº†å®ƒï¼Œä»¥å¯¹æ¯ä¸ªç›®æ ‡å¹¶è¡ŒåŒ–å·¥ä½œï¼Œå°½ç®¡é€šè¿‡è®¸å¤šLLVM-TBLGEN JSON Dumpsæ¶‰åŠè®¸å¤šå…†å­—èŠ‚ï¼Œä½†ä½¿å®ƒä¼šæ›´å¿«åœ°è¿è¡Œã€‚</p><p>    In the  --watch REPL, empty command re-runs previous command. This can be especially useful combined with the new  update-and-run command.</p><p>    åœ¨--watch replä¸­ï¼Œç©ºå‘½ä»¤é‡æ–°è¿è¡Œä»¥å‰çš„å‘½ä»¤ã€‚è¿™å¯ä»¥ç‰¹åˆ«æœ‰ç”¨ï¼Œä¸æ–°çš„æ›´æ–°å’Œè¿è¡Œå‘½ä»¤ç›¸ç»“åˆã€‚</p><p>      I have been reading Richard Fabian&#39;s book,  Data-Oriented Design, and finally things started to &#34;click&#34; for me. I&#39;ve had these ideas swirling around in my head for years, but only recently do I feel like I have an intuitive grasp on how modern CPUs work, especially with regards to L1 cache, and the relative latencies of uncached memory loads vs computations.</p><p>      æˆ‘ä¸€ç›´åœ¨è¯»Richard Fabianï¼†ï¼ƒ39;ä¹¦ç±ï¼Œä»¥æ•°æ®ä¸ºå¯¼å‘çš„è®¾è®¡ï¼Œæœ€åäº‹æƒ…å¼€å§‹ï¼†ï¼ƒ34;ç‚¹å‡»ï¼†ï¼ƒ34;ä¸ºæˆ‘ã€‚æˆ‘æœ‰è¿™äº›æƒ³æ³•åœ¨æˆ‘è„‘æµ·é‡Œæ—‹è½¬å¤šå¹´ï¼Œä½†æœ€è¿‘æˆ‘è§‰å¾—æˆ‘æœ‰ä¸€ä¸ªç›´è§‚çš„æŒæ¡ç°ä»£CPUå·¥ä½œå¦‚ä½•ï¼Œç‰¹åˆ«æ˜¯å¯¹äºL1ç¼“å­˜ï¼Œä»¥åŠæœªåŠ å·¥çš„å†…å­˜è´Ÿè·çš„ç›¸å¯¹å»¶è¿Ÿvsè®¡ç®—ã€‚</p><p>  Compilation speed is a top priority for the design of both the Zig self-hosted compiler as well as the language itself. I have been careful to design the language in a way as to unlock the potential of an ambitiously fast compiler.</p><p>  ç¼–è¯‘é€Ÿåº¦æ˜¯è®¾è®¡ZIGè‡ªä¸»ä¸»æœºç¼–è¯‘å™¨ä»¥åŠè¯­è¨€æœ¬èº«çš„é¦–è¦ä»»åŠ¡ã€‚æˆ‘ä¸€ç›´å°å¿ƒåœ°è®¾è®¡è¯­è¨€ï¼Œä»¥è§£é”æ½œåœ¨çš„å¿«é€Ÿç¼–è¯‘å™¨çš„æ½œåŠ›ã€‚</p><p>  In this release cycle, I took the time to rework the memory layout of 3 out of 4 phases of the compiler pipeline:</p><p>  åœ¨æ­¤ç‰ˆæœ¬å‘¨æœŸä¸­ï¼Œæˆ‘èŠ±äº†æ—¶é—´é‡æ–°åˆ¶ä½œäº†ç¼–è¯‘å™¨ç®¡é“çš„4ä¸ªé˜¶æ®µçš„å†…å­˜å¸ƒå±€ï¼š</p><p>  tokenize â¡ï¸ parse â¡ï¸ ast lowering â¡ï¸ semantic analysis â¡ï¸ machine code gen</p><p>  æ ‡è®°â¡ï¸è§£æâ¡ï¸ASTé™ä½â¡ï¸è¯­ä¹‰åˆ†æâ¡ï¸æœºä»£ç  </p><p>  Each arrow in this diagram represents a phase in the compiler pipeline inputting data in one form, and outputting data in a different form, for the next phase.</p><p>è¯¥å›¾ä¸­çš„æ¯ä¸ªç®­å¤´è¡¨ç¤ºç¼–è¯‘å™¨æµæ°´çº¿ä¸­çš„ç›¸ä½ä»¥ä¸€ç§å½¢å¼è¾“å…¥æ•°æ®ï¼Œå¹¶ä»¥ä¸åŒçš„å½¢å¼è¾“å‡ºæ•°æ®ï¼Œç”¨äºä¸‹ä¸€é˜¶æ®µã€‚</p><p>    I decided to try to reduce the number of heap-allocated bytes of the  token list as well as the  AST, as a pilot test for doing a similar strategy for ZIR and AIR later. I had a few key insights here:</p><p>    æˆ‘å†³å®šå°è¯•å‡å°‘ä»¤ç‰Œåˆ—è¡¨çš„å †åˆ†é…å­—èŠ‚æ•°ä»¥åŠASTï¼Œä½œä¸ºå¯¹ZIRå’ŒAIRçš„ç±»ä¼¼ç­–ç•¥çš„è¯•éªŒè¯•éªŒã€‚æˆ‘åœ¨è¿™é‡Œæœ‰ä¸€äº›ä¸»è¦çš„è§è§£ï¼š</p><p>  Underlying premise: using less memory will make things faster, because of fewer allocations and better cache utilization. Also using less memory is valuable in and of itself.</p><p>  åŸºç¡€å‰æï¼šä½¿ç”¨è¾ƒå°‘çš„å†…å­˜å°†ä½¿äº‹æƒ…æ›´å¿«ï¼Œå› ä¸ºè¾ƒå°‘çš„åˆ†é…å’Œæ›´å¥½çš„ç¼“å­˜åˆ©ç”¨ç‡ã€‚åŒæ ·ä½¿ç”¨è¾ƒå°‘çš„å†…å­˜åœ¨å…¶æœ¬èº«å’Œæœ¬èº«çš„ä»·å€¼æ˜¯æœ‰ä»·å€¼çš„ã€‚</p><p>  Using a  Struct-Of-Arrays for tokens and AST nodes, saves the bytes of padding between the enum tag (which kind of token is it; which kind of AST node is it) and the next fields in the struct. It also improves cache coherence, since one can peek ahead in the tokens array without having to load the source locations of tokens.</p><p>  å¯¹äºä»¤ç‰Œå’ŒASTèŠ‚ç‚¹ä½¿ç”¨é˜µåˆ—ç»“æ„ï¼Œä¿å­˜æšä¸¾æ ‡è®°ä¹‹é—´çš„å¡«å……å­—èŠ‚ï¼ˆå“ªç§ä»¤ç‰Œ;å®ƒæ˜¯å“ªç§ASTèŠ‚ç‚¹ï¼‰å’Œç»“æ„ä¸­çš„ä¸‹ä¸€ä¸ªå­—æ®µã€‚å®ƒè¿˜æé«˜äº†ç¼“å­˜ä¸€è‡´æ€§ï¼Œå› ä¸ºäººä»¬å¯ä»¥åœ¨ä»¤ç‰Œé˜µåˆ—ä¸­çª¥è§†ï¼Œè€Œæ— éœ€åŠ è½½ä»¤ç‰Œçš„æºä½ç½®ã€‚</p><p>  Token memory can be conserved by only having the tag (1 byte) and byte offset (4 bytes) for a total of 5 bytes per token. It is not necessary to store the token ending byte offset because one can always re-tokenize later, but also most tokens the length can be trivially determined from the tag alone, and for ones where it doesn&#39;t, string literals for example, one must parse the string literal again later anyway in astgen, making it free to re-to</p><p>  å¯ä»¥é€šè¿‡ä»…å…·æœ‰æ ‡è®°ï¼ˆ1å­—èŠ‚ï¼‰å’Œå­—èŠ‚åç§»é‡ï¼ˆ4å­—èŠ‚ï¼‰æ¥ä¿å­˜ä»¤ç‰Œå­˜å‚¨å™¨ï¼Œæ¯ä¸ªä»¤ç‰Œæ€»å…±5ä¸ªå­—èŠ‚ã€‚æ²¡æœ‰å¿…è¦å­˜å‚¨ä»¤ç‰Œç»“æŸå­—èŠ‚åç§»ï¼Œå› ä¸ºç¨åå¯ä»¥å§‹ç»ˆé‡æ–°é”€é‡ï¼Œä½†æ˜¯å¤§å¤šæ•°ä»¤ç‰Œçš„é•¿åº¦å¯ä»¥å•ç‹¬åœ°ä»æ ‡ç­¾ä¸­çª¥æ¢ï¼Œå¹¶ä¸”å¯¹äºå®ƒè€Œä¸æ˜¯å…¶ä¸­ï¼Œä¾‹å¦‚å®ƒçš„å­—ç¬¦ä¸²æ–‡å­—ã€‚ ï¼Œä¸€ä¸ªäººå¿…é¡»åœ¨astgenä¸­ç¨åå†æ¬¡è§£æå­—ç¬¦ä¸²æ–‡å­—ï¼Œä½¿å…¶è‡ªç”±åœ°é‡æ–°å®ç°</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ziglang.org/download/0.8.0/release-notes.html">https://ziglang.org/download/0.8.0/release-notes.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/å‘è¡Œ/">#å‘è¡Œ</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/release/">#release</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>