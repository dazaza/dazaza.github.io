<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Elixir Swenserverè§£é‡Šè¯´æ˜ Elixir GenServer Explained</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Elixir GenServer Explained<br/>Elixir Swenserverè§£é‡Šè¯´æ˜ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-28 11:19:52</div><div class="page_narrow text-break page_content"><p>I started learning Elixir a few months ago, mostly through hacking on  Papercups. I&#39;m ashamed to say most of my Elixir education has been through trial and error, figuring things out as I go along. So this past week I decided to take some time off from Papercups to go a bit deeper into the language.</p><p>å‡ ä¸ªæœˆå‰ï¼Œæˆ‘å¼€å§‹å­¦ä¹ Elixirï¼Œä¸»è¦æ˜¯é€šè¿‡é»‘å®¢æ”»å‡»çº¸å¼ ã€‚æˆ‘æ„¤æ€’åœ°è¯´ï¼Œæˆ‘çš„å¤§éƒ¨åˆ†Elixiræ•™è‚²ä¸€ç›´æ˜¯é€šè¿‡å®¡åˆ¤å’Œé”™è¯¯çš„ï¼Œåœ¨æˆ‘èµ°çš„æ—¶å€™å¼„æ¸…æ¥šã€‚æ‰€ä»¥è¿‡å»çš„ä¸€å‘¨æˆ‘å†³å®šä»çº¸ä¸Šæ‰ä¸€æ®µæ—¶é—´ä¼‘æ¯ï¼Œæ›´æ·±å…¥åœ°è¿›å…¥è¯­è¨€ã€‚</p><p> In particular, I was itching to learn more about handling concurrency in Elixir. This, of course, led me to GenServers.</p><p> ç‰¹åˆ«æ˜¯ï¼Œæˆ‘æ­£åœ¨æ‹æ‘„æ›´å¤šå…³äºåœ¨Elixirä¸­å¤„ç†å¹¶å‘æ€§çš„æ›´å¤šä¿¡æ¯ã€‚å½“ç„¶ï¼Œè¿™è®©æˆ‘æ„Ÿåˆ°äº†æƒ©ç½šè€…ã€‚</p><p> Anyone who&#39;s moderately familiar with Elixir has probably at least  heard of   GenServer. (If you haven&#39;t, that&#39;s ok too!) Strictly speaking, it&#39;s one of those things you can get away with avoiding for a while, and still be reasonably productive while using something like the Phoenix framework.</p><p> ï¼†ï¼ƒ39; SOMEDERYç†Ÿæ‚‰ELIXIRçš„äººå¯èƒ½è‡³å°‘å¬è¯´äº†Genserverã€‚ ï¼ˆå¦‚æœä½ æ²¡æœ‰ï¼Œé‚£ä¹Ÿæ²¡æœ‰ï¼Œé‚£ä¸ªï¼†ï¼ƒ39; SOODï¼ï¼‰ä¸¥æ ¼æ¥è¯´ï¼Œå®ƒï¼†ï¼ƒ39;è™½ç„¶ä½ å¯ä»¥é€ƒé¿ä¸€æ®µæ—¶é—´ï¼Œä½†åœ¨ä½¿ç”¨è¿™æ ·çš„ä¸œè¥¿æ—¶ä»ç„¶å…·æœ‰åˆç†çš„æ•ˆç‡å‡¤å‡°æ¡†æ¶ã€‚</p><p> But it&#39;s an incredible useful feature of the language that you can add to your toolbox! There are so many nice things you can do with it. For example, with GenServers, you can:</p><p> ä½†å®ƒï¼†ï¼ƒ39;æ˜¯æ‚¨å¯ä»¥æ·»åŠ åˆ°å·¥å…·ç®±çš„è¯­è¨€çš„ä»¤äººéš¾ä»¥ç½®ä¿¡çš„æœ‰ç”¨åŠŸèƒ½ï¼ä½ å¯ä»¥ç”¨å®ƒåšå¾ˆå¤šå¥½çš„ä¸œè¥¿ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨Genserversï¼Œæ‚¨å¯ä»¥ï¼š</p><p> set up recurring tasks to run every few hours (e.g. check out Jose&#39;s answer to  &#34;How can I schedule code to run every few hours in Elixir?&#34; on Stack Overflow)</p><p> è®¾ç½®æ¯éš”å‡ ä¸ªå°æ—¶çš„é‡å¤ä»»åŠ¡æ¯éš”å‡ ä¸ªå°æ—¶ï¼ˆä¾‹å¦‚ï¼Œæ£€æŸ¥ä½•å¡ï¼†ï¼ƒ39;ç­”æ¡ˆåˆ°ï¼†ï¼ƒ34;å¦‚ä½•å®‰æ’åœ¨Elixirä¸­æ¯éš”å‡ ä¸ªå°æ—¶è¿è¡Œä»£ç ï¼Ÿï¼†ï¼ƒ34;å †æ ˆæº¢å‡ºï¼‰</p><p> handle async processes much more easily, with built-in functionality for tracing, error reporting, and retry logic</p><p> æ›´è½»æ¾åœ°å¤„ç†å¼‚æ­¥æµç¨‹ï¼Œå…·æœ‰è¿½è¸ªï¼Œé”™è¯¯æŠ¥å‘Šå’Œé‡è¯•é€»è¾‘çš„å†…ç½®åŠŸèƒ½</p><p>   A  GenServer is a process, just like any other Elixir process. It can be used to manage state and execute code asynchronously, and includes some handy functionality around tracing and error reporting.</p><p>   Genserveræ˜¯ä¸€ä¸ªè¿‡ç¨‹ï¼Œå°±åƒä»»ä½•å…¶ä»–Elixirè¿›ç¨‹ä¸€æ ·ã€‚å®ƒå¯ç”¨äºå¼‚æ­¥ç®¡ç†çŠ¶æ€å¹¶æ‰§è¡Œä»£ç ï¼Œå¹¶åŒ…æ‹¬å›´ç»•è·Ÿè¸ªå’Œé”™è¯¯æŠ¥å‘Šçš„ä¸€äº›æ–¹ä¾¿çš„åŠŸèƒ½ã€‚ </p><p> Another way of thinking about it â€” a GenServer is like an isolated little box, with a few things inside of it:</p><p>å¦ä¸€ç§æ€è€ƒæ–¹å¼ - ä¸€ä¸ªå’’è¯­å°±åƒä¸€ä¸ªå­¤ç«‹çš„å°ç›’å­ï¼Œå…¶ä¸­æœ‰ä¸€äº›ä¸œè¥¿ï¼š</p><p> its internal state (which can be any Elixir data structure, from a simple number to a complex map/struct),</p><p> å…¶å†…éƒ¨çŠ¶æ€ï¼ˆå¯ä»¥æ˜¯ä»»ä½•Elixiræ•°æ®ç»“æ„ï¼Œä»ç®€å•çš„æ•°å­—åˆ°å¤æ‚çš„åœ°å›¾/ç»“æ„ï¼‰ï¼Œ</p><p>  and a callback module, which defines the code to run depending on the message that is received in the mailbox</p><p>  å’Œä¸€ä¸ªå›è°ƒæ¨¡å—ï¼Œå®ƒå®šä¹‰äº†æ ¹æ®é‚®ç®±ä¸­æ”¶åˆ°çš„æ¶ˆæ¯è¿è¡Œçš„ä»£ç </p><p>   While learning about GenServers, I found many of the examples to be a bit contrived... a lot of &#34;key-value&#34; stores, shopping lists, and things like that. I wanted to understand how GenServers are being used &#34;out in the wild&#34;, so I turned to one of my favorite Elixir open-source repos:  https://github.com/plausible/analytics</p><p>   åœ¨å­¦ä¹ Genserversæ—¶ï¼Œæˆ‘å‘ç°è®¸å¤šä¾‹å­æœ‰ç‚¹æ˜¯ä¸€ä¸ª......å¾ˆå¤šï¼†ï¼ƒ34;é’¥åŒ™å€¼ï¼†ï¼ƒ34;å•†åº—ï¼Œè´­ç‰©åˆ—è¡¨å’Œç±»ä¼¼çš„ä¸œè¥¿ã€‚æˆ‘æƒ³äº†è§£Genserversæ˜¯å¦‚ä½•ä½¿ç”¨çš„ï¼Œå¹¶ä¸”åœ¨é‡å¤–ï¼†ï¼ƒ34;æ‰€ä»¥æˆ‘è½¬å‘äº†æˆ‘æœ€å–œæ¬¢çš„elixirå¼€æºreposï¼šhttpsï¼š//github.com/plausible/analytics</p><p> A bit of background:  Plausible is an open-source analytics platform, with &gt;1000 paying customers. Because they are a real-world production application serving many users, I figured I could learn a lot from diagnosing one of their modules. ğŸ¤“</p><p> æœ‰ç‚¹èƒŒæ™¯ï¼šåˆç†çš„æ˜¯ä¸€ä¸ªå¼€æºåˆ†æå¹³å°ï¼Œå…·æœ‰ï¼†gt; 1000æ”¯ä»˜å®¢æˆ·ã€‚å› ä¸ºå®ƒä»¬æ˜¯æœåŠ¡è®¸å¤šç”¨æˆ·çš„çœŸå®ç”Ÿäº§åº”ç”¨ç¨‹åºï¼Œæ‰€ä»¥æˆ‘æƒ³æˆ‘å¯ä»¥å­¦ä¹ å¾ˆå¤šè¯Šæ–­ä»–ä»¬çš„æ¨¡å—ã€‚ ğŸ¤“</p><p> For the sake of this post, I&#39;m going to go through one of the simpler GenServers in their repo:  Plausible.Event.WriteBuffer, which can be found at  /lib/plausible/event/write_buffer.ex</p><p> ä¸ºäº†è¿™ç¯‡æ–‡ç« ï¼Œæˆ‘å°†é€šè¿‡ä»–ä»¬çš„repoä¸­çš„ä¸€ä¸ªæ›´ç®€å•çš„genserversä¹‹ä¸€ï¼šplausible.event.writeBufferï¼Œå®ƒå¯ä»¥åœ¨/lib/plausible/fent/write_buffer.exä¸­æ‰¾åˆ°</p><p>  At a high level, this GenServer allows Plausible to insert large quantities of events into the database in batches, rather than doing an insertion for each individual event. (This seems particularly important for a product like Plausible&#39;s, where they are potentially ingesting thousands of events per second!)</p><p>  åœ¨é«˜çº§åˆ«ä¸­ï¼Œæ­¤Genserverå…è®¸åˆç†çš„ä¿¡æ¯ä»¥æ‰¹é‡å°†å¤§é‡äº‹ä»¶æ’å…¥æ•°æ®åº“ä¸­ï¼Œè€Œä¸æ˜¯ä¸ºæ¯ä¸ªå•ç‹¬äº‹ä»¶è¿›è¡Œæ’å…¥ã€‚ ï¼ˆè¿™å¯¹åƒåˆç†çš„äº§å“ä¼¼ä¹å°¤ä¸ºé‡è¦ï¼Œåœ¨é‚£é‡Œä»–ä»¬å¯èƒ½ä¼šæ‘„å–æ¯ç§’æˆåƒä¸Šä¸‡çš„äº‹ä»¶ï¼ï¼‰ </p><p>  adding them to a  buffer in the process&#39;s internal state, represented by a list (i.e.  [])</p><p>å°†å®ƒä»¬æ·»åŠ åˆ°è¿‡ç¨‹ä¸­çš„ç¼“å†²åŒºï¼†ï¼ƒ39; så†…éƒ¨çŠ¶æ€ï¼Œç”±åˆ—è¡¨è¡¨ç¤ºï¼ˆå³[]ï¼‰</p><p> &#34;flushing&#34; the buffer every 5 seconds, or if it reaches its capacity of 10,000 events â€” whichever comes first where &#34;flushing&#34; means saving all the events in the buffer to a database (in this case, ClickHouse)</p><p> ï¼†ï¼ƒ34;å†²æ´—ï¼†ï¼ƒ34;æ¯5ç§’çš„ç¼“å†²åŒºï¼Œæˆ–è€…å®ƒè¾¾åˆ°å…¶å®¹é‡ä¸º10,000ä¸ªäº‹ä»¶ - æ— è®ºå“ªä¸ªæ˜¯ç¬¬ä¸€æ¬¡åœ¨å…¶ä¸­ï¼†ï¼ƒ34;å†²æ´—ï¼†ï¼ƒ34;æ„å‘³ç€å°†ç¼“å†²åŒºä¸­çš„æ‰€æœ‰äº‹ä»¶ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆåœ¨æœ¬ä¾‹ä¸­ï¼Œå•å‡»å°æ—¶ï¼‰</p><p> (For the full context, let&#39;s take a look at the codebase: we can see that the  Plausible.Event.WriteBuffer GenServer is used in the   PlausibleWeb.Api.ExternalController.event/2 method, which handles the logic for the   POST /api/event API endpoint, which in turn gets called from their  JavaScript tracking snippet.)</p><p> ï¼ˆå¯¹äºå®Œæ•´çš„ä¸Šä¸‹æ–‡ï¼Œè®©ï¼†ï¼ƒ39; sçœ‹çœ‹ä»£ç åº“ï¼šæˆ‘ä»¬å¯ä»¥çœ‹åˆ°plausible.event.writeBuffer Genserverç”¨äºPlausibleWeb.api.externalController.Event / 2æ–¹æ³•ï¼Œå®ƒå¤„ç†é€»è¾‘post / api /äº‹ä»¶APIç«¯ç‚¹ï¼Œåˆä»ä»–ä»¬çš„JavaScriptè·Ÿè¸ªç‰‡æ®µè°ƒç”¨ã€‚ï¼‰</p><p>  Before we jump into it, here&#39;s the  full module, with some minor stylistic tweaks and annotations I&#39;ve added myself for some additional context:</p><p>  åœ¨æˆ‘ä»¬è·³å…¥å®ƒä¹‹å‰ï¼Œè¿™é‡Œçš„å®Œæ•´æ¨¡å—ï¼Œå¸¦æœ‰ä¸€äº›å°å‹é£æ ¼è°ƒæ•´å’Œæ³¨é‡ŠIï¼†ï¼ƒ39; veæ·»åŠ äº†ä¸€äº›å…¶ä»–èƒŒæ™¯ï¼š</p><p> defmodule Plausible .Event .WriteBuffer  do  use GenServer  require Logger    5_000    10_000  # Client APIs  def start_link (_opts )  do GenServer .start_link (__MODULE__ ,  [ ] ,   __MODULE__ )  end  def insert (event )  do GenServer .cast (__MODULE__ ,  { :insert , event } )  { :ok , event }  end  def flush ( )  do GenServer .call (__MODULE__ ,  :flush ,  :infinity )  :ok  end  # Server (callbacks)    true  def init (buffer )  do Process .flag ( :trap_exit ,  true ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :ok ,  % {  buffer ,   timer } }  end    true  def handle_cast ( { :insert , event } ,  % {  buffer ,   timer }  = _state )  do new_buffer  =  [event  | buffer ]  if length (new_buffer )  &gt;=    do Logger .info ( &#34;Buffer full, flushing to disk&#34; ) Process .cancel_timer (timer ) do_flush (new_buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   new_timer } }  else  { :noreply ,  % {state  |   new_buffer } }  end  end    true  def handle_info ( :tick ,  % {  buffer }  = _state )  do do_flush (buffer ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   timer } }  end    true  def handle_call ( :flush , _from ,  % {  buffer ,   timer }  = _state )  do Process .cancel_timer (timer ) do_flush (buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :reply ,  nil ,  % {   [ ] ,   new_timer } }  end    true  def terminate (_reason ,  % {  buffer }  = _state )  do Logger .info ( &#34;Flushing event buffer before shutdown...&#34; ) do_flush (buffer )  end  # Private/utility methods  defp do_flush (buffer )  do  case buffer  do  [ ]  -&gt;  nil events  -&gt; Logger .info ( &#34;Flushing   #{length (events ) } events&#34; ) events  = Enum .map (events ,  &amp; (Map .from_struct ( &amp;1 )  |&gt; Map .delete ( :__meta__ ) ) ) Plausible .ClickhouseRepo .insert_all (Plausible .ClickhouseEvent , events )  end  end end</p><p> DefModuleåˆç†çš„.Event .writeBufferç¡®å®ä½¿ç”¨Genserverè¦æ±‚è®°å½•å™¨5_000 10_000ï¼ƒå®¢æˆ·ç«¯API Def Start_Linkï¼ˆ_Optsï¼‰Do Genserver .start_linkï¼ˆ__module__ï¼Œ[]ï¼Œ__module__ï¼‰ç»“æŸdefæ’å…¥ï¼ˆäº‹ä»¶ï¼‰do genserver .castï¼ˆ__module__ï¼Œ{ï¼šæ’å…¥ï¼Œäº‹ä»¶}ï¼‰{ï¼šç¡®å®šï¼Œäº‹ä»¶}ç»“æŸdef flushï¼ˆï¼‰do genserver .callï¼ˆ__module__ï¼Œï¼šflushï¼Œï¼šInfinityï¼‰ï¼šç¡®å®š#serverï¼ˆå›è°ƒï¼‰true def initï¼ˆbufferï¼‰do process .flagï¼ˆï¼štrap_exitï¼Œtrue ï¼‰timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼štickï¼Œï¼‰{ï¼šokï¼Œï¼…{bufferï¼Œtimer}}ç»“æŸtrue def handle_castï¼ˆ{ï¼šæ’å…¥ï¼Œäº‹ä»¶}ï¼Œï¼…{bufferï¼Œtimer} = _stateï¼‰do new_buffer = [äº‹ä»¶|ç¼“å†²åŒº]å¦‚æœé•¿åº¦ï¼ˆnew_bufferï¼‰ï¼†gt; = do logger .infoï¼ˆï¼†ï¼ƒ34; buffer fullï¼Œåˆ·æ–°åˆ°ç£ç›˜ï¼†ï¼ƒ34;ï¼‰è¿›ç¨‹.cancel_timerï¼ˆtimerï¼‰do_flushï¼ˆnew_bufferï¼‰new_timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼šå‹¾é€‰ï¼Œï¼‰{ï¼šnoreplyï¼Œï¼…{[]ï¼Œnew_timer}} else {ï¼šnoreplyï¼Œï¼…{state | new_buffer}}ç»“æŸç»“æŸtrue def handle_infoï¼ˆï¼štickï¼Œï¼…{buffer} = _stateï¼‰do do_flushï¼ˆbufferï¼‰timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼štickï¼Œï¼‰{ï¼šï¼šnoreplyï¼Œï¼…{[]ï¼Œtimer}}ç»“æŸçœŸå®def handle_callï¼ˆï¼šflushï¼Œ_fromï¼Œï¼…{bufferï¼Œtimer} = _stateï¼‰doè¿›ç¨‹.cancel_timerï¼ˆtimerï¼‰do_flushï¼ˆbeafferï¼‰new_timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼štickï¼Œï¼‰{ï¼šå›å¤ï¼Œnilï¼Œ ï¼…{[]ï¼Œnew_timer}}ç»“æŸtry def tendineï¼ˆ_reasonï¼Œï¼…{buffer} = _stateï¼‰do logger .infoï¼ˆï¼†ï¼ƒ34;å…³é—­å‰åˆ·æ–°äº‹ä»¶ç¼“å†²åŒº...ï¼†ï¼ƒ34;ï¼‰do_flushï¼ˆç¼“å†²åŒºï¼‰ç»“æŸï¼ƒç§äºº/å®ç”¨æ–¹æ³•DEFP DO_FLUSHï¼ˆç¼“å†²åŒºï¼‰DO CASE BUFFER DO []  - ï¼†gt;é›¶äº‹ä»¶ - ï¼†gt; logger .infoï¼ˆï¼†ï¼ƒ34;åˆ·æ–°ï¼ƒ{é•¿åº¦ï¼ˆäº‹ä»¶ï¼‰}äº‹ä»¶ï¼†ï¼ƒ34;ï¼‰events = enum .mapï¼ˆäº‹ä»¶ï¼Œï¼†amp;ï¼ˆmap.from_structï¼ˆï¼†amp; 1ï¼‰|ï¼†gt;åœ°å›¾.deleteï¼ˆï¼š__å…ƒ__ï¼‰ ï¼‰ï¼‰åˆç†çš„.clickhouseepo .insert_allï¼ˆåˆç†çš„.clickhouseEventï¼Œæ´»åŠ¨ï¼‰ç»“æŸç»“æŸ</p><p> Note: If you&#39;re able to read the code above and know  exactly what&#39;s going on at every step, you probably don&#39;t need to read any further!</p><p> æ³¨æ„ï¼šå¦‚æœæ‚¨ï¼†ï¼ƒ39;é‡æ–°èƒ½å¤Ÿé˜…è¯»ä¸Šé¢çš„ä»£ç ï¼Œå¹¶ç¡®åˆ‡åœ°çŸ¥é“æ¯ä¸€æ­¥ï¼Œä½ å¯èƒ½è¿˜è¦è¿›ä¸€æ­¥é˜…è¯»ï¼†ï¼ƒ39;</p><p> Let&#39;s start off where the core of the logic actually lives: in the GenServer callbacks.</p><p> è®©ï¼†ï¼ƒ39; så¼€å§‹é€»è¾‘çš„æ ¸å¿ƒå®é™…ç”Ÿæ´»çš„æ ¸å¿ƒï¼šåœ¨Genserverå›è°ƒä¸­ã€‚ </p><p>   handle_call/3 - invoked when  GenServer.call/3 is called, to handle messages synchronously GenServer.call/3 will block until a reply is received (unless the call times out or nodes are disconnected)</p><p>å¥æŸ„_call / 3  - è°ƒç”¨genserver.call/3æ—¶è°ƒç”¨ï¼ŒåŒæ­¥å¤„ç†æ¶ˆæ¯genserver.call/3å°†é˜»æ­¢ï¼Œç›´åˆ°æ”¶åˆ°å›å¤ï¼ˆé™¤éå‘¼å«è¶…æ—¶æˆ–èŠ‚ç‚¹æ–­å¼€è¿æ¥ï¼‰</p><p> handle_info/2 - invoked to handle all other messages (i.e. outside of those triggered by  GenServer.call/3 and  GenServer.cast/2, and  &#34;system&#34; messages)</p><p> handle_info / 2  - è°ƒç”¨ä»¥å¤„ç†æ‰€æœ‰å…¶ä»–æ¶ˆæ¯ï¼ˆå³ç”±Genserver.Call/3å’ŒGenserver.Cast / 2è§¦å‘çš„é‚£äº›é‚®ä»¶ï¼ˆå³ï¼Œå’Œï¼ƒ34;ç³»ç»Ÿï¼†ï¼ƒ34;æ¶ˆæ¯ï¼‰</p><p>   The  init/1 callback is invoked when the GenServer is started, and handles setting the initial internal state of the server process.</p><p>   å¯åŠ¨Genserveræ—¶è°ƒç”¨init / 1å›è°ƒï¼Œå¹¶å¤„ç†è®¾ç½®æœåŠ¡å™¨è¿›ç¨‹çš„åˆå§‹å†…éƒ¨çŠ¶æ€ã€‚</p><p>   true  def init (buffer )  do Process .flag ( :trap_exit ,  true ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :ok ,  % {  buffer ,   timer } }  end</p><p>   true def initï¼ˆç¼“å†²åŒºï¼‰doè¿›ç¨‹.flagï¼ˆï¼štrap_exitï¼Œtrueï¼‰timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼štickï¼Œï¼‰{ï¼šç¡®å®šï¼Œï¼…{bufferï¼Œtimer}}ç»“æŸ</p><p> The first line of this method ( Process.flag(:trap_exit, true)) sets us up to &#34;trap exits&#34;. This allows us to handle any &#34;clean-up&#34; tasks before the process terminates, in the  terminate/2 callback. (We&#39;ll discuss this below!)</p><p> æ­¤æ–¹æ³•çš„ç¬¬ä¸€è¡Œï¼ˆprocess.flagï¼ˆï¼štrap_exitï¼Œtrueï¼‰è®¾ç½®æˆ‘ä»¬æœ€å¤šï¼†ï¼ƒ34;é™·é˜±é€€å‡ºï¼†ï¼ƒ34;è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿå¤„ç†ä»»ä½•ï¼†ï¼ƒ34;æ¸…ç†ï¼†ï¼ƒ34;åœ¨è¿‡ç¨‹ä¹‹å‰ä»»åŠ¡ç»ˆæ­¢ï¼Œåœ¨ç»ˆæ­¢/ 2å›è°ƒä¸­ã€‚ ï¼ˆæˆ‘ä»¬ï¼†ï¼ƒ39; llåœ¨ä¸‹é¢è®¨è®ºè¿™ä¸ªï¼ï¼‰</p><p> Next, we set up a timer to run the  :tick event in 5 seconds ( @flush_interval_ms == 5_000). As we&#39;ll see below, this  :tick event also calls itself recursively, so that it effectively runs every 5 seconds while the server is alive. (That explains why it&#39;s called &#34;tick&#34;!)</p><p> æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åœ¨5ç§’å†…è®¾ç½®ä¸€ä¸ªè®¡æ—¶å™¨ä»¥åœ¨5ç§’å†…è¿è¡Œï¼šå‹¾é€‰äº‹ä»¶ï¼ˆ@flush_interval_ms == 5_000ï¼‰ã€‚å½“æˆ‘ä»¬ï¼†ï¼ƒ39; llè§ä¸‹æ–‡ï¼Œè¿™ä¸ªï¼šå‹¾é€‰äº‹ä»¶è¿˜è¦é€’å½’è°ƒç”¨è‡ªå·±ï¼Œä»¥ä¾¿åœ¨æœåŠ¡å™¨æ´»è·ƒæ—¶æœ‰æ•ˆåœ°è¿è¡Œæ¯5ç§’ä¸€æ¬¡ã€‚ ï¼ˆè¿™è§£é‡Šäº†ä¸ºä»€ä¹ˆå®ƒï¼†ï¼ƒ39; sè¢«å«ï¼†ï¼ƒ34;å‹¾é€‰ï¼†ï¼ƒ34 ;!ï¼‰</p><p> Finally, we store the initial  buffer (in this case, an empty list, i.e.  []) and the  timer in the internal state.</p><p> æœ€åï¼Œæˆ‘ä»¬å­˜å‚¨åˆå§‹ç¼“å†²åŒºï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç©ºåˆ—è¡¨ï¼Œå³å†…éƒ¨çŠ¶æ€ä¸­çš„è®¡æ—¶å™¨ã€‚ </p><p>     true  def handle_cast ( { :insert , event } ,  % {  buffer ,   timer }  = _state )  do new_buffer  =  [event  | buffer ]  if length (new_buffer )  &gt;=    do Logger .info ( &#34;Buffer full, flushing to disk&#34; ) Process .cancel_timer (timer ) do_flush (new_buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   new_timer } }  else  { :noreply ,  % {state  |   new_buffer } }  end  end</p><p>True Def Handle_castï¼ˆ{ï¼šæ’å…¥ï¼Œäº‹ä»¶}ï¼Œï¼…{bufferï¼Œtimer} = _stateï¼‰do new_buffer = [äº‹ä»¶|ç¼“å†²åŒº]å¦‚æœé•¿åº¦ï¼ˆnew_bufferï¼‰ï¼†gt; = do logger .infoï¼ˆï¼†ï¼ƒ34; buffer fullï¼Œåˆ·æ–°åˆ°ç£ç›˜ï¼†ï¼ƒ34;ï¼‰è¿›ç¨‹.cancel_timerï¼ˆtimerï¼‰do_flushï¼ˆnew_bufferï¼‰new_timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼šå‹¾é€‰ï¼Œï¼‰{ï¼šnoreplyï¼Œï¼…{[]ï¼Œnew_timer}} else {ï¼šnoreplyï¼Œï¼…{state | new_buffer}}ç»“æŸç»“æŸ</p><p>  Inserting a new event into the internal state&#39;s  buffer, by prepending it to the list</p><p>  å°†æ–°äº‹ä»¶æ’å…¥å†…éƒ¨çŠ¶æ€å’Œï¼ƒ39; sç¼“å†²åŒºï¼Œé€šè¿‡é¢„å…ˆé…ç½®åˆ°åˆ—è¡¨</p><p> Checking if the buffer has reached capacity, and if so, sets up a new timer which will trigger the next automatic  flush in 5 seconds</p><p> æ£€æŸ¥ç¼“å†²åŒºæ˜¯å¦å·²è¾¾åˆ°å®¹é‡ï¼Œå¦‚æœæ˜¯ï¼Œè¯·è®¾ç½®ä¸€ä¸ªæ–°çš„è®¡æ—¶å™¨ï¼Œå®ƒå°†åœ¨5ç§’å†…è§¦å‘ä¸‹ä¸€ä¸ªè‡ªåŠ¨åˆ·æ–°</p><p> resets the internal state&#39;s  buffer to an empty list, and updates the timer as well</p><p> å°†å†…éƒ¨çŠ¶æ€é‡ç½®ä¸ºç©ºåˆ—è¡¨ï¼Œå¹¶æ›´æ–°è®¡æ—¶å™¨</p><p> The reason this is handled in a  handle_cast/2 callback rather than a  handle_call/3 callback is so that the client can execute this asynchronously, without blocking on the completion of a potential  do_flush/1 method invocation. (As we&#39;ll see below, the &#34;flushing&#34;/saving of 10,000 events is a potentially expensive operation that could take a few seconds to complete.)</p><p> æ­¤åŸå› è¿™åœ¨Handle_cast / 2å›è°ƒä¸­å¤„ç†è€Œä¸æ˜¯hange_call / 3å›è°ƒæ˜¯ä¸ºäº†ä½¿å®¢æˆ·ç«¯å¯ä»¥å¼‚æ­¥æ‰§è¡Œï¼Œè€Œä¸ä¼šåœ¨å®Œæˆæ½œåœ¨DO_FLUSH / 1æ–¹æ³•è°ƒç”¨çš„æƒ…å†µä¸‹é˜»æ­¢ã€‚ ï¼ˆä½œä¸ºæˆ‘ä»¬ï¼†ï¼ƒ39; llè§ä¸‹æ–‡ï¼Œï¼†ï¼ƒ34;å†²æ´—ï¼†ï¼ƒ34; /æŒ½æ•‘10,000ä¸ªäº‹ä»¶æ˜¯ä¸€ä¸ªå¯èƒ½éœ€è¦å‡ ç§’é’Ÿçš„æ½œåœ¨æ˜‚è´µçš„æ“ä½œã€‚ï¼‰</p><p> Let&#39;s take a quick look at the  do_flush/1 method to see what&#39;s going on there:</p><p> è®©ï¼†ï¼ƒ39;å¿«é€Ÿçœ‹çœ‹Do_Flush / 1æ–¹æ³•ï¼Œä»¥æŸ¥çœ‹é‚£é‡Œçš„å†…å®¹å’Œï¼ƒ39;</p><p> defp do_flush (buffer )  do  case buffer  do  [ ]  -&gt;  nil events  -&gt; Logger .info ( &#34;Flushing   #{length (events ) } events&#34; ) events  = Enum .map (events ,  &amp; (Map .from_struct ( &amp;1 )  |&gt; Map .delete ( :__meta__ ) ) ) Plausible .ClickhouseRepo .insert_all (Plausible .ClickhouseEvent , events )  end  end</p><p> defp do_flushï¼ˆç¼“å†²åŒºï¼‰do case buffer do []  - ï¼†gt;é›¶äº‹ä»¶ - ï¼†gt; logger .infoï¼ˆï¼†ï¼ƒ34;åˆ·æ–°ï¼ƒ{é•¿åº¦ï¼ˆäº‹ä»¶ï¼‰}äº‹ä»¶ï¼†ï¼ƒ34;ï¼‰events = enum .mapï¼ˆäº‹ä»¶ï¼Œï¼†amp;ï¼ˆmap.from_structï¼ˆï¼†amp; 1ï¼‰|ï¼†gt;åœ°å›¾.deleteï¼ˆï¼š__å…ƒ__ï¼‰ ï¼‰ï¼‰åˆç†çš„.clickhouterepo .insert_allï¼ˆåˆç†çš„.clickhouseEventï¼Œæ´»åŠ¨ï¼‰ç»“æŸç»“æŸ </p><p> This method is just standard Elixir. All it&#39;s doing is taking the events in the buffer, formatting them into plain maps (rather than structs), and then persisting them to the database ( ClickHouse). (If we wanted a slightly more explicit name for this method, we could call it something like  save_to_clickhouse/1 instead.)</p><p>è¿™ç§æ–¹æ³•åªæ˜¯æ ‡å‡†çš„elixirã€‚æ‰€æœ‰ï¼†ï¼ƒ39;æ­£åœ¨åšçš„æ˜¯åœ¨ç¼“å†²åŒºä¸­å–å‡ºäº‹ä»¶ï¼Œå°†å®ƒä»¬æ ¼å¼åŒ–ä¸ºçº¯åœ°å›¾ï¼ˆè€Œä¸æ˜¯ç»“æ„ï¼‰ï¼Œç„¶åæŒç»­åˆ°æ•°æ®åº“ï¼ˆç‚¹å‡»å±‹ï¼‰ã€‚ ï¼ˆå¦‚æœæˆ‘ä»¬æƒ³è¦è¿™ç§æ–¹æ³•ç¨å¾®æ˜ç¡®çš„åç§°ï¼Œæˆ‘ä»¬å¯ä»¥ç§°ä¹‹ä¸ºsave_to_clickhouse / 1ã€‚ï¼‰</p><p> Note that if we wanted to save some whitespace, this could also be written like:</p><p> è¯·æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ä¿å­˜ä¸€äº›ç©ºæ ¼ï¼Œè¿™ä¹Ÿå¯ä»¥å†™ç±»ä¼¼ï¼š</p><p> defp do_flush ( [ ] ) ,    nil  defp do_flush (events )  do Logger .info ( &#34;Flushing   #{length (events ) } events&#34; ) events  = Enum .map (events ,  &amp; (Map .from_struct ( &amp;1 )  |&gt; Map .delete ( :__meta__ ) ) ) Plausible .ClickhouseRepo .insert_all (Plausible .ClickhouseEvent , events )  end</p><p> defp do_flushï¼ˆ[]ï¼‰ï¼Œnil defp do_flushï¼ˆäº‹ä»¶ï¼‰do logger .infoï¼ˆï¼†ï¼ƒ34;åˆ·æ–°ï¼ƒ{length_ {lence}äº‹ä»¶ï¼†ï¼ƒ34;ï¼‰events = enum .mapï¼ˆäº‹ä»¶ï¼Œï¼†amp;ï¼ˆmap.from_structï¼ˆï¼‰ ï¼†amp; 1ï¼‰|ï¼†gt;åœ°å›¾ã€‚åœ°å›¾.deleteï¼ˆï¼š__ meta__ï¼‰ï¼‰ï¼‰åˆç†çš„.clickhoutersepo .insert_allï¼ˆåˆç†çš„.clickhouseEventï¼Œæ´»åŠ¨ï¼‰ç»“æŸ</p><p>   The  handle_call/3 callback is invoked when  GenServer.call/3 is called, to handle synchronous messages. Note that  GenServer.call/3 will block until a reply is received (unless the call times out or nodes are disconnected).</p><p>   è°ƒç”¨genserver.call/3æ—¶è°ƒç”¨handle_call / 3å›è°ƒï¼Œä»¥å¤„ç†åŒæ­¥æ¶ˆæ¯ã€‚è¯·æ³¨æ„ï¼ŒGenserver.Call/3å°†é˜»æ­¢ï¼Œç›´åˆ°æ”¶åˆ°å›å¤ï¼ˆé™¤éå‘¼å«è¶…æ—¶æˆ–èŠ‚ç‚¹æ–­å¼€è¿æ¥ï¼‰ã€‚</p><p>   true  def handle_call ( :flush , _from ,  % {  buffer ,   timer }  = _state )  do Process .cancel_timer (timer ) do_flush (buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :reply ,  nil ,  % {   [ ] ,   new_timer } }  end</p><p>   true def handle_callï¼ˆï¼šflushï¼Œ_fromï¼Œï¼…{bufferï¼Œtimer} = _stateï¼‰doè¿›ç¨‹.cancel_timerï¼ˆtimerï¼‰do_flushï¼ˆbufferï¼‰new_timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼štickï¼Œï¼‰{ï¼šå›å¤ï¼Œnilï¼Œï¼… {[]ï¼Œnew_timer}}ç»“æŸ</p><p> This code looks quite similar to the logic above, in the  handle_cast/2 callback. In this case, we&#39;re allow the  :flush event to be called manually, which takes whatever is currently in the state&#39;s  buffer and saves it to the database (in the  do_flush/1 method). Once again, the  buffer is reset to an empty list, and  timer is reset as well.</p><p> æ­¤ä»£ç çœ‹èµ·æ¥éå¸¸ç±»ä¼¼äºä¸Šé¢çš„é€»è¾‘ï¼Œåœ¨Handle_cast / 2å›è°ƒä¸­ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ï¼†ï¼ƒ39;é‡æ–°å…è®¸æ‰‹åŠ¨è°ƒç”¨ï¼šåˆ·æ–°äº‹ä»¶ï¼Œè¿™éœ€è¦å½“å‰å¤„äºçŠ¶æ€å’Œï¼ƒ39; sç¼“å†²åŒºå¹¶å°†å…¶ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆåœ¨do_flush / 1æ–¹æ³•ä¸­ï¼‰ã€‚å†æ¬¡ï¼Œç¼“å†²åŒºå°†é‡ç½®ä¸ºç©ºåˆ—è¡¨ï¼Œå¹¶ä¸”è¿˜å¤ä½è®¡æ—¶å™¨ã€‚</p><p>  The  handle_info/2 callback is invoked to handle all other messages (i.e. outside of those triggered by  GenServer.call/3 and  GenServer.cast/2). In our case, we use it to handle messages passed around internally within the GenServer itself.</p><p>  è°ƒç”¨handle_info / 2å›è°ƒä»¥å¤„ç†æ‰€æœ‰å…¶ä»–æ¶ˆæ¯ï¼ˆå³ç”±genserver.call/3å’Œgenserver.cest / 2è§¦å‘çš„é‚£äº›é‚®ä»¶ï¼‰ã€‚åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨å®ƒæ¥å¤„ç†å†…éƒ¨åœ¨Genserveræœ¬èº«å†…éƒ¨ä¼ é€’çš„æ¶ˆæ¯ã€‚ </p><p>   true  def handle_info ( :tick ,  % {  buffer }  = _state )  do do_flush (buffer ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   timer } }  end</p><p>true def handle_infoï¼ˆï¼štickï¼Œï¼…{buffer} = _stateï¼‰do do_flushï¼ˆbufferï¼‰timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼štickï¼Œï¼‰{ï¼šnoreclyï¼Œï¼…{[]ï¼Œtimer}}ç»“æŸ</p><p> The  :tick handles flushing the events in our  buffer at a regular interval. (In this case, every 5 seconds.)</p><p> ç­”æ¡ˆï¼šåˆ»åº¦å¤„ç†åœ¨å¸¸è§„é—´éš”ä¸­åˆ·æ–°æˆ‘ä»¬ç¼“å†²åŒºä¸­çš„äº‹ä»¶ã€‚ ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¯5ç§’é’Ÿã€‚ï¼‰</p><p>   This callback is invoked when the server is about to exit, and can handle any clean-up tasks.</p><p>   å½“æœåŠ¡å™¨å³å°†é€€å‡ºæ—¶ï¼Œå¯ä»¥è°ƒç”¨æ­¤å›è°ƒï¼Œå¹¶å¯ä»¥å¤„ç†ä»»ä½•æ¸…ç†ä»»åŠ¡ã€‚</p><p>  true  def terminate (_reason ,  % {  buffer }  = _state )  do Logger .info ( &#34;Flushing event buffer before shutdown...&#34; ) do_flush (buffer )  end</p><p>  true def terminateï¼ˆ_reasonï¼Œï¼…{buffer} = _stateï¼‰do logger .infoï¼ˆï¼†ï¼ƒ34;å…³é—­å‰åˆ·æ–°äº‹ä»¶ç¼“å†²åŒº...ï¼†ï¼ƒ34;ï¼‰do_flushï¼ˆç¼“å†²åŒºï¼‰ç»“æŸ</p><p> By trapping exists in the  init/1 callback above, we can ensure that before this GenServer process terminates, we flush anything that&#39;s left in our  buffer. Otherwise, we might end up in a situation where the process is terminated before some of the events in memory don&#39;t have a chance to get saved to the database, and would be lost.</p><p> é€šè¿‡é™·é˜±å­˜åœ¨äºä¸Šé¢çš„init / 1å›è°ƒä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿åœ¨æ­¤Genserverè¿‡ç¨‹ç»ˆæ­¢ä¹‹å‰ï¼Œæˆ‘ä»¬äº’åŒ–çš„ä»»ä½•ï¼†ï¼ƒ39;ç•™åœ¨æˆ‘ä»¬çš„ç¼“å†²åŒºä¸­ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šåœ¨å†…å­˜ä¸­çš„ä¸€äº›äº‹ä»¶ä¹‹å‰ç»ˆæ­¢è¿›ç¨‹çš„æƒ…å†µç»“æŸï¼Œå…¶ä¸­æœ‰æœºä¼šä¿å­˜åˆ°æ•°æ®åº“ï¼Œå¹¶ä¸”ä¼šä¸¢å¤±ã€‚</p><p>   def start_link (_opts )  do GenServer .start_link (__MODULE__ ,  [ ] ,   __MODULE__ )  end  def insert (event )  do GenServer .cast (__MODULE__ ,  { :insert , event } )  { :ok , event }  end  def flush ( )  do GenServer .call (__MODULE__ ,  :flush ,  :infinity )  :ok  end</p><p>   def start_linkï¼ˆ_optsï¼‰do genserver .start_linkï¼ˆ__module__ï¼Œ[]ï¼Œ__module__ï¼‰ç»“æŸdefæ’å…¥ï¼ˆäº‹ä»¶ï¼‰do genserver .castï¼ˆ__module__ï¼Œ{ï¼šæ’å…¥ï¼Œäº‹ä»¶}ï¼‰{ï¼šç¡®å®šï¼Œäº‹ä»¶}ç»“æŸdef flushï¼ˆï¼‰do genserver .callï¼ˆ__module__ï¼Œï¼šflushï¼Œï¼šæ— é™ï¼‰ï¼šokç»“æŸ</p><p>   This is probably the least intuitive of the three methods above â€” once we understand the code here, the rest should more or less fall into place.</p><p>   è¿™å¯èƒ½æ˜¯ä¸Šé¢ä¸‰ç§æ–¹æ³•çš„æœ€å°‘ç›´è§‚ - ä¸€æ—¦æˆ‘ä»¬ç†è§£è¿™é‡Œçš„ä»£ç ï¼Œå…¶ä½™çš„åº”è¯¥æˆ–å¤šæˆ–å°‘åœ°åˆ°ä½ã€‚ </p><p>  As you might guess, the  start_link/1 method is responsible for, well, starting the GenServer process. All it&#39;s doing is calling  start_link/3 on  GenServer itself, with a few strange arguments:</p><p>æ­£å¦‚æ‚¨å¯èƒ½çŒœåˆ°çš„é‚£æ ·ï¼Œstart_link / 1æ–¹æ³•æ˜¯è´Ÿè´£ï¼Œå—¯ï¼Œå¯åŠ¨Genserverè¿›ç¨‹ã€‚æ‰€æœ‰å®ƒï¼†ï¼ƒ39; sæ­£åœ¨è‡´ç”µgenserveræœ¬èº«ä¸Šè°ƒç”¨start_link / 3ï¼Œæœ‰ä¸€äº›å¥‡æ€ªçš„å‚æ•°ï¼š</p><p> __MODULE__, which is simply an alias for the module itself (in this case,  Plausible.Event.WriteBuffer). This first argument passes the  Plausible.Event.WriteBuffer in as the callback module, so that we can use the server callbacks we implemented above when certain messages are passed to the server process via  GenServer.call and  GenServer.cast. Note that calling  GenServer.start_link(Plausible.Event.WriteBuffer, [], name: Plausible.Event.WriteBuffer) would result in identical behavior. The main advantage of using  __MODULE__ is if we decide to rename the module, we only have to update it in one place!</p><p> __Module__ï¼Œè¿™åªæ˜¯æ¨¡å—æœ¬èº«çš„åˆ«åï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒPlausible.Event.WriteBufferï¼‰ã€‚æ­¤ç¬¬ä¸€å‚æ•°å°†Plausible.Event.Went.WriteBufferä½œä¸ºå›è°ƒæ¨¡å—ï¼Œä»¥ä¾¿åœ¨é€šè¿‡Genserver.Callå’ŒGenserver.Castä¼ æ’­åˆ°æœåŠ¡å™¨è¿›ç¨‹æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬åœ¨ä¸Šé¢å®ç°çš„æœåŠ¡å™¨å›è°ƒã€‚è¯·æ³¨æ„ï¼Œè°ƒç”¨genserver.start_linkï¼ˆplausible.event.writeBufferï¼Œ[]ï¼Œåç§°ï¼šPlausible.Event.WriteBufferï¼‰å°†å¯¼è‡´ç›¸åŒçš„è¡Œä¸ºã€‚ä½¿ç”¨__module__çš„ä¸»è¦ä¼˜ç‚¹æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å†³å®šé‡å‘½åæ¨¡å—ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ä¸€ä¸ªåœ°æ–¹æ›´æ–°å®ƒï¼</p><p> An empty list (i.e.  []) is passed in as the second argument. This is passed to our  init/1 callback as the default  buffer. We&#39;ll take a look at this in more detail below.</p><p> ç©ºåˆ—è¡¨ï¼ˆå³[]ï¼‰ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ä¼ é€’ã€‚è¿™å°†ä¼ é€’ç»™æˆ‘ä»¬çš„init / 1å›è°ƒä½œä¸ºé»˜è®¤ç¼“å†²åŒºã€‚æˆ‘ä»¬ï¼†ï¼ƒ39; llåœ¨ä¸‹é¢æ›´è¯¦ç»†åœ°çœ‹ä¸€ä¸‹è¿™ä¸€ç‚¹ã€‚</p><p> The last argument is a keyword list of options. Here, we assign the process a name with  name: __MODULE__ (which is the same as  name: Plausible.Event.WriteBuffer). This allows us to pass messages to the GenServer using the module name (i.e  GenServer.call(__MODULE__, message, timeout)/ GenServer.cast(__MODULE__, message)). Otherwise, after starting the GenServer, we would have to keep a reference to its process ID (or &#34;PID&#34;, which is returned in the  start_link/1 method), and then pass it in explicitly. (This is a very common practice.)</p><p> æœ€åä¸€ä¸ªå‚æ•°æ˜¯é€‰é¡¹çš„å…³é”®å­—åˆ—è¡¨ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸ºè¯¥è¿‡ç¨‹åˆ†é…åç§°ï¼š__module__ï¼ˆä¸åç§°ç›¸åŒï¼šplausible.event.writeBufferï¼‰ã€‚è¿™å…è®¸æˆ‘ä»¬ä½¿ç”¨æ¨¡å—åç§°ï¼ˆigenserver.callï¼ˆ__æ¨¡å—__ï¼Œæ¶ˆæ¯ï¼Œè¶…æ—¶ï¼‰/ genserver.cestï¼ˆ__æ¨¡å—__ï¼Œæ¶ˆæ¯ï¼‰ï¼‰ä¼ é€’ç»™Genserverçš„æ¶ˆæ¯ã€‚å¦åˆ™ï¼Œåœ¨å¯åŠ¨Genserverä¹‹åï¼Œæˆ‘ä»¬å¿…é¡»ç»§ç»­å‚è€ƒå…¶è¿›ç¨‹IDï¼ˆæˆ–ï¼†ï¼ƒ34; pidï¼†ï¼ƒ34;åœ¨start_link / 1æ–¹æ³•ä¸­è¿”å›çš„pidï¼†ï¼ƒ34ï¼‰ï¼Œç„¶åæ˜ç¡®ä¼ é€’å®ƒã€‚ ï¼ˆè¿™æ˜¯ä¸€ä¸ªéå¸¸å¸¸è§çš„åšæ³•ã€‚ï¼‰</p><p> (GenServer also has a method called simply  start/3, which takes the same arguments as  start_link/3 â€” the only difference is that  start_link/3 &#34;links&#34; the GenServer process to the current process, which is useful when we want to start the GenServer as part of a &#34;supervision tree&#34;. By starting a process with  start_link under a  Supervisor, it allows the application to monitor the process for any errors/crashes, and automatically restart the process if necessary.)</p><p> ï¼ˆGenserverè¿˜æœ‰ä¸€ç§ç§°ä¸ºsign start / 3çš„æ–¹æ³•ï¼Œå®ƒé‡‡ç”¨ä¸start_link / 3ç›¸åŒçš„å‚æ•° - å”¯ä¸€çš„åŒºåˆ«æ˜¯start_link / 3ï¼†ï¼ƒ34;é“¾æ¥ï¼†ï¼ƒ34; Genserverè¿›ç¨‹åˆ°å½“å‰è¿‡ç¨‹ï¼Œè¿™æ˜¯æœ‰ç”¨çš„æˆ‘ä»¬å¸Œæœ›å°†Genserverä½œä¸ºAï¼†ï¼ƒ34çš„ä¸€éƒ¨åˆ†å¯åŠ¨;é€šè¿‡åœ¨ä¸»ç®¡ä¸‹ä½¿ç”¨Start_Linkå¼€å§‹ä¸€ä¸ªè¿›ç¨‹ï¼Œå®ƒå…è®¸åº”ç”¨ç¨‹åºç›‘è§†ä»»ä½•é”™è¯¯/å´©æºƒçš„è¿‡ç¨‹ï¼Œå¹¶è‡ªåŠ¨é‡æ–°å¯åŠ¨æ­¤è¿‡ç¨‹å¿…è¦çš„ã€‚ï¼‰</p><p>   defmodule Plausible .Application  do  use Application  def start (_type , _args )  do children  =  [  # ... Plausible .Event .WriteBuffer ,  # ...  ] opts  =  [   :one_for_one ,   Plausible .Supervisor ]  # ... Supervisor .start_link (children , opts )  end  # ... end</p><p>   defmoduleåˆç†çš„ã€‚åº”ç”¨ç¨‹åºdef startï¼ˆ_typeï¼Œ_argsï¼‰do shopts = [ï¼ƒ...åˆç†çš„..writebufferï¼Œï¼ƒ...] opts = [ï¼šone_for_oneï¼Œplausible .supervisor]ï¼ƒ... supervisor .start_link ï¼ˆå„¿ç«¥ï¼Œé€‰æ‹©ï¼‰ç»“æŸï¼ƒ...ç»“æŸ</p><p> GenServer&#39;s  start_link/3 method is what enables us to start the process under this  Supervisor. (When we include  Plausible.Event.WriteBuffer amongst the children of the supervisor, its  start_link/3 method is invoked automatically when  Supervisor.start_link/2 is called.)</p><p> Genserverï¼†ï¼ƒ39; s start_link / 3æ–¹æ³•æ˜¯è®©æˆ‘ä»¬åœ¨æ­¤ä¸»ç®¡ä¸‹å¯åŠ¨è¿‡ç¨‹ã€‚ ï¼ˆå½“æˆ‘ä»¬åŒ…æ‹¬Plausible.Event.Went.writeBufferåœ¨ä¸»ç®¡çš„å­å¥³ä¸­ï¼Œå½“è°ƒç”¨Supervisor.Start_Link / 2æ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨å…¶Start_Link / 3æ–¹æ³•ã€‚ï¼‰ </p><p> Hopefully at this point, we have a pretty good understanding of what&#39;s going on in  Plausible.Event.WriteBuffer.start_link/1! Now all that&#39;s left to cover are the two methods exposed in our client API:  insert/1 and  flush/0</p><p>å¸Œæœ›åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬éå¸¸äº†è§£åœ¨Plausible.event.writeBuffer.start_link / 1ä¸­è¿›è¡Œçš„ï¼†ï¼ƒ39; start.start_link / 1ï¼ç°åœ¨ï¼Œå·¦ç›–ä¸Šçš„æ‰€æœ‰è¿™äº›éƒ½æ˜¯æˆ‘ä»¬çš„å®¢æˆ·ç«¯APIä¸­æš´éœ²çš„ä¸¤ç§æ–¹æ³•ï¼šæ’å…¥/ 1å’ŒFlush / 0</p><p>    Here we see that all this is doing is taking an  event and sending an asynchronous request to our GenServer via the  cast/2 method. (Since we&#39;re using  cast/2 here instead of  call/3, we know that this is a non-blocking call which will return immediately, regardless of what happens in the callback.)</p><p>    åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬çœ‹åˆ°æ‰€æœ‰è¿™äº›éƒ½åœ¨åšä¸€ä¸ªäº‹ä»¶å¹¶é€šè¿‡æ¼”å‘˜/ 2æ–¹æ³•å‘æˆ‘ä»¬çš„Genserverå‘é€å¼‚æ­¥è¯·æ±‚ã€‚ ï¼ˆå› ä¸ºæˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨CAST / 2è€Œä¸æ˜¯å‘¼å«/ 3ï¼Œæˆ‘ä»¬çŸ¥é“è¿™æ˜¯ä¸€ä¸ªéé˜»å¡å‘¼å«ï¼Œå®ƒå°†ç«‹å³è¿”å›ï¼Œæ— è®ºåœ¨å›è°ƒä¸­å‘ç”Ÿä»€ä¹ˆã€‚ï¼‰</p><p> The first argument of  GenServer.cast/2 takes a process ID (i.e. PID) or a registered server name. In this case, we set the name to  __MODULE__ in the 3rd argument of our  GenServer.start_link/3 above, which is why we&#39;re using that here. (This is a very common practice with GenServers.)</p><p> Genserver.Cast / 2çš„ç¬¬ä¸€ä¸ªå‚æ•°é‡‡ç”¨è¿›ç¨‹IDï¼ˆå³PIDï¼‰æˆ–å·²æ³¨å†Œçš„æœåŠ¡å™¨åç§°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†åç§°è®¾ç½®ä¸º__module__åœ¨æˆ‘ä»¬çš„genserver.start_link / 3çš„ç¬¬3ä¸ªå‚æ•°ä¸­ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨å®ƒã€‚ ï¼ˆè¿™æ˜¯Genserversçš„ä¸€ç§éå¸¸å¸¸è§çš„åšæ³•ã€‚ï¼‰</p><p> The second argument is the &#34;message&#34; we want to send, often in the form of a tuple or an atom. Here we&#39;re sending  {:insert, event}, which will be handled in the  handle_cast({:insert, event}, ...) callback discussed above.</p><p> ç¬¬äºŒä¸ªè®ºç‚¹æ˜¯ï¼†ï¼ƒ34;æ¶ˆæ¯ï¼†ï¼ƒ34;æˆ‘ä»¬æƒ³å¸¸å¸¸ä»¥å…ƒåº¦æˆ–åŸå­çš„å½¢å¼å‘é€ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å‘é€{ï¼šæ’å…¥ï¼Œäº‹ä»¶}ï¼Œå®ƒå°†åœ¨ä¸Šé¢è®¨è®ºçš„Handle_castï¼ˆ{ï¼šæ’å…¥ï¼Œäº‹ä»¶}ï¼Œ...ï¼‰å›è°ƒä¸­å¤„ç†ã€‚</p><p> Since we don&#39;t wait for a return value, the  insert/1 method just returns an echo of the event that was passed in, in the form of  {:ok, event}.</p><p> ç”±äºæˆ‘ä»¬ä¸ç­‰å¾…è¿”å›å€¼ï¼Œå› æ­¤æ’å…¥/ 1æ–¹æ³•åˆšåˆšè¿”å›ä¼ é€’çš„äº‹ä»¶çš„å›å£°ï¼Œä»¥{ï¼šç¡®å®šï¼Œäº‹ä»¶}çš„å½¢å¼ã€‚</p><p>     GenServer.call/3, unlike  GenServer.cast/2, blocks the process until the callback completes. So if the  :flush event ends up taking 10 seconds to execute, the  flush/0 method will not return  :ok until 10 seconds have passed.</p><p>     Genserver.Call/3ï¼Œä¸Genserver.Cast / 2ä¸åŒï¼Œé˜»æ­¢è¯¥è¿‡ç¨‹ç›´åˆ°å›è°ƒå®Œæˆã€‚å› æ­¤ï¼Œå¦‚æœï¼šåˆ·æ–°äº‹ä»¶æœ€ç»ˆéœ€è¦10ç§’é’Ÿæ‰èƒ½æ‰§è¡Œï¼Œåˆ™åˆ·æ–°/ 0æ–¹æ³•å°†ä¸ä¼šè¿”å›ï¼šOKç›´åˆ°10ç§’è¿‡å»ã€‚</p><p> call/3 takes a third argument, which we see here is  :infinity. This represents the maximum amount of time we allow the method to take before a timeout error occurs. By default, this is set to  5_000, or 5 seconds. By passing in  :infinity, we&#39;re allowing the process to take as long as it needs to complete.</p><p> å‘¼å«/ 3é‡‡å–ç¬¬ä¸‰ä¸ªè®ºç‚¹ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œçœ‹åˆ°äº†ï¼šæ— é™ã€‚è¿™ä»£è¡¨äº†åœ¨å‘ç”Ÿè¶…æ—¶é”™è¯¯ä¹‹å‰å…è®¸è¯¥æ–¹æ³•é‡‡å–çš„æœ€å¤§æ—¶é—´ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™è®¾ç½®ä¸º5_000æˆ–5ç§’ã€‚é€šè¿‡è¿›å…¥ï¼šæ— é™ï¼Œæˆ‘ä»¬ï¼†ï¼ƒ39;åªè¦éœ€è¦å®Œæˆï¼Œå°±å…è®¸è¿‡ç¨‹éœ€è¦ã€‚ </p><p>  Let&#39;s take one last look at the full module definition, to double check that we understand everything that&#39;s going on. I&#39;ve added some comments in the code to help out a bit. ğŸ˜‰</p><p>è®©ï¼†ï¼ƒ39;æœ€åä¸€çœ‹ä¸€ä¸‹å®Œæ•´çš„æ¨¡å—å®šä¹‰ï¼Œè¦ä»”ç»†æ£€æŸ¥æˆ‘ä»¬äº†è§£çš„ä¸€åˆ‡ï¼†ï¼ƒ39;æˆ‘åœ¨ä»£ç ä¸­æ·»åŠ äº†ä¸€äº›è¯„è®ºæ¥å¸®åŠ©è§£å†³ä¸€ç‚¹ã€‚ ğŸ˜‰</p><p> defmodule Plausible .Event .WriteBuffer  do  use GenServer  require Logger  # Flush/save every 5 seconds    5_000  # Allow a maximum of 10,000 events in our buffer list    10_000  ############################################################################  # Client APIs  ############################################################################    &#34;&#34;&#34; Starts a linked GenServer process, passing in the current module (`__MODULE__` == `Plausible.Event.WriteBuffer`) as both the callback module and the alias/name of the server process for future reference. We also pass in an empty list (`[]`) as the initial value of the internal state&#39;s `buffer` (handled in the `init/1` callback below). &#34;&#34;&#34;  def start_link (_opts )  do GenServer .start_link (__MODULE__ ,  [ ] ,   __MODULE__ )  end    &#34;&#34;&#34; Sends an `:insert` message asynchronously to the current module&#39;s GenServer process, which adds the provided `event` to the internal state&#39;s `buffer`. &#34;&#34;&#34;  def insert (event )  do GenServer .cast (__MODULE__ ,  { :insert , event } )  { :ok , event }  end    &#34;&#34;&#34; Sends a (synchronous) `:flush` message to the current module&#39;s GenServer process, which manually &#34;flushes&#34; all events in the internal state&#39;s `buffer` to the database. Sets the `timeout` option to `:infinity`, allowing this call to take as long as it needs to complete. &#34;&#34;&#34;  def flush ( )  do GenServer .call (__MODULE__ ,  :flush ,  :infinity )  :ok  end  ############################################################################  # Server callbacks  ############################################################################    &#34;&#34;&#34; Sets up the initial state of the GenServer, and traps exits so that we can gracefully handle a process termination in our `terminate/2` callback below. &#34;&#34;&#34;    true  def init (buffer )  do Process .flag ( :trap_exit ,  true ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :ok ,  % {  buffer ,   timer } }  end    &#34;&#34;&#34; Callback that handles `:insert` messages passed to `GenServer.cast/2`. In this callback, we add the new event to the internal state&#39;s `buffer`. If we reach the maximum capacity of the `buffer`, we &#34;flush&#34; it to the database and reset our state. Otherwise, we simply update the internal state with the updated `buffer`. &#34;&#34;&#34;    true  def handle_cast ( { :insert , event } ,  % {  buffer ,   timer }  = _state )  do new_buffer  =  [event  | buffer ]  if length (new_buffer )  &gt;=    do Logger .info ( &#34;Buffer full, flushing to disk&#34; ) Process .cancel_timer (timer ) do_flush (new_buffer ) new_timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   new_timer } }  else  { :noreply ,  % {state  |   new_buffer } }  end  end    &#34;&#34;&#34; Callback that handles internal `:tick` messages. In this callback, we automatically flush whatever is in the `buffer` every 5 seconds (i.e. `@flush_interval_ms`). &#34;&#34;&#34;    true  def handle_info ( :tick ,  % {  buffer }  = _state )  do do_flush (buffer ) timer  = Process .send_after (self ( ) ,  :tick ,   )  { :noreply ,  % {   [ ] ,   timer } }  end    &#34;&#34;&#34; Callback that handles `:flush` messages passed to `GenServer.call/3`. In this callback, we handle manually flushing whatever is currently in the internal state&#39;s `buffer` to the database. &#34;&#34;&#34;    true  def handle_call ( :flush , _from ,  % {  buffer ,   timer }  = _state )  do Process .cancel_timer (timer ) do_flush (buffer ) new_timer  = Process .send_after (self </p><p> DefModuleåˆç†çš„..Event .writeBufferç¡®å®ä½¿ç”¨Genserverè¦æ±‚è®°å½•è®°å½•å™¨ï¼ƒæ¯5ç§’5ç§’5ç§’5_000ï¼ƒå…è®¸åœ¨æˆ‘ä»¬çš„ç¼“å†²åŒºåˆ—è¡¨ä¸­æœ€å¤š10,000ä¸ªäº‹ä»¶10_000 ################### ######################################## ########å®¢æˆ·ç«¯API ################################## ###################################ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;å¯åŠ¨é“¾æ¥çš„Genserverè¿›ç¨‹ï¼Œä¼ é€’åœ¨å½“å‰æ¨¡å—ï¼ˆ`__module__` =='plausible.fent.writebuuster`ï¼‰ä½œä¸ºå›è°ƒæ¨¡å—å’ŒæœåŠ¡å™¨è¿›ç¨‹çš„åˆ«å/åç§°ï¼Œä»¥ä¾¿å°†æ¥å‚è€ƒã€‚æˆ‘ä»¬è¿˜é€šè¿‡ç©ºåˆ—è¡¨ï¼ˆ`[]`ï¼‰ä½œä¸ºå†…éƒ¨çŠ¶æ€çš„åˆå§‹å€¼ï¼†ï¼ƒ39; s`ç¼“å†²åŒºçš„åˆå§‹å€¼ï¼ˆåœ¨ä¸‹é¢çš„`init / 1`å›è°ƒä¸­å¤„ç†ï¼‰ã€‚ ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; def start_linkï¼ˆ_optsï¼‰do genserver .start_linkï¼ˆ__module__ï¼Œ[]ï¼Œ__module__ï¼‰ç»“æŸï¼†ï¼ƒ34;ï¼†ï¼ƒ34;å‘é€åˆ°å½“å‰æ¨¡å—çš„â€œï¼šINSERT`â€æ¶ˆæ¯ï¼Œå¹¶å°†æ‰€æä¾›çš„â€œäº‹ä»¶â€æ·»åŠ åˆ°å†…éƒ¨çŠ¶æ€å’Œï¼ƒ39; Sâ€œç¼“å†²åŒºâ€çš„Genserverè¿›ç¨‹ä¸­ã€‚ ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; defæ’å…¥ï¼ˆäº‹ä»¶ï¼‰do genserver .castï¼ˆ__module__ï¼Œ{ï¼šæ’å…¥ï¼Œäº‹ä»¶}ï¼‰{ï¼šå¥½çš„ï¼Œäº‹ä»¶} Endï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;å‘é€ï¼ˆåŒæ­¥ï¼‰`ï¼šflush`ï¼šæ‰‹åŠ¨ï¼†ï¼ƒ39; sçš„genserverè¿‡ç¨‹ï¼Œå®ƒæ‰‹åŠ¨ï¼†ï¼ƒ34; flushesï¼†ï¼ƒ34;å†…éƒ¨çŠ¶æ€çš„æ‰€æœ‰äº‹ä»¶ï¼†ï¼ƒ39; s`ç¼“å†²åŒºobåˆ°æ•°æ®åº“ã€‚å°†`: timeout`é€‰é¡¹è®¾ç½®ä¸º`ï¼šInfinity`ï¼Œåªè¦éœ€è¦å®Œæˆæ­¤è°ƒç”¨å³å¯ã€‚ ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; def flushï¼ˆï¼‰do genserver .callï¼ˆ__module__ï¼Œï¼šflushï¼Œï¼šæ— ç©·å¤§ï¼‰ï¼šç¡®å®š############################ #######################################æœåŠ¡å™¨å›è°ƒï¼ƒ ######################################## #########################ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;è®¾ç½®Genserverçš„åˆå§‹çŠ¶æ€ï¼Œé™·é˜±é€€å‡ºï¼Œä»¥ä¾¿åœ¨ä¸‹é¢çš„â€œç»ˆæ­¢/ 2â€å›è°ƒä¸­ä¼˜é›…åœ°å¤„ç†æµç¨‹ç»ˆæ­¢ã€‚ ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; true def initï¼ˆç¼“å†²åŒºï¼‰doè¿›ç¨‹.flagï¼ˆï¼štrap_exitï¼Œtrueï¼‰timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼štickï¼Œï¼‰{ï¼šç¡®å®šï¼Œï¼…{bufferï¼Œtimer}} Endï¼†ï¼ƒ34;ï¼†ï¼ƒ34; ï¼†ï¼ƒ34;å¤„ç†`ï¼šæ’å…¥çš„å‘¼å«ä¼ æ’­åˆ°`genserver.cest / 2`ã€‚åœ¨æ­¤å›è°ƒä¸­ï¼Œæˆ‘ä»¬å°†æ–°äº‹ä»¶æ·»åŠ åˆ°å†…éƒ¨çŠ¶æ€å’Œï¼ƒ39; s`ç¼“å†²åŒºã€‚å¦‚æœæˆ‘ä»¬è¾¾åˆ°â€œç¼“å†²åŒºâ€çš„æœ€å¤§å®¹é‡ï¼Œæˆ‘ä»¬ï¼†ï¼ƒ34; Flushï¼†ï¼ƒ34;å®ƒåˆ°æ•°æ®åº“å¹¶é‡ç½®æˆ‘ä»¬çš„å·ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬åªéœ€ä½¿ç”¨æ›´æ–°çš„`Buffer`æ›´æ–°å†…éƒ¨çŠ¶æ€ã€‚ ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; True Def Handle_castï¼ˆ{ï¼šæ’å…¥ï¼Œäº‹ä»¶}ï¼Œï¼…{bufferï¼Œtimer} = _stateï¼‰do new_buffer = [äº‹ä»¶|ç¼“å†²åŒº]å¦‚æœé•¿åº¦ï¼ˆnew_bufferï¼‰ï¼†gt; = do logger .infoï¼ˆï¼†ï¼ƒ34; buffer fullï¼Œåˆ·æ–°åˆ°ç£ç›˜ï¼†ï¼ƒ34;ï¼‰è¿›ç¨‹.cancel_timerï¼ˆtimerï¼‰do_flushï¼ˆnew_bufferï¼‰new_timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼šå‹¾é€‰ï¼Œï¼‰{ï¼šnoreplyï¼Œï¼…{[]ï¼Œnew_timer}} else {ï¼šnoreplyï¼Œï¼…{state | new_buffer}}ç»“æŸï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;å¤„ç†å†…éƒ¨`ï¼šå‹¾å·çš„å›è°ƒã€‚åœ¨æ­¤å›è°ƒä¸­ï¼Œæˆ‘ä»¬æ¯5ç§’ï¼ˆå³'@ flush_interval_ms`ï¼‰è‡ªåŠ¨äº’åŒ–`ç¼“å†²åŒºå¡«å……ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; true def handle_infoï¼ˆï¼štickï¼Œï¼…{buffer} = _stateï¼‰do do_flushï¼ˆbufferï¼‰timer = process .send_afterï¼ˆselfï¼ˆï¼‰ï¼Œï¼štickï¼Œï¼‰{ï¼šnoreplyï¼Œï¼…{[]ï¼Œtimer}}æœ«ç«¯ï¼†ï¼ƒ34; ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;å¤„ç†`ï¼šåˆ·æ–°çš„æ¶ˆæ¯ä¼ é€’ç»™`genserver.call / 3`ã€‚åœ¨æ­¤å›è°ƒä¸­ï¼Œæˆ‘ä»¬å¤„ç†ç›®å‰å†…éƒ¨çŠ¶æ€çš„ä»»ä½•å†…å®¹äº’åŒ–çš„ä¸œè¥¿ï¼†ï¼ƒ39; s`ç¼“å†²åŒºob theæ•°æ®åº“ã€‚ ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; true def handle_callï¼ˆï¼šflushï¼Œ_fromï¼Œï¼…{bufferï¼Œtimer} = _stateï¼‰do process .cancel_timerï¼ˆtimerï¼‰do_flushï¼ˆbufferï¼‰new_timer = process .send_afterï¼ˆself</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://papercups.io/blog/genserver">https://papercups.io/blog/genserver</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/genserver/">#genserver</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>