<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>GCCé“é”ˆæœˆæŠ¥ï¼Œ2022å¹´2æœˆGCC Rust Monthly Report, February 2022</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">GCC Rust Monthly Report, February 2022<br/>GCCé“é”ˆæœˆæŠ¥ï¼Œ2022å¹´2æœˆ</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-26 08:55:37</div><div class="page_narrow text-break page_content"><p>Thanks again to  Open Source Security, inc and  Embecosm for their ongoing support for this project.</p><p>å†æ¬¡æ„Ÿè°¢å¼€æºå®‰å…¨å…¬å¸å’ŒEmbecosmå¯¹è¯¥é¡¹ç›®çš„æŒç»­æ”¯æŒã€‚</p><p>  February was a big month for GCC Rust; our previous Google Summer of Code student Arthur Cohen joins us in Embecosm, Germany, working on the compiler full time. With the additional resource, we can split up work and delegate tasks allowing multiple streams of complex work to take place, which frees Philip up to work on Sliceâ€™s and bugs in the type system.</p><p>2æœˆå¯¹GCCæ¥è¯´æ˜¯ä¸€ä¸ªé‡è¦çš„æœˆä»½ï¼›æˆ‘ä»¬ä¹‹å‰çš„è°·æ­Œä»£ç æš‘æœŸå­¦ç”Ÿé˜¿ç‘ŸÂ·ç§‘æ©ï¼ˆArthur Cohenï¼‰åœ¨å¾·å›½çš„EmbecosmåŠ å…¥æˆ‘ä»¬ï¼Œå…¨èŒä»äº‹ç¼–è¯‘å™¨çš„å·¥ä½œã€‚æœ‰äº†é¢å¤–çš„èµ„æºï¼Œæˆ‘ä»¬å¯ä»¥æ‹†åˆ†å·¥ä½œå¹¶å§”æ´¾ä»»åŠ¡ï¼Œä»è€Œå…è®¸è¿›è¡Œå¤šä¸ªå¤æ‚çš„å·¥ä½œæµï¼Œè¿™å°†ä½¿Philipèƒ½å¤Ÿå¤„ç†ç±»å‹ç³»ç»Ÿä¸­çš„åˆ‡ç‰‡å’Œbugã€‚</p><p> Concerning our macro expansion milestone, we have the building blocks in place and support most declarative macros though there are some quirks and bugs to work through still. The remaining time of this milestone will be spent on setting up the builtin macros and fixing bugs.</p><p>å…³äºæˆ‘ä»¬çš„å®æ‰©å±•é‡Œç¨‹ç¢‘ï¼Œæˆ‘ä»¬å·²ç»å‡†å¤‡å¥½äº†æ„å»ºå—ï¼Œå¹¶ä¸”æ”¯æŒå¤§å¤šæ•°å£°æ˜æ€§å®ï¼Œå°½ç®¡ä»ç„¶æœ‰ä¸€äº›æ€ªç™–å’Œé”™è¯¯éœ€è¦è§£å†³ã€‚è¿™ä¸ªé‡Œç¨‹ç¢‘çš„å‰©ä½™æ—¶é—´å°†ç”¨äºè®¾ç½®å†…ç½®å®å’Œä¿®å¤bugã€‚</p><p> Other than macros, there has been a focus on code cleanup and bug fixing in February, which has been fruitful.</p><p>é™¤äº†å®ä¹‹å¤–ï¼Œ2æœˆä»½çš„å·¥ä½œé‡ç‚¹æ˜¯ä»£ç æ¸…ç†å’Œbugä¿®å¤ï¼Œè¿™æ˜¯å¯Œæœ‰æˆæ•ˆçš„ã€‚</p><p>  Itâ€™s time for our next community call, feel free to join in! ğŸ™‚</p><p>æ˜¯æˆ‘ä»¬ä¸‹ä¸€ä¸ªç¤¾åŒºç”µè¯çš„æ—¶å€™äº†ï¼Œæ¬¢è¿åŠ å…¥ï¼ğŸ™‚</p><p>   Add Support for index and Range lang items and boiler plate for Slice typechecking  PR974</p><p>æ·»åŠ å¯¹ç´¢å¼•å’ŒèŒƒå›´é¡¹ç›®çš„æ”¯æŒï¼Œä»¥åŠç”¨äºåˆ‡ç‰‡ç±»å‹æ£€æŸ¥PR974çš„é”…ç‚‰æ¿</p><p>                 We have improved our canonical-path tracking so that we can build up paths for the legacy mangling scheme. So for example impl blocks nested under modules are given a prefix of impl in their path.</p><p>æˆ‘ä»¬å·²ç»æ”¹è¿›äº†æˆ‘ä»¬çš„è§„èŒƒè·¯å¾„è·Ÿè¸ªï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ä¸ºé—ç•™çš„æŸåæ–¹æ¡ˆå»ºç«‹è·¯å¾„ã€‚ä¾‹å¦‚ï¼ŒåµŒå¥—åœ¨æ¨¡å—ä¸‹çš„implå—åœ¨å…¶è·¯å¾„ä¸­è¢«èµ‹äºˆä¸€ä¸ªimplå‰ç¼€ã€‚</p><p> struct Foo(i32);mod A { impl Foo { fn test(&amp;self) -&gt; i32 { self.0 } }}fn test() { let a = Foo(123); let b:i32 = a.test();}</p><p>struct Fooï¼ˆi32ï¼‰ï¼›mod A{impl Foo{fn testï¼ˆ&ampï¼›selfï¼‰->i32{self.0}}}fn testï¼ˆï¼‰{let A=Fooï¼ˆ123ï¼‰ï¼›let b:i32=A.testï¼ˆï¼‰ï¼›}</p><p> As you can see we have the crate-name of example -&gt; structure A -&gt; impl block for example::A -&gt; function name test.</p><p>å¦‚æ‚¨æ‰€è§ï¼Œæˆ‘ä»¬æœ‰ç¤ºä¾‹çš„æ¿æ¡ç®±åç§°-&gtï¼›ç»“æ„A-&gtï¼›implå—ä¾‹å¦‚ï¼šï¼šA-&gtï¼›å‡½æ•°åæµ‹è¯•ã€‚</p><p> i32 example::A::&lt;impl example::Foo&gt;::test (const struct example::Foo &amp; const self){ i32 D.85; D.85 = self-&gt;0; return D.85;}void example::test (){ const struct example::Foo a; const i32 b; try { a.0 = 123; b = example::A::&lt;impl example::Foo&gt;::test (&amp;a); } finally { a = {CLOBBER}; }}</p><p>i32ç¤ºä¾‹ï¼šï¼šA:ï¼š&ltï¼›implç¤ºä¾‹ï¼šï¼šFoo&gtï¼›ï¼šï¼štestï¼ˆconst struct example:ï¼šFoo&ampï¼›const selfï¼‰{i32 D.85ï¼›D.85=self-&gtï¼›0ï¼›è¿”å›D.85ï¼›}void example:ï¼štestï¼ˆï¼‰{const struct example:ï¼šFoo aï¼›const i32 bï¼›try{a.0=123ï¼›b=example:ï¼ša:&ltï¼›impl example:ï¼šFoo&gtï¼›ï¼šï¼štestï¼ˆ&ampï¼›aï¼‰ï¼›}æœ€å{a={CLOBBER}ï¼›}</p><p>   We added support for any, all and not predicates on cfg expansions so in this example this ensures that both A and B are specified for the all predicate.</p><p>æˆ‘ä»¬åœ¨cfgæ‰©å±•ä¸­æ·»åŠ äº†å¯¹anyã€allå’Œnotè°“è¯çš„æ”¯æŒï¼Œå› æ­¤åœ¨æœ¬ä¾‹ä¸­ï¼Œè¿™ç¡®ä¿äº†ä¸ºallè°“è¯æŒ‡å®šAå’ŒBã€‚</p><p> struct Foo;impl Foo { #[cfg(all(A, B))] fn test(&amp;self) {}}fn main() { let a = Foo; a.test();}</p><p>struct Fooï¼›impl Foo{#[cfgï¼ˆallï¼ˆAï¼ŒBï¼‰ï¼‰]fn testï¼ˆ&ampï¼›selfï¼‰{}fn mainï¼ˆï¼‰{let A=Fooï¼›A.testï¼ˆï¼‰}</p><p>   Rust allows us to specify key-value pairs for config expansion this is mostly associated with host/os/cpu options such as os = â€œlinuxâ€ for example but here is an example below you can try in compiler explorer.</p><p>Rustå…è®¸æˆ‘ä»¬ä¸ºé…ç½®æ‰©å±•æŒ‡å®šé”®å€¼å¯¹ï¼Œè¿™ä¸»è¦ä¸ä¸»æœº/os/cpué€‰é¡¹æœ‰å…³ï¼Œä¾‹å¦‚os=â€œlinuxâ€ï¼Œä½†ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œæ‚¨å¯ä»¥åœ¨ç¼–è¯‘å™¨èµ„æºç®¡ç†å™¨ä¸­å°è¯•ã€‚</p><p> struct Foo;impl Foo { #[cfg(A = &#34;B&#34;)] fn test(&amp;self) {}}fn main() { let a = Foo; a.test();}</p><p>struct Fooï¼›impl Foo{#[cfgï¼ˆA=&#34ï¼›B&#34ï¼›ï¼‰]fn testï¼ˆ&ampï¼›selfï¼‰{}fn mainï¼ˆï¼‰{let a=Fooï¼›a.testï¼ˆï¼‰ï¼›}</p><p>     Inline without any option is analogous to C style inline keyword giving a hint to the compiler that this function is a good candidate for inlining. Inline always can be acheived with GCCâ€™s inline always attribute:  https://gcc.gnu.org/onlinedocs/gcc/Inline.html. Finally never we can mark functions as DECL_UNINLINEABLE. The one difference is that inline optimizations require optimizations to be enabled. So when compiling at -O0 no inlining will occur, any level greater than this, the inline pass will be enforced.</p><p>ä¸å¸¦ä»»ä½•é€‰é¡¹çš„Inlineç±»ä¼¼äºCé£æ ¼çš„Inlineå…³é”®å­—ï¼Œå®ƒå‘ç¼–è¯‘å™¨æç¤ºæ­¤å‡½æ•°æ˜¯å†…è”çš„è‰¯å¥½å€™é€‰å‡½æ•°ã€‚Inline alwayså¯ä»¥é€šè¿‡GCCçš„Inline alwayså±æ€§å®ç°ï¼šhttps://gcc.gnu.org/onlinedocs/gcc/Inline.html.æœ€åï¼Œæˆ‘ä»¬æ°¸è¿œä¸èƒ½å°†å‡½æ•°æ ‡è®°ä¸ºDECL_ä¸å¯çº¿æ€§ã€‚ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œå†…è”ä¼˜åŒ–éœ€è¦å¯ç”¨ä¼˜åŒ–ã€‚å› æ­¤ï¼Œå½“åœ¨-O0ç¼–è¯‘æ—¶ï¼Œä¸ä¼šå‘ç”Ÿå†…è”ï¼Œä»»ä½•çº§åˆ«å¤§äºæ­¤çº§åˆ«ï¼Œéƒ½å°†å¼ºåˆ¶æ‰§è¡Œå†…è”ä¼ é€’ã€‚</p><p>       Work on method resolution has continued steadily and we now support the deref_mut lang item so that for methods that require a &amp;mut self reference we try to lookup any relevant deref_mut lang item to get the indirection required from the receiver.</p><p>æ–¹æ³•è§£ææ–¹é¢çš„å·¥ä½œä¸€ç›´åœ¨ç¨³æ­¥è¿›è¡Œï¼Œæˆ‘ä»¬ç°åœ¨æ”¯æŒderef_mut langé¡¹ç›®ï¼Œå› æ­¤å¯¹äºéœ€è¦a&ampï¼›æˆ‘ä»¬å°è¯•ä»ä»»ä½•ç›¸å…³çš„æ¥æ”¶è€…å¤„è·å–æ‰€éœ€çš„é—´æ¥å¼•ç”¨ã€‚</p><p> extern &#34;C&#34; { fn printf(s: *const i8, ...);} #[lang = &#34;deref&#34;]pub trait Deref { type Target; fn deref(&amp;self) -&gt; &amp;Self::Target;}#[lang = &#34;deref_mut&#34;]pub trait DerefMut: Deref { fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;}impl&lt;T&gt; Deref for &amp;T { type Target = T; fn deref(&amp;self) -&gt; &amp;T { *self }}impl&lt;T&gt; Deref for &amp;mut T { type Target = T; fn deref(&amp;self) -&gt; &amp;T { *self }}pub struct Bar(i32); impl Bar { pub fn foobar(&amp;mut self) -&gt; i32 { self.0 }}pub struct Foo&lt;T&gt;(T);impl&lt;T&gt; Deref for Foo&lt;T&gt; { type Target = T; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.0 }}impl&lt;T&gt; DerefMut for Foo&lt;T&gt; { fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target { unsafe { let a = &#34;mut_deref\n\0&#34;; let b = a as *const str; let c = b as *const i8; printf(c); } &amp;mut self.0 }}pub fn main() -&gt; i32 { let bar = Bar(123); let mut foo: Foo&lt;Bar&gt; = Foo(bar); let foobar = foo.foobar(); foobar - 123}</p><p>å¤–éƒ¨äººå‘˜&#34ï¼›C&#34ï¼›{fn printfï¼ˆs:*const i8ï¼Œâ€¦ï¼‰ï¼›}#[lang=&#34ï¼›deref&#34ï¼›]pub trait Deref{type Targetï¼›fn Derefï¼ˆ&ampï¼›selfï¼‰->self:ï¼šTargetï¼›}#[lang=&#34ï¼›deref#mut&#34ï¼›]pub trait DerefMut:Deref{fn Deref_mutï¼ˆ&ampï¼›mut selfï¼‰&gtï¼›&ampï¼›mut self:ï¼šTargetï¼›}impl&ltï¼›T&gtï¼›å¾·é›·å¤«ï¼›T{type Target=Tï¼›fn-derefï¼ˆ&ampï¼›selfï¼‰&gtï¼›&ampï¼›T{*self}impl&ltï¼›T&gtï¼›å¾·é›·å¤«ï¼›mut T{type Target=Tï¼›fn derefï¼ˆ&ampï¼›selfï¼‰&gtï¼›&ampï¼›T{*self}å‘å¸ƒç»“æ„æ¡ï¼ˆi32ï¼‰ï¼›impl Bar{pub fn foobarï¼ˆ&ampï¼›mut selfï¼‰->i32{self.0}pub struct Foo&ltï¼›T&gtï¼›ï¼ˆTï¼‰ )ï¼›impl&ltï¼›T&gtï¼›ä¸ºFoo&ltï¼›T&gtï¼›{type Target=Tï¼›fn derefï¼ˆ&ampï¼›selfï¼‰&gtï¼›&ampï¼›self:ï¼šTarget{&ampï¼›self.0}}impl&ltï¼›T&gtï¼›å¯¹Foo&ltï¼›T&gtï¼›{fn deref_mutï¼ˆ&ampï¼›mut selfï¼‰&gtï¼›&ampï¼›mut selfï¼šï¼šTarget{safe{let a=&amp#34ï¼›mut_deref\n\0&#34ï¼›ï¼›let b=a as*const strï¼›let c=b as*const i8ï¼›printfï¼ˆcï¼‰ï¼›}&ampï¼›è«ç‰¹Â·èµ›å°”å¤«ã€‚0}pub fn mainï¼ˆï¼‰-&gtï¼›i32{let bar=barï¼ˆ123ï¼‰ï¼›let mut foo:foo&ltï¼›bar&gtï¼›=fooï¼ˆbarï¼‰ï¼›let foobar=foo.foobarï¼ˆï¼‰ï¼›foobar-123}</p><p>   We have merged our first pass of the macro expansion pass. The approach taken here is that we reuse our existing parser to call the apropriate functions as specified as part of the MacroFragmentType enum if the parser does not have errors parsing that item then it must be a match. Then once we match a rule we have a map of the token begin/end offsets for each fragment match, this is then used to adjust and create a new token stream for the macro rule definition so that when we feed it to the parser the tokens are already substituted. The resulting expression or item is then attached to the respective macro invocation and this is then name resolved and used for hir lowering.</p><p>æˆ‘ä»¬å·²ç»åˆå¹¶äº†æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªå®è§‚æ‰©å¼ é€šé“ã€‚è¿™é‡Œé‡‡ç”¨çš„æ–¹æ³•æ˜¯ï¼Œæˆ‘ä»¬é‡ç”¨ç°æœ‰çš„è§£æå™¨æ¥è°ƒç”¨ä½œä¸ºMacroFragmentTypeæšä¸¾çš„ä¸€éƒ¨åˆ†æŒ‡å®šçš„é€‚å½“å‡½æ•°ã€‚å¦‚æœè§£æå™¨åœ¨è§£æè¯¥é¡¹æ—¶æ²¡æœ‰é”™è¯¯ï¼Œé‚£ä¹ˆå®ƒå¿…é¡»æ˜¯åŒ¹é…çš„ã€‚ç„¶åï¼Œä¸€æ—¦æˆ‘ä»¬åŒ¹é…äº†ä¸€ä¸ªè§„åˆ™ï¼Œæˆ‘ä»¬å°±æœ‰äº†æ¯ä¸ªç‰‡æ®µåŒ¹é…çš„ä»¤ç‰Œå¼€å§‹/ç»“æŸåç§»çš„æ˜ å°„ï¼Œç„¶åç”¨å®ƒæ¥è°ƒæ•´å’Œåˆ›å»ºå®è§„åˆ™å®šä¹‰çš„æ–°ä»¤ç‰Œæµï¼Œè¿™æ ·å½“æˆ‘ä»¬å°†å…¶æä¾›ç»™è§£æå™¨æ—¶ï¼Œä»¤ç‰Œå°±å·²ç»è¢«æ›¿æ¢äº†ã€‚ç”Ÿæˆçš„è¡¨è¾¾å¼æˆ–é¡¹éšåé™„åŠ åˆ°ç›¸åº”çš„å®è°ƒç”¨ï¼Œç„¶åè§£æåç§°å¹¶ç”¨äºhiré™ä½ã€‚</p><p> In this example the macro has two rules so we demonstrate that we match the apropriate rule and transcribe it respectively.</p><p>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå®æœ‰ä¸¤ä¸ªè§„åˆ™ï¼Œæ‰€ä»¥æˆ‘ä»¬è¯æ˜æˆ‘ä»¬åŒ¹é…äº†é€‚å½“çš„è§„åˆ™ï¼Œå¹¶åˆ†åˆ«è½¬å½•äº†å®ƒã€‚</p><p> macro_rules! add { ($a:expr,$b:expr) =&gt; { $a + $b }; ($a:expr) =&gt; { $a };}fn main() -&gt; i32 { let mut x = add!(1); x += add!(2, 3); x - 6}</p><p>å®è§„åˆ™ï¼æ·»åŠ {ï¼ˆ$a:exprï¼Œ$b:exprï¼‰=&gtï¼›{$a+$b}ï¼›ï¼ˆ$a:exprï¼‰=&gtï¼›{$a}ï¼›}fn mainï¼ˆï¼‰-&gtï¼›i32{let mut x=addï¼ï¼ˆ1ï¼‰ï¼›x+=addï¼ï¼ˆ2,3ï¼‰ï¼›x-6}</p><p>  macro_rules! Test { ($a:ident, $b:ty) =&gt; { struct $a($b); };}Test!(Foo, i32);fn main() -&gt; i32 { let a = Foo(123); a.0 - 123}</p><p>å®è§„åˆ™ï¼æµ‹è¯•{ï¼ˆ$a:identï¼Œ$b:tyï¼‰=&gtï¼›{struct$aï¼ˆ$bï¼‰ï¼›}ï¼›}æµ‹éªŒï¼ˆå¯Œï¼Œi32ï¼‰ï¼›fn mainï¼ˆï¼‰-&gtï¼›i32{let a=Fooï¼ˆ123ï¼‰ï¼›a.0-123}</p><p> Here we take into account the context of the macro invocation and parse it into AST::Items. In the even of failure to match a rule the compiler error looks like the following:</p><p>è¿™é‡Œæˆ‘ä»¬è€ƒè™‘å®è°ƒç”¨çš„ä¸Šä¸‹æ–‡ï¼Œå¹¶å°†å…¶è§£æä¸ºAST:ï¼šItemsã€‚å¦‚æœæœªèƒ½åŒ¹é…è§„åˆ™ï¼Œç¼–è¯‘å™¨é”™è¯¯å¦‚ä¸‹æ‰€ç¤ºï¼š</p><p> &lt;source&gt;:11:17: error: Failed to match any rule within macro 1 | macro_rules! add { | ~ ...... 11 | let mut x = add!(1, 2, 3); | ^</p><p>&ltï¼›æ¥æº&gtï¼›ï¼š11:17ï¼šé”™è¯¯ï¼šæœªèƒ½åŒ¹é…å®1 |å®|è§„åˆ™ä¸­çš„ä»»ä½•è§„åˆ™ï¼åŠ {| ~..11 |è®©mut x=addï¼ï¼ˆ1,2,3ï¼‰|^</p><p> More error handling has been added for when the transcribed rule actually is not fully used so for example:</p><p>å½“è½¬å½•è§„åˆ™å®é™…ä¸Šæ²¡æœ‰å®Œå…¨ä½¿ç”¨æ—¶ï¼Œæ·»åŠ äº†æ›´å¤šé”™è¯¯å¤„ç†ï¼Œä¾‹å¦‚ï¼š</p><p>    In rust ranges are turned into structs so what seems like piece of syntax to specify some kind of constraint is actually something which can be assigned and manipulated. This is one of the building blocks in our journey to support slices.</p><p>åœ¨rustä¸­ï¼ŒèŒƒå›´è¢«è½¬æ¢ä¸ºç»“æ„ï¼Œå› æ­¤ï¼ŒæŒ‡å®šæŸç§çº¦æŸçš„è¯­æ³•ç‰‡æ®µå®é™…ä¸Šæ˜¯å¯ä»¥èµ‹å€¼å’Œæ“ä½œçš„ã€‚è¿™æ˜¯æˆ‘ä»¬æ”¯æŒåˆ‡ç‰‡è¿‡ç¨‹ä¸­çš„ä¸€ä¸ªç»„æˆéƒ¨åˆ†ã€‚</p><p> #[lang = &#34;RangeFull&#34;]pub struct RangeFull;#[lang = &#34;Range&#34;]pub struct Range&lt;Idx&gt; { pub start: Idx, pub end: Idx,}#[lang = &#34;RangeFrom&#34;]pub struct RangeFrom&lt;Idx&gt; { pub start: Idx,}#[lang = &#34;RangeTo&#34;]pub struct RangeTo&lt;Idx&gt; { pub end: Idx,}#[lang = &#34;RangeInclusive&#34;]pub struct RangeInclusive&lt;Idx&gt; { pub start: Idx, pub end: Idx,}fn test() { let a = 1..2; // range let b = 1..; // range from let c = ..3; // range to let d = 0..=2; // range inclusive}</p><p>#[lang=&#34ï¼›RangeFull&#34ï¼›]pub struct RangeFull#[lang=&#34ï¼›èŒƒå›´&#34ï¼›]pub struct Range&ltï¼›Idx&gtï¼›{pub start:Idxï¼Œpub end:Idxï¼Œ}#[lang=&#34ï¼›RangeFrom&#34ï¼›]pub struct RangeFrom&ltï¼›Idx&gtï¼›{pub start:Idxï¼Œ}#[lang=&#34ï¼›RangeTo&#34ï¼›]é…’å§ç»“æ„RangeTo&ltï¼›Idx&gtï¼›{pub end:Idxï¼Œ}#[lang=&#34ï¼›range inclusive&#34ï¼›]pub struct range inclusive&ltï¼›Idx&gtï¼›{pub start:Idxï¼Œpub end:Idxï¼Œ}fn testï¼ˆï¼‰{let a=1..2ï¼›//range let b=1..ï¼›//range from let c=..3ï¼›//range to let d=0..=2ï¼›//range inclusive}</p><p>   Another building block to support slices is the ability to suport the index lang item core::ops::index so that a range can be an argument and the code in core::slice::index can actually become the starting point in giving us a slice from an array.</p><p>æ”¯æŒåˆ‡ç‰‡çš„å¦ä¸€ä¸ªæ„å»ºå—æ˜¯æ”¯æŒç´¢å¼•lang item core:ï¼šops:ï¼šindexçš„èƒ½åŠ›ï¼Œè¿™æ ·ä¸€ä¸ªèŒƒå›´å°±å¯ä»¥ä½œä¸ºå‚æ•°ï¼Œcore:ï¼šslice:ï¼šindexä¸­çš„ä»£ç å®é™…ä¸Šå¯ä»¥æˆä¸ºä»æ•°ç»„ä¸­è·å–åˆ‡ç‰‡çš„èµ·ç‚¹ã€‚</p><p> #[lang = &#34;index&#34;]trait Index&lt;Idx&gt; { type Output; fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;}struct Foo(i32, i32);impl Index&lt;isize&gt; for Foo { type Output = i32; fn index(&amp;self, index: isize) -&gt; &amp;i32 { if index == 0 { &amp;self.0 } else { &amp;self.1 } }}fn main() -&gt; i32 { let a = Foo(1, 2); let b = a[0]; let c = a[1]; c - b - 1}</p><p>#[lang=&#34ï¼›ç´¢å¼•&#34ï¼›]ç‰¹è´¨æŒ‡æ•°&ltï¼›Idx&gtï¼›{type Outputï¼›fn indexï¼ˆ&ampï¼›selfï¼Œindex:Idxï¼‰-&gtï¼›&ampï¼›self:ï¼šOutputï¼›}struct Fooï¼ˆi32ï¼Œi32ï¼‰ï¼›implç´¢å¼•&ltï¼›isize&gtï¼›å¯¹äºFoo{type Output=i32ï¼›fn indexï¼ˆ&ampï¼›selfï¼Œindex:isizeï¼‰->ï¼›i32{let a=Fooï¼ˆ1,2ï¼‰ï¼›let b=a[0]ï¼›let c=a[1]ï¼›c-b-1}</p><p>    Macro match arms can contain repetition operators, which indicate the possibilty of passing multiple instances of a single token or metavariable.</p><p>å®åŒ¹é…è‡‚å¯ä»¥åŒ…å«é‡å¤è¿ç®—ç¬¦ï¼Œå®ƒæŒ‡ç¤ºä¼ é€’å•ä¸ªæ ‡è®°æˆ–å…ƒå˜é‡çš„å¤šä¸ªå®ä¾‹çš„å¯èƒ½æ€§ã€‚</p><p> You can denote such repetitions using Kleene operators: Three variants are available,  ?,  + and  *. Each corresponds to varying bounds on the amount of tokens associated with the operator, similarly to regular expressions.</p><p>æ‚¨å¯ä»¥ä½¿ç”¨Kleeneè¿ç®—ç¬¦è¡¨ç¤ºæ­¤ç±»é‡å¤ï¼šæœ‰ä¸‰ç§å˜ä½“å¯ç”¨ï¼Œï¼Ÿï¼Œ+åŠ*ã€‚æ¯ä¸€ä¸ªéƒ½å¯¹åº”äºä¸è¿ç®—ç¬¦å…³è”çš„æ ‡è®°æ•°é‡çš„ä¸åŒç•Œé™ï¼Œç±»ä¼¼äºæ­£åˆ™è¡¨è¾¾å¼ã€‚</p><p> macro_rules! kleene { ($a:ident $(,)?) =&gt; {{ }}; ($($i:literal tok)+) =&gt; {{ }}; ($($e:expr)*) =&gt; {{ }};}</p><p>å®è§„åˆ™ï¼kleene{ï¼ˆ$a:ident$ï¼ˆï¼Œï¼‰ï¼Ÿï¼‰=&gtï¼›{{}ï¼›ï¼ˆ$ï¼ˆ$i:literal tokï¼‰+ï¼‰=&gtï¼›{{ }}; ï¼ˆ$ï¼ˆ$e:exprï¼‰*ï¼‰=&gtï¼›{{ }};}</p><p>  Either a singular identifier, with zero or one commas (pattern:  &lt;comma&gt;, kleene operator:  ? (0 -&gt; 1))</p><p>å•æ•°æ ‡è¯†ç¬¦ï¼Œå¸¦æœ‰é›¶ä¸ªæˆ–ä¸€ä¸ªé€—å·ï¼ˆæ¨¡å¼ï¼š&ltï¼›é€—å·&gtï¼›ï¼Œkleeneè¿ç®—ç¬¦ï¼šï¼Ÿï¼ˆ0-&gtï¼›1ï¼‰ï¼‰</p><p> One or more literal followed by the separator  tok (pattern  $i:literal tok, kleene operator:  + (1 -&gt;  +inf))</p><p>ä¸€ä¸ªæˆ–å¤šä¸ªæ–‡æœ¬åè·Ÿåˆ†éš”ç¬¦tokï¼ˆæ¨¡å¼$i:literal tokï¼Œkleeneè¿ç®—ç¬¦ï¼š+ï¼ˆ1-&gtï¼›+infï¼‰ï¼‰</p><p> The first of implementing macro repetitions comes in matching the actual patterns given to the users. We are now able to match simple repetitions, with a few limitations and bugs still. For example, the Rust reference specifies valid separators to use after fragment specifiers, which we do not check yet. It is for example forbidden to add an identifier after an  $&lt;&gt;:expr specifier, since that could cause ambiguity: The only allowed separators after an expression are thus  =&gt;,  &lt;comma&gt; or  ;.</p><p>å®ç°å®é‡å¤çš„ç¬¬ä¸€æ­¥æ˜¯åŒ¹é…ç»™å®šç»™ç”¨æˆ·çš„å®é™…æ¨¡å¼ã€‚æˆ‘ä»¬ç°åœ¨èƒ½å¤ŸåŒ¹é…ç®€å•çš„é‡å¤ï¼Œä½†ä»æœ‰ä¸€äº›é™åˆ¶å’Œç¼ºé™·ã€‚ä¾‹å¦‚ï¼ŒRustå¼•ç”¨æŒ‡å®šäº†åœ¨ç‰‡æ®µè¯´æ˜ç¬¦ä¹‹åä½¿ç”¨çš„æœ‰æ•ˆåˆ†éš”ç¬¦ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰æ£€æŸ¥è¿™äº›åˆ†éš”ç¬¦ã€‚ä¾‹å¦‚ï¼Œç¦æ­¢åœ¨$&lt&gtï¼›ï¼šexprè¯´æ˜ç¬¦ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šå¯¼è‡´æ­§ä¹‰ï¼šè¡¨è¾¾å¼åå”¯ä¸€å…è®¸çš„åˆ†éš”ç¬¦æ˜¯=&gt&ä¹¦ä¿¡ç”µæŠ¥ï¼›é€—å·&gtï¼›æˆ–</p><p>  Once those repetition patterns are matched, it is easy to figure out how many repetitions of said pattern were given by the user. We store this data alongside the rest of the fragment, to make sure that we expand said pattern a correct amount of times when transcribing.</p><p>ä¸€æ—¦åŒ¹é…äº†è¿™äº›é‡å¤æ¨¡å¼ï¼Œå°±å¾ˆå®¹æ˜“è®¡ç®—å‡ºç”¨æˆ·ç»™å‡ºäº†å¤šå°‘é‡å¤æ¨¡å¼ã€‚æˆ‘ä»¬å°†è¿™äº›æ•°æ®ä¸ç‰‡æ®µçš„å…¶ä½™éƒ¨åˆ†ä¸€èµ·å­˜å‚¨ï¼Œä»¥ç¡®ä¿åœ¨è½¬å½•æ—¶å°†æ‰€è¿°æ¨¡å¼æ‰©å±•æ­£ç¡®çš„æ¬¡æ•°ã€‚</p><p>     we will have matched the repetition 3 times, and attributed a repetition amount of 3 to the  $e meta-variable.</p><p>æˆ‘ä»¬å°†åŒ¹é…é‡å¤3æ¬¡ï¼Œå¹¶å°†é‡å¤é‡3å½’å› äº$eå…ƒå˜é‡ã€‚</p><p>   Following the matching of these repetitions, we can recursively expand all tokens contained in the pattern.</p><p>åœ¨åŒ¹é…è¿™äº›é‡å¤ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥é€’å½’åœ°æ‰©å±•æ¨¡å¼ä¸­åŒ…å«çš„æ‰€æœ‰æ ‡è®°ã€‚</p><p> Considering once again the previous declaration and invocation, we can parse the following pattern as the one to expand:</p><p>å†æ¬¡è€ƒè™‘å‰é¢çš„å£°æ˜å’Œè°ƒç”¨ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä»¥ä¸‹æ¨¡å¼è§£æä¸ºè¦å±•å¼€çš„æ¨¡å¼ï¼š</p><p>  This pattern is then recursively expanded as if it was a regular macro invocation. In order to make sure that each meta-variable gets expanded correctly, we only give a subset of the matched fragments to the new subsitution context.</p><p>ç„¶åï¼Œè¯¥æ¨¡å¼è¢«é€’å½’åœ°æ‰©å±•ï¼Œå°±å¥½åƒå®ƒæ˜¯ä¸€ä¸ªå¸¸è§„çš„å®è°ƒç”¨ä¸€æ ·ã€‚ä¸ºäº†ç¡®ä¿æ¯ä¸ªå…ƒå˜é‡å¾—åˆ°æ­£ç¡®çš„æ‰©å±•ï¼Œæˆ‘ä»¬åªç»™æ–°çš„æ›¿ä»£ä¸Šä¸‹æ–‡æä¾›åŒ¹é…ç‰‡æ®µçš„å­é›†ã€‚</p><p> macro_rules! lit_plus_tok { ($($e:literal tok)*) =&gt; {}}lit_plus_tok!(&#34;rustc&#34; tok &#39;v&#39; tok 1.59 tok);// Original matched fragments: { &#34;lit&#34;: [&#34;rustc&#34;, &#39;v&#39;, 1.59] }// We then expand the repetition pattern once with { &#34;lit&#34;: [&#34;rustc&#34;] },// once with { &#34;lit&#34;: [&#39;v&#39;] },// and finally once with { &#34;lit&#34;: [1.59] },</p><p>å®è§„åˆ™ï¼lit_plus_tok{ï¼ˆ$ï¼ˆ$e:literal tokï¼‰*ï¼‰=&gtï¼›{}lit_plus_tokï¼ï¼ˆ&#34ï¼›rustc&#34ï¼›tok&#39ï¼›v&#39ï¼›tok 1.59 tokï¼‰ï¼›//åŸå§‹åŒ¹é…ç‰‡æ®µï¼š{&#34ï¼›lit&#34ï¼›ï¼š[&#34ï¼›rustc&#34ï¼›ï¼Œ&#39ï¼›v&#39ï¼›ï¼Œ1.59]}//ç„¶åæˆ‘ä»¬ç”¨{&#34ï¼›lit&#34ï¼›ï¼š[&#34ï¼›rustc&#34ï¼›]æ›¾ç»ä¸{&#34ï¼›lit&#34ï¼›ï¼š[&#39ï¼›v&#39ï¼›]}ï¼Œ//æœ€åä¸€æ¬¡æ˜¯{&#34ï¼›lit&#34ï¼›ï¼š[1.59]}ï¼Œ</p><p> Once again, certain restrictions apply, which we have yet to implement: Some specifiers get expanded eagerly, while some stay under the form inputted by the user.</p><p>åŒæ ·ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰å®ç°æŸäº›é™åˆ¶ï¼šä¸€äº›è¯´æ˜ç¬¦æ€¥åˆ‡åœ°å¾—åˆ°æ‰©å±•ï¼Œè€Œä¸€äº›ä¿ç•™åœ¨ç”¨æˆ·è¾“å…¥çš„è¡¨å•ä¸‹ã€‚</p><p>  Likewise, not all repetition patterns are covered properly. Some issues remain to be ironed out for a complete and correct implementation.</p><p>åŒæ ·ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„é‡å¤æ¨¡å¼éƒ½è¢«æ°å½“åœ°è¦†ç›–ã€‚ä¸ºäº†å…¨é¢ã€æ­£ç¡®åœ°å®æ–½ï¼Œæœ‰äº›é—®é¢˜ä»æœ‰å¾…è§£å†³ã€‚</p><p>  In order to implement some specific behaviour, the rust standard library requires some macros to be built into the compiler. You can find a full list  here.</p><p>ä¸ºäº†å®ç°æŸäº›ç‰¹å®šçš„è¡Œä¸ºï¼Œrustæ ‡å‡†åº“éœ€è¦åœ¨ç¼–è¯‘å™¨ä¸­å†…ç½®ä¸€äº›å®ã€‚ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°å®Œæ•´çš„æ¸…å•ã€‚</p><p> gccrs should implement to allow for the compilation of the standard rust library, as both  core and  std depend on a multitude of them.</p><p>GCCRçš„å®æ–½åº”è€ƒè™‘åˆ°æ ‡å‡†ruståº“çš„ç¼–è¯‘ï¼Œå› ä¸ºcoreå’Œstdéƒ½ä¾èµ–äºå®ƒä»¬ã€‚</p><p> These macros are defined as empty within the core library, and their transcriber is provided in the compiler as a simple function. We implement those builtins in  gccrs as functions returning fragments of abstract syntax trees, which are inserted during the macro-expansion phase and then lowered to an intermediate representation alongside the rest of the userâ€™s code.</p><p>è¿™äº›å®åœ¨æ ¸å¿ƒåº“ä¸­å®šä¹‰ä¸ºç©ºï¼Œå®ƒä»¬çš„è½¬å½•å™¨åœ¨ç¼–è¯‘å™¨ä¸­ä½œä¸ºä¸€ä¸ªç®€å•å‡½æ•°æä¾›ã€‚æˆ‘ä»¬åœ¨GCCRä¸­å®ç°è¿™äº›å†…ç½®å‡½æ•°ï¼Œä½œä¸ºè¿”å›æŠ½è±¡è¯­æ³•æ ‘ç‰‡æ®µçš„å‡½æ•°ï¼Œè¿™äº›ç‰‡æ®µåœ¨å®æ‰©å±•é˜¶æ®µæ’å…¥ï¼Œç„¶åä¸ç”¨æˆ·ä»£ç çš„å…¶ä½™éƒ¨åˆ†ä¸€èµ·é™ä½åˆ°ä¸­é—´è¡¨ç¤ºå½¢å¼ã€‚</p><p> We have a long list of macros ahead of us, some of which we should be able to implement easily. If you are interested in contributing, we have opened 3 good first issues regarding builtin macros with detailed guides on how to solve them.</p><p>æˆ‘ä»¬é¢å‰æœ‰ä¸€é•¿ä¸²å®ï¼Œå…¶ä¸­ä¸€äº›åº”è¯¥å¯ä»¥è½»æ¾å®ç°ã€‚å¦‚æœä½ æœ‰å…´è¶£å‚ä¸è¿›æ¥ï¼Œæˆ‘ä»¬å·²ç»æ‰“å¼€äº†å…³äºå†…ç½®å®çš„3ä¸ªå¥½çš„ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œä»¥åŠå¦‚ä½•è§£å†³å®ƒä»¬çš„è¯¦ç»†æŒ‡å—ã€‚</p><p> Thanks a lot to  bjorn3 for all the help regarding builtin macros and their implementation details.</p><p>éå¸¸æ„Ÿè°¢bjorn3å¯¹å†…ç½®å®åŠå…¶å®ç°ç»†èŠ‚çš„å¸®åŠ©ã€‚</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gcc/">#gcc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gt/">#gt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>