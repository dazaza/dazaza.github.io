<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>åŒçº¿æ€§ä¸‹é‡‡æ ·ï¼Œå¯¹é½åƒç´ ç½‘æ ¼å’Œè‡­åæ˜­è‘—çš„åŠåƒç´ åç§» Bilinear downsampling, aligning pixel grids and the infamous half pixel offset</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bilinear downsampling, aligning pixel grids and the infamous half pixel offset<br/>åŒçº¿æ€§ä¸‹é‡‡æ ·ï¼Œå¯¹é½åƒç´ ç½‘æ ¼å’Œè‡­åæ˜­è‘—çš„åŠåƒç´ åç§» </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-25 09:33:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/f369cc0d1b9b9138ce316b6551425d09.gif"><img src="http://img2.diglog.com/img/2021/2/f369cc0d1b9b9138ce316b6551425d09.gif" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Itâ€™s been more than two decades of me using bilinear texture filtering, a few months since  Iâ€™ve written about bilinear resampling, but only two days since I discovered a bug of mine related to it. ğŸ˜… Similarly, just last week a colleague asked for a very fast implementation of bilinear on a CPU and it caused a series of questions â€œwhich kind of bilinear?â€.</p><p>æˆ‘ä½¿ç”¨åŒçº¿æ€§çº¹ç†è¿‡æ»¤å·²ç»æœ‰äºŒåå¤šå¹´äº†ï¼Œè·ç¦»æˆ‘æ’°å†™åŒçº¿æ€§é‡é‡‡æ ·å·²ç»æœ‰å‡ ä¸ªæœˆäº†ï¼Œä½†æ˜¯è·ç¦»å‘ç°æˆ‘çš„ä¸€ä¸ªä¸ä¹‹ç›¸å…³çš„é”™è¯¯åªæœ‰ä¸¤å¤©äº†ã€‚ ğŸ˜…åŒæ ·ï¼Œå°±åœ¨ä¸Šå‘¨ï¼Œä¸€ä½åŒäº‹è¦æ±‚åœ¨CPUä¸Šéå¸¸å¿«é€Ÿåœ°å®ç°åŒçº¿æ€§ï¼Œè¿™å¼•èµ·äº†ä¸€ç³»åˆ—é—®é¢˜â€œå“ªç§åŒçº¿æ€§ï¼Ÿâ€ã€‚</p><p> So I figured itâ€™s an opportunity for another short blog post â€“ on bilinear filtering, but in context of down/upsampling. We will touch here on  GPU half pixel offsets, aligning pixel grids, a bug / confusion in Tensorflow, deeper signal processing analysis of whatâ€™s going on during bilinear operations, and analysis of the magic of the  famous â€œmagic kernelâ€.</p><p> å› æ­¤ï¼Œæˆ‘è®¤ä¸ºè¿™æ˜¯å¦ä¸€ç¯‡ç®€çŸ­çš„åšå®¢æ–‡ç« çš„æœºä¼šâ€“å…³äºåŒçº¿æ€§è¿‡æ»¤ï¼Œä½†æ¶‰åŠä¸‹é‡‡æ ·/ä¸Šé‡‡æ ·ã€‚æˆ‘ä»¬å°†åœ¨è¿™é‡Œä»‹ç»GPUåŠåƒç´ åç§»ï¼Œå¯¹é½åƒç´ ç½‘æ ¼ï¼ŒTensorflowä¸­çš„é”™è¯¯/æ··æ·†ï¼Œå¯¹åŒçº¿æ€§æ“ä½œæœŸé—´å‘ç”Ÿçš„æƒ…å†µè¿›è¡Œæ›´æ·±å…¥çš„ä¿¡å·å¤„ç†åˆ†æï¼Œä»¥åŠå¯¹è‘—åçš„â€œé­”æœ¯æ ¸â€çš„é­”æœ¯æ€§è¿›è¡Œåˆ†æã€‚</p><p> I highly recommend  my previous post as a primer on the topic, as Iâ€™ll use some of the tools and terminology from there, but itâ€™s not strictly required. Letâ€™s go!</p><p> æˆ‘å¼ºçƒˆæ¨èæˆ‘çš„ä¸Šä¸€ç¯‡æ–‡ç« ä½œä¸ºè¯¥ä¸»é¢˜çš„å…¥é—¨ï¼Œå› ä¸ºæˆ‘å°†ä»é‚£é‡Œå¼€å§‹ä½¿ç”¨ä¸€äº›å·¥å…·å’Œæœ¯è¯­ï¼Œä½†è¿™å¹¶ä¸æ˜¯ä¸¥æ ¼è¦æ±‚çš„ã€‚æˆ‘ä»¬èµ°å§ï¼</p><p>  The term bilinear upsampling and downsampling is used a lot, but what does it mean?</p><p>  ç»å¸¸ä½¿ç”¨æœ¯è¯­åŒçº¿æ€§ä¸Šé‡‡æ ·å’Œä¸‹é‡‡æ ·ï¼Œä½†è¿™æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ</p><p> One of the few ideas Iâ€™d like to convey in this post is that  bilinear upsampling / downsampling doesnâ€™t have a single meaning or a consensus around this term use. Which is kind of surprising for a bread and butter type of image processing operation that is used all the time!</p><p> æˆ‘æƒ³åœ¨è¿™ç¯‡æ–‡ç« ä¸­ä¼ è¾¾çš„å‡ ä¸ªæƒ³æ³•ä¹‹ä¸€æ˜¯ï¼ŒåŒçº¿æ€§ä¸Šé‡‡æ ·/ä¸‹é‡‡æ ·åœ¨æ­¤æœ¯è¯­çš„ä½¿ç”¨ä¸Šæ²¡æœ‰å•ä¸€å«ä¹‰æˆ–å…±è¯†ã€‚å¯¹äºä¸€ç›´ä½¿ç”¨çš„é¢åŒ…å’Œé»„æ²¹ç±»å‹çš„å›¾åƒå¤„ç†æ“ä½œæ¥è¯´ï¼Œè¿™æ˜¯ä»¤äººæƒŠè®¶çš„ï¼</p><p> Itâ€™s also surprisingly hard to get it right even by image processing professionals, and a  source of long standing bugs and confusion in top libraries (and I know of some actual production bugs caused by this  Tensorflow inconsistency)!</p><p> å³ä½¿æ˜¯å›¾åƒå¤„ç†ä¸“ä¸šäººå‘˜ï¼Œä¹Ÿå¾ˆéš¾åšåˆ°è¿™ä¸€ç‚¹ï¼Œè€Œä¸”é•¿æœŸå­˜åœ¨bugå’Œé¡¶çº§åº“çš„æ··ä¹±ï¼ˆæˆ‘çŸ¥é“ä¸€äº›ç”±Tensorflowä¸ä¸€è‡´å¼•èµ·çš„å®é™…ç”Ÿäº§bugï¼‰ï¼</p><p> Edit: thereâ€™s a blog post titled   â€œHow Tensorflowâ€™s tf.image.resize stole 60 days of my lifeâ€ and itâ€™s describing same issue. I know of some of my colleagues that spent months on fixing it in Tensorflow 2 â€“ imagine effort of fixing incorrect uses and â€œfixingâ€ already trained models that were trained around this bugâ€¦</p><p> ç¼–è¾‘ï¼šä¸€ç¯‡åšå®¢æ–‡ç« æ ‡é¢˜ä¸ºâ€œ Tensorflowçš„tf.image.resizeå¦‚ä½•å·èµ°äº†æˆ‘60å¤©çš„ç”Ÿå‘½â€ï¼Œå¹¶æè¿°äº†åŒæ ·çš„é—®é¢˜ã€‚æˆ‘çŸ¥é“æˆ‘çš„ä¸€äº›åŒäº‹èŠ±äº†å‡ ä¸ªæœˆçš„æ—¶é—´åœ¨Tensorflow 2ä¸­ä¿®å¤å®ƒ-æƒ³åƒä¸€ä¸‹å¦‚ä½•ä¿®å¤ä¸æ­£ç¡®çš„ç”¨æ³•å¹¶â€œä¿®å¤â€å·²ç»å—è¿‡æ­¤é”™è¯¯è®­ç»ƒçš„æ¨¡å‹ã€‚ </p><p>  Some parts of it like phase shifting are so tricky that a famous blog post of  â€œmagic kernelâ€ comes up every few years and again, experts re(read) it a few times to figure out whatâ€™s going on there, while the author simply  rediscovered the bilinear! ( Important note: I donâ€™t want to pick on the author, far from it, as he is a super smart and knowledgeable person, and willingness to share insights is always respect worthy. â€œMagic kernelâ€ is just an example of why itâ€™s so hard and confusing to talk about  â€œbilinearâ€. I also respect how he amended and improved the post multiple times. But there is no â€œmagic kernelâ€.)</p><p>å®ƒçš„æŸäº›éƒ¨åˆ†ï¼ˆå¦‚ç›¸ç§»ï¼‰æ˜¯å¦‚æ­¤æ£˜æ‰‹ï¼Œä»¥è‡³äºè‘—åçš„â€œé­”æœ¯å†…æ ¸â€åšå®¢æ–‡ç« æ¯éš”å‡ å¹´å‡ºç°ä¸€æ¬¡ï¼Œä¸“å®¶ä»¬é‡æ–°é˜…è¯»äº†å‡ æ¬¡ä»¥å¼„æ¸…æ¥šåˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆï¼Œè€Œä½œè€…åªæ˜¯é‡æ–°å‘ç°äº†åŒçº¿æ€§ï¼ ï¼ˆé‡è¦è¯´æ˜ï¼šæˆ‘ä¸æƒ³é€‰æ‹©ä½œè€…ï¼Œå› ä¸ºä»–æ˜¯ä¸€ä¸ªéå¸¸èªæ˜å’Œåšå­¦çš„äººï¼Œå¹¶ä¸”ä¹äºåˆ†äº«è§è§£æ€»æ˜¯å€¼å¾—å°Šé‡çš„ã€‚â€œé­”æœ¯å†…æ ¸â€åªæ˜¯ä¸ºä»€ä¹ˆå®ƒå¦‚æ­¤å¾ˆéš¾è°ˆè®ºâ€œåŒçº¿æ€§â€ã€‚æˆ‘ä¹Ÿå°Šé‡ä»–å¦‚ä½•å¤šæ¬¡ä¿®æ”¹å’Œæ”¹è¿›è¯¥èŒä½ã€‚ä½†æ˜¯æ²¡æœ‰â€œé­”æœ¯å†…æ ¸â€ã€‚ï¼‰</p><p> So letâ€™s have a look at whatâ€™s the problem. I will focus here exclusively on 2x up/downsampling and hope that some thought framework I propose and use here will be beneficial for you to also look at and analyze different (and non-integer factors).</p><p> å› æ­¤ï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸‹é—®é¢˜æ‰€åœ¨ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘å°†ä»…ä¸“æ³¨äº2å€å‘ä¸Š/å‘ä¸‹é‡‡æ ·ï¼Œå¹¶å¸Œæœ›åœ¨æ­¤å»ºè®®å’Œä½¿ç”¨çš„æŸäº›æ€æƒ³æ¡†æ¶å¯¹æ‚¨æœ‰ç›Šï¼Œä¹Ÿæœ‰åŠ©äºæ‚¨ç ”ç©¶å’Œåˆ†æä¸åŒçš„ï¼ˆå’Œéæ•´æ•°å› ç´ ï¼‰ã€‚</p><p> Because of bilinear separability, I will again  abuse the notation and call â€œbilinearâ€ a filter when applied to 1D signals and generally a lot of my analysis will be in 1D.</p><p> ç”±äºåŒçº¿æ€§çš„å¯åˆ†ç¦»æ€§ï¼Œå½“å†æ¬¡åº”ç”¨äºä¸€ç»´ä¿¡å·æ—¶ï¼Œæˆ‘å°†å†æ¬¡æ»¥ç”¨è¯¥è¡¨ç¤ºæ³•å¹¶ç§°å…¶ä¸ºâ€œåŒçº¿æ€§â€æ»¤æ³¢å™¨ï¼Œé€šå¸¸ï¼Œæˆ‘çš„å¾ˆå¤šåˆ†æå°†åœ¨ä¸€ç»´ä¸­è¿›è¡Œã€‚</p><p>   Letâ€™s start with the most simple explanation, without the nitty gritty: it is creating a larger resolution image where every sample is created from bilinear filtering of a smaller resolution image.</p><p>   è®©æˆ‘ä»¬ä»æœ€ç®€å•çš„è§£é‡Šå¼€å§‹ï¼Œè€Œä¸æ˜¯ä¸€æˆä¸å˜ï¼šåˆ›å»ºä¸€ä¸ªåˆ†è¾¨ç‡æ›´é«˜çš„å›¾åƒï¼Œå…¶ä¸­æ¯ä¸ªæ ·æœ¬éƒ½æ˜¯é€šè¿‡å¯¹åˆ†è¾¨ç‡è¾ƒä½çš„å›¾åƒè¿›è¡ŒåŒçº¿æ€§è¿‡æ»¤è€Œåˆ›å»ºçš„ã€‚</p><p> For the bilinear downsampling, things get a bit muddy. It is using a bilinear filter to prevent signal aliasing when decimating the input image â€“ ugh, lots of technical terms. I will circle back to it, but first address the first common confusion.</p><p> å¯¹äºåŒçº¿æ€§ä¸‹é‡‡æ ·ï¼Œæƒ…å†µä¼šå˜å¾—æœ‰äº›æ··ä¹±ã€‚å®ƒä½¿ç”¨åŒçº¿æ€§æ»¤æ³¢å™¨æ¥é˜²æ­¢åœ¨æŠ½å–è¾“å…¥å›¾åƒæ—¶å‡ºç°ä¿¡å·æ··å â€“å—¯ï¼Œå¾ˆå¤šæŠ€æœ¯æœ¯è¯­ã€‚æˆ‘ä¼šå›å¤´å†è¯´ï¼Œä½†é¦–å…ˆè¦è§£å†³ç¬¬ä¸€ä¸ªå¸¸è§çš„å›°æƒ‘ã€‚</p><p>  When downsampling images by 2, we every often use terms box filter and bilinear filter interchangeably. And both can be correct. How so?</p><p>  å½“å¯¹å›¾åƒè¿›è¡Œ2å€é™é‡‡æ ·æ—¶ï¼Œæˆ‘ä»¬ç»å¸¸äº’æ¢ä½¿ç”¨æœ¯è¯­ç›’æ»¤æ³¢å™¨å’ŒåŒçº¿æ€§æ»¤æ³¢å™¨ã€‚ä¸¤è€…éƒ½æ˜¯æ­£ç¡®çš„ã€‚æ€ä¹ˆä¼šè¿™æ ·ï¼Ÿ</p><p>   We can see that a  2 tap box filter is the same as a 2 tap bilinear filter. The reason for it is that in this case, both filters are centered between the pixels. After discretizing them (evaluating filter weights at sample points), there is no difference, as we no longer know what was the formula to generate them, and how the filter kernel looked outside of the evaluation points.</p><p>   æˆ‘ä»¬å¯ä»¥çœ‹åˆ°2æŠ½å¤´ç›’æ»¤æ³¢å™¨ä¸2æŠ½å¤´åŒçº¿æ€§æ»¤æ³¢å™¨ç›¸åŒã€‚åŸå› æ˜¯åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªæ»¤é•œéƒ½ä½äºåƒç´ ä¹‹é—´çš„ä¸­å¿ƒã€‚ç¦»æ•£åŒ–å®ƒä»¬ä¹‹åï¼ˆåœ¨é‡‡æ ·ç‚¹è¯„ä¼°æ»¤æ³¢å™¨æƒé‡ï¼‰ï¼Œæ²¡æœ‰åŒºåˆ«ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å†çŸ¥é“ç”Ÿæˆå®ƒä»¬çš„å…¬å¼æ˜¯ä»€ä¹ˆï¼Œä»¥åŠæ»¤æ³¢å™¨å†…æ ¸åœ¨è¯„ä¼°ç‚¹ä¹‹å¤–çš„å¤–è§‚ã€‚ </p><p> The most typical way of doing bilinear downsampling is the same as box downsampling. Using those two names for 2x downsampling interchangeably is both correct! (Side note: Things diverge when taking about more than 2x downsampling. This might be a good topic for another blog post.) For 1D signals it means averaging every two elements together, for 2D images averaging 4 elements to produce a single one.</p><p>è¿›è¡ŒåŒçº¿æ€§ä¸‹é‡‡æ ·çš„æœ€å…¸å‹æ–¹æ³•ä¸ç›’ä¸‹é‡‡æ ·ç›¸åŒã€‚äº¤æ›¿ä½¿ç”¨è¿™ä¸¤ä¸ªåç§°è¿›è¡Œ2å€ä¸‹é‡‡æ ·éƒ½æ˜¯æ­£ç¡®çš„ï¼ ï¼ˆæ—æ³¨ï¼šå½“è¿›è¡Œå¤§çº¦2å€çš„ä¸‹é‡‡æ ·æ—¶ï¼Œæƒ…å†µä¼šå‘æ•£ã€‚å¯¹äºå¦ä¸€ç¯‡åšå®¢æ–‡ç« ï¼Œè¿™å¯èƒ½æ˜¯ä¸ªä¸é”™çš„è¯é¢˜ã€‚ï¼‰å¯¹äº1Dä¿¡å·ï¼Œè¿™æ„å‘³ç€å°†æ¯ä¸¤ä¸ªå…ƒç´ å¹³å‡åœ¨ä¸€èµ·ï¼Œå¯¹äº2Då›¾åƒï¼Œå°†4ä¸ªå…ƒç´ å¹³å‡äº§ç”Ÿä¸€ä¸ªã€‚</p><p> You might have noticed something that I implicitly assumed there â€“  pixel centers there were shifted by half a pixel, and the edges/corners were aligned.</p><p> æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°äº†æˆ‘éšå«çš„å‡è®¾-åƒç´ ä¸­å¿ƒåç§»äº†åŠä¸ªåƒç´ ï¼Œå¹¶ä¸”è¾¹ç¼˜/è§’å¯¹é½ã€‚</p><p>   This one definitely and clearly is also a linear tent, and it doesnâ€™t shift pixel centers. The resulting filter weights of [0.25 0.5 0.25] are also called a [1 2 1] filter, or the simplest case of a  binomial filter, a very reasonable approximation to a  Gaussian filter. (To understand why, see what happens to the binomial distribution as the trial count goes to infinity!). Itâ€™s probably the filter I use the most in my work, but I digress. ğŸ™‚</p><p>   æ˜¾ç„¶ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªçº¿æ€§å¸ç¯·ï¼Œå®ƒä¸ä¼šç§»åŠ¨åƒç´ ä¸­å¿ƒã€‚æ‰€å¾—çš„æ»¤æ³¢å™¨æƒé‡[0.25 0.5 0.25]ä¹Ÿç§°ä¸º[1 2 1]æ»¤æ³¢å™¨ï¼Œæˆ–è€…æ˜¯äºŒé¡¹å¼æ»¤æ³¢å™¨çš„æœ€ç®€å•æƒ…å†µï¼Œéå¸¸æ¥è¿‘é«˜æ–¯æ»¤æ³¢å™¨ã€‚ ï¼ˆè¦äº†è§£åŸå› ï¼Œè¯·æŸ¥çœ‹å½“è¯•ç®—æ¬¡æ•°è¾¾åˆ°æ— ç©·å¤§æ—¶äºŒé¡¹å¼åˆ†å¸ƒä¼šå‘ç”Ÿä»€ä¹ˆï¼ï¼‰ã€‚è¿™å¯èƒ½æ˜¯æˆ‘åœ¨å·¥ä½œä¸­ä½¿ç”¨æœ€å¤šçš„è¿‡æ»¤å™¨ï¼Œä½†æˆ‘ç¦»é¢˜äº†ã€‚ ğŸ™‚</p><p> Why this second method is not used that much? This is by design and a reason for half texel shifts in GPU coordinates / samplers, and you might have noticed the problem â€“ the last texel of high resolution array gets discarded. But letâ€™s not get ahead of ourselves, first we can have a look at the relationship with upsampling.</p><p> ä¸ºä»€ä¹ˆç¬¬äºŒç§æ–¹æ³•æ²¡æœ‰ä½¿ç”¨å¤ªå¤šï¼Ÿè¿™æ˜¯è®¾è®¡ä½¿ç„¶ï¼Œä¹Ÿæ˜¯GPUåæ ‡/é‡‡æ ·å™¨ä¸­åŠåƒç´ çš„åƒç´ ç§»åŠ¨çš„åŸå› ï¼Œæ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°äº†é—®é¢˜â€“é«˜åˆ†è¾¨ç‡é˜µåˆ—çš„æœ€åä¸€ä¸ªåƒç´ è¢«ä¸¢å¼ƒã€‚ä½†æ˜¯ï¼Œè®©æˆ‘ä»¬ä¸è¦è¶…è¶Šè‡ªå·±ï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹ä¸ä¸Šé‡‡æ ·çš„å…³ç³»ã€‚</p><p>  If you were to design a bilinear upsampling algorithm, there are a few ways to address it.</p><p>  å¦‚æœè¦è®¾è®¡åŒçº¿æ€§ä¸Šé‡‡æ ·ç®—æ³•ï¼Œåˆ™æœ‰å‡ ç§è§£å†³æ–¹æ³•ã€‚</p><p> Let me start with a â€œnaiveâ€ one that can have problems. We can take every original pixel, and between them just place averages of the other ones.</p><p> è®©æˆ‘ä»ä¸€ä¸ªå¯èƒ½å­˜åœ¨é—®é¢˜çš„â€œå¤©çœŸâ€å¼€å§‹ã€‚æˆ‘ä»¬å¯ä»¥è·å–æ¯ä¸ªåŸå§‹åƒç´ ï¼Œå¹¶åœ¨å®ƒä»¬ä¹‹é—´æ”¾ç½®å…¶ä»–åƒç´ çš„å¹³å‡å€¼ã€‚</p><p>  Is it bilinear / tent? Yes, itâ€™s a tent filter on zero-inserted image (more on it later). It has an unusual property; some pixels get blurred, some pixels stay â€œsharpâ€ (original copied).</p><p>  æ˜¯åŒçº¿æ€§/å¸ç¯·å—ï¼Ÿæ˜¯çš„ï¼Œå®ƒæ˜¯å¯¹é›¶æ’å…¥å›¾åƒçš„å¸ç¯·è¿‡æ»¤å™¨ï¼ˆç¨åä¼šè¯¦ç»†ä»‹ç»ï¼‰ã€‚å®ƒå…·æœ‰ä¸å¯»å¸¸çš„ç‰¹æ€§ï¼›ä¸€äº›åƒç´ å˜å¾—æ¨¡ç³Šï¼Œä¸€äº›åƒç´ ä¿æŒâ€œæ¸…æ™°â€ï¼ˆåŸå§‹å¤åˆ¶ï¼‰ã€‚ </p><p> But more importantly, if you do box/bilinear downsampling as described above, and then upsample an image,  it will be shifted:</p><p>ä½†æ›´é‡è¦çš„æ˜¯ï¼Œå¦‚æœæ‚¨å¦‚ä¸Šæ‰€è¿°è¿›è¡Œæ¡†/åŒçº¿æ€§ä¸‹é‡‡æ ·ï¼Œç„¶åå¯¹å›¾åƒè¿›è¡Œä¸Šé‡‡æ ·ï¼Œåˆ™å›¾åƒä¼šå‘ç”Ÿåç§»ï¼š</p><p>  Or rather â€“ it will not correct for the half pixel shift created by downsampling.</p><p>  æˆ–æ›´ç¡®åˆ‡åœ°è¯´ï¼Œå®ƒæ— æ³•æ ¡æ­£ä¸‹é‡‡æ ·æ‰€é€ æˆçš„åŠä¸ªåƒç´ åç§»ã€‚</p><p> It will work however with downsampling using the second method. The second method interpolates every single output pixel; all are interpolated:</p><p> ä½†æ˜¯ï¼Œä½¿ç”¨ç¬¬äºŒç§æ–¹æ³•è¿›è¡Œä¸‹é‡‡æ ·ä¹Ÿå¯ä»¥ã€‚ç¬¬äºŒç§æ–¹æ³•æ˜¯å¯¹æ¯ä¸ªè¾“å‡ºåƒç´ è¿›è¡Œæ’å€¼ï¼›å…¨éƒ¨æ’å€¼ï¼š</p><p>  This another way of doing bilinear upsampling that might first feel initially  unintuitive: every pixel is 0.75 of one pixel, and 0.25 of another one, alternating â€œto the leftâ€ and â€œto the rightâ€. This is exactly what a GPU does when you upsample a texture by 2x:</p><p>  è¿›è¡ŒåŒçº¿æ€§ä¸Šé‡‡æ ·çš„å¦ä¸€ç§æ–¹æ³•æœ€åˆå¯èƒ½æœ€åˆå¹¶ä¸ç›´è§‚ï¼šæ¯ä¸ªåƒç´ æ˜¯ä¸€ä¸ªåƒç´ çš„0.75ï¼Œå¦ä¸€ä¸ªåƒç´ çš„0.25ï¼Œäº¤æ›¿â€œå‘å·¦â€å’Œâ€œå‘å³â€ã€‚å½“æ‚¨å°†çº¹ç†ä¸Šé‡‡æ ·2å€æ—¶ï¼ŒGPUæ­£æ˜¯è¿™æ ·åšçš„ï¼š</p><p>  There are two simple explanations for those â€œalternatingâ€ weights. The first, easiest one is just looking at the â€œtentsâ€ in this scheme:</p><p>  å¯¹äºé‚£äº›â€œæ›¿ä»£â€æƒé‡ï¼Œæœ‰ä¸¤ç§ç®€å•çš„è§£é‡Šã€‚ç¬¬ä¸€ä¸ªæœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯æŸ¥çœ‹æ­¤æ–¹æ¡ˆä¸­çš„â€œå¸ç¯·â€ï¼š</p><p>  Iâ€™ll have a look at the second interpretation of this filter â€“  itâ€™s [0.125 0.375 0.375 0.125] in disguise ğŸ•µï¸â€â™€ï¸, but first with this intro, I think itâ€™s time to make the main claim / statement:  we need to be careful to use same reference coordinate frames when discussing images of different resolutions.</p><p>  æˆ‘å°†çœ‹çœ‹è¿™ä¸ªè¿‡æ»¤å™¨çš„ç¬¬äºŒç§è§£é‡Šâ€“ä¼ªè£…æˆ[ï¸0.125 0.375 0.375 0.125]ï¼Œä½†é¦–å…ˆï¼Œæˆ‘æƒ³æ˜¯æ—¶å€™æå‡ºä¸»è¦å£°æ˜/å£°æ˜äº†ï¼šæˆ‘ä»¬éœ€è¦è°¨æ…åœ¨è®¨è®ºä¸åŒåˆ†è¾¨ç‡çš„å›¾åƒæ—¶ä½¿ç”¨ç›¸åŒçš„å‚è€ƒåæ ‡ç³»ã€‚</p><p>  Your upsampling operations should be aware of what downsampling operations are and how they define the pixel grid offset, and the other way around!</p><p>  æ‚¨çš„ä¸Šé‡‡æ ·æ“ä½œåº”è¯¥çŸ¥é“ä»€ä¹ˆæ˜¯ä¸‹é‡‡æ ·æ“ä½œï¼Œä»¥åŠå®ƒä»¬å¦‚ä½•å®šä¹‰åƒç´ ç½‘æ ¼åç§»ï¼Œåä¹‹äº¦ç„¶ï¼ </p><p>  One important thing to internalize is that signal filters can have odd or even number of samples. If we have an even number of samples, such a filter doesnâ€™t have a â€œcenterâ€, so it has to shift the whole signal by a half pixel in either direction. By comparison, symmetric odd filters can shift specific frequencies, but donâ€™t shift the whole signal:</p><p>å†…éƒ¨åŒ–çš„é‡è¦ä¸€ä»¶äº‹æ˜¯ä¿¡å·æ»¤æ³¢å™¨å¯ä»¥å…·æœ‰å¥‡æ•°æˆ–å¶æ•°ä¸ªé‡‡æ ·ã€‚å¦‚æœæˆ‘ä»¬æœ‰å¶æ•°ä¸ªæ ·æœ¬ï¼Œé‚£ä¹ˆè¿™ç§æ»¤æ³¢å™¨å°±æ²¡æœ‰â€œä¸­å¿ƒâ€ï¼Œå› æ­¤å¿…é¡»å°†æ•´ä¸ªä¿¡å·æ²¿ä»»ä¸€æ–¹å‘ç§»åŠ¨åŠä¸ªåƒç´ ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¯¹ç§°å¥‡æ•°æ»¤æ³¢å™¨å¯ä»¥ç§»åŠ¨ç‰¹å®šé¢‘ç‡ï¼Œä½†ä¸èƒ½ç§»åŠ¨æ•´ä¸ªä¿¡å·ï¼š</p><p>  If you know signal processing, those are the type I and II  linear phase filters.</p><p>  å¦‚æœæ‚¨çŸ¥é“ä¿¡å·å¤„ç†ï¼Œé‚£ä¹ˆå®ƒä»¬å°±æ˜¯Iå‹å’ŒIIå‹çº¿æ€§ç›¸ä½æ»¤æ³¢å™¨ã€‚</p><p>  Hereâ€™s a visual demonstration of why it matters. A Kodak dataset image processed with different sequences, first starting with box downsampling:</p><p>  è¿™æ˜¯ä¸ºä»€ä¹ˆé‡è¦çš„è§†è§‰æ¼”ç¤ºã€‚ä½¿ç”¨ä¸åŒåºåˆ—å¤„ç†çš„æŸ¯è¾¾æ•°æ®é›†å›¾åƒï¼Œé¦–å…ˆä»æ¡†ä¸‹é‡‡æ ·å¼€å§‹ï¼š</p><p>    If there is a single lesson from my post, I would like it to be this one: Both â€œtakesâ€ on the bilinear up/downsampling above can be the valid and correct ones, you simply need to pick the proper one for your use-case and the convention used throughout your code/frameworks/libraries;  always use a consistent coordinate convention for the downsampling and upsampling. When you see term â€œbilinearâ€, always double check what it means! Because of it, I actually like to reimplement those and be sure that Iâ€™m consistentâ€¦</p><p>    å¦‚æœæˆ‘çš„å¸–å­ä¸­åªæœ‰ä¸€è¯¾ï¼Œæˆ‘å¸Œæœ›æ˜¯è¿™æ ·ï¼šä¸Šé¢çš„åŒçº¿æ€§ä¸Š/ä¸‹é‡‡æ ·ä¸­çš„ä¸¤ä¸ªâ€œå–æâ€éƒ½å¯ä»¥æ˜¯æœ‰æ•ˆå’Œæ­£ç¡®çš„ï¼Œæ‚¨åªéœ€è¦é€‰æ‹©ä¸€ä¸ªé€‚åˆæ‚¨çš„ç”¨é€”å³å¯ï¼šæ¡ˆä¾‹å’Œæ•´ä¸ªä»£ç /æ¡†æ¶/åº“ä¸­ä½¿ç”¨çš„çº¦å®šï¼›å§‹ç»ˆå¯¹ä¸‹é‡‡æ ·å’Œä¸Šé‡‡æ ·ä½¿ç”¨ä¸€è‡´çš„åæ ‡çº¦å®šã€‚å½“æ‚¨çœ‹åˆ°â€œåŒçº¿æ€§â€ä¸€è¯æ—¶ï¼Œè¯·åŠ¡å¿…ä»”ç»†æ£€æŸ¥å…¶å«ä¹‰ï¼å› æ­¤ï¼Œæˆ‘å®é™…ä¸Šå¾ˆæƒ³é‡æ–°å®ç°å®ƒä»¬ï¼Œå¹¶ç¡®ä¿æˆ‘ä¿æŒä¸€è‡´â€¦</p><p> That said, Iâ€™d argue that the  â€œboxâ€ bilinear downsampling and the â€œalternating weightsâ€ are better for average use-case. The first reason might be somewhat subjective / minor (because bilinear down/upsampling is inherently low quality and I donâ€™t recommend using it when the quality matters more than simplicity / performance). If we visually inspect the upsampling operation, we can see more leftover aliasing (just look at the diagonal edges) in the odd/odd combo:</p><p> ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘è®¤ä¸ºå¯¹äºæ™®é€šç”¨ä¾‹è€Œè¨€ï¼Œâ€œç›’å¼â€åŒçº¿æ€§ä¸‹é‡‡æ ·å’Œâ€œæ›¿ä»£æƒé‡â€æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚ç¬¬ä¸€ä¸ªåŸå› å¯èƒ½æ˜¯ä¸»è§‚çš„/æ¬¡è¦çš„ï¼ˆå› ä¸ºåŒçº¿æ€§ä¸‹é‡‡æ ·/ä¸Šé‡‡æ ·æœ¬è´¨ä¸Šæ˜¯ä½è´¨é‡çš„ï¼Œæ‰€ä»¥æˆ‘ä¸å»ºè®®åœ¨è´¨é‡è¿œä¸åªæ˜¯ç®€å•æ€§/æ€§èƒ½æ—¶ä½¿ç”¨å®ƒï¼‰ã€‚å¦‚æœæˆ‘ä»¬ç›®è§†æ£€æŸ¥å‡é‡‡æ ·æ“ä½œï¼Œåˆ™å¯ä»¥åœ¨å¥‡/å¥‡ç»„åˆä¸­çœ‹åˆ°æ›´å¤šçš„å‰©ä½™æ··å ï¼ˆä»…çœ‹å¯¹è§’çº¿è¾¹ç¼˜ï¼‰ï¼š</p><p>  The second reason, IMO a more important one is how easily they align images. And this is why GPU sampling has this â€œinfamousâ€ half a pixel offset.</p><p>  ç¬¬äºŒä¸ªåŸå› ï¼ŒIMOæ›´é‡è¦çš„ä¸€ä¸ªåŸå› æ˜¯å®ƒä»¬å¯¹é½å›¾åƒçš„å®¹æ˜“ç¨‹åº¦ã€‚è¿™å°±æ˜¯GPUé‡‡æ ·å…·æœ‰â€œè‡­åæ˜­è‘—â€çš„åŠåƒç´ åç§»çš„åŸå› ã€‚</p><p>  Ok, so my favorite part starts â€“ half pixel offsets! Source of pain, frustration, misunderstanding, but also a super reasonable and robust way of representing texture and pixel coordinates. If you started graphics programming relatively recently (DX10+ era) or are not a graphics programmer â€“ this might be not a big deal for you. But basically, with older graphics APIs framebuffer coordinates didnâ€™t have a half texel offset, while the texture sampler expected it, so you had to add it manually. Sometimes people added it in the vertex shader, sometimes in the pixel shader, sometimes setting up uniforms on the CPUâ€¦ a complete mess; it was a source of endless bugs found almost every day, especially on video games shipping on multiple platforms / APIs!</p><p>  å¥½çš„ï¼Œæ‰€ä»¥æˆ‘æœ€å–œæ¬¢çš„éƒ¨åˆ†å¼€å§‹äº†â€“åŠåƒç´ åç§»ï¼ç—›è‹¦ï¼Œæ²®ä¸§ï¼Œè¯¯è§£çš„æ ¹æºï¼Œä¹Ÿæ˜¯è¡¨ç¤ºçº¹ç†å’Œåƒç´ åæ ‡çš„ä¸€ç§è¶…çº§åˆç†è€Œå¼ºå¤§çš„æ–¹æ³•ã€‚å¦‚æœæ‚¨æ˜¯æœ€è¿‘æ‰å¼€å§‹è¿›è¡Œå›¾å½¢ç¼–ç¨‹ï¼ˆDX10 +æ—¶ä»£ï¼‰çš„äººï¼Œæˆ–è€…æ‚¨ä¸æ˜¯å›¾å½¢ç¨‹åºå‘˜ï¼Œé‚£ä¹ˆè¿™å¯¹æ‚¨æ¥è¯´å¹¶ä¸é‡è¦ã€‚ä½†åŸºæœ¬ä¸Šï¼Œä½¿ç”¨è¾ƒæ—§çš„å›¾å½¢APIæ—¶ï¼Œå¸§ç¼“å†²åŒºåæ ‡æ²¡æœ‰texelåç§»çš„ä¸€åŠï¼Œè€Œçº¹ç†é‡‡æ ·å™¨å´å¸Œæœ›å¦‚æ­¤ï¼Œå› æ­¤æ‚¨å¿…é¡»æ‰‹åŠ¨æ·»åŠ å®ƒã€‚æœ‰æ—¶äººä»¬å°†å…¶æ·»åŠ åˆ°é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œæœ‰æ—¶å°†å…¶æ·»åŠ åˆ°åƒç´ ç€è‰²å™¨ä¸­ï¼Œæœ‰æ—¶åœ¨CPUä¸Šè®¾ç½®åˆ¶æœã€‚è¿™å‡ ä¹æ˜¯æ¯å¤©éƒ½æœ‰æ— å°½é”™è¯¯çš„æ¥æºï¼Œå°¤å…¶æ˜¯åœ¨é€šè¿‡å¤šç§å¹³å°/ APIå‘è¡Œçš„è§†é¢‘æ¸¸æˆä¸­ï¼ </p><p>   They can be [0, 1, 2, 3]. But GPUs use a convention of half pixel offsets, so they end up being [0.5, 1.5, 2.5, 3.5]. This translates to UVs, or â€œnormalizedâ€ coordinates [0.5/4, 1.5/4, 2.5/4, 3.5/4], which spans a range of [0.5/width, 1 â€“ 0.5/width].</p><p>å®ƒä»¬å¯ä»¥æ˜¯[0ï¼Œ1ï¼Œ2ï¼Œ3]ã€‚ä½†æ˜¯GPUä½¿ç”¨åŠåƒç´ åç§»çš„æƒ¯ä¾‹ï¼Œå› æ­¤å®ƒä»¬æœ€ç»ˆä¸º[0.5ã€1.5ã€2.5ã€3.5]ã€‚è¿™å°†è½¬æ¢ä¸ºUVæˆ–â€œå½’ä¸€åŒ–â€åæ ‡[0.5 / 4ã€1.5 / 4ã€2.5 / 4ã€3.5 / 4]ï¼Œå…¶èŒƒå›´ä¸º[0.5 / widthï¼Œ1 â€“ 0.5 / width]ã€‚</p><p> This representation seems counterintuitive at first, but what it provides us is a guarantee and convention that the  image corners are placed at  [0 and 1] normalized, or [0, width] unnormalized.</p><p> èµ·åˆï¼Œè¿™ç§è¡¨ç¤ºæ–¹å¼ä¼¼ä¹è¿åç›´è§‰ï¼Œä½†æ˜¯å®ƒä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªä¿è¯å’Œçº¦å®šï¼Œå³å›¾åƒè§’ä½äº[0å’Œ1]å½’ä¸€åŒ–ï¼Œæˆ–[0ï¼Œå®½åº¦]æœªå½’ä¸€åŒ–ã€‚</p><p>     While the half a pixel align pixel corners,  the other way of down/upsampling comes from aligning the first pixel centers in the image.</p><p>     å½“åŠä¸ªåƒç´ å¯¹é½åƒç´ è§’æ—¶ï¼Œå‘ä¸‹/ä¸Šé‡‡æ ·çš„å¦ä¸€ç§æ–¹å¼æ¥è‡ªå¯¹é½å›¾åƒä¸­çš„ç¬¬ä¸€ä¸ªåƒç´ ä¸­å¿ƒã€‚</p><p> Now, letâ€™s have a look at how we compute the bilinear upsampling weights in the half a pixel shift convention:</p><p> ç°åœ¨ï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸‹å¦‚ä½•åœ¨åŠåƒç´ ç§»ä½æƒ¯ä¾‹ä¸­è®¡ç®—åŒçº¿æ€§ä¸Šé‡‡æ ·æƒé‡ï¼š</p><p>  This convention makes it amazingly simple and obvious where the weights come from â€“ and how simple the computation is once we align the grid corners. I personally use it as well even in APIs outside of GPU shader realm â€“ everything is easier. If adding and removing 0.5 adds performance cost, then can be removed at microoptimizations stage, but usually doesnâ€™t matter that much.</p><p>  è¯¥çº¦å®šä½¿æƒé‡ä»ä½•å¤„å˜å¾—éå¸¸ç®€å•æ˜äº†ï¼Œè€Œä¸”ä¸€æ—¦å¯¹é½ç½‘æ ¼è§’ï¼Œè®¡ç®—å°±å˜å¾—å¤šä¹ˆç®€å•ã€‚å³ä½¿åœ¨GPUç€è‰²å™¨é¢†åŸŸä¹‹å¤–çš„APIä¸­ï¼Œæˆ‘ä¹Ÿäº²è‡ªä½¿ç”¨å®ƒ-ä¸€åˆ‡éƒ½å˜å¾—æ›´åŠ å®¹æ˜“ã€‚å¦‚æœæ·»åŠ å’Œåˆ é™¤0.5ä¼šå¢åŠ æ€§èƒ½æˆæœ¬ï¼Œåˆ™å¯ä»¥åœ¨å¾®ä¼˜åŒ–é˜¶æ®µå°†å…¶åˆ é™¤ï¼Œä½†é€šå¸¸æ²¡å…³ç³»ã€‚</p><p>  Half a pixel offset for pixel centers used in GPU convention for both pixels and texels is a reasonable default for any image processing code dealing with images of different resolutions.</p><p>  å¯¹äºå¤„ç†ä¸åŒåˆ†è¾¨ç‡å›¾åƒçš„ä»»ä½•å›¾åƒå¤„ç†ä»£ç ï¼ŒGPUçº¦å®šä¸­é’ˆå¯¹åƒç´ å’Œçº¹ç†åƒç´ ä½¿ç”¨çš„åƒç´ ä¸­å¿ƒçš„åŠä¸ªåƒç´ åç§»æ˜¯ä¸€ä¸ªåˆç†çš„é»˜è®¤å€¼ã€‚</p><p> This is expecially important when to dealing with textures of different resolutions and for example mip maps of non power of 2 textures. A texture with 9 texels instead of 4? No problem:</p><p> åœ¨å¤„ç†ä¸åŒåˆ†è¾¨ç‡çš„çº¹ç†ï¼ˆä¾‹å¦‚ï¼Œ2å¹‚çš„éå¹‚çš„mipè´´å›¾ï¼‰æ—¶ï¼Œè¿™ç‰¹åˆ«é‡è¦ã€‚ 9çº¹ç´ è€Œä¸æ˜¯4çš„çº¹ç†ï¼Ÿæ²¡é—®é¢˜ï¼š </p><p>  It makes sure that grids are aligned, and the up/downsampling operations â€œjust workâ€. To get box/bilinear downsampling, you can just take a single bilinear tap of the source texture, the same with the upsampling.</p><p>å®ƒç¡®ä¿ç½‘æ ¼å¯¹é½ï¼Œå¹¶ä¸”ä¸Š/ä¸‹é‡‡æ ·æ“ä½œâ€œæ­£å¸¸å·¥ä½œâ€ã€‚è¦è·å¾—ç›’/åŒçº¿æ€§ä¸‹é‡‡æ ·ï¼Œæ‚¨åªéœ€å¯¹æºçº¹ç†è¿›è¡Œä¸€æ¬¡åŒçº¿æ€§æŠ½å¤´ï¼Œä¸ä¸Šé‡‡æ ·ç›¸åŒã€‚</p><p> So trivial to use it that when you start graphics programming, you rarely think about it. Which is a double edge sword â€“ both great for an easy entry point for beginners, but also a source of confusion once you start getting deeper into it and analyzing whatâ€™s going on or do things like fractional or nearest neighbor downsampling (or e.g. create a non-interpolable depth map pyramidâ€¦).</p><p> ä½¿ç”¨å®ƒæ˜¯å¦‚æ­¤ç®€å•ï¼Œä»¥è‡³äºå½“æ‚¨å¼€å§‹å›¾å½¢ç¼–ç¨‹æ—¶ï¼Œæ‚¨å¾ˆå°‘è€ƒè™‘å®ƒã€‚è¿™æ˜¯ä¸€æŠŠåŒåˆƒå‰‘â€“æ—¢å¾ˆé€‚åˆåˆå­¦è€…å…¥é—¨ï¼Œä¹Ÿå¾ˆå®¹æ˜“å¼•èµ·æ··æ·†ï¼Œä¸€æ—¦æ‚¨å¼€å§‹æ·±å…¥äº†è§£å®ƒå¹¶åˆ†ææ­£åœ¨å‘ç”Ÿçš„äº‹æƒ…æˆ–è¿›è¡Œå°æ•°æˆ–æœ€è¿‘é‚»é™é‡‡æ ·ï¼ˆä¾‹å¦‚åˆ›å»ºéé‡‡æ ·ï¼‰ã€‚ -å¯æ’å…¥çš„æ·±åº¦å›¾é‡‘å­—å¡”â€¦ï¼‰ã€‚</p><p> Even if there were no other reasons, this is why Iâ€™d recommend treating phase shifting box downsample and the [0.25 0.75] / [0.75 0.25] upsamplers  as your default when talking about bilinear as well.</p><p> å³ä½¿æ²¡æœ‰å…¶ä»–åŸå› ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæˆ‘å»ºè®®åœ¨è®¨è®ºåŒçº¿æ€§æ—¶å°†ç§»ç›¸ç®±ä¸‹é‡‡æ ·å’Œ[0.25 0.75] / [0.75 0.25]ä¸Šé‡‡æ ·å™¨ä½œä¸ºé»˜è®¤è®¾ç½®çš„åŸå› ã€‚</p><p> Bonus advantage: having texel coordinates shifted by 0.5 means that if you want to get an integer coordinate â€“ for example for texelFetch instruction â€“ you donâ€™t need to round. Floor / truncation (which in some settings can be a cheaper operation) gives you the closest pixel integer coordinate to index!</p><p> ä¼˜ç‚¹ï¼šå°†texelåæ ‡åç§»0.5æ„å‘³ç€å¦‚æœè¦è·å–æ•´æ•°åæ ‡ï¼ˆä¾‹å¦‚texelFetchæŒ‡ä»¤ï¼‰ï¼Œåˆ™æ— éœ€å››èˆäº”å…¥ã€‚åœ°æ¿/æˆªæ–­ï¼ˆåœ¨æŸäº›è®¾ç½®ä¸‹å¯ä»¥æ›´ä¾¿å®œçš„æ“ä½œï¼‰ä¸ºæ‚¨æä¾›æœ€æ¥è¿‘çš„åƒç´ æ•´æ•°åæ ‡ä»¥è¿›è¡Œç´¢å¼•ï¼</p><p> Note:  Tensorflow got it wrong. The â€œalign_cornersâ€ parameter alignsâ€¦ centers of the corner pixels??? This is a really bad and weird naming plus design choice, where upsampling a [0.0 1.0] by factor of 2 produces [0, 1/3, 2/3, 1], which is something completely unexpected and different from either of the conventions I described here.</p><p> æ³¨æ„ï¼šTensorflowå¼„é”™äº†ã€‚ â€œ align_cornersâ€å‚æ•°å¯¹é½â€¦è§’è½åƒç´ çš„ä¸­å¿ƒï¼Ÿï¼Ÿï¼Ÿè¿™æ˜¯ä¸€ä¸ªéå¸¸ç³Ÿç³•çš„å‘½ååŠ ä¸Šè®¾è®¡é€‰æ‹©ï¼Œå°†[0.0 1.0]ä¹˜ä»¥2ä¼šäº§ç”Ÿ[0ï¼Œ1/3ï¼Œ2/3ï¼Œ1]ï¼Œè¿™æ˜¯å®Œå…¨å‡ºä¹æ„æ–™çš„ï¼Œå¹¶ä¸”ä¸ä»»ä½•ä¸€ç§çº¦å®šéƒ½ä¸åŒæˆ‘åœ¨è¿™é‡Œæè¿°äº†ã€‚</p><p>  I love writing about signal processing and analyzing signals also in the frequency domain, so let me explain here how you can model bilinear up/downsampling in the EE / signal processing framework.</p><p>  æˆ‘å–œæ¬¢å†™å…³äºä¿¡å·å¤„ç†å’Œåœ¨é¢‘åŸŸä¸­åˆ†æä¿¡å·çš„æ–‡ç« ï¼Œæ‰€ä»¥è®©æˆ‘åœ¨è¿™é‡Œè§£é‡Šå¦‚ä½•åœ¨EE /ä¿¡å·å¤„ç†æ¡†æ¶ä¸­å¯¹åŒçº¿æ€§ä¸Š/ä¸‹é‡‡æ ·å»ºæ¨¡ã€‚</p><p>  If you never heard of this way of looking at it (especially the zero insertion), itâ€™s most likely because in practice nobody in practice (at least in graphics or image processing) implements it like this, it would be super wasteful to do it in such a sequence. ğŸ™‚</p><p>  å¦‚æœæ‚¨ä»æœªå¬è¯´è¿‡è¿™ç§æŸ¥çœ‹æ–¹å¼ï¼ˆå°¤å…¶æ˜¯é›¶æ’å…¥ï¼‰ï¼Œåˆ™å¾ˆå¯èƒ½æ˜¯å› ä¸ºå®é™…ä¸Šæ²¡æœ‰äººï¼ˆè‡³å°‘åœ¨å›¾å½¢æˆ–å›¾åƒå¤„ç†ä¸­ï¼‰å®ç°è¿™ç§æ–¹å¼ï¼Œè¿™æ ·åšéå¸¸æµªè´¹ã€‚è¿™æ ·çš„é¡ºåºã€‚ ğŸ™‚ </p><p>  Zero insertion is an interesting, counter-intuitive operation. You insert zeros between each element (often multiplying the original ones by 2x to preserve the constant/average energy in the signal; or we can fold this multiplication in our filter later) and get 2x more samples, but they are not very â€œusefulâ€. You have an image consisting of mostly â€œholesâ€â€¦</p><p>é›¶æ’å…¥æ˜¯ä¸€ä¸ªæœ‰è¶£çš„ï¼Œè¿åç›´è§‰çš„æ“ä½œã€‚æ‚¨åœ¨æ¯ä¸ªå…ƒç´ ä¹‹é—´æ’å…¥é›¶ï¼ˆé€šå¸¸å°†åŸå§‹å…ƒç´ ä¹˜ä»¥2xä»¥ä¿ç•™ä¿¡å·ä¸­çš„æ’å®š/å¹³å‡èƒ½é‡ï¼›æˆ–è€…æˆ‘ä»¬å¯ä»¥åœ¨ä»¥åçš„æ»¤æ³¢å™¨ä¸­å°†æ­¤ä¹˜ç§¯æŠ˜å ï¼‰ï¼Œå†è·å¾—2xçš„æ ·æœ¬ï¼Œä½†å®ƒä»¬å¹¶ä¸æ˜¯éå¸¸â€œæœ‰ç”¨â€ ã€‚æ‚¨çš„å›¾åƒä¸»è¦ç”±â€œå­”â€ç»„æˆ...</p><p>    From this plot, we can immediately see that with zero insertion, there are many high frequencies that were not there! All of those zeros create lots of high frequency coming from alternating and â€œoscillatingâ€ between the original signal, and zero. Filters that are â€œdilatedâ€ and have zeros in between coefficients (like a-trous / dilated convolution) are called  comb filters â€“ because they resemble a comb teeth!</p><p>    ä»è¯¥å›¾å¯ä»¥ç«‹å³çœ‹åˆ°é›¶æ’å…¥æ—¶æœ‰å¾ˆå¤šé«˜é¢‘ä¸å­˜åœ¨ï¼æ‰€æœ‰è¿™äº›é›¶éƒ½ä¼šç”±äºåŸå§‹ä¿¡å·å’Œé›¶ä¹‹é—´çš„äº¤æ›¿å’Œâ€œæŒ¯è¡â€è€Œäº§ç”Ÿå¤§é‡é«˜é¢‘ã€‚è¢«â€œæ‰©å¼ â€å¹¶åœ¨ç³»æ•°ä¹‹é—´ä¸ºé›¶çš„æ»¤æ³¢å™¨ï¼ˆå¦‚a-trous /æ‰©å¼ å·ç§¯ï¼‰è¢«ç§°ä¸ºæ¢³çŠ¶æ»¤æ³¢å™¨-å› ä¸ºå®ƒä»¬ç±»ä¼¼äºæ¢³é½¿ï¼</p><p> Letâ€™s look at it from the spectral analysis. Zero insertion duplicates the frequency spectrum:</p><p> è®©æˆ‘ä»¬ä»å…‰è°±åˆ†ææ¥çœ‹ä¸€ä¸‹ã€‚é›¶æ’å…¥ä¼šå¤åˆ¶é¢‘è°±ï¼š</p><p>  Every frequency of the original signal is duplicated, but we know that there were no frequencies like this present in the smaller resolution image; it wasnâ€™t possible to represent anything above its Nyquist! To fix that, we need to filter them out after this operation with a low pass filter:</p><p>  åŸå§‹ä¿¡å·çš„æ¯ä¸ªé¢‘ç‡éƒ½æ˜¯é‡å¤çš„ï¼Œä½†æ˜¯æˆ‘ä»¬çŸ¥é“åœ¨è¾ƒå°åˆ†è¾¨ç‡çš„å›¾åƒä¸­ä¸å­˜åœ¨è¿™æ ·çš„é¢‘ç‡ã€‚å¥ˆå¥æ–¯ç‰¹ä¸Šæ–¹ä¸å¯èƒ½ä»£è¡¨ä»»ä½•ä¸œè¥¿ï¼ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ­¤æ“ä½œä¹‹åä½¿ç”¨ä½é€šæ»¤æ³¢å™¨å°†å…¶è¿‡æ»¤æ‰ï¼š</p><p>  I have shown some remainder frequency content on purpose, as itâ€™s generally hard to do â€œperfectâ€ lowpass filtering (and itâ€™s also questionable if weâ€™d want this â€“ ringing problems etc).</p><p>  æˆ‘æ•…æ„æ˜¾ç¤ºäº†ä¸€äº›ä½™ä¸‹çš„é¢‘ç‡å†…å®¹ï¼Œå› ä¸ºé€šå¸¸å¾ˆéš¾åšåˆ°â€œå®Œç¾â€çš„ä½é€šæ»¤æ³¢ï¼ˆå¦‚æœæˆ‘ä»¬æƒ³è¦çš„è¯ï¼Œä¾‹å¦‚æŒ¯é“ƒé—®é¢˜ï¼Œè¿™ä¹Ÿå€¼å¾—æ€€ç–‘ï¼‰ã€‚</p><p> Here is how progressively filtered 1D signal looks like, notice high frequencies and â€œcombsâ€ disappearing:</p><p> è¿™æ˜¯ç»è¿‡é€æ­¥æ»¤æ³¢çš„ä¸€ç»´ä¿¡å·çš„æ ·å­ï¼Œæ³¨æ„åˆ°é«˜é¢‘å’Œâ€œæ¢³â€æ¶ˆå¤±äº†ï¼š</p><p>  Hereâ€™s an animation of blurring/filtering on the 2D image and how there it also causes this zero-inserted image to become more and more like just properly upsampled:</p><p>  è¿™æ˜¯2Då›¾ç‰‡ä¸Šçš„æ¨¡ç³Š/è¿‡æ»¤åŠ¨ç”»ï¼Œä»¥åŠå¦‚ä½•ä½¿è¿™å¼ é›¶æ’å…¥çš„å›¾ç‰‡å˜å¾—è¶Šæ¥è¶Šåƒæ­£ç¡®åœ°è¿›è¡Œè¿‡é‡‡æ ·å¤„ç†ï¼š </p><p>  Looks like image blending, but itâ€™s just blending filters â€“ imo itâ€™s pretty cool. ğŸ˜</p><p>çœ‹èµ·æ¥å¾ˆåƒå›¾åƒèåˆï¼Œä½†å®ƒåªæ˜¯èåˆæ»¤é•œ-imoéå¸¸é…·ã€‚ ğŸ˜</p><p>  Obviously, the choice of the blur (or technically â€“ lowpass) filter matters â€“ a lot. Some interesting connection: what if we convolve this zero-inserted signal with a  symmetric [0.5, 0.5] (or 1,1 if we didnâ€™t multiply the signal by 2 when inserting zeros) filter?</p><p>  æ˜¾ç„¶ï¼Œæ¨¡ç³Šï¼ˆæˆ–æŠ€æœ¯ä¸Šä¸ºä½é€šï¼‰æ»¤æ³¢å™¨çš„é€‰æ‹©éå¸¸é‡è¦ã€‚ä¸€äº›æœ‰è¶£çš„è”ç³»ï¼šå¦‚æœå°†è¿™ä¸ªé›¶æ’å…¥ä¿¡å·ä¸å¯¹ç§°[0.5ï¼Œ0.5]ï¼ˆå¦‚æœåœ¨æ’å…¥é›¶æ—¶ä¸å°†ä¿¡å·ä¹˜ä»¥2çš„è¯ï¼Œåˆ™ä¸º1,1ï¼‰è¿›è¡Œå·ç§¯è¯¥æ€ä¹ˆåŠï¼Ÿ</p><p>   The interesting part here is that we kind of  â€œreinventedâ€ the nearest neighbor filter! After a second of though, this should be intuitive; a sample that is zero gets contributions from the single non-zero neighbor, which is like a copy, while the sample that is non-zero is surrounded by two zeros, and they donâ€™t affect it.</p><p>   æœ‰è¶£çš„æ˜¯ï¼Œæˆ‘ä»¬æœ‰ç‚¹â€œæ”¹é€ â€äº†æœ€è¿‘çš„é‚»å±…è¿‡æ»¤å™¨ï¼ä¸€ç§’é’Ÿä¹‹åï¼Œè¿™åº”è¯¥å¾ˆç›´è§‚ã€‚é›¶æ ·æœ¬ä¼šä»å•ä¸ªéé›¶é‚»å±…è·å¾—è´¡çŒ®ï¼Œå°±åƒä¸€ä¸ªå‰¯æœ¬ï¼Œè€Œéé›¶æ ·æœ¬ä¼šè¢«ä¸¤ä¸ªé›¶åŒ…å›´ï¼Œå¹¶ä¸”å®ƒä»¬ä¸ä¼šå¯¹å…¶äº§ç”Ÿå½±å“ã€‚</p><p> We can see on the spectral / Fourier plot where the nearest neighbor hard edges and post-aliasing comes from (red part of the plot):</p><p> æˆ‘ä»¬å¯ä»¥åœ¨é¢‘è°±/å‚…ç«‹å¶å›¾ä¸Šçœ‹åˆ°æœ€è¿‘çš„ç›¸é‚»ç¡¬è¾¹å’Œåæ··å æ¥è‡ªå“ªé‡Œï¼ˆå›¾çš„çº¢è‰²éƒ¨åˆ†ï¼‰ï¼š</p><p>  The nearest neighbor upsampling is also shifting the signal (because it is even number of samples) and will work well to undo the box downsampling filter, which fits the common intuition of replicating samples being the â€œreverseâ€ of box filtering and causing no shift problem.</p><p>  æœ€è¿‘çš„é‚»å±…ä¸Šé‡‡æ ·ä¹Ÿä¼šç§»åŠ¨ä¿¡å·ï¼ˆå› ä¸ºå®ƒæ˜¯é‡‡æ ·æ•°çš„å¶æ•°ï¼‰ï¼Œå¹¶ä¸”å¯ä»¥å¾ˆå¥½åœ°æ’¤æ¶ˆç›’ä¸‹é‡‡æ ·æ»¤æ³¢å™¨ï¼Œè¿™ç¬¦åˆå¤åˆ¶é‡‡æ ·çš„é€šå¸¸ç›´è§‰ï¼Œå³ç›’æ»¤æ³¢çš„â€œåå‘â€å¹¶ä¸”ä¸ä¼šå¼•èµ·ç§»ä½é—®é¢˜ã€‚</p><p>  Letâ€™s have a look at how the strategy of â€œkeep one sample, interpolate betweenâ€ can be represented in this framework.</p><p>  è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹å¦‚ä½•åœ¨æ­¤æ¡†æ¶ä¸­è¡¨ç¤ºâ€œä¿ç•™ä¸€ä¸ªæ ·æœ¬ï¼Œåœ¨ä¸¤ä¸ªæ ·æœ¬ä¹‹é—´è¿›è¡Œæ’å€¼â€çš„ç­–ç•¥ã€‚</p><p> Itâ€™s equivalent to  filtering our zero-upsampled image with a [0.25 0.5 0.25] filter.</p><p> è¿™ç­‰æ•ˆäºä½¿ç”¨[0.25 0.5 0.25]è¿‡æ»¤å™¨è¿‡æ»¤é›¶è¿‡é‡‡æ ·çš„å›¾åƒã€‚ </p><p> The problem is that in such setup, if we multiply the weights two (to keep average signal the same) and then by zeros (where the signal is zero), we get alternating [0.0 1.0 0.0] and [0.5 0.0 0.5] filters, with very different frequency response and variance reductionâ€¦Â Iâ€™ll reference you here again to my previous blog post on it, but basically you get  alternating 1.0 and 0.5 of original signal variance (sum of effective weights squared).</p><p>é—®é¢˜åœ¨äºï¼Œåœ¨è¿™ç§è®¾ç½®ä¸­ï¼Œå¦‚æœæˆ‘ä»¬å°†æƒé‡ä¹˜ä»¥2ï¼ˆä»¥ä½¿å¹³å‡ä¿¡å·ä¿æŒç›¸åŒï¼‰ï¼Œç„¶åå†ä¹˜ä»¥é›¶ï¼ˆå…¶ä¸­ä¿¡å·ä¸ºé›¶ï¼‰ï¼Œåˆ™ä¼šå¾—åˆ°äº¤æ›¿çš„[0.0 1.0 0.0]å’Œ[0.5 0.0 0.5]æ»¤æ³¢å™¨ï¼Œå…·æœ‰éå¸¸ä¸åŒçš„é¢‘ç‡å“åº”å’Œæ–¹å·®å‡å°...æˆ‘å°†åœ¨è¿™é‡Œå†æ¬¡å‚è€ƒæˆ‘ä»¥å‰çš„åšå®¢æ–‡ç« ï¼Œä½†æ˜¯åŸºæœ¬ä¸Šæ‚¨ä¼šäº¤æ›¿è·å¾—åŸå§‹ä¿¡å·æ–¹å·®çš„1.0å’Œ0.5ï¼ˆæœ‰æ•ˆæƒé‡å¹³æ–¹çš„æ€»å’Œï¼‰ã€‚</p><p>  The second approach of alternating weights of [0.25 0.75] can be seen as simply: nearest neighbor upsampling â€“ a filter of [0.5 0.5], and then [0.25 0.5 0.25] filtering!</p><p>  æƒé‡ä¸º[0.25 0.75]çš„ç¬¬äºŒç§æ–¹æ³•å¯ä»¥ç®€å•åœ°çœ‹åšï¼šæœ€è¿‘é‚»å±…ä¸Šé‡‡æ ·â€“è¿‡æ»¤[0.5 0.5]ï¼Œç„¶åè¿‡æ»¤[0.25 0.5 0.25]ï¼</p><p> This sequence of two convolutions gives us an effective kernel of  [0.125 0.375 0.375 0.125] on the zero inserted image, so if we multiply it by 2 simply alternating [0.25 0.0 0.75 0.0] and [0.0 0.75 0.0 0.25].  Corners aligned bilinear upsampling (standard bilinear upsampling on the GPU) is exactly the same as the â€œmagic kernelâ€! ğŸ™‚Â This is also this second, more complicated explanation of bilinear 0.25 0.75 weights I promised.</p><p> ä¸¤ä¸ªå·ç§¯çš„åºåˆ—åœ¨é›¶æ’å…¥å›¾åƒä¸Šä¸ºæˆ‘ä»¬æä¾›äº†[0.125 0.375 0.375 0.125]çš„æœ‰æ•ˆæ ¸ï¼Œå› æ­¤ï¼Œå¦‚æœå°†å…¶ä¹˜ä»¥2ï¼Œåˆ™åªéœ€äº¤æ›¿äº¤æ›¿[0.25 0.0 0.75 0.0]å’Œ[0.0 0.75 0.0 0.25]ã€‚è§’å¯¹é½çš„åŒçº¿æ€§ä¸Šé‡‡æ ·ï¼ˆGPUä¸Šçš„æ ‡å‡†åŒçº¿æ€§ä¸Šé‡‡æ ·ï¼‰ä¸â€œé­”æœ¯æ ¸â€å®Œå…¨ç›¸åŒï¼ alsoè¿™ä¹Ÿæ˜¯æˆ‘ç­”åº”çš„ç¬¬äºŒä¸ªæ›´å¤æ‚çš„åŒçº¿æ€§0.25 0.75æƒé‡çš„è§£é‡Šã€‚</p><p> Advantage of it is that with the effective weight of [0.25 0.75] and [0.75 0.25] (ignoring zeros) on alternating pixels, they have the same amount of filtering and  variance reduction of 0.625 â€“ very important!</p><p> è¿™æ ·åšçš„ä¼˜ç‚¹æ˜¯ï¼Œåœ¨äº¤æ›¿åƒç´ ä¸Šçš„æœ‰æ•ˆæƒé‡ä¸º[0.25 0.75]å’Œ[0.75 0.25]ï¼ˆå¿½ç•¥é›¶ï¼‰ï¼Œå®ƒä»¬å…·æœ‰ç›¸åŒçš„è¿‡æ»¤é‡å’Œ0.625çš„æ–¹å·®å‡å°â€“éå¸¸é‡è¦ï¼</p><p>    Neither is perfect, but the even one will generally cause you less â€œproblemsâ€.</p><p>    ä¸¤è€…éƒ½ä¸æ˜¯å®Œç¾çš„ï¼Œä½†æ˜¯å¶æ•°é€šå¸¸ä¼šå‡å°‘æ‚¨çš„â€œé—®é¢˜â€ã€‚</p><p>  By comparison, downsampling process should be a bit more familiar to readers who have done some computer graphics or image processing and know of aliasing in this context.</p><p>  ç›¸æ¯”ä¹‹ä¸‹ï¼Œè¿›è¡Œè¿‡ä¸€äº›è®¡ç®—æœºå›¾å½¢æˆ–å›¾åƒå¤„ç†å¹¶äº†è§£è¿™ç§æƒ…å†µä¸‹åˆ«åçš„è¯»è€…åº”è¯¥å¯¹ä¸‹é‡‡æ ·è¿‡ç¨‹æ›´ä¸ºç†Ÿæ‚‰ã€‚</p><p> Downsampling consists of two steps in opposite order:  1. Filtering the signal.  2. Decimating the signal by discarding every other sample.</p><p> ä¸‹é‡‡æ ·åŒ…æ‹¬ä¸¤ä¸ªç›¸åçš„æ­¥éª¤ï¼š1.è¿‡æ»¤ä¿¡å·ã€‚ 2.é€šè¿‡ä¸¢å¼ƒå…¶ä»–æ‰€æœ‰æ ·æœ¬æ¥æŠ½å–ä¿¡å·ã€‚ </p><p> The ordering and step no 1 is important, as the second step, decimating is equivalent to (re)sampling. If we donâ€™t filter the signal spectrum above frequencies representible in the new resolution, we are going to end up with aliasing, folding back of frequencies above previous half Nyquist:</p><p>æ’åºå’Œç¬¬1æ­¥å¾ˆé‡è¦ï¼Œå› ä¸ºç¬¬äºŒæ­¥ï¼ŒæŠ½å–ç­‰æ•ˆäºï¼ˆé‡æ–°ï¼‰é‡‡æ ·ã€‚å¦‚æœæˆ‘ä»¬ä¸å¯¹æ–°åˆ†è¾¨ç‡æ‰€èƒ½ä»£è¡¨çš„é¢‘ç‡ä¹‹ä¸Šçš„ä¿¡å·é¢‘è°±è¿›è¡Œæ»¤æ³¢ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†æœ€ç»ˆäº§ç”Ÿæ··å ï¼Œå°†é¢‘ç‡å›è½åˆ°å‰ä¸€åŠå¥ˆå¥æ–¯ç‰¹ä¹‹ä¸Šï¼š</p><p>     First antialiasing filter weâ€™d want to analyze would be our old friend â€œlinear in box disguiseâ€, [0.5, 0.5] filter. It is definitely imperfect, and we can see  both blurring, and some leftover aliasing:</p><p>     æˆ‘ä»¬è¦åˆ†æçš„ç¬¬ä¸€ä¸ªæŠ—é”¯é½¿æ»¤æ³¢å™¨æ˜¯æˆ‘ä»¬çš„è€æœ‹å‹â€œçº¿æ€§ä¼ªè£…â€æ»¤æ³¢å™¨[0.5ï¼Œ0.5]ã€‚è¿™ç»å¯¹æ˜¯ä¸å®Œç¾çš„ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ¨¡ç³Šå’Œæ®‹ç•™çš„æ··å ï¼š</p><p>  The Graphics community realized this a while ago â€“ when doing a series of downsamples for post-processing,  for example bloom / glare; the default box/tent/bilinear filters are pretty bad in such case. Even small aliasing like this can be really bad when it gets â€œblownâ€ to the whole screen, and especially in motion. It was even a large chunk of Siggraph presentations, like  this excellent one from my friend Jorge Jimenez.</p><p>  å›¾å½¢ç¤¾åŒºä¸ä¹…å‰å°±æ„è¯†åˆ°äº†è¿™ä¸€ç‚¹â€“åœ¨è¿›è¡Œä¸€ç³»åˆ—åæœŸå¤„ç†çš„ä¸‹é‡‡æ ·æ—¶ï¼Œä¾‹å¦‚å…‰æ™•/çœ©å…‰ï¼›åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé»˜è®¤çš„æ¡†/å¸ç¯·/åŒçº¿æ€§è¿‡æ»¤å™¨éå¸¸ç³Ÿç³•ã€‚å½“è¿™æ ·çš„å°æ··å â€œå¹â€åˆ°æ•´ä¸ªå±å¹•æ—¶ï¼Œå°¤å…¶æ˜¯åœ¨è¿åŠ¨ä¸­ï¼Œè¿™ç§æƒ…å†µç¡®å®å¾ˆç³Ÿç³•ã€‚è¿™ç”šè‡³æ˜¯Siggraphæ¼”ç¤ºæ–‡ç¨¿ä¸­çš„å¾ˆå¤§ä¸€éƒ¨åˆ†ï¼Œä¾‹å¦‚æˆ‘çš„æœ‹å‹Jorge Jimenezçš„å‡ºè‰²æ¼”è®²ã€‚</p><p> I also had a personal stab at addressing it early in my career, and even described the idea â€“ weird cross filter (because it was fast on the GPU) â€“ please donâ€™t do it, itâ€™s a bad idea and very  outdated! ğŸ™‚</p><p> åœ¨æˆ‘èŒä¸šç”Ÿæ¶¯çš„æ—©æœŸï¼Œæˆ‘ä¹Ÿå¾ˆæƒ³è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œç”šè‡³æè¿°äº†è¿™ä¸ªæƒ³æ³•â€“å¥‡æ€ªçš„äº¤å‰æ»¤é•œï¼ˆå› ä¸ºå®ƒåœ¨GPUä¸Šé€Ÿåº¦å¾ˆå¿«ï¼‰â€“è¯·ä¸è¦è¿™æ ·åšï¼Œè¿™æ˜¯ä¸€ä¸ªåä¸»æ„ï¼Œè€Œä¸”å·²ç»è¿‡æ—¶äº†ï¼ ğŸ™‚</p><p>  By comparison the odd bilinear filter (that doesnâ€™t shift the phase) looks like a little different trade-off:</p><p>  ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¥‡æ•°åŒçº¿æ€§æ»¤æ³¢å™¨ï¼ˆä¸ä¼šç§»åŠ¨ç›¸ä½ï¼‰çœ‹èµ·æ¥æœ‰ç‚¹ä¸åŒï¼š</p><p>  Less aliasing, more blurring. It might be better for many cases, but the trade-offs from breaking the half-pixel / corners aligned convention are IMO unacceptable. And itâ€™s also more costly (not possible to do a single tap 2x downsampling).</p><p>  æ›´å°‘çš„é”¯é½¿ï¼Œæ›´æ¨¡ç³Šã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹å¯èƒ½ä¼šæ›´å¥½ï¼Œä½†æ˜¯ä»ç ´ååŠåƒç´ /è§’ç‚¹å¯¹é½çº¦å®šçš„å–èˆæ˜¯IMOä¸èƒ½æ¥å—çš„ã€‚è€Œä¸”ä»·æ ¼ä¹Ÿæ›´é«˜ï¼ˆæ— æ³•ä¸€æ¬¡ç‚¹å‡»2å€ä¸‹é‡‡æ ·ï¼‰ã€‚</p><p> To get better results -&gt; youâ€™ll need more samples, some of them with negative lobes. And you can design an even filter with more samples too, for example even Lanczos:</p><p> ä¸ºäº†è·å¾—æ›´å¥½çš„ç»“æœ-ï¼†gt;æ‚¨å°†éœ€è¦æ›´å¤šæ ·æœ¬ï¼Œå…¶ä¸­ä¸€äº›æ ·æœ¬å¸¦æœ‰è´Ÿç“£ã€‚æ‚¨è¿˜å¯ä»¥è®¾è®¡ä¸€ä¸ªåŒ…å«æ›´å¤šæ ·æœ¬çš„å‡åŒ€æ»¤æ³¢å™¨ï¼Œä¾‹å¦‚Lanczosï¼š </p><p>   One interesting thing that has occurred to me on a few occasions is that the trade-offs for low pass filtering for upsampling and downsampling are different. If you use a â€œperfectâ€ upsampling lowpass filter, you will end up with nasty ringing.</p><p>åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘å‘ç”Ÿçš„ä¸€ä»¶æœ‰è¶£çš„äº‹æƒ…æ˜¯ï¼Œå¯¹äºä½é‡‡æ ·ç‡å’Œä¸Šé‡‡æ ·ç‡çš„æƒè¡¡å–èˆæ˜¯ä¸åŒçš„ã€‚å¦‚æœæ‚¨ä½¿ç”¨â€œå®Œç¾â€çš„ä¸Šé‡‡æ ·ä½é€šæ»¤æ³¢å™¨ï¼Œåˆ™ä¼šå¯¼è‡´è®¨åŒçš„æŒ¯é“ƒã€‚</p><p> This is typically not the case for downsampling. So you can opt for a sharper filter when downsampling, and a less sharp for upsampling, and this is what Photoshop suggests as well:</p><p> ä¸‹é‡‡æ ·é€šå¸¸ä¸æ˜¯è¿™ç§æƒ…å†µã€‚å› æ­¤ï¼Œåœ¨é™é‡‡æ ·æ—¶ï¼Œæ‚¨å¯ä»¥é€‰æ‹©è¾ƒé”åˆ©çš„æ»¤é•œï¼Œè€Œåœ¨å‡é‡‡æ ·æ—¶ï¼Œåˆ™å¯ä»¥é€‰æ‹©è¾ƒä¸é”åˆ©çš„æ»¤é•œï¼Œè¿™ä¹Ÿæ˜¯Photoshopçš„å»ºè®®ï¼š</p><p>   I hope that my blog post helped to clarify some common confusions coming from using the same, very broad terms to represent some different operations.</p><p>   æˆ‘å¸Œæœ›æˆ‘çš„åšå®¢æ–‡ç« æœ‰åŠ©äºæ¾„æ¸…ä½¿ç”¨ç›¸åŒçš„éå¸¸å¹¿æ³›çš„æœ¯è¯­æ¥è¡¨ç¤ºæŸäº›ä¸åŒæ“ä½œæ‰€å¼•èµ·çš„ä¸€äº›å¸¸è§æ··æ·†ã€‚</p><p>  There are  a few ways of doing bilinear upsampling and downsampling. Make sure that whatever you use uses the same convention and  doesnâ€™t shift your image after down/upsampling.</p><p>  æœ‰å‡ ç§æ–¹æ³•å¯ä»¥è¿›è¡ŒåŒçº¿æ€§ä¸Šé‡‡æ ·å’Œä¸‹é‡‡æ ·ã€‚ç¡®ä¿æ‚¨ä½¿ç”¨çš„ä»»ä½•å†…å®¹éƒ½ä½¿ç”¨ç›¸åŒçš„çº¦å®šï¼Œå¹¶ä¸”åœ¨ä¸‹é‡‡æ ·/ä¸Šé‡‡æ ·åä¸ä¼šåç§»å›¾åƒã€‚</p><p> Half pixel center offset is a very convenient convention. It ensures that  image borders and corners are aligned. It is default on the GPU and happens automatically. When working on the CPU/DSP, itâ€™s worth using the same convention.</p><p> åŠåƒç´ ä¸­å¿ƒåç§»æ˜¯ä¸€ä¸ªéå¸¸æ–¹ä¾¿çš„çº¦å®šã€‚å®ƒå¯ä»¥ç¡®ä¿å›¾åƒçš„è¾¹ç•Œå’Œè§’å¯¹é½ã€‚å®ƒæ˜¯GPUä¸Šçš„é»˜è®¤è®¾ç½®ï¼Œå¹¶ä¸”ä¼šè‡ªåŠ¨å‘ç”Ÿã€‚åœ¨CPU / DSPä¸Šå·¥ä½œæ—¶ï¼Œå€¼å¾—ä½¿ç”¨ç›¸åŒçš„çº¦å®šã€‚</p><p> Different ways of upsampling/downsampling have different freque</p><p> ä¸åŒçš„ä¸Šé‡‡æ ·/ä¸‹é‡‡æ ·æ–¹å¼å…·æœ‰ä¸åŒçš„é¢‘ç‡</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/">https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/åƒç´ /">#åƒç´ </a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pixel/">#pixel</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/é‡‡æ ·/">#é‡‡æ ·</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>