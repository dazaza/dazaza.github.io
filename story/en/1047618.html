<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Goä¸­çš„å—åˆ†æ Block Profiling in Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Block Profiling in Go<br/>Goä¸­çš„å—åˆ†æ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-10 00:20:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/431df62be2f4c604dc62513a6e7d1011.png"><img src="http://img2.diglog.com/img/2021/2/431df62be2f4c604dc62513a6e7d1011.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Permalink       This document was last updated for  go1.15.7 but probably still applies to older/newer versions for the most parts.</p><p>æ°¸ä¹…é“¾æ¥æœ¬æ–‡æ¡£æœ€åä¸€æ¬¡æ›´æ–°æ˜¯é’ˆå¯¹go1.15.7ï¼Œä½†åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ä»å¯èƒ½é€‚ç”¨äºæ—§/æ–°ç‰ˆæœ¬ã€‚</p><p>    The block profile in Go lets you analyze how much time your program spends waiting on the blocking operations listed below:</p><p>    Goä¸­çš„é˜»æ­¢é…ç½®æ–‡ä»¶å¯è®©æ‚¨åˆ†æç¨‹åºç­‰å¾…ä»¥ä¸‹é˜»æ­¢æ“ä½œæ‰€èŠ±è´¹çš„æ—¶é—´ï¼š</p><p>  Time is only tracked when Go has to suspend the goroutine&#39;s execution by parking it into a  waiting state. So for example a  Mutex.Lock() operation will not show up in your profile if the lock can be aquired immediately or via a short amount of  spinning.</p><p>  ä»…å½“Goå¿…é¡»é€šè¿‡å°†goroutineåœåœ¨ç­‰å¾…çŠ¶æ€æ¥ä¸­æ­¢æ‰§è¡Œgoroutineçš„æ‰§è¡Œæ—¶ï¼Œæ‰ä¼šè·Ÿè¸ªæ—¶é—´ã€‚å› æ­¤ï¼Œä¾‹å¦‚ï¼Œå¦‚æœå¯ä»¥ç«‹å³æˆ–é€šè¿‡å°‘é‡æ—‹è½¬æ¥è·å–é”ï¼Œåˆ™Mutex.Lockï¼ˆï¼‰æ“ä½œå°†ä¸ä¼šæ˜¾ç¤ºåœ¨æ‚¨çš„é…ç½®æ–‡ä»¶ä¸­ã€‚</p><p> The operations above are a subset of the  waiting states used by the Go runtime, i.e. the operations below  will not show up in a block profile:</p><p> ä¸Šé¢çš„æ“ä½œæ˜¯Goè¿è¡Œæ—¶ä½¿ç”¨çš„ç­‰å¾…çŠ¶æ€çš„å­é›†ï¼Œå³ä¸‹é¢çš„æ“ä½œä¸ä¼šæ˜¾ç¤ºåœ¨å—é…ç½®æ–‡ä»¶ä¸­ï¼š</p><p>    The block profiler is disabled by default. You can enable it by passing a  rate &gt; 0 as shown below.</p><p>    é»˜è®¤æƒ…å†µä¸‹ï¼Œå—åˆ†æå™¨æ˜¯ç¦ç”¨çš„ã€‚æ‚¨å¯ä»¥é€šè¿‡ä¼ é€’é€Ÿç‡ï¼†gt;æ¥å¯ç”¨å®ƒã€‚ 0å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚</p><p>  The  rate impacts the  Accuracy and  Overhead of the profiler. In the  docs the rate is described like this:</p><p>  é€Ÿç‡å½±å“æ¢æŸ¥å™¨çš„å‡†ç¡®æ€§å’Œå¼€é”€ã€‚åœ¨æ–‡æ¡£ä¸­ï¼Œé€Ÿç‡çš„æè¿°å¦‚ä¸‹ï¼š</p><p> SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.</p><p> SetBlockProfileRateæ§åˆ¶åœ¨é˜»æ­¢é…ç½®æ–‡ä»¶ä¸­æŠ¥å‘Šçš„goroutineé˜»æ­¢äº‹ä»¶çš„æ¯”ä¾‹ã€‚æ¢æŸ¥å™¨çš„ç›®çš„æ˜¯å¹³å‡æ¯é˜»å¡1çº³ç§’çš„é€Ÿç‡é‡‡æ ·ä¸€æ¬¡é˜»å¡äº‹ä»¶ã€‚ </p><p> To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &lt;= 0.</p><p>è¦å°†æ¯ä¸ªé˜»æ­¢äº‹ä»¶åŒ…æ‹¬åœ¨é…ç½®æ–‡ä»¶ä¸­ï¼Œåˆæ ¼ç‡=1ã€‚è¦å®Œå…¨å…³é—­åˆ†æï¼Œåˆæ ¼ç‡ï¼†lt; = 0ã€‚</p><p> Personally I struggle to parse the second sentence, and prefer to describe the  rate (aka  blockprofilerate) like this instead:</p><p> å°±æˆ‘ä¸ªäººè€Œè¨€ï¼Œæˆ‘å¾ˆéš¾è§£æç¬¬äºŒå¥è¯ï¼Œè€Œæ˜¯æ›´å–œæ¬¢è¿™æ ·æè¿°é€Ÿç‡ï¼ˆaka blockprofilerateï¼‰ï¼š</p><p> rate =&gt; 2 sets the sampling rate in  nanoseconds. Every event with a  duration &gt;= rate will be tracked. For events with a  duration &lt; rate, the profiler will  randomly sample  duration / rate events. E.g. if you have an event with a duration of  100ns and your rate is  1000ns, there is a  10% chance it will be tracked by the block profiler.</p><p> æ¯”ç‡=ï¼†gt; 2è®¾ç½®é‡‡æ ·ç‡ï¼ˆä»¥çº³ç§’ä¸ºå•ä½ï¼‰ã€‚æŒç»­æ—¶é—´ï¼†gt; =é€Ÿç‡çš„æ¯ä¸ªäº‹ä»¶éƒ½å°†è¢«è·Ÿè¸ªã€‚å¯¹äºæŒç»­æ—¶é—´ï¼†lt;é€Ÿç‡ï¼Œæ¢æŸ¥å™¨å°†éšæœºé‡‡æ ·æŒç»­æ—¶é—´/é€Ÿç‡äº‹ä»¶ã€‚ä¾‹å¦‚ã€‚å¦‚æœæ‚¨æœ‰ä¸€ä¸ªæŒç»­æ—¶é—´ä¸º100nsçš„äº‹ä»¶ï¼Œå¹¶ä¸”æ‚¨çš„é€Ÿç‡ä¸º1000nsï¼Œåˆ™å—åˆ†æå™¨å°†æœ‰10ï¼…çš„æœºä¼šå¯¹å…¶è¿›è¡Œè·Ÿè¸ªã€‚</p><p> Block durations are aggregated over the lifetime of the program (while the profiling is enabled). To get a  pprof formated snapshot of the current stack traces that lead to blocking events and their cumulative time duration, you can call:</p><p> å—æŒç»­æ—¶é—´ä¼šåœ¨ç¨‹åºçš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…æ±‡æ€»ï¼ˆå¯ç”¨æ¦‚è¦åˆ†ææ—¶ï¼‰ã€‚è¦è·å–å¯¼è‡´å †æ ˆäº‹ä»¶åŠå…¶ç´¯ç§¯æŒç»­æ—¶é—´çš„å½“å‰å †æ ˆè·Ÿè¸ªçš„pprofæ ¼å¼å¿«ç…§ï¼Œå¯ä»¥è°ƒç”¨ï¼š</p><p>  Alternatively you can use  github.com/pkg/profile for convenience, or  net/http/pprof to expose profiling via http, or use a  continious profiler to collect the data automatically in production.</p><p>  å¦å¤–ï¼Œä¸ºæ–¹ä¾¿èµ·è§ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨github.com/pkg/profileæˆ–net / http / pprofé€šè¿‡httpå…¬å¼€åˆ†æï¼Œæˆ–ä½¿ç”¨è¿ç»­åˆ†æå™¨åœ¨ç”Ÿäº§ä¸­è‡ªåŠ¨æ”¶é›†æ•°æ®ã€‚</p><p> Last but not least you can use the   runtime.BlockProfile API to get the same information in a structured format.</p><p> æœ€åä½†å¹¶éæœ€ä¸é‡è¦çš„ä¸€ç‚¹æ˜¯ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨runtime.BlockProfile APIä»¥ç»“æ„åŒ–æ ¼å¼è·å–ç›¸åŒçš„ä¿¡æ¯ã€‚</p><p>  tl;dr: A  blockprofilerate &gt;=  10000 (10Âµs) should have negligable impact on production apps, including those suffering from extreme contention.</p><p>  tlï¼› drï¼šå—é…ç½®ç‡ï¼†gt; = 10000ï¼ˆ10Âµsï¼‰å¯¹ç”Ÿäº§åº”ç”¨ç¨‹åºï¼ˆåŒ…æ‹¬é­å—æç«¯ç«äº‰çš„åº”ç”¨ç¨‹åºï¼‰çš„å½±å“åº”å¿½ç•¥ä¸è®¡ã€‚ </p><p>  Block profiling is essentially implemented like this inside of the Go runtime (see the links in the  Description above for real code):</p><p>å—åˆ†æåŸºæœ¬ä¸Šæ˜¯åœ¨Goè¿è¡Œæ—¶å†…éƒ¨å®ç°çš„ï¼ˆæœ‰å…³å®é™…ä»£ç ï¼Œè¯·å‚è§ä¸Šé¢çš„è¯´æ˜ä¸­çš„é“¾æ¥ï¼‰ï¼š</p><p> func  chansend( ...) {  var  t0  int64  if  blockprofilerate  &gt;  0 {  t0  =  cputicks() }  // ... park goroutine in waiting state while blocked ...  if  blockprofilerate  &gt;  0 {  cycles  :=  cputicks()  -  t0  if  blocksampled( cycles) {  saveblockevent( cycles) } }}</p><p> func chansendï¼ˆ...ï¼‰{å¦‚æœblockprofilerateï¼†gt;åˆ™ä¸ºvar t0 int64ï¼› 0 {t0 = cputicksï¼ˆï¼‰} // ...åœ¨é˜»å¡çŠ¶æ€ä¸‹å°†goroutineåœåœ¨ç­‰å¾…çŠ¶æ€...å¦‚æœblockprofilerateï¼†gt; 0 {å‘¨æœŸï¼š= cputicksï¼ˆï¼‰-å¦‚æœblocksampledï¼ˆå‘¨æœŸï¼‰{saveblockeventï¼ˆå‘¨æœŸï¼‰}}}</p><p> This means that unless you enable block profiling, the overhead should be effectively zero thanks to CPU branch prediction.</p><p> è¿™æ„å‘³ç€é™¤éå¯ç”¨å—åˆ†æï¼Œå¦åˆ™ç”±äºCPUåˆ†æ”¯é¢„æµ‹ï¼Œå¼€é”€åº”å®é™…ä¸Šä¸ºé›¶ã€‚</p><p> When block profiling is enabled, every blocking operation will pay the overhead of two  cputicks() calls. On  amd64 this is done via  optimized assembly using the  RDTSC instruction and takes a negligible  ~10ns/op on  my machine. On other platforms various alternative clock sources are used which may have higher overheads and lower accuracy.</p><p> å¯ç”¨å—åˆ†æåï¼Œæ¯ä¸ªé˜»æ­¢æ“ä½œå°†æ”¯ä»˜ä¸¤æ¬¡cputicksï¼ˆï¼‰è°ƒç”¨çš„å¼€é”€ã€‚åœ¨amd64ä¸Šï¼Œè¿™æ˜¯é€šè¿‡ä½¿ç”¨RDTSCæŒ‡ä»¤è¿›è¡Œä¼˜åŒ–çš„æ±‡ç¼–æ¥å®Œæˆçš„ï¼Œå¹¶ä¸”åœ¨æˆ‘çš„è®¡ç®—æœºä¸Šçš„è€—è´¹çº¦ä¸º10ns / opã€‚åœ¨å…¶ä»–å¹³å°ä¸Šï¼Œä½¿ç”¨äº†å„ç§æ›¿ä»£æ—¶é’Ÿæºï¼Œè¿™äº›æ—¶é’Ÿæºå¯èƒ½å…·æœ‰æ›´é«˜çš„å¼€é”€å’Œæ›´ä½çš„ç²¾åº¦ã€‚</p><p> Depending on the configured  blockprofilerate (more about this in the  Accuracy section) the block event may end up getting saved. This means a stack trace is collected which takes  ~1Âµs on  my machine (stackdepth=16). The stack is then used as a key to update an  internal hashmap by incrementing the corresponding   blockRecord count and cycles.</p><p> æ ¹æ®é…ç½®çš„å—è½®å»“é€Ÿç‡ï¼ˆâ€œç²¾åº¦â€éƒ¨åˆ†ä¸­çš„æ›´å¤šä¿¡æ¯ï¼‰ï¼Œå—äº‹ä»¶å¯èƒ½æœ€ç»ˆä¼šè¢«ä¿å­˜ã€‚è¿™æ„å‘³ç€æ”¶é›†çš„å †æ ˆè·Ÿè¸ªåœ¨æˆ‘çš„æœºå™¨ä¸Šå¤§çº¦éœ€è¦1Âµsï¼ˆå †æ ˆæ·±åº¦= 16ï¼‰ã€‚ç„¶åï¼Œé€šè¿‡å¢åŠ ç›¸åº”çš„blockRecordè®¡æ•°å’Œå‘¨æœŸï¼Œå°†å †æ ˆç”¨ä½œæ›´æ–°å†…éƒ¨å“ˆå¸Œå›¾çš„é”®ã€‚</p><p>  The costs of updating the hash map is probably similar to collecting the stack traces, but I haven&#39;t measured it yet.</p><p>  æ›´æ–°å“ˆå¸Œå›¾çš„æˆæœ¬å¯èƒ½ä¸æ”¶é›†å †æ ˆè·Ÿè¸ªä¿¡æ¯ç›¸ä¼¼ï¼Œä½†æ˜¯æˆ‘å°šæœªå¯¹å…¶è¿›è¡Œæµ‹é‡ã€‚</p><p>  Anyway, what does all of this mean in terms of overhead for your application? It generally means that block profiling is  low overhead. Unless your application spends literally all of its time parking and unparking goroutines due to contention, you probably won&#39;t be able to see a measurable impact even when sampling every block event.</p><p>  æ— è®ºå¦‚ä½•ï¼Œè¿™å¯¹äºæ‚¨çš„åº”ç”¨ç¨‹åºçš„å¼€é”€è€Œè¨€æ„å‘³ç€ä»€ä¹ˆï¼Ÿé€šå¸¸ï¼Œè¿™æ„å‘³ç€å—åˆ†æçš„å¼€é”€å¾ˆä½ã€‚é™¤éæ‚¨çš„åº”ç”¨ç¨‹åºç”±äºäº‰ç”¨è€Œåœ¨å­—é¢ä¸Šå…¨éƒ¨èŠ±è´¹æ—¶é—´æ¥åœæ³Šå’Œå–æ¶ˆgoroutineï¼Œå¦åˆ™å³ä½¿å¯¹æ¯ä¸ªå—äº‹ä»¶è¿›è¡Œé‡‡æ ·ï¼Œæ‚¨ä¹Ÿå°†æ— æ³•çœ‹åˆ°å¯æµ‹é‡çš„å½±å“ã€‚ </p><p> That being said, the benchmark results below (see  Methodology) should give you an idea of the  theoretical worst case overhead block profiling could have. The graph  chan(cap=0) shows that setting  blockprofilerate from  1 to  1000 on a  workload that consists entirely in sending tiny messages across unbuffered channels decreases throughput significantly. Using a buffered channel as in graph  chan(cap=128) greatly reduces the problem to the point that it probably won&#39;t matter for real applications that don&#39;t spend all of their time on channel communication overheads.</p><p>è¯è™½è¿™ä¹ˆè¯´ï¼Œä¸‹é¢çš„åŸºå‡†æµ‹è¯•ç»“æœï¼ˆè¯·å‚é˜…æ–¹æ³•è®ºï¼‰åº”è¯¥ä½¿æ‚¨å¯¹å¼€é”€å—åˆ†æå¯èƒ½å…·æœ‰çš„ç†è®ºä¸Šæœ€åæƒ…å†µæœ‰æ‰€äº†è§£ã€‚å›¾è¡¨chanï¼ˆcap = 0ï¼‰æ˜¾ç¤ºï¼Œåœ¨å®Œå…¨åŒ…å«é€šè¿‡æ— ç¼“å†²é€šé“å‘é€å¾®å°æ¶ˆæ¯çš„å·¥ä½œè´Ÿè½½ä¸Šï¼Œå°†blockprofilerateä»1è®¾ç½®ä¸º1000ä¼šå¤§å¤§é™ä½ååé‡ã€‚ä½¿ç”¨å›¾chanï¼ˆcap = 128ï¼‰ä¸­çš„ç¼“å†²é€šé“å¯ä»¥æå¤§åœ°å‡å°‘é—®é¢˜ï¼Œä»¥è‡³äºå¯¹äºä¸èŠ±æ‰€æœ‰æ—¶é—´åœ¨é€šé“é€šä¿¡å¼€é”€ä¸Šçš„å®é™…åº”ç”¨æ¥è¯´ï¼Œè¿™å¯èƒ½æ— å…³ç´§è¦ã€‚</p><p> It&#39;s also interesting to note that I was unable to see significant overheads for   mutex based workloads. I believe this is due to the fact that mutexes employe spin locks before parking a goroutine when there is contention. If somebody has a good idea for a workload that exhibits high non-spinning mutex contention in Go, please let me know!</p><p> è¿˜è¦æœ‰è¶£çš„æ˜¯ï¼Œæˆ‘çœ‹ä¸åˆ°åŸºäºäº’æ–¥é‡çš„å·¥ä½œè´Ÿè½½çš„å¤§é‡å¼€é”€ã€‚æˆ‘è®¤ä¸ºè¿™æ˜¯ç”±äºå­˜åœ¨äº‰ç”¨æ—¶äº’æ–¥é”åœ¨å­˜æ”¾goroutineä¹‹å‰å…ˆä½¿ç”¨äº†è‡ªæ—‹é”ã€‚å¦‚æœæœ‰äººå¯¹åœ¨Goä¸­è¡¨ç°å‡ºé«˜éæ—‹è½¬äº’æ–¥é”äº‰ç”¨çš„å·¥ä½œè´Ÿè½½æœ‰ä¸ªå¥½ä¸»æ„ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼</p><p> Anyway, please remember that the graphs below show workloads that were specifically designed to trigger the worst block profiling overhead you can imagine. Real applications will usually see no significant overhead, especially when using a  blockprofilerate &gt;=  10000 (10Âµs).</p><p> æ— è®ºå¦‚ä½•ï¼Œè¯·è®°ä½ï¼Œä¸‹å›¾æ˜¾ç¤ºäº†ä¸“é—¨è®¾è®¡ç”¨æ¥è§¦å‘æ‚¨å¯ä»¥æƒ³è±¡çš„æœ€åçš„æ•°æ®å—åˆ†æå¼€é”€çš„å·¥ä½œè´Ÿè½½ã€‚å®é™…çš„åº”ç”¨ç¨‹åºé€šå¸¸ä¸ä¼šçœ‹åˆ°æ˜æ˜¾çš„å¼€é”€ï¼Œç‰¹åˆ«æ˜¯åœ¨ä½¿ç”¨å—é…ç½®ç‡> == 10000ï¼ˆ10Âµsï¼‰æ—¶ã€‚</p><p>   Block profiling utilizes a shared hash map that  uses  1.4 MiB of memory even when empty. Unless you explicitly  disable heap profiling in your application, this map will get allocated regardless of whether you use the block profiler or not.</p><p>   å—åˆ†æåˆ©ç”¨å…±äº«å“ˆå¸Œå›¾ï¼Œå³ä½¿ç©ºé—´ä¸ºç©ºï¼Œå®ƒä¹Ÿä½¿ç”¨1.4 MiBçš„å†…å­˜ã€‚é™¤éæ‚¨åœ¨åº”ç”¨ç¨‹åºä¸­æ˜ç¡®ç¦ç”¨å †åˆ†æï¼Œå¦åˆ™æ— è®ºæ˜¯å¦ä½¿ç”¨å—åˆ†æå™¨ï¼Œéƒ½å°†åˆ†é…æ­¤æ˜ å°„ã€‚</p><p> Addtionally each unique stack trace will take up some additional memory. The  BuckHashSys field of   runtime.MemStats allows you to inspect this usage at runtime. In the future I might try to provide additional information about this along with real world data.</p><p> å¦å¤–ï¼Œæ¯ä¸ªå”¯ä¸€çš„å †æ ˆè·Ÿè¸ªéƒ½å°†å ç”¨ä¸€äº›é¢å¤–çš„å†…å­˜ã€‚ runtime.MemStatsçš„BuckHashSyså­—æ®µå…è®¸æ‚¨åœ¨è¿è¡Œæ—¶æ£€æŸ¥æ­¤ç”¨æ³•ã€‚å°†æ¥ï¼Œæˆ‘å¯èƒ½ä¼šå°è¯•æä¾›æœ‰å…³æ­¤æ–¹é¢çš„å…¶ä»–ä¿¡æ¯ä»¥åŠç°å®ä¸–ç•Œçš„æ•°æ®ã€‚</p><p>  The first call to  runtime.SetBlockProfileRate() takes  100ms because it tries to  measure the speed ratio between the wall clock and the  TSC clock. However, recent changes around async preemption have  broken this code, so the call is taking only  ~10ms right now.</p><p>  ç¬¬ä¸€æ¬¡è°ƒç”¨runtime.SetBlockProfileRateï¼ˆï¼‰éœ€è¦100æ¯«ç§’ï¼Œå› ä¸ºå®ƒè¯•å›¾æµ‹é‡æŒ‚é’Ÿå’ŒTSCæ—¶é’Ÿä¹‹é—´çš„é€Ÿåº¦æ¯”ã€‚ä½†æ˜¯ï¼Œæœ‰å…³å¼‚æ­¥æŠ¢å çš„æœ€æ–°æ›´æ”¹å·²ç ´åäº†æ­¤ä»£ç ï¼Œå› æ­¤è¯¥è°ƒç”¨ç°åœ¨ä»…éœ€è¦10æ¯«ç§’ã€‚</p><p>   tl;dr: Setting your sampling  rate too high will bias your results towards infrequent long events over frequent short events.</p><p>   tl; drï¼šå°†é‡‡æ ·ç‡è®¾ç½®å¾—å¤ªé«˜ä¼šä½¿æ‚¨çš„ç»“æœåå‘äºä¸ç»å¸¸å‘ç”Ÿçš„é•¿äº‹ä»¶è€Œä¸æ˜¯é¢‘ç¹å‘ç”Ÿçš„çŸ­äº‹ä»¶ã€‚ </p><p>    func  blocksampled( cycles  int64)  bool {	 rate  :=  int64( atomic. Load64( &amp; blockprofilerate))	 if  rate  &lt;=  0  || ( rate  &gt;  cycles  &amp;&amp;  int64( fastrand()) % rate  &gt;  cycles) {		 return  false	}	 return  true}</p><p>func blocksampledï¼ˆå¾ªç¯int64ï¼‰bool {å¦‚æœé€Ÿç‡ï¼†lt; = 0 ||ï¼Œåˆ™é€Ÿç‡== int64ï¼ˆåŸå­ã€‚Load64ï¼ˆï¼†amp; blockprofilerateï¼‰ï¼‰ã€‚ ï¼ˆæ¯”ç‡ï¼†gt;å‘¨æœŸï¼†amp;ï¼†amp; int64ï¼ˆfastrandï¼ˆï¼‰ï¼‰ï¼…æ¯”ç‡ï¼†gt;å‘¨æœŸï¼‰{return false} return true}</p><p> This means that if you set your profiling  rate low enough, you&#39;ll get very accurate results. However, if your  rate is higher than the  duration of some of the events you are sampling, the sampling process will exhibit a bias favoring infrequent events of higher  duration over frequent events with lower  duration even so they may contribute to the same amount of overall block duration in your program.</p><p> è¿™æ„å‘³ç€ï¼Œå¦‚æœå°†é…ç½®ç‡è®¾ç½®å¾—è¶³å¤Ÿä½ï¼Œæ‚¨å°†è·å¾—éå¸¸å‡†ç¡®çš„ç»“æœã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨çš„é€Ÿç‡é«˜äºæ‚¨è¦é‡‡æ ·çš„æŸäº›äº‹ä»¶çš„æŒç»­æ—¶é—´ï¼Œåˆ™é‡‡æ ·è¿‡ç¨‹å°†å‡ºç°åå‘ï¼Œå³åå‘äºå…·æœ‰è¾ƒé«˜æŒç»­æ—¶é—´çš„å¶å‘äº‹ä»¶è€Œä¸æ˜¯å…·æœ‰è¾ƒä½æŒç»­æ—¶é—´çš„é¢‘ç¹äº‹ä»¶ï¼Œå³ä½¿å®ƒä»¬å¯èƒ½å¯¹ç›¸åŒæ•°é‡çš„æ€»ä½“é˜»æ­¢èµ·ä½œç”¨ç¨‹åºçš„æŒç»­æ—¶é—´ã€‚</p><p>    Given this scenario, the  blockprofiler is guaranteed to catch and accurately report event  A as  100ns in the profile. For event  B the most likely outcome is that the profiler will capture only a single event (10% of 10 events) and report  B as  10ns in the profile. So you might find yourself in a situation where you think event  A is causing 10x more blocking than event  B, which is not true.</p><p>    åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ä¿è¯blockprofileråœ¨é…ç½®æ–‡ä»¶ä¸­æ•è·å¹¶å‡†ç¡®æŠ¥å‘Šäº‹ä»¶Aä¸º100nsã€‚å¯¹äºäº‹ä»¶Bï¼Œæœ€æœ‰å¯èƒ½çš„ç»“æœæ˜¯ï¼Œäº‹ä»¶æ¢æŸ¥å™¨å°†ä»…æ•è·å•ä¸ªäº‹ä»¶ï¼ˆ10ä¸ªäº‹ä»¶ä¸­çš„10ï¼…ï¼‰ï¼Œå¹¶å°†BæŠ¥å‘Šä¸ºäº‹ä»¶10nsã€‚å› æ­¤ï¼Œæ‚¨å¯èƒ½ä¼šå‘ç°è‡ªå·±è®¤ä¸ºäº‹ä»¶Aå¯¼è‡´çš„é˜»å¡æ¯”äº‹ä»¶Bå¤š10å€ï¼Œè¿™æ˜¯ä¸æ­£ç¡®çš„ã€‚</p><p>  For an even better intuition about this, consider the  simulated example below. Here we have a histogram of all durations collected from 3 types of blocking events. As you can see, they all have different mean durations ( 1000ns,  2000ns,  3000ns) and they are occurring at different frequencies, with  count(a) &gt; count(b) &gt; count(c). What&#39;s more difficult to see, is that the cumulative durations of these events are the same, i.e.  sum(a) = sum(b) = sum(c), but you can trust me on that : ).</p><p>  ä¸ºäº†è·å¾—æ›´å¥½çš„ç›´è§‰ï¼Œè¯·è€ƒè™‘ä¸‹é¢çš„æ¨¡æ‹Ÿç¤ºä¾‹ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä»3ç§é˜»å¡äº‹ä»¶ä¸­æ”¶é›†äº†æ‰€æœ‰æŒç»­æ—¶é—´çš„ç›´æ–¹å›¾ã€‚å¦‚æ‚¨æ‰€è§ï¼Œå®ƒä»¬éƒ½å…·æœ‰ä¸åŒçš„å¹³å‡æŒç»­æ—¶é—´ï¼ˆ1000nsï¼Œ2000nsï¼Œ3000nsï¼‰ï¼Œå¹¶ä¸”å®ƒä»¬ä»¥ä¸åŒçš„é¢‘ç‡å‘ç”Ÿï¼Œä¸”countï¼ˆaï¼‰æ•°ï¼ˆbï¼‰ï¼†gt;è®¡æ•°ï¼ˆcï¼‰ã€‚æ›´éš¾çœ‹åˆ°çš„æ˜¯è¿™äº›äº‹ä»¶çš„ç´¯ç§¯æŒç»­æ—¶é—´æ˜¯ç›¸åŒçš„ï¼Œå³sumï¼ˆaï¼‰= sumï¼ˆbï¼‰= sumï¼ˆcï¼‰ï¼Œä½†æ˜¯æ‚¨å¯ä»¥ç›¸ä¿¡æˆ‘ï¼š)ã€‚</p><p>  So given that your application might produce events like this, how will they show up in your block profile as you try out different  blockprofilerate values? As you can see below, all is well and fine until a  blockprofilerate of  1000ns. Each event shows up with the same total duration in the profile (the red and green dots are hidden below the blue ones). However starting at  1000ns you see that event  a starts to fade from our profile and at  2000ns you&#39;d already think that events  b and  c are causing twice as much blocking time as event  a.</p><p>  å› æ­¤ï¼Œå‡è®¾æ‚¨çš„åº”ç”¨ç¨‹åºå¯èƒ½ä¼šäº§ç”Ÿè¿™æ ·çš„äº‹ä»¶ï¼Œé‚£ä¹ˆå½“æ‚¨å°è¯•ä¸åŒçš„blockprofilerateå€¼æ—¶ï¼Œå®ƒä»¬å°†å¦‚ä½•æ˜¾ç¤ºåœ¨æ‚¨çš„åŒºå—æ–‡ä»¶ä¸­ï¼Ÿå¦‚ä¸‹æ‰€ç¤ºï¼Œä¸€åˆ‡æ­£å¸¸ï¼Œç›´åˆ°è¾¾åˆ°1000nsçš„å—è½®å»“é€Ÿç‡ä¸ºæ­¢ã€‚æ¯ä¸ªäº‹ä»¶åœ¨é…ç½®æ–‡ä»¶ä¸­ä»¥ç›¸åŒçš„æ€»æŒç»­æ—¶é—´æ˜¾ç¤ºï¼ˆçº¢è‰²å’Œç»¿è‰²çš„ç‚¹éšè—åœ¨è“è‰²çš„ä¸‹é¢ï¼‰ã€‚ä½†æ˜¯ï¼Œä»1000nså¼€å§‹ï¼Œæ‚¨ä¼šçœ‹åˆ°äº‹ä»¶aå¼€å§‹ä»æˆ‘ä»¬çš„é…ç½®æ–‡ä»¶ä¸­æ¶ˆå¤±ï¼Œè€Œåœ¨2000nsï¼Œæ‚¨å·²ç»è®¤ä¸ºäº‹ä»¶bå’Œcé€ æˆçš„é˜»å¡æ—¶é—´æ˜¯äº‹ä»¶açš„ä¸¤å€ã€‚</p><p>  So what can we do? Do we always need to live in fear of bias when working with block profiles? No! If the  Overhead for your workload allows it, the simplest solution is to use a low enough  blockprofilerate in order to capture most blocking events.</p><p>  æ‰€ä»¥ï¼Œæˆ‘ä»¬èƒ½åšäº›ä»€ä¹ˆï¼Ÿåœ¨ä½¿ç”¨å—è½®å»“æ—¶ï¼Œæ˜¯å¦æ€»æ˜¯éœ€è¦æ‹…å¿ƒåè§å—ï¼Ÿæ²¡æœ‰ï¼å¦‚æœæ‚¨çš„å·¥ä½œè´Ÿè½½å¼€é”€å…è®¸çš„è¯ï¼Œæœ€ç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨è¶³å¤Ÿä½çš„å—æ¦‚è¦é€Ÿç‡æ¥æ•è·å¤§å¤šæ•°é˜»å¡äº‹ä»¶ã€‚</p><p> But perhaps there is an even better way. I&#39;m thinking we could correct for the current bias by keeping the same logic of sampling  duration / rate fraction of events when  duration &lt; rate. However, when this happens we could simply multiply the sampled duration like this:</p><p> ä½†æ˜¯ä¹Ÿè®¸è¿˜æœ‰æ›´å¥½çš„æ–¹æ³•ã€‚æˆ‘è®¤ä¸ºæˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨æŒç»­æ—¶é—´ï¼†lt;ï¼†lt;ï¼†lt;ç‡ã€‚ä½†æ˜¯ï¼Œå‘ç”Ÿè¿™ç§æƒ…å†µæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åƒè¿™æ ·ç®€å•åœ°ä¹˜ä»¥é‡‡æ ·æŒç»­æ—¶é—´ï¼š </p><p> duration = duration * (rate/duration)# note: the expression above can be simplified to just `duration = rate`</p><p>æŒç»­æ—¶é—´=æŒç»­æ—¶é—´*ï¼ˆé€Ÿç‡/æŒç»­æ—¶é—´ï¼‰ï¼ƒæ³¨æ„ï¼šä»¥ä¸Šè¡¨è¾¾å¼å¯ä»¥ç®€åŒ–ä¸ºâ€œæŒç»­æ—¶é—´=é€Ÿç‡â€</p><p> Doing so could be done with a  trivial patch to the go runtime and the picture below shows the results from simulating it. So from my point of view it should be possible to eliminate this bias from future versions of Go and I&#39;m planning to work with the Go project on that.</p><p> å¯ä»¥ä½¿ç”¨goè¿è¡Œæ—¶çš„æ™®é€šè¡¥ä¸æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œä¸‹é¢çš„å›¾ç‰‡æ˜¾ç¤ºäº†æ¨¡æ‹Ÿå®ƒçš„ç»“æœã€‚å› æ­¤ï¼Œä»æˆ‘çš„è§’åº¦æ¥çœ‹ï¼Œåº”è¯¥æœ‰å¯èƒ½æ¶ˆé™¤Goçš„æœªæ¥ç‰ˆæœ¬ä¸­çš„è¿™ç§åè§ï¼Œå¹¶ä¸”æˆ‘è®¡åˆ’åœ¨è¯¥ç‰ˆæœ¬ä¸Šä¸Goé¡¹ç›®ä¸€èµ·å·¥ä½œã€‚</p><p> That being said, I&#39;m not trained in statistics, so my analysis here might be hilariously misguided  ğŸ™ƒ.</p><p> è¯è™½è¿™ä¹ˆè¯´ï¼Œæˆ‘æ²¡æœ‰æ¥å—è¿‡ç»Ÿè®¡å­¦æ–¹é¢çš„åŸ¹è®­ï¼Œæ‰€ä»¥æˆ‘åœ¨è¿™é‡Œçš„åˆ†æå¯èƒ½ä¼šè¢«è¯¯å¯¼ğŸ™ƒã€‚</p><p>  ğŸš§ It might be possible to reduce the bias in block profiles after recording them. I&#39;ve got a  proof of concept for this, but it&#39;s not clear yet if this will work well in practice.</p><p>  recordingè®°å½•ä¸‹æ¥ä¹‹åï¼Œå¯èƒ½å¯ä»¥å‡å°‘å—è½®å»“ä¸­çš„åå·®ã€‚æˆ‘å·²ç»å¯¹æ­¤è¿›è¡Œäº†æ¦‚å¿µéªŒè¯ï¼Œä½†æ˜¯å°šä¸æ¸…æ¥šè¿™åœ¨å®è·µä¸­æ˜¯å¦èƒ½å¾ˆå¥½åœ°å·¥ä½œã€‚</p><p>  amd64 and other platforms use  TSC for implementing the  cputicks() function. This technique has been historically challenged by problems with frequency scaling and other kinds of CPU power transitions. Modern CPUs should provide invariant TSCs, but at  least some Go users are still reporting issues. I can&#39;t tell whether those are due to broken hardware or issues regarding multi-socket systems, but hope to do more research on this in the future.</p><p>  amd64å’Œå…¶ä»–å¹³å°ä½¿ç”¨TSCæ¥å®ç°cputicksï¼ˆï¼‰å‡½æ•°ã€‚è¿‡å»ï¼Œæ­¤æŠ€æœ¯ä¸€ç›´å—åˆ°é¢‘ç‡ç¼©æ”¾å’Œå…¶ä»–ç±»å‹çš„CPUç”µæºè½¬æ¢é—®é¢˜çš„æŒ‘æˆ˜ã€‚ç°ä»£CPUåº”è¯¥æä¾›ä¸å˜çš„TSCï¼Œä½†æ˜¯è‡³å°‘æŸäº›Goç”¨æˆ·ä»åœ¨æŠ¥å‘Šé—®é¢˜ã€‚æˆ‘æ— æ³•ç¡®å®šåŸå› æ˜¯ç”±äºç¡¬ä»¶æŸåè¿˜æ˜¯ä¸å¤šè·¯æ’åº§ç³»ç»Ÿæœ‰å…³çš„é—®é¢˜ï¼Œä½†å¸Œæœ›å°†æ¥å¯¹æ­¤åšæ›´å¤šçš„ç ”ç©¶ã€‚</p><p> Please also note the bug description in the  Initialization Time section which may impact the accuracy of converting cputicks to wall clock time.</p><p> å¦è¯·æ³¨æ„â€œåˆå§‹åŒ–æ—¶é—´â€éƒ¨åˆ†ä¸­çš„é”™è¯¯æè¿°ï¼Œè¿™å¯èƒ½ä¼šå½±å“å°†cputicksè½¬æ¢ä¸ºå¢™ä¸Šæ—¶é’Ÿæ—¶é—´çš„å‡†ç¡®æ€§ã€‚</p><p>  The max stack depth for block profiles is  32. Block events occurring at deeper stack depths will still be included in the profile, but the resulting data might be more difficult to work with.</p><p>  å—æ¦‚è¦æ–‡ä»¶çš„æœ€å¤§å †æ ˆæ·±åº¦ä¸º32ã€‚åœ¨è¾ƒæ·±çš„å †æ ˆæ·±åº¦å¤„å‘ç”Ÿçš„å—äº‹ä»¶ä»å°†åŒ…å«åœ¨æ¦‚è¦æ–‡ä»¶ä¸­ï¼Œä½†æ˜¯ç”Ÿæˆçš„æ•°æ®å¯èƒ½æ›´éš¾å¤„ç†ã€‚ </p><p>  As described earlier, contended Go mutexes will first try to  spin for a bit before yielding to the scheduler. If the spinning is successful, no block event will be tracked. This presents another subtle bias in the block profiler towards events of longer duration.</p><p>å¦‚å‰æ‰€è¿°ï¼Œæœ‰äº‰è®®çš„Goäº’æ–¥é”å°†é¦–å…ˆå°è¯•æ—‹è½¬ä¸€ä¸‹ï¼Œç„¶åå±ˆæœäºè°ƒåº¦ç¨‹åºã€‚å¦‚æœæ—‹è½¬æˆåŠŸï¼Œåˆ™ä¸ä¼šè·Ÿè¸ªä»»ä½•å—äº‹ä»¶ã€‚è¿™åœ¨å—å‰–æå™¨ä¸­å¯¹æŒç»­æ—¶é—´è¾ƒé•¿çš„äº‹ä»¶æå‡ºäº†å¦ä¸€ä¸ªç»†å¾®çš„åå·®ã€‚</p><p> ğŸš§ This section needs more research that I&#39;ll do as part of my mutex profiler note.</p><p> sectionè¿™éƒ¨åˆ†éœ€è¦åšæ›´å¤šçš„ç ”ç©¶ï¼Œä½œä¸ºäº’æ–¥é‡åˆ†æå™¨æ³¨é‡Šçš„ä¸€éƒ¨åˆ†ã€‚</p><p>  Blocking time is not bound by wall clock time. Multiple goroutines can simultaneously spend time blocking, which means it&#39;s possible to see profiles with a cumulative block duration that exceeds the runtime of the program.</p><p>  é˜»å¡æ—¶é—´ä¸å—æŒ‚é’Ÿæ—¶é—´é™åˆ¶ã€‚å¤šä¸ªgoroutineå¯ä»¥åŒæ—¶èŠ±è´¹æ—¶é—´è¿›è¡Œé˜»å¡ï¼Œè¿™æ„å‘³ç€å¯ä»¥æŸ¥çœ‹ç´¯ç§¯çš„å—æŒç»­æ—¶é—´è¶…è¿‡ç¨‹åºè¿è¡Œæ—¶é—´çš„é…ç½®æ–‡ä»¶ã€‚</p><p>  The  mutex profiling feature in Go overlaps with block profiling. It seems like both can be used to understand mutex contention. When using the mutex profiler it will report the  Unlock() call sites rather than the  Lock() call sites reported by the block profiler. The mutex profiler also uses a simpler and probably unbiased sampling mechanism which should make it more accurate. However, the mutex profiler does not cover channel contention, so the block profiler is a bit more flexible. When the mutex and block profiler are both enabled, it seems likely that some overhead will be wasted on tracking duplicate contention events.</p><p>  Goä¸­çš„äº’æ–¥é”åˆ†æåŠŸèƒ½ä¸å—åˆ†æé‡å ã€‚ä¼¼ä¹ä¸¤è€…éƒ½å¯ä»¥ç”¨æ¥ç†è§£äº’æ–¥äº‰ç”¨ã€‚ä½¿ç”¨äº’æ–¥é‡æ¢æŸ¥å™¨æ—¶ï¼Œå®ƒå°†æŠ¥å‘ŠUnlockï¼ˆï¼‰è°ƒç”¨ç«™ç‚¹ï¼Œè€Œä¸æ˜¯å—æ¢æŸ¥å™¨æŠ¥å‘Šçš„Lockï¼ˆï¼‰è°ƒç”¨ç«™ç‚¹ã€‚äº’æ–¥é”æ¢æŸ¥å™¨è¿˜ä½¿ç”¨äº†ä¸€ç§æ›´ç®€å•ä¸”å¯èƒ½æ— åçš„é‡‡æ ·æœºåˆ¶ï¼Œè¿™åº”è¯¥ä½¿å…¶æ›´åŠ å‡†ç¡®ã€‚ä½†æ˜¯ï¼Œäº’æ–¥é”æ¢æŸ¥å™¨ä¸æ¶µç›–é€šé“äº‰ç”¨ï¼Œå› æ­¤å—æ¢æŸ¥å™¨æ›´åŠ çµæ´»ã€‚å¯ç”¨äº’æ–¥é‡å’Œå—åˆ†æå™¨åï¼Œè·Ÿè¸ªé‡å¤çš„äº‰ç”¨äº‹ä»¶å¯èƒ½ä¼šæµªè´¹ä¸€äº›å¼€é”€ã€‚</p><p> ğŸš§ This section needs more research that I&#39;ll do as part of my mutex profiler notes.</p><p> sectionè¿™éƒ¨åˆ†éœ€è¦åšæ›´å¤šçš„ç ”ç©¶ï¼Œä½œä¸ºäº’æ–¥é‡åˆ†æå™¨æ³¨é‡Šçš„ä¸€éƒ¨åˆ†ã€‚</p><p>  The block profiler does not support  profiler labels right now, but it seems like this might be easy to implement in the future.</p><p>  å—æ¢æŸ¥å™¨ç›®å‰ä¸æ”¯æŒæ¢æŸ¥å™¨æ ‡ç­¾ï¼Œä½†ä¼¼ä¹å°†æ¥å¯èƒ½å¾ˆå®¹æ˜“å®ç°ã€‚</p><p>  Below is an example of block profile encoded in  pprof&#39;s protobuf format. There are two value types:</p><p>  ä¸‹é¢æ˜¯ä»¥pprofçš„protobufæ ¼å¼ç¼–ç çš„å—é…ç½®æ–‡ä»¶çš„ç¤ºä¾‹ã€‚æœ‰ä¸¤ç§å€¼ç±»å‹ï¼š </p><p>   $ go tool pprof -raw block.pb.gz PeriodType: contentions countPeriod: 1Time: 2021-02-08 14:53:53.243777 +0100 CETSamples:contentions/count delay/nanoseconds 22820 867549417: 1 2 3 4 22748 453510869: 1 2 5 4 Locations 1: 0x10453af M=1 runtime.selectgo /usr/local/Cellar/go/1.15.6/libexec/src/runtime/select.go:511 s=0 2: 0x10d082b M=1 main.simulateBlockEvents /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:71 s=0 3: 0x10d0b72 M=1 main.eventB /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:57 s=0 main.run.func2 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:33 s=0 4: 0x10d01b8 M=1 golang.org/x/sync/errgroup.(*Group).Go.func1 /Users/felix.geisendoerfer/go/pkg/mod/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup/errgroup.go:57 s=0 5: 0x10d0b12 M=1 main.eventA /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:53 s=0 main.run.func1 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:30 s=0Mappings1: 0x0/0x0/0x0 [FN]</p><p>$ goå·¥å…·pprof -raw block.pb.gz PeriodTypeï¼šäº‰ç”¨è®¡æ•°å‘¨æœŸï¼š1æ—¶é—´ï¼š2021-02-08 14ï¼š53ï¼š53.243777 +0100 CETSæ ·æœ¬ï¼šäº‰ç”¨/è®¡æ•°å»¶è¿Ÿ/çº³ç§’22820 867549417ï¼š1 2 3 4 22748 453510869ï¼š1 2 5 4ä½ç½®1ï¼š0x10453af M = 1è¿è¡Œæ—¶.selectgo /usr/local/Cellar/go/1.15.6/libexec/src/runtime/select.go:511 s = 0 2ï¼š0x10d082b M = 1 main.simulateBlockEvents / Users /felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:71 s = 0 3ï¼š0x10d0b72 M = 1 main.eventB /Users/felix.geisendoerfer /go/src/github.com/felixge/go-profiler-notes/examples/block-sample/main.go:57 s = 0 main.run.func2 /Users/felix.geisendoerfer/go/src/github.com /felixge/go-profiler-notes/examples/block-sample/main.go:33 s = 0 4ï¼š0x10d01b8 M = 1 golang.org/x/sync/errgroup.(*Group).Go.func1 / Users / felix.geisendoerfer/go/pkg/mod/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup/errgroup.goï¼š57 s = 0 5ï¼š0x10d0b12 M = 1 main.eventA / Users / felixã€‚ geisendoerfer / go / src / github.com / felixge / go-profile r-notes / examples / block-sample / main.goï¼š53 s = 0 main.run.func1 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/block- sample / main.goï¼š30 s = 0Mappings1ï¼š0x0 / 0x0 / 0x0 [FN]</p><p>  Block profiling was  implemented by  Dmitry Vyukov and first appeared in the  go1.1 release (2013-05-13).</p><p>  åŒºå—å‰–æç”±Dmitry Vyukovå®ç°ï¼Œå¹¶é¦–æ¬¡å‡ºç°åœ¨go1.1ç‰ˆæœ¬ï¼ˆ2013-05-13ï¼‰ä¸­ã€‚</p><p>  I work at  Datadog on  Continuous Profiling for Go. You should check it out. We&#39;re also  hiring : ).</p><p>  æˆ‘åœ¨Datadogä¸Šè¿›è¡ŒGoçš„è¿ç»­åˆ†æã€‚ä½ åº”è¯¥æ£€æŸ¥ä¸€ä¸‹ã€‚æˆ‘ä»¬ä¹Ÿæ­£åœ¨æ‹›è˜ï¼šï¼‰ã€‚</p><p> The information on this page is believed to be correct, but no warranty is provided. Feedback is welcome!</p><p> è¯¥é¡µé¢ä¸Šçš„ä¿¡æ¯è¢«è®¤ä¸ºæ˜¯æ­£ç¡®çš„ï¼Œä½†ä¸æä¾›ä»»ä½•ä¿ä¿®ã€‚æ¬¢è¿åé¦ˆï¼ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/felixge/go-profiler-notes/blob/main/block.md">https://github.com/felixge/go-profiler-notes/blob/main/block.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/åˆ†æ/">#åˆ†æ</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/block/">#block</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/äº‹ä»¶/">#äº‹ä»¶</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>