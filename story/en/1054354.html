<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>æ¯”è¾ƒSvelteå¹¶ååº” Comparing Svelte and React</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Comparing Svelte and React<br/>æ¯”è¾ƒSvelteå¹¶ååº” </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 19:43:11</div><div class="page_narrow text-break page_content"><p>Last year I created  Pomodone, a small time tracking application based on the Pomodoro technique of working in 25 minute intervals. It&#39;s a pretty basic app; it has a 25 minute timer (that runs in a Web Worker) and saves a history of your &#34;poms&#34; to a small Firebase database. I initially built it using React (well, Preact actually) but I then started to play around with Svelte, and decided rebuilding the app in Svelte might be a nice way to blog about the similarities and differences between the libraries.</p><p>å»å¹´æˆ‘åˆ›å»ºäº†Pomodoneï¼Œè¿™æ˜¯ä¸€ä¸ªå°å‹æ—¶é—´è·Ÿè¸ªåº”ç”¨ï¼ŒåŸºäºPomodoroæŠ€æœ¯çš„å·¥ä½œæ—¶é—´ä¸º25åˆ†é’Ÿçš„é—´éš”ã€‚å®ƒï¼†ï¼ƒ39; sä¸€ä¸ªéå¸¸åŸºæœ¬çš„åº”ç”¨ç¨‹åº;å®ƒæœ‰ä¸€ä¸ª25åˆ†é’Ÿçš„è®¡æ—¶å™¨ï¼ˆåœ¨Webå·¥ä½œè€…ä¸­è¿è¡Œï¼‰å¹¶ä¿å­˜æ‚¨çš„ï¼†ï¼ƒ34; Pomsï¼†ï¼ƒ34çš„å†å²;åˆ°ä¸€ä¸ªå°çš„firebaseæ•°æ®åº“ã€‚æˆ‘æœ€åˆä½¿ç”¨Reactï¼ˆäº•å®é™…ä¸Šï¼‰å»ºç«‹å®ƒï¼Œä½†æˆ‘å¼€å§‹ä½¿ç”¨Svelteæ’­æ”¾ï¼Œå¹¶å†³å®šåœ¨Svelteä¸­é‡å»ºåº”ç”¨ç¨‹åºå¯èƒ½æ˜¯åšå®¢å…³äºåº“ä¹‹é—´çš„ç›¸ä¼¼æ€§å’Œå·®å¼‚çš„å¥½æ–¹æ³•ã€‚</p><p> This is  not a post declaring Svelte to be better than React, or vice-versa. This is a post where I&#39;ll tell you about my preferences, and what I find easier or harder with either framework. I&#39;m not here to pick a fight! Plus, Pomodone is hardily a vastly complex application that could be used to fully put React or Svelte through its paces. Think of this post as a commentary based on my experience throwing a side project together, focusing on the developer experience putting these components together.</p><p> è¿™ä¸æ˜¯å£°æ˜svelteçš„å¸–å­æ¯”ååº”æ›´å¥½ï¼Œæˆ–åä¹‹äº¦ç„¶ã€‚è¿™æ˜¯ä¸€ä¸ªï¼†ï¼ƒ39; llå‘Šè¯‰ä½ æˆ‘çš„åå¥½çš„å¸–å­ï¼Œä»¥åŠæˆ‘å‘ç°æ›´å®¹æ˜“æˆ–æ¡†æ¶æ›´å®¹æ˜“æˆ–æ›´éš¾ã€‚æˆ‘ä¸æ˜¯åœ¨è¿™é‡Œé€‰æ‹©ä¸€åœºæˆ˜æ–—ï¼æ­¤å¤–ï¼ŒPOMODONEæ˜¯éš¾ä»¥ç½®ä¿¡çš„åº”ç”¨ç¨‹åºï¼Œå¯ç”¨äºé€šè¿‡å…¶é‹é¢å®Œå…¨æ”¾ç½®ååº”æˆ–æ™ºèƒ½ã€‚å°†è¿™ç¯‡æ–‡ç« ä½œä¸ºè¯„è®ºï¼Œæ ¹æ®æˆ‘çš„ç»éªŒæ‰”åœ¨ä¸€èµ·ï¼Œä¸“æ³¨äºå°†è¿™äº›ç»„ä»¶æ”¾åœ¨ä¸€èµ·çš„å¼€å‘äººå‘˜ä½“éªŒã€‚</p><p>  The app uses Firebase Authentication to log a user in via either their GitHub or Google account. I  love Firebase Authentication, it&#39;s such an easy way to add auth to side projects.</p><p>  è¯¥åº”ç”¨ç¨‹åºä½¿ç”¨Firebaseèº«ä»½éªŒè¯é€šè¿‡å…¶GitHubæˆ–Googleå¸æˆ·ç™»å½•ç”¨æˆ·ã€‚æˆ‘å–œæ¬¢Firebaseèº«ä»½éªŒè¯ï¼Œå®ƒï¼†ï¼ƒ39;è¿™æ˜¯ä¸€ä¸ªç®€å•çš„æ–¹æ³•ï¼Œå¯ä»¥å°†éªŒè¯æ·»åŠ åˆ°ä¾§é¢é¡¹ç›®ã€‚</p><p> React&#39;s hooks are a great way to package this up; I create a  useCurrentUser hook which listens out to authentication changes and sets some state accordingly. I can then trust React to re-render as required when an authentication change is noted.</p><p> ååº”ï¼†ï¼ƒ39; sé’©å­æ˜¯åŒ…è£…çš„å¥½æ–¹æ³•;æˆ‘åˆ›å»ºäº†ä¸€ä¸ªUSECURRENTUSERæŒ‚é’©ï¼Œä¾¦å¬èº«ä»½éªŒè¯æ›´æ”¹å¹¶ç›¸åº”åœ°è®¾ç½®æŸäº›çŠ¶æ€ã€‚ç„¶åï¼Œå½“æ³¨æ„åˆ°è®¤è¯æ›´æ”¹æ—¶ï¼Œæˆ‘å¯ä»¥ä¿¡ä»»é‡æ–°æ¸²æŸ“é‡æ–°æ¸²æŸ“ã€‚</p><p> export  const  useCurrentUser  =  ( )  =&gt;  {   const  [currentUser , setCurrentUser ]  =  useState ( undefined )    useEffect ( ( )  =&gt;  {   return firebase . auth ( ) . onAuthStateChanged ( ( details )  =&gt;  {   setCurrentUser (  details   ?  {  displayName : details .displayName ,  provider :  {   &#39;google.com&#39; :  &#39;Google&#39; ,   &#39;github.com&#39; :  &#39;GitHub&#39; ,   } [details .providerData [ 0 ] .providerId ] ,  uid : details .uid ,   }   :  null   )   } )   } ,  [ ] )   return  [currentUser ]  }</p><p> Export Const UseCurrentUser =ï¼ˆï¼‰=ï¼†gt; {const [currentUserï¼ŒsetCurrentUser] = useStateï¼ˆæœªå®šä¹‰ï¼‰ä½¿ç”¨effeffectï¼ˆï¼ˆï¼‰=ï¼†gt; {return firebaseã€‚authï¼ˆï¼‰ã€‚OnauthstateChangedï¼ˆï¼ˆè¯¦ç»†ä¿¡æ¯ï¼‰=ï¼†gt; {setCurrentUserï¼ˆè¯¦ç»†ä¿¡æ¯ï¼Ÿ{displaynameï¼šè¯¦ç»†ä¿¡æ¯.displaynameï¼Œæä¾›è€…ï¼š{ ï¼†ï¼ƒ39; google.comï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39; googleï¼†ï¼ƒ39;ï¼Œï¼†ï¼ƒ39; github.comï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39; githubï¼†ï¼ƒ39;ï¼Œ} [è¯¦ç»†ä¿¡æ¯.providerdata [0] .providerid ]ï¼ŒUIDï¼šè¯¦ç»†ä¿¡æ¯.UIDï¼Œ}ï¼šnullï¼‰}ï¼‰}ï¼Œ[]ï¼‰è¿”å›[æ™®ç…§ç”¨æˆ·]}</p><p>   This is nice; it&#39;s low effort and lets any component quickly access the current user. The only downside of this is that you potentially have many  onAuthStateChanged listeners; I could mitigate this by only binding one listener, or by putting the current user in a  context instead.</p><p>   è¿™å¾ˆå¥½;å®ƒï¼†ï¼ƒ39;ä½çš„åŠªåŠ›ï¼Œè®©ä»»ä½•ç»„ä»¶å¿«é€Ÿè®¿é—®å½“å‰ç”¨æˆ·ã€‚è¿™å”¯ä¸€çš„ç¼ºç‚¹æ˜¯æ‚¨å¯èƒ½æœ‰è®¸å¤šOnauthstateChangedå¬ä¼—;æˆ‘å¯ä»¥é€šè¿‡ä»…ç»‘å®šä¸€ä¸ªä¾¦å¬å™¨ï¼Œæˆ–è€…é€šè¿‡å°†å½“å‰ç”¨æˆ·æ”¾åœ¨ä¸Šä¸‹æ–‡ä¸­æ¥ç¼“è§£è¿™ä¸€ç‚¹ã€‚</p><p> Talking of context, that&#39;s much closer to the approach I take with Svelte and use a  writable store.</p><p> è°ˆè®ºä¸Šä¸‹æ–‡ï¼Œï¼†ï¼ƒ39;è¾ƒè¿‘æˆ‘å¸¦æœ‰Svelteçš„æ–¹æ³•ï¼Œå¹¶ä½¿ç”¨å¯å†™å•†åº—ã€‚ </p><p> export  const currentUser  =  writable ( )   export  const  listenForAuthChanges  =  ( )  =&gt;  {   return firebase . auth ( ) . onAuthStateChanged ( ( details )  =&gt;  {   if  (details )  {  currentUser . set ( {  displayName : details .displayName ,  provider :  {   &#39;google.com&#39; :  &#39;Google&#39; ,   &#39;github.com&#39; :  &#39;GitHub&#39; ,   } [details .providerData [ 0 ] .providerId ] ,  uid : details .uid ,   } )   }  else  {  currentUser . set ( null )   }   } )  }</p><p>Export Const CurrentUser =å¯å†™ï¼ˆï¼‰å¯¼å‡ºconst listenforauthchanges =ï¼ˆï¼‰=ï¼†gt; {è¿”å›Firebaseã€‚ authï¼ˆï¼‰ã€‚ OnauthStateChangedï¼ˆï¼ˆè¯¦ç»†ä¿¡æ¯ï¼‰=ï¼†gt; {ifï¼ˆè¯¦ç»†ä¿¡æ¯ï¼‰{uscusererã€‚è®¾ç½®ï¼ˆ{displaynameï¼šè¯¦ç»†ä¿¡æ¯.displaynameï¼Œæä¾›ç¨‹åºï¼š{ï¼†ï¼ƒ39; google.comï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39;è°·æ­Œï¼†ï¼ƒ39;ï¼Œï¼†ï¼ƒ 39; github.comï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39; githubï¼†ï¼ƒ39;ï¼Œ} [è¯¦ç»†ä¿¡æ¯.providerdata [0] .providerid]ï¼Œuidï¼šè¯¦ç»†ä¿¡æ¯.uidï¼Œ}ï¼‰} else {lustuserã€‚setï¼ˆnullï¼‰}}ï¼‰ }</p><p> Within the top level Svelte component, I can call this within  onMount, which will run once when the component is mounted (the function is  returned so we unsubscribe when the component is removed, much like how  useEffect lets you return a function).</p><p> åœ¨é¡¶å±‚Svelteç»„ä»¶ä¸­ï¼Œæˆ‘å¯ä»¥åœ¨onmountå†…è°ƒç”¨æ­¤ï¼Œè¿™å°†åœ¨æŒ‚è½½ç»„ä»¶æ—¶è¿è¡Œä¸€æ¬¡ï¼ˆè¿”å›è¯¥å‡½æ•°ï¼Œå› æ­¤æˆ‘ä»¬åœ¨åˆ é™¤ç»„ä»¶æ—¶å–æ¶ˆè®¢é˜…ï¼Œå°±åƒä½¿ç”¨çš„æ˜¯ä½¿ç”¨yeffect excume yours yours yours yourse yeffectï¼‰ã€‚</p><p>  Now anywhere in my Svelte codebase, a component can import the  currentUser writable store, and act accordingly. What I like is that  currentUser isn&#39;t a value, it&#39;s a store, and therefore you have full control over how you deal with it. You can either subscribe to it and manually control with state changes:</p><p>  ç°åœ¨åœ¨æˆ‘çš„svelteä»£ç åº“ä¸­çš„ä»»ä½•åœ°æ–¹ï¼Œä¸€ä¸ªç»„ä»¶å¯ä»¥å¯¼å…¥æ™®ç…§ç”¨æˆ·å¯å†™å­˜å‚¨ï¼Œå¹¶ç›¸åº”è¡ŒåŠ¨ã€‚æˆ‘å–œæ¬¢çš„æ˜¯æ™®ç…§ç”¨æˆ·ISNï¼†ï¼ƒ39; t aå€¼ï¼Œå®ƒï¼†ï¼ƒ39;å®ƒçš„ä¸€å®¶å•†åº—ï¼Œå› æ­¤æ‚¨å¯ä»¥å®Œå…¨æ§åˆ¶æ‚¨å¦‚ä½•å¤„ç†å®ƒã€‚æ‚¨å¯ä»¥è®¢é˜…å®ƒå¹¶ä½¿ç”¨çŠ¶æ€æ›´æ”¹æ‰‹åŠ¨æ§åˆ¶ï¼š</p><p>  Or, if you want to just read the latest value, you can prefix it with a  $:</p><p>  æˆ–è€…ï¼Œå¦‚æœæ‚¨æƒ³è¦ä»”ç»†é˜…è¯»æœ€æ–°å€¼ï¼Œåˆ™å¯ä»¥ä½¿ç”¨$å‰ç¼€ä¸º$ï¼š</p><p>  This is where some of Svelte&#39;s syntax trickery begins to shine; this dollar prefix trick automatically subscribes you to the store&#39;s latest value. I both like and dislike this; it&#39;s a nice syntax once you know it, but it&#39;s a bit odd as a beginner to get used to. However I like that Svelte doesn&#39;t make me use the  subscribe API every time I need to read the value.</p><p>  è¿™æ˜¯ä¸€äº›Svelteï¼†ï¼ƒ39; sè¯­æ³•æŠ€å·§å¼€å§‹å‘å…‰çš„åœ°æ–¹;è¿™æ¬¾ç¾å…ƒå‰ç¼€æŠ€å·§è‡ªåŠ¨å‘æ‚¨è®¢è´­å•†åº—ï¼†ï¼ƒ39;æœ€æ–°å€¼ã€‚æˆ‘éƒ½å–œæ¬¢å’Œä¸å–œæ¬¢è¿™ä¸ª;å®ƒä¸€æ—¦ä½ çŸ¥é“ï¼Œå®ƒå°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è¯­æ³•ï¼Œä½†å®ƒï¼†ï¼ƒ39;æœ‰ç‚¹å¥‡æ€ªä½œä¸ºåˆå­¦è€…ä¹ æƒ¯ã€‚ä½†æ˜¯ï¼Œæˆ‘å–œæ¬¢é‚£ä¸ªsvelteå¹¶åœ¨æ¯æ¬¡éœ€è¦è¯»å–è¯¥å€¼æ—¶è®©æˆ‘ä½¿ç”¨è®¢é˜…APIã€‚</p><p> As far as basic authentication goes, both libraries seem to take similar approaches here. Whilst the terminology and exact syntax differs slightly, both allow you to subscribe to a Firebase listener and get updated when the authentication state changes. React&#39;s contexts and Svelte&#39;s stores play almost identical roles for their library.</p><p> å°±åŸºæœ¬èº«ä»½éªŒè¯è€Œè¨€ï¼Œè¿™ä¸¤ä¸ªåº“ä¼¼ä¹éƒ½åœ¨è¿™é‡Œé‡‡å–ç±»ä¼¼çš„æ–¹æ³•ã€‚è™½ç„¶æœ¯è¯­å’Œç²¾ç¡®è¯­æ³•ç•¥æœ‰ä¸åŒï¼Œä½†ä¸¤è€…éƒ½å…è®¸æ‚¨è®¢é˜…Firebaseä¾¦å¬å™¨å¹¶åœ¨éªŒè¯çŠ¶æ€æ›´æ”¹æ—¶æ›´æ–°ã€‚ååº”ï¼†ï¼ƒ39; sçš„ä¸Šä¸‹æ–‡å’Œsvelteï¼†ï¼ƒ39; så•†åº—å¯¹ä»–ä»¬çš„å›¾ä¹¦é¦†å‘æŒ¥å‡ ä¹ç›¸åŒçš„è§’è‰²ã€‚</p><p>  Pomodone has to keep a 25 minute timer going and try to be as accurate as possible. If a browser tab is backgrounded (e.g., not the focused tab), most browsers will lower the priority of its  setTimeout calls and not run them strictly to time. Most of the time on the web this isn&#39;t a massive deal, but when a user is tracking 25 minutes of work via your app, it is! Plus, over the course of 25 minutes, any slight time drift will cause the final time to be quite far off. However, if these timeouts are moved into a web worker, they should run to time and not get de-prioritised by the browser.</p><p>  Pomodoneå¿…é¡»ä¿æŒ25åˆ†é’Ÿçš„è®¡æ—¶å™¨ï¼Œå¹¶å°½é‡å°½å¯èƒ½å‡†ç¡®ã€‚å¦‚æœèƒŒæ™¯ï¼ˆä¾‹å¦‚ï¼Œä¸æ˜¯èšç„¦é€‰é¡¹å¡ï¼‰ï¼Œå¤§å¤šæ•°æµè§ˆå™¨å°†é™ä½å…¶SetTimeoutè°ƒç”¨çš„ä¼˜å…ˆçº§ï¼Œè€Œä¸æ˜¯ä¸¥æ ¼è¿è¡Œæ—¶é—´ã€‚å¤§éƒ¨åˆ†æ—¶é—´åœ¨ç½‘ä¸Šè¿™ä¸ªéƒ½æ˜¯ä¸€ä¸ªå¤§é‡çš„äº¤æ˜“ï¼Œä½†æ˜¯å½“ç”¨æˆ·é€šè¿‡ä½ çš„åº”ç”¨ç¨‹åºè·Ÿè¸ª25åˆ†é’Ÿçš„å·¥ä½œæ—¶ï¼Œå®ƒæ˜¯ï¼æ­¤å¤–ï¼Œåœ¨25åˆ†é’Ÿçš„è¿‡ç¨‹ä¸­ï¼Œä»»ä½•è½»å¾®çš„æ—¶é—´æ¼‚ç§»â€‹â€‹éƒ½ä¼šå¯¼è‡´æœ€åä¸€æ¬¡æ›´è¿œã€‚ä½†æ˜¯ï¼Œå¦‚æœè¿™äº›è¶…æ—¶è¢«ç§»åŠ¨åˆ°Webå·¥ä½œè€…ï¼Œåˆ™å®ƒä»¬åº”è¯¥è¿è¡Œæ—¶é—´è€Œä¸ä¼šè¢«æµè§ˆå™¨è¿›è¡Œé™¤è§æ‰€è¦æ±‚ã€‚ </p><p> Therefore, in my  Tracker component, I need to instantiate a web worker, send it messages and receive data (such as time remaining) back. This is one area where I found React more &#34;admin heavy&#34; than Svelte; because React components are re-executed every time the component re-renders, you can easily end up with thousands of workers being created! It&#39;s essential to use  useRef to avoid this problem by maintaining a reference to the worker that you&#39;ve created.</p><p>å› æ­¤ï¼Œåœ¨æˆ‘çš„è·Ÿè¸ªå™¨ç»„ä»¶ä¸­ï¼Œæˆ‘éœ€è¦å®ä¾‹åŒ–ä¸€ä¸ªWebå·¥ä½œè€…ï¼Œå‘é€å®ƒæ¶ˆæ¯å¹¶æ¥æ”¶æ•°æ®ï¼ˆä¾‹å¦‚å‰©ä½™æ—¶é—´ï¼‰ã€‚è¿™æ˜¯æˆ‘å‘ç°çš„ä¸€ä¸ªé¢†åŸŸï¼Œå…¶ä¸­ï¼†ï¼ƒ34; adminé‡ï¼ƒ34;æ¯”velte;å› ä¸ºæ¯æ¬¡ç»„ä»¶é‡æ–°æ¸²æŸ“æ—¶é‡æ–°æ‰§è¡ŒReactç»„ä»¶ï¼Œæ‰€ä»¥æ‚¨å¯ä»¥è½»æ¾åœ°ç»“æŸæˆåƒä¸Šä¸‡çš„å·¥äººï¼å®ƒï¼†ï¼ƒ39;å¯¹äºä½¿ç”¨valefæ¥é¿å…å¯¹æ‚¨åˆ›å»ºçš„å·¥äººçš„å‚è€ƒæ¥é¿å…è¿™ä¸ªé—®é¢˜ã€‚</p><p>   And then create a  useEffect hook that will instantiate the worker, if required, and bind an event listener to listen for messages:</p><p>   ç„¶ååˆ›å»ºä¸€ä¸ªä½¿ç”¨æ•ˆæœé’©å­ï¼Œå¦‚æœéœ€è¦ï¼Œå°†å®ä¾‹åŒ–å·¥ä½œè€…ï¼Œå¹¶ç»‘å®šäº‹ä»¶ä¾¦å¬å™¨ä»¥ä¾¦å¬æ¶ˆæ¯ï¼š</p><p> useEffect ( ( )  =&gt;  {   if  ( !worker .current )  {  worker .current  =  new   (workerURL )  window .worker  = worker .current   }    const  onMessage  =  ( event )  =&gt;  {   if  (event .data .name  ===  &#39;tick&#39; )  {   setCurrentPom ( ( currentPom )  =&gt;  ( {   ...currentPom ,  secondsRemaining : event .data .counter ,   } ) )   }  else  if  (event .data .name  ===  &#39;start&#39; )  {   // More branches removed here to save space...   }   }  worker .current . addEventListener ( &#39;message&#39; , onMessage )    return  ( )  =&gt;  {  worker .current . removeEventListener ( &#39;message&#39; , onMessage )   }  } ,  [currentUser ] )</p><p> ä½¿ç”¨effeffectï¼ˆï¼ˆï¼‰=ï¼†gt; {ifï¼ˆï¼worker .currentï¼‰{worlter .current = newï¼ˆwarlerullï¼‰çª—å£.worker = worker .current} const onmessage =ï¼ˆäº‹ä»¶ï¼‰=ï¼†gt; {ifï¼ˆäº‹ä»¶.data .name = ==ï¼†ï¼ƒ39;å‹¾é€‰ï¼†ï¼ƒ39;ï¼‰{setCurrentPomï¼ˆï¼ˆcurrentPomï¼‰=ï¼†gt;ï¼ˆ{... currentPomï¼Œç§’æ•°ï¼šäº‹ä»¶.data .counterï¼Œ}ï¼‰}å¦‚æœï¼ˆäº‹ä»¶.data .name === ï¼†ï¼ƒ39; startï¼†ï¼ƒ39;ï¼‰{//åœ¨è¿™é‡Œåˆ é™¤çš„æ›´å¤šåˆ†æ”¯ä»¥ä¿å­˜ç©ºé—´...}}}å·¥ä½œè€….Currentã€‚addeventListenerï¼ˆï¼†ï¼ƒ39;æ¶ˆæ¯ï¼†ï¼ƒ39;ï¼Œonmessageï¼‰returnï¼ˆï¼‰=ï¼†gt; {å·¥äººã€‚å½“å‰ã€‚RemoveeventListenerï¼ˆï¼†ï¼ƒ39;æ¶ˆæ¯ï¼†ï¼ƒ39;ï¼Œonmessageï¼‰}ï¼Œ[æ™®æŸ¥é˜Ÿ]ï¼‰</p><p> And then, when the user hits the &#34;Start&#34; button, I have to send the worker a message:</p><p> ç„¶åï¼Œå½“ç”¨æˆ·å‡»ä¸­ï¼†ï¼ƒ34;å¼€å§‹ï¼†ï¼ƒ34;æŒ‰é’®ï¼Œæˆ‘å¿…é¡»å‘é€å·¥ä½œè€…æ¶ˆæ¯ï¼š</p><p>  Svelte looks pretty similar, but has two small changes that personally make the Svelte code easier to read, in my opinion:</p><p>  Svelteçœ‹èµ·æ¥å¾ˆç›¸ä¼¼ï¼Œä½†æœ‰ä¸¤ä¸ªå°å˜åŒ–ï¼Œä¸ªäººä½¿Svelteä»£ç æ›´å®¹æ˜“é˜…è¯»ï¼Œåœ¨æˆ‘çœ‹æ¥ï¼š</p><p> We don&#39;t have to keep the worker in  useRef, and can just assign it to a variable.</p><p> æˆ‘ä»¬ä¸å¿…å°†å·¥äººä¿ç•™åœ¨Userefä¸­ï¼Œå¯ä»¥å°†å…¶åˆ†é…ç»™å˜é‡ã€‚</p><p> We can pull the event listener code out into a function more easily, as that function won&#39;t then become a dependency to a  useEffect - at which point we will have to wrap it in  useCallback.</p><p> æˆ‘ä»¬å¯ä»¥æ›´è½»æ¾åœ°å°†äº‹ä»¶ä¾¦å¬å™¨ä»£ç æ›´å®¹æ˜“åœ°è¾“å‡ºï¼Œå› ä¸ºè¯¥å‡½æ•°Wonï¼†ï¼ƒ39; tç„¶åæˆä¸ºä¸€ä¸ªä½¿ç”¨effeffectçš„ä¾èµ– - é‚£ä¹ˆæˆ‘ä»¬å¿…é¡»å°†å…¶åŒ…è£…åœ¨USECALLBALLä¸­ã€‚ </p><p>  let worker  onMount ( ( )  =&gt;  {  worker  =  new   (workerURL )  worker . addEventListener ( &#39;message&#39; , onWorkerMessage )   return  ( )  =&gt;  {  worker . removeEventListener ( &#39;message&#39; , onWorkerMessage )   }  } )</p><p>è®©å·¥ä½œè€…onmountï¼ˆï¼ˆï¼‰=ï¼†gt; {worler = newï¼ˆworkerullï¼‰å·¥ä½œè€…ã€‚addeventlistenerï¼ˆï¼†ï¼ƒ39; messageï¼†ï¼ƒ39;ï¼Œonworkermessageï¼‰returnï¼ˆï¼‰=ï¼†gt; {worlterã€‚removeeventlistenerï¼ˆï¼†ï¼ƒ39;æ¶ˆæ¯ï¼†ï¼ƒ39; ï¼Œonworkermessageï¼‰}}ï¼‰</p><p> We also don&#39;t have to set state by using React&#39;s  setX(oldX =&gt; newX) convention, and can just mutate the local variable:</p><p> æˆ‘ä»¬ä¹Ÿä¸è¦ä½¿ç”¨Reactï¼†ï¼ƒ39; s setxï¼ˆoldx =ï¼†gt; newxï¼‰æƒ¯ä¾‹æ¥è®¾ç½®çŠ¶æ€ï¼Œå¹¶ä¸”å¯ä»¥åªæ˜¯çªå˜å±€éƒ¨å˜é‡ï¼š</p><p> function  onWorkerMessage ( event )  {   if  (event .data .name  ===  &#39;tick&#39; )  {  currentPom  =  {   ...currentPom ,  secondsRemaining : event .data .counter ,   }   }  else  if  (event .data .name  ===  &#39;start&#39; )  {   // More branches here removed to save space...   }  }</p><p> å‡½æ•°onWorkermessageï¼ˆäº‹ä»¶ï¼‰{ifï¼ˆäº‹ä»¶.data .name ===ï¼†ï¼ƒ39;å‹¾é€‰ï¼†ï¼ƒ39;ï¼‰{currentpom = {... currentpomï¼ŒstickeRemainingï¼šäº‹ä»¶.data .counterï¼Œ}} elseï¼ˆäº‹ä»¶.data .name ===ï¼†ï¼ƒ39; startï¼†ï¼ƒ39;ï¼‰{//æ›´å¤šåˆ†æ”¯æœºæ„åˆ é™¤ä»¥ä¿å­˜ç©ºé—´...}}</p><p> Here&#39;s where I start to have a preference for Svelte; the two are very similar but once I got used to Svelte I found that React felt like jumping through hoops. You can&#39;t create a worker instance, it has to go in a  useRef, and then you can&#39;t easily pull code out into a function without then requiring  useCallback so it can be a safe dependency on  useEffect. With Svelte I write code that&#39;s closer to &#34;plain&#34; JavaScript, whereas in React more of my code is wrapped in a React primitive.</p><p> è¿™é‡Œï¼†ï¼ƒ39;æˆ‘å¼€å§‹æœ‰å¦™è¯­çš„åå¥½;è¿™ä¸¤è€…éå¸¸ç›¸ä¼¼ï¼Œä½†æ˜¯ä¸€æ—¦æˆ‘ä¹ æƒ¯äº†Svelteï¼Œæˆ‘å‘ç°é‚£ç§ååº”æ„Ÿè§‰åƒè·³è¿‡ç®ä¸€æ ·ã€‚æ‚¨å¯ä»¥åˆ›å»ºä¸€ä¸ªå·¥äººå®ä¾‹ï¼Œå®ƒå¿…é¡»è¿›å…¥USERFï¼Œç„¶åæ‚¨å¯ä»¥ï¼†ï¼ƒ39; tè½»æ¾åœ°å°†ä»£ç æ‹‰å‡ºåˆ°ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œè€Œæ— éœ€USECALLBALLï¼Œå› æ­¤å®ƒå¯ä»¥æ˜¯å¯¹ä½¿ç”¨æ•ˆæœçš„å®‰å…¨ä¾èµ–æ€§ã€‚ä½¿ç”¨svelteæˆ‘å†™ä»£ç ï¼†ï¼ƒ39;é è¿‘ï¼†ï¼ƒ34; plainï¼†ï¼ƒ34; JavaScriptï¼Œè€Œåœ¨ååº”åŸå§‹ä¸­å°†æ›´å¤šçš„ä»£ç é€ æˆæ›´å¤šä»£ç ã€‚</p><p>  One part of React that I&#39;ve always championed is how  it&#39;s just JavaScript. I like that in React you don&#39;t use a distinct template syntax and instead embed JavaScript, compared to Svelte&#39;s templating language:</p><p>  ååº”çš„ä¸€éƒ¨åˆ†æ˜¯æˆ‘ï¼†ï¼ƒ39; Veå§‹ç»ˆå† å†›çš„ååº”æ˜¯å®ƒçš„ï¼†ï¼ƒ39; såªæ˜¯javascriptã€‚æˆ‘å–œæ¬¢é‚£ä¸ªååº”ä½ ä¸è¦ä½¿ç”¨ä¸åŒçš„æ¨¡æ¿è¯­æ³•ï¼Œè€Œæ˜¯ä¸svelteï¼†ï¼ƒ39; sæ¨¡æ¿è¯­è¨€ç›¸æ¯”åµŒå…¥äº†javascriptï¼š</p><p>  {pomsForCurrentDay . map ( entryData , index )  =&gt;  {   const finishedAt  =  format ( new   (entryData .timeFinished ) ,  &#39;H:mm:ss&#39; )   return   {index  +  1 }    } ) }</p><p>  {PomsforCurrentdayã€‚åœ°å›¾ï¼ˆentrydataï¼Œindexï¼‰=ï¼†gt; {const iteftat =æ ¼å¼ï¼ˆnewï¼ˆentrydata .timefinishedï¼‰ï¼Œï¼†ï¼ƒ39; hï¼šmmï¼šssï¼†ï¼ƒ39;ï¼‰è¿”å›{index + 1}}ï¼‰}</p><p> &lt;ul  class = &#34;poms-list&#34; &gt;   {#each currentDayPoms  as value , index }   &lt;li  title = {  ` Finished at   ${ format (   new   (value .timeFinished ) ,   &#39;H:mm:ss&#39;   ) } ` }   &gt;   {index  +  1 }   &lt; /li &gt;   { /each }  &lt; /ul &gt;</p><p> ï¼†lt; ul class =ï¼†ï¼ƒ34; poms-listï¼†ï¼ƒ34; ï¼†gt; {#ach CurrandayPoMSä¸ºå€¼ï¼Œç´¢å¼•}ï¼†lt; liæ ‡é¢˜= {`ä»¥$ {æ ¼å¼å®Œæˆï¼ˆé‡å¤§å€¼ã€‚ {index + 1}ï¼†lt; / Liï¼†gt; {/æ¯ä¸ª}ï¼†lt; / ulï¼†gt; </p><p> I was pleasantly surprised by Svelte&#39;s templating; in the past I&#39;ve found templating languages overwhelming and inflexible, but Svelte offers just the right amount of templating whilst enabling you to use JavaScript too. That said, I will always find React&#39;s approach easier - at least in my head - and I think more friendly to people familiar with JavaScript who are learning a library.</p><p>æˆ‘å¯¹Svelteï¼†ï¼ƒ39çš„æ¨¡æ¿æ„Ÿåˆ°æƒŠå–œ;åœ¨è¿‡å»çš„æˆ‘ï¼†ï¼ƒ39; veå‘ç°æ¨¡æ¿è¯­è¨€å‹å€’æ€§å’Œä¸çµæ´»ï¼Œä½†Svelteæä¾›äº†é€‚é‡çš„æ¨¡æ¿ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ä½¿ç”¨JavaScriptã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘å°†æ°¸è¿œå‘ç°ååº”ï¼†ï¼ƒ39;è‡³å°‘åœ¨æˆ‘çš„å¤´ä¸Šï¼Œæˆ‘è®¤ä¸ºå¯¹ç†Ÿæ‚‰æ­£åœ¨å­¦ä¹ å›¾ä¹¦é¦†çš„javascriptçš„äººæ›´å‹å¥½ã€‚</p><p> However, Svelte does have some nice touches to its syntax when it comes to rendering components (which feels very JSX-like). My favourite is the ability to collapse props:</p><p> ä½†æ˜¯ï¼Œåœ¨æ¸²æŸ“ç»„ä»¶ï¼ˆæ„Ÿè§‰éå¸¸JSXç±»ä¼¼ï¼‰æ—¶ï¼ŒSvelteç¡®å®æœ‰ä¸€äº›å¾ˆå¥½çš„è§¦æ‘¸å®ƒçš„è¯­æ³•ã€‚æˆ‘æœ€å–œæ¬¢çš„æ˜¯æŠ˜å é“å…·çš„èƒ½åŠ›ï¼š</p><p>      React requires us to use  useEffect and other hooks because it fully controls how all your code is run and re-runs your code whenever a component is re-rendered. Svelte is different in that by default most of your code is only going to run once; a  console.log(&#39;foo&#39;) line in a component will only run when that component is first rendered. In React, it will run many times.</p><p>      Reactè¦æ±‚æˆ‘ä»¬ä½¿ç”¨IndeFeffectå’Œå…¶ä»–é’©å­ï¼Œå› ä¸ºå®ƒå®Œå…¨æ§åˆ¶äº†æ‰€æœ‰ä»£ç å¦‚ä½•è¿è¡Œå¹¶åœ¨é‡æ–°å‘ˆç°ç»„ä»¶æ—¶é‡æ–°è¿è¡Œä»£ç ã€‚ Svelteæ˜¯ä¸åŒçš„ï¼Œå› ä¸ºé»˜è®¤æƒ…å†µä¸‹ï¼Œå¤§å¤šæ•°ä»£ç åªèƒ½è¿è¡Œä¸€æ¬¡; CONSOLE.LOGï¼ˆï¼†ï¼ƒ39; fooï¼†ï¼ƒ39;ï¼‰åœ¨ç»„ä»¶ä¸­åªåœ¨ç¬¬ä¸€æ¬¡å‘ˆç°è¯¥ç»„ä»¶æ—¶è¿è¡Œã€‚åœ¨ååº”ä¸­ï¼Œå®ƒå°†è¿è¡Œå¾ˆå¤šæ¬¡ã€‚</p><p> React&#39;s re-rendering approach has its upsides: let&#39;s say you are taking in a big list of data and running some function to convert it into data that you can render. In React, within your component, you can write:</p><p> ååº”ï¼†ï¼ƒ39; Sé‡æ–°æ¸²æŸ“æ–¹æ³•æœ‰å…¶ä¸Šé™ï¼šå‡è®¾æ‚¨æ­£åœ¨è¿›è¡Œå¤§é‡æ•°æ®åˆ—è¡¨ï¼Œå¹¶è¿è¡Œä¸€äº›åŠŸèƒ½ä»¥å°†å…¶è½¬æ¢ä¸ºæ‚¨å¯ä»¥å‘ˆç°çš„æ•°æ®ã€‚åœ¨æ‚¨çš„ç»„ä»¶ä¸­ååº”ï¼Œæ‚¨å¯ä»¥å†™å…¥ï¼š</p><p>  And this will always be up to date - should the user provide new  props.inputData, the component will re-render and the output will be updated.</p><p>  å¹¶ä¸”è¿™å°†å§‹ç»ˆæ˜¯æœ€æ–°çš„ - å¦‚æœç”¨æˆ·æä¾›æ–°çš„Props.InputDataï¼Œåˆ™ç»„ä»¶å°†é‡æ–°å‘ˆç°ï¼Œè¾“å‡ºå°†æ›´æ–°ã€‚</p><p>   Here the output will be rendered the first time the component is rendered, but then not updated at all. We can solve this in two ways, either by using the  $: label syntax, which marks the code as reactive, or by moving our transform logic into the template:</p><p>   è¿™é‡Œé¦–æ¬¡å‘ˆç°ç»„ä»¶çš„è¾“å‡ºå°†å‘ˆç°ï¼Œä½†æ ¹æœ¬ä¸ä¼šæ›´æ–°ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨$ï¼šæ ‡ç­¾è¯­æ³•ä»¥ä¸¤ç§æ–¹å¼è§£å†³è¿™ä¸€æ–¹å¼ï¼Œå®ƒå°†ä»£ç æ ‡è®°ä¸ºååº”ï¼Œæˆ–è€…é€šè¿‡å°†æˆ‘ä»¬çš„è½¬æ¢é€»è¾‘ç§»åŠ¨åˆ°æ¨¡æ¿ä¸­ï¼š</p><p>    This is another example of Svelte taking JavaScript syntax and using it for a slightly different meaning; it tells Svelte that the statement is  reactive and should be recalculate should any imports change. You might also call it a &#34;computed property&#34;. The second solution simply moves the logic into the template, thus ensuring that when the component re-renders the logic is executed again. In my time with Svelte this is the approach I&#39;ve gone with most of the time, often pulling out the logic into a function:</p><p>    è¿™æ˜¯Svelteæ‹æ‘„JavaScriptè¯­æ³•çš„å¦ä¸€ä¸ªä¾‹å­ï¼Œå¹¶ä½¿ç”¨å®ƒç•¥æœ‰ä¸åŒçš„å«ä¹‰;å®ƒå‘Šè¯‰Svelteå£°æ˜æ˜¯ååº”æ€§çš„ï¼Œå¦‚æœä»»ä½•è¿›å£æ”¹å˜ï¼Œåº”é‡æ–°è®¡ç®—ã€‚æ‚¨ä¹Ÿå¯ä»¥ç§°ä¹‹ä¸ºAï¼†ï¼ƒ34;è®¡ç®—çš„å±æ€§ï¼†ï¼ƒ34;ç¬¬äºŒä¸ªè§£å†³æ–¹æ¡ˆåªéœ€å°†é€»è¾‘ç§»åŠ¨åˆ°æ¨¡æ¿ä¸­ï¼Œä»è€Œç¡®ä¿å½“ç»„ä»¶é‡æ–°æ¸²æŸ“é€»è¾‘æ—¶å†æ¬¡æ‰§è¡Œã€‚åœ¨æˆ‘çš„æ—¶é—´ä¸svelteè¿™æ˜¯æˆ‘å¤§éƒ¨åˆ†æ—¶é—´éƒ½èµ°äº†çš„æ–¹æ³•ï¼Œç»å¸¸å°†é€»è¾‘æ‹‰åˆ°ä¸€ä¸ªå‡½æ•°ï¼š </p><p>  Coming from React to Svelte this did catch me out numerous times but for me I now prefer Svelte&#39;s approach, particularly because it removes some of the boilerplate around  useEffect.</p><p>æ¥è‡ªæ™ºæ…§çš„ååº”ï¼Œè¿™ç¡®å®å¾ˆå¤šæ¬¡ï¼Œä½†å¯¹æˆ‘æ¥è¯´ï¼Œæˆ‘ç°åœ¨æ›´å–œæ¬¢Svelteï¼†ï¼ƒ39; Sçš„æ–¹æ³•ï¼Œç‰¹åˆ«æ˜¯å› ä¸ºå®ƒå»é™¤äº†å›´ç»•ä½¿ç”¨çš„ä¸€äº›æ ·æ¿ã€‚</p><p>  Component composition is a huge part of what makes working with a component based framework enjoyable or not and it&#39;s something that both React and Svelte solve well. React&#39;s  children prop makes it very easy to render any provided content:</p><p>  ç»„ä»¶ç»„æˆæ˜¯ä½¿åŸºäºç»„ä»¶åŸºäºç»„ä»¶çš„æ¡†æ¶ä¸”è¯¸å¦‚ååº”å’ŒSvelteè§£å†³æ–¹æ¡ˆçš„ä¸œè¥¿çš„å·¨å¤§éƒ¨åˆ†ã€‚ Reactï¼†ï¼ƒ39; sendrain propä½¿å…¶å¾ˆå®¹æ˜“æ¸²æŸ“ä»»ä½•æä¾›çš„å†…å®¹ï¼š</p><p>  (If you&#39;ve not read it, the  React guide on Composition is well worth a read).</p><p>  ï¼ˆå¦‚æœä½ æ²¡æœ‰é˜…è¯»å®ƒï¼Œé‚£ä¹ˆç»„åˆç‰©çš„ååº”æŒ‡å—éƒ½å€¼å¾—ä¸€è¯»ï¼‰ã€‚</p><p>   They take different approaches when it comes to multiple children, and this is where I find myself preferring Svelte&#39;s approach more. React suggest passing through multiple props:</p><p>   å½“æ¶‰åŠå¤šä¸ªå­©å­æ—¶ï¼Œä»–ä»¬é‡‡å–ä¸åŒçš„æ–¹æ³•ï¼Œè¿™å°±æ˜¯æˆ‘å‘ç°è‡ªå·±æ›´å–œæ¬¢æ™ºæ…§çš„åœ°æ–¹ã€‚ååº”è¡¨æ˜é€šè¿‡å¤šä¸ªé“å…·ï¼š</p><p> function  Box ( props )  {   return  (        {props .left }      {props .right }        )  }   function  App ( )  {   return    }</p><p> åŠŸèƒ½æ¡†ï¼ˆé“å…·ï¼‰{returnï¼ˆ{props .left} {props .right}ï¼‰}å‡½æ•°appï¼ˆï¼‰{return}</p><p> One gripe I&#39;ve had with this approach is that you lose the visual cues that you&#39;re passing children into the Box component; they now aren&#39;t nested within the Box when you render them like we&#39;re used to in HTML; it&#39;s now up to you to read the props and spot which ones are being used to provide children. It&#39;s easily done on this dummy example, but harder in &#34;real world&#34; applications - or at least, I find it harder!</p><p> ä¸€ä¸ªæŠ±ç€æˆ‘çš„æ–¹æ³•æ˜¯è¿™ç§æ–¹æ³•ï¼Œä½ è¿˜å¤±å»äº†ä½ çš„è§†è§‰çº¿ç´¢å’Œï¼ƒ39;å°†å­©å­ä»¬ä¼ å…¥ç›’å­ç»„ä»¶;å½“ä½ åƒæˆ‘ä»¬ä¸€æ ·æ¸²æŸ“å®ƒä»¬æ—¶ï¼Œä»–ä»¬ç°åœ¨ä»ç„¶åµŒå¥—åœ¨ç›’å­é‡Œã€‚å®ƒç°åœ¨ç”±æ‚¨è¯»åˆ°ç”¨äºæä¾›å„¿ç«¥çš„é“å…·å’Œä½ç½®ã€‚å®ƒï¼†ï¼ƒ39è½»æ¾åœ¨è¿™ä¸ªè™šè®¾çš„ä¾‹å­ä¸Šå®Œæˆï¼Œä½†åœ¨ï¼†ï¼ƒ34ä¸­æ›´éš¾;ç°å®ä¸–ç•Œï¼†ï¼ƒ34;åº”ç”¨ç¨‹åº - æˆ–è€…è‡³å°‘ï¼Œæˆ‘å‘ç°å®ƒæ›´éš¾ï¼</p><p> Svelte&#39;s approach is to define multiple slots with explicit names to let the user provide the elements that should fill those slots:</p><p> svelteï¼†ï¼ƒ39; sæ–¹æ³•æ˜¯å®šä¹‰å…·æœ‰æ˜¾å¼åç§°çš„å¤šä¸ªæ’æ§½ï¼Œè®©ç”¨æˆ·æä¾›åº”è¯¥å¡«å……è¿™äº›æ’æ§½çš„å…ƒç´ ï¼š </p><p>  I like this approach more because I can scan the code that renders the  Box component and easily spot that it takes two children. If the  Box took any props, they&#39;d be within the opening  &lt;Box&gt; tag, and they would be distinct from any children props.</p><p>æˆ‘å–œæ¬¢è¿™ç§æ–¹æ³•æ›´å¤šï¼Œå› ä¸ºæˆ‘å¯ä»¥æ‰«ææ¸²æŸ“æ¡†ç»„ä»¶çš„ä»£ç ï¼Œå¹¶ä¸”è½»æ¾å‘ç°å®ƒéœ€è¦ä¸¤ä¸ªå­©å­ã€‚å¦‚æœç›’å­æ¥å—äº†ä»»ä½•é“å…·ï¼Œå®ƒä»¬åœ¨å¼€å£ï¼†lt; boxï¼†gt;æ ‡ç­¾ï¼Œä»–ä»¬ä¼šä¸ä»»ä½•å„¿ç«¥é“å…·ä¸åŒã€‚</p><p> My preference here is biased by the fact that I spend everyday at work building web components, so Svelte&#39;s approach feels very familiar to  slots in web components.</p><p> æˆ‘çš„åå¥½é€šè¿‡æˆ‘æ¯å¤©åœ¨å·¥ä½œå»ºç­‘Webç»„ä»¶ä¸ŠèŠ±è´¹çš„äº‹å®åè§ï¼Œæ‰€ä»¥Svelteï¼†ï¼ƒ39; Sæ–¹æ³•å¯¹Webç»„ä»¶ä¸­çš„æ’æ§½æ„Ÿè§‰éå¸¸ç†Ÿæ‚‰ã€‚</p><p>  I enjoy that Svelte has an opinion about styling; especially in the context of small side projects like Pomodone, it&#39;s great to have that decision made for me. The fact that Svelte can also detect unused CSS is great, and this is one of the reasons why I suspect I&#39;ll reach more for Svelte in future projects.</p><p>  æˆ‘å–œæ¬¢Svelteå¯¹é€ å‹æœ‰æ„ä¹‰;ç‰¹åˆ«æ˜¯åœ¨åƒä¸˜é™µç­‰å°çš„ä¾§é¢é¡¹ç›®çš„èƒŒæ™¯ä¸‹ï¼Œå®ƒå¾ˆé«˜å…´ä¸ºæˆ‘åšå‡ºè¿™ä¸ªå†³å®šã€‚ Svelteè¿˜å¯ä»¥æ£€æµ‹åˆ°æœªä½¿ç”¨çš„CSSçš„äº‹å®æ˜¯å¾ˆå¤§çš„ï¼Œè¿™æ˜¯æˆ‘æ€€ç–‘iï¼†ï¼ƒ39çš„åŸå› ä¹‹ä¸€; LLåœ¨æœªæ¥çš„é¡¹ç›®ä¸­ä¸ºSvelteè¾¾åˆ°æ›´å¤šã€‚</p><p> This isn&#39;t really a downside to React; one of React&#39;s strengths is that it lets you control so much and slot React into your environment, but I like that Svelte comes with a good CSS story out the box.</p><p> è¿™ä¸æ˜¯ä¸€ä¸ªç¼ºç‚¹çš„ååº”; Reactï¼†ï¼ƒ39; Sä¼˜åŠ¿ä¹‹ä¸€æ˜¯å®ƒè®©æ‚¨æ§åˆ¶å¦‚æ­¤å¤šï¼Œæ’æ§½åœ¨æ‚¨çš„ç¯å¢ƒä¸­ååº”ï¼Œä½†æˆ‘å–œæ¬¢é‚£ä¸ªSvelteé™„å¸¦ä¸€ä¸ªå¾ˆå¥½çš„CSSæ•…äº‹ã€‚</p><p>  One small feature I love about Svelte is how I can apply classes conditionally to an element:</p><p>  æˆ‘å–œæ¬¢svelteçš„ä¸€ä¸ªå°åŠŸèƒ½æ˜¯æˆ‘å¦‚ä½•æœ‰æ¡ä»¶åœ°å°†ç±»åº”ç”¨äºå…ƒç´ ï¼š</p><p>  This will apply the class  is-active to the element, but only if the value  isActive is truthy. This reads well, is clear and is great that it comes out of the box.</p><p>  è¿™å°†åº”ç”¨è¯¥ç±»å¯¹å…ƒç´ æœ‰æ•ˆï¼Œä½†ä»…å½“å€¼æ˜¯achiachæ˜¯çœŸå®çš„ã€‚è¿™è¯»å¾—å¾ˆå¥½ï¼Œå¾ˆæ¸…æ¥šï¼Œå¾ˆæ£’ï¼Œå®ƒå‡ºæ¥äº†ç›’å­é‡Œã€‚</p><p> I have used  classnames to achieve similar functionality in React, and it&#39;s a good solution, but I enjoy that Svelte provides this out the box.</p><p> æˆ‘ä½¿ç”¨ClassNamesåœ¨ååº”ä¸­å®ç°äº†ç±»ä¼¼çš„åŠŸèƒ½ï¼Œè€Œä¸”å®ƒæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆï¼Œä½†æˆ‘å–œæ¬¢Svelteæä¾›äº†è¿™ä¸ªç›’å­ã€‚ </p><p>  Similarly to conditional classes, Svelte packs in some extra utilities for binding event listeners in the form of  modifiers. These let you modify event listeners to ask Svelte to include common functionality, such as calling  event.preventDefault(), for you.</p><p>ä¸æ¡ä»¶ç±»ç±»ä¼¼ï¼ŒSvelteåŒ…åœ¨ä¸€äº›é¢å¤–çš„å®ç”¨ç¨‹åºä¸­ï¼Œç”¨äºä»¥ä¿®é¥°ç¨‹åºçš„å½¢å¼ç»‘å®šäº‹ä»¶ä¾¦å¬å™¨ã€‚è¿™äº›å…è®¸æ‚¨ä¿®æ”¹äº‹ä»¶ä¾¦å¬å™¨ä»¥ä¾¿è¯¢é—®Svelteä»¥åŒ…å«å¸¸ç”¨åŠŸèƒ½ï¼Œä¾‹å¦‚è°ƒç”¨event.preventdefaultï¼ˆï¼‰ã€‚</p><p>   &lt;script &gt;  function  click ( )  {   // No need to preventDefault ourselves   // logic here  }  &lt; /script &gt;   &lt;button on :click |preventDefault = {click } &gt;  Click me !  &lt; /button &gt;</p><p>   ï¼†lt; scriptï¼†gt;å‡½æ•°å•å‡»ï¼ˆï¼‰{//æ— éœ€é˜²æ­¢æˆ‘ä»¬è‡ªå·±//é€»è¾‘}}ï¼†lt; / scriptï¼†gt; ï¼†lt;æŒ‰é’®ï¼šå•å‡»| preventdefault = {click}ï¼†gt;ç‚¹å‡»æˆ‘ï¼ ï¼†lt; /æŒ‰é’®ï¼†gt;</p><p>  I like both React and Svelte. Put me in a codebase with either of them and I&#39;ll enjoy it, be productive and happy putting new features together or fixing bugs. I have side projects in React, and others in Svelte, and I&#39;m in no rush to convert any from one to the other. React and Svelte are very similar in many ways, but what I&#39;ve found is that in all the little ways that they are different, I prefer Svelte. The codebase for Pomodone makes more sense to me in Svelte, not React. I find it easier to navigate and work with.</p><p>  æˆ‘å–œæ¬¢ååº”å’Œsvelteã€‚è®©æˆ‘åœ¨ä¸€ä¸ªç æ¯”ä¸­ä¸å…¶ä¸­ä»»ä½•ä¸€ä¸ªï¼Œæˆ‘äº«å—å®ƒï¼Œäº«å—å®ƒï¼Œå¯Œæœ‰æˆæ•ˆï¼Œå¿«ä¹åœ°å°†æ–°åŠŸèƒ½æ”¾åœ¨ä¸€èµ·æˆ–ä¿®å¤é”™è¯¯ã€‚æˆ‘çš„ååº”å’Œå…¶ä»–äººåœ¨Svelteä¸­æœ‰ä¸€æ–¹çš„é¡¹ç›®ï¼Œæˆ‘ï¼†ï¼ƒ39; mæ¯«ä¸æ€¥äºå°†ä»»ä½•ä¸€ä¸ªè½¬æ¢ä¸ºå¦ä¸€ä¸ªã€‚ååº”å’ŒSvelteåœ¨è®¸å¤šæ–¹é¢éå¸¸ç›¸ä¼¼ï¼Œä½†æ˜¯æˆ‘å‘ç°çš„æ˜¯ï¼Œåœ¨å®ƒä»¬ä¸åŒçš„ä¸€åˆ‡æ–¹é¢ï¼Œæˆ‘æ›´å–œæ¬¢Svelteã€‚ POMODONEçš„CODEBASEå¯¹SVelteä¸­çš„MEæ›´ä¸ºæœ‰æ„ä¹‰ï¼Œè€Œä¸æ˜¯ååº”ã€‚æˆ‘å‘ç°å®ƒæ›´å®¹æ˜“å¯¼èˆªå’Œå·¥ä½œã€‚</p><p> If I were to sum up why in one sentence, it&#39;s because  I don&#39;t miss  useEffect. I understand why it exists, I understand the approach React takes, and there are benefits of its approach. But writing complex React components feels more like admin; a constant worry that I&#39;ll miss a dependency in my  useEffect call and end up crashing my browser session. With Svelte I don&#39;t have that lingering feeling, and that&#39;s what I&#39;ve come to enjoy. Svelte is there when I need it with useful APIs, but fades into the background as I put my app together.</p><p> å¦‚æœæˆ‘æ€»ç»“ä¸ºä»€ä¹ˆåœ¨ä¸€å¥è¯ä¸­ï¼Œå®ƒï¼†ï¼ƒ39; sæ˜¯å› ä¸ºæˆ‘æ²¡æœ‰é”™è¿‡ä½¿ç”¨çš„ä½¿ç”¨ã€‚æˆ‘ç†è§£ä¸ºä»€ä¹ˆå®ƒå­˜åœ¨ï¼Œæˆ‘ç†è§£è¿™ç§æ–¹æ³•ä¼šé‡‡å–çš„ï¼Œå¹¶ä¸”æœ‰åˆ©äºå…¶æ–¹æ³•ã€‚ä½†æ˜¯å†™å¤æ‚çš„ååº”ç»„ä»¶æ„Ÿè§‰æ›´åƒæ˜¯ç®¡ç†å‘˜;ä¸€ä¸ªä¸æ–­æ‹…å¿ƒæˆ‘ï¼†ï¼ƒ39; llé”™è¿‡äº†æˆ‘çš„ä½¿ç”¨æ¬¡æ•°å‘¼å«ä¸­çš„ä¾èµ–ï¼Œæœ€ç»ˆå´©æºƒäº†æˆ‘çš„æµè§ˆå™¨ä¼šè¯ã€‚ç”¨svelteæˆ‘æ²¡æœ‰ï¼†ï¼ƒ39; tæœ‰é‚£ç§æŒ¥ä¹‹ä¸å»çš„æ„Ÿè§‰ï¼Œé‚£ä¸ªï¼†ï¼ƒ39;é‚£æ˜¯æˆ‘çš„ï¼†ï¼ƒ39; vereæ¥äº«å—ã€‚å½“æˆ‘ç”¨æœ‰ç”¨çš„APIéœ€è¦æ—¶ï¼Œsvelteæ˜¯åœ¨é‚£é‡Œï¼Œä½†æ˜¯å½“æˆ‘æŠŠæˆ‘çš„åº”ç”¨ç¨‹åºæ”¾åœ¨ä¸€èµ·æ—¶ï¼Œé€æ¸æ¶ˆå¤±ã€‚</p><p> If you enjoyed this post, join the newsletter to get updates on new content ğŸ˜.</p><p> å¦‚æœæ‚¨å–œæ¬¢æ­¤å¸–å­ï¼Œè¯·åŠ å…¥æ—¶äº‹é€šè®¯ä»¥è·å–æ–°å†…å®¹çš„æ›´æ–°ğŸ˜ã€‚ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.jackfranklin.co.uk/blog/comparing-svelte-and-react-javascript/">https://www.jackfranklin.co.uk/blog/comparing-svelte-and-react-javascript/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/svelte/">#svelte</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>