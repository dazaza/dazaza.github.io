<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ç½®æ¢è§£æå™¨ï¼Œä¸éªŒè¯ Permutate Parsers, Don't Validate</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Permutate Parsers, Don't Validate<br/>ç½®æ¢è§£æå™¨ï¼Œä¸éªŒè¯ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 22:27:05</div><div class="page_narrow text-break page_content"><p>â€œParse, donâ€™tvalidateâ€has been one of my favourite programming articles for some time. The maingist of the article is that, when writing in a type-driven fashion, yoursnappy slogan should be:</p><p>ä¸€æ®µæ—¶é—´ä»¥æ¥ï¼Œâ€œè§£æï¼Œä¸éªŒè¯â€ä¸€ç›´æ˜¯æˆ‘æœ€å–œæ¬¢çš„ç¼–ç¨‹æ–‡ç« ä¹‹ä¸€ã€‚è¿™ç¯‡æ–‡ç« çš„ä¸»æ—¨æ˜¯ï¼Œå½“ä»¥ç±»å‹é©±åŠ¨çš„æ–¹å¼ç¼–å†™æ—¶ï¼Œæ‚¨çš„è´ªå©ªå£å·åº”è¯¥æ˜¯ï¼š</p><p>  The core difference between parsing and validating can be explained bylooking at two very similar functions:</p><p>  å¯ä»¥é€šè¿‡æŸ¥çœ‹ä¸¤ä¸ªéå¸¸ç›¸ä¼¼çš„å‡½æ•°æ¥è§£é‡Šè§£æå’ŒéªŒè¯ä¹‹é—´çš„æ ¸å¿ƒåŒºåˆ«ï¼š</p><p> parseInt  ::  String  -&gt;  Maybe  Int parseInt  str  =  Text.Read.readMaybe  str validateInt  ::  String  -&gt;  Bool validateInt  str  =  Text.Read.readMaybe  str  /=  Nothing</p><p> parseInt ::å­—ç¬¦ä¸²-ï¼†gt;ä¹Ÿè®¸Int parseInt str = Text.Read.readMaybe str validateInt :: String-ï¼†gt; Bool validateInt str = Text.Read.readMaybe str / =ä»€ä¹ˆéƒ½æ²¡æœ‰</p><p> As you can see, they look very similar. The main difference is that parseInt returns a useful value, the  Int that we wanted to parse, while validateInt takes that useful value and throws it away. This is alsomentioned in the wonderful  Haskell Mini-PatternsHandbookas the â€œEvidenceâ€ pattern.</p><p> å¦‚æ‚¨æ‰€è§ï¼Œå®ƒä»¬çœ‹èµ·æ¥éå¸¸ç›¸ä¼¼ã€‚ä¸»è¦åŒºåˆ«åœ¨äºparseIntè¿”å›ä¸€ä¸ªæœ‰ç”¨çš„å€¼ï¼Œå³æˆ‘ä»¬è¦è§£æçš„Intï¼Œè€ŒvalidateIntæ¥å—äº†è¯¥æœ‰ç”¨çš„å€¼å¹¶å°†å…¶ä¸¢å¼ƒã€‚åœ¨å¥‡å¦™çš„Haskellè¿·ä½ æ¨¡å¼æ‰‹å†Œä¸­ä¹Ÿæåˆ°äº†â€œè¯æ®â€æ¨¡å¼ã€‚</p><p> The key issue here is that by calling a function that returns Bool youlose the information about earlier performed validation. Instead, you cankeep this information by explicitly pattern-matching on the validation orresult.</p><p> æ­¤å¤„çš„å…³é”®é—®é¢˜æ˜¯ï¼Œé€šè¿‡è°ƒç”¨è¿”å›Boolçš„å‡½æ•°ï¼Œæ‚¨ä¼šä¸¢å¤±æœ‰å…³è¾ƒæ—©æ‰§è¡Œçš„éªŒè¯çš„ä¿¡æ¯ã€‚ç›¸åï¼Œæ‚¨å¯ä»¥é€šè¿‡å¯¹éªŒè¯æˆ–ç»“æœè¿›è¡Œæ˜¾å¼æ¨¡å¼åŒ¹é…æ¥ä¿ç•™æ­¤ä¿¡æ¯ã€‚</p><p> In this post, I would like to go through a practical example that shows thepower of bringing this concept to its limits. Which brings us toâ€¦</p><p> åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘æƒ³é€šè¿‡ä¸€ä¸ªå®é™…çš„ä¾‹å­æ¥å±•ç¤ºå°†è¿™ä¸ªæ¦‚å¿µå‘æŒ¥åˆ°æè‡´çš„åŠ›é‡ã€‚å¸¦æˆ‘ä»¬å»â€¦</p><p>   - byr (Birth Year)- iyr (Issue Year)- eyr (Expiration Year)- hgt (Height)- hcl (Hair Color)- ecl (Eye Color)- pid (Passport ID)- cid (Country ID)</p><p>   -æ‹œå°”ï¼ˆå‡ºç”Ÿå¹´ï¼‰-ä¼Šå°”ï¼ˆç­¾å‘å¹´ï¼‰-å¹´ï¼ˆåˆ°æœŸå¹´ï¼‰-hgtï¼ˆèº«é«˜ï¼‰-hclï¼ˆå¤´å‘é¢œè‰²ï¼‰-eclï¼ˆçœ¼ç›é¢œè‰²ï¼‰-pidï¼ˆæŠ¤ç…§IDï¼‰-cidï¼ˆå›½å®¶IDï¼‰ </p><p> All the fields are required except for the  cid field, which is optional.Note that the fields can be written in any order, this will be importantlater. Our batch is composed of multiple passports separated by empty lines(the  input.txt):</p><p>é™¤cidå­—æ®µå¤–ï¼Œæ‰€æœ‰å­—æ®µéƒ½æ˜¯å¿…å¡«å­—æ®µï¼Œcidå­—æ®µæ˜¯å¯é€‰å­—æ®µã€‚è¯·æ³¨æ„ï¼Œè¿™äº›å­—æ®µå¯ä»¥æŒ‰ä»»ä½•é¡ºåºå†™å…¥ï¼Œè¿™å°†åœ¨ä»¥åå˜å¾—å¾ˆé‡è¦ã€‚æˆ‘ä»¬çš„æ‰¹æ¬¡ç”±å¤šè¡ŒæŠ¤ç…§ç»„æˆï¼Œå¹¶ç”¨ç©ºè¡Œï¼ˆinput.txtï¼‰éš”å¼€ï¼š</p><p> ecl:gry pid:860033327 eyr:2020 hcl:#fffffdbyr:1937 iyr:2017 cid:147 hgt:183cmiyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884hcl:#cfa07d byr:1929hcl:#ae17e1 iyr:2013eyr:2024ecl:brn pid:760753108 byr:1931hgt:179cmhcl:#cfa07d eyr:2025 pid:166559648iyr:2011 ecl:brn hgt:59in</p><p> eclï¼šgry pidï¼š860033327 eyrï¼š2020 hclï¼š#fffffdbyrï¼š1937 iyrï¼š2017 cidï¼š147 hgtï¼š183cmiyrï¼š2013 eclï¼šamb cidï¼š350 eyrï¼š2023 pidï¼š028048884hclï¼šï¼ƒcfa07d byrï¼š1929hclï¼šï¼ƒae17e1 iyrï¼š2013eyr ï¼š2024eclï¼šbrn pidï¼š760753108 byrï¼š1931hgtï¼š179cmhclï¼šï¼ƒcfa07d eyrï¼š2025 pidï¼š166559648iyrï¼š2011 eclï¼šbrn hgtï¼š59in</p><p> The third passport is interesting: the only missing field is the optional  cid, which makes it  valid.</p><p> ç¬¬ä¸‰æœ¬æŠ¤ç…§å¾ˆæœ‰è¶£ï¼šå”¯ä¸€ç¼ºå°‘çš„å­—æ®µæ˜¯å¯é€‰çš„cidï¼Œè¿™ä½¿å…¶æœ‰æ•ˆã€‚</p><p> The fourth passport is missing two fields,  cid and  byr. Missing  cid is fine, but missing  byr is not, so this passport is  invalid.</p><p> ç¬¬å››æœ¬æŠ¤ç…§ç¼ºå°‘ä¸¤ä¸ªå­—æ®µï¼Œcidå’Œbyrã€‚ç¼ºå°‘èº«ä»½è¯ä»¶æ˜¯å¯ä»¥çš„ï¼Œä½†ç¼ºå°‘ä¼¯å°”å…ˆç”Ÿåˆ™ä¸èƒ½ï¼Œå› æ­¤è¯¥æŠ¤ç…§æ— æ•ˆã€‚</p><p>  Letâ€™s write some code to open the file and parse each group of passportfields:</p><p>  è®©æˆ‘ä»¬ç¼–å†™ä¸€äº›ä»£ç æ¥æ‰“å¼€æ–‡ä»¶å¹¶è§£ææ¯ç»„æŠ¤ç…§å­—æ®µï¼š</p><p> module  Main  where  import  qualified Data.List.Split  as S main  ::  IO  ( ) main  =  do  contents  &lt;-  readFile  &#34;input.txt&#34;  let  entries  =  map  parseEntry  ( S.splitOn  &#34;\n\n&#34;  contents )  print  entries data  PassportEntry  =  PassportEntry  deriving  ( Show ) parseEntry  ::  String  -&gt;  PassportEntry parseEntry  text  =  undefined</p><p> æ¨¡å—Mainï¼Œåœ¨å…¶ä¸­å¯¼å…¥åˆæ ¼çš„Data.List.Splitä½œä¸ºS main :: IOï¼ˆï¼‰main =åšå†…å®¹ï¼†lt;-readFileï¼†ï¼ƒ34; input.txtï¼†ï¼ƒ34; letæ¡ç›®=æ˜ å°„parseEntryï¼ˆS.splitOnï¼†ï¼ƒ34; \ n \ nï¼†ï¼ƒ34;å†…å®¹ï¼‰æ‰“å°æ¡ç›®æ•°æ®PassportEntry =æ´¾ç”Ÿï¼ˆæ˜¾ç¤ºï¼‰parseEntry :: String-ï¼†gt;çš„PassportEntry PassportEntry parseEntryæ–‡æœ¬=æœªå®šä¹‰</p><p> Nothing too fancy here, weâ€™re using  Data.List.Split from the  splitpackage to do the heavy lifting. And the implementation of  parseEntry hasbeen conveniently stubbed so that the code compiles.</p><p> è¿™é‡Œæ²¡ä»€ä¹ˆå¥½æƒ³çš„ï¼Œæˆ‘ä»¬ä½¿ç”¨splitpackageä¸­çš„Data.List.Splitè¿›è¡Œç¹é‡çš„å·¥ä½œã€‚å¹¶ä¸”parseEntryçš„å®ç°å·²è¢«æ–¹ä¾¿åœ°å–æ¶ˆäº†ä»£ç çš„ç¼–è¯‘èŒƒå›´ã€‚ </p><p> Now how should our  PassportEntry data structure look like? Iâ€™d love toeventually represent passports as:</p><p>ç°åœ¨ï¼Œæˆ‘ä»¬çš„PassportEntryæ•°æ®ç»“æ„åº”è¯¥å¦‚ä½•ï¼Ÿæˆ‘æœ€ç»ˆå¸Œæœ›å°†æŠ¤ç…§è¡¨ç¤ºä¸ºï¼š</p><p> data  Passport  =  Passport  {  birthYear  ::  Int ,  issueYear  ::  Int ,  expirationYear  ::  Int ,  height  ::  String ,  hairColor  ::  String ,  eyeColor  ::  String ,  passportId  ::  String ,  countryId  ::  Maybe  Int  }</p><p> æ•°æ®Passport = Passport {birthYear :: Intï¼ŒissueYear :: Intï¼ŒexpirationYear :: Intï¼Œheight :: Stringï¼ŒhairColor :: Stringï¼ŒeyeColor :: Stringï¼ŒpassportId :: Stringï¼ŒcountryId :: Maybe Int}</p><p> If we imagine parsing each field sequentially, we can see that we wonâ€™t beable to construct this data structure in a single operation. Weâ€™ll have toaccumulate the data up until weâ€™re ready to create a proper  Passport.</p><p> å¦‚æœæˆ‘ä»¬æƒ³è±¡é¡ºåºåœ°è§£ææ¯ä¸ªå­—æ®µï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†æ— æ³•åœ¨å•ä¸ªæ“ä½œä¸­æ„é€ è¯¥æ•°æ®ç»“æ„ã€‚åœ¨å‡†å¤‡å¥½åˆ›å»ºé€‚å½“çš„æŠ¤ç…§ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»ç´¯ç§¯æ•°æ®ã€‚</p><p> One way to store the fields is to insert them into a hash. First of all,weâ€™re going to use a custom data type to represent the keys of the hash.Why is that? We really donâ€™t want to be making typos later when comparingraw strings like  &#34;ecl&#34; and  &#34;elc&#34;. Weâ€™ll use a  HashMap from the Data.HashMap.Strict module:</p><p> å­˜å‚¨å­—æ®µçš„ä¸€ç§æ–¹æ³•æ˜¯å°†å®ƒä»¬æ’å…¥å“ˆå¸Œã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è‡ªå®šä¹‰æ•°æ®ç±»å‹æ¥è¡¨ç¤ºå“ˆå¸Œé”®ã€‚ä¸ºä»€ä¹ˆï¼Ÿæˆ‘ä»¬çœŸçš„ä¸å¸Œæœ›ç¨ååœ¨æ¯”è¾ƒï¼†ï¼ƒ34; eclï¼†ï¼ƒ34;å’Œï¼†ï¼ƒ34; elcï¼†ï¼ƒ34;ã€‚æˆ‘ä»¬å°†ä½¿ç”¨Data.HashMap.Strictæ¨¡å—ä¸­çš„HashMapï¼š</p><p> import  qualified Data.HashMap.Strict  as HM data  PassportField  =  BirthYear  |  IssueYear  |  ExpirationYear  |  Height  |  HairColor  |  EyeColor  |  PassportId  |  CountryId  deriving  ( Eq ,  Show ) type  PassportEntry  =  HM.HashMap  PassportField  String</p><p> å°†åˆæ ¼çš„Data.HashMap.Strictå¯¼å…¥ä¸ºHMæ•°æ®PassportField = BirthYear |å‘è¡Œå¹´ä»½|åˆ°æœŸå¹´ä»½|èº«é«˜|å‘è‰²| EyeColor | PassportId | CountryIdæ´¾ç”Ÿï¼ˆEqï¼ŒShowï¼‰ç±»å‹PassportEntry = HM.HashMap PassportFieldå­—ç¬¦ä¸²</p><p> Of course things canâ€™t be that easy. We also need to make our typeimplement the  Hashable typeclass:</p><p> å½“ç„¶ï¼Œäº‹æƒ…ä¸å¯èƒ½é‚£ä¹ˆå®¹æ˜“ã€‚æˆ‘ä»¬è¿˜éœ€è¦ä½¿æˆ‘ä»¬çš„ç±»å‹å®ç°æˆä¸ºHashableç±»å‹ç±»ï¼š</p><p> {-# LANGUAGE DeriveGeneric #-}  import  qualified Data.HashMap.Strict  as HM  import Data.Hashable  import GHC.Generics  ( Generic ) data  PassportField  =  BirthYear  |  IssueYear  |  ExpirationYear  |  Height  |  HairColor  |  EyeColor  |  PassportId  |  CountryId  deriving  ( Eq ,  Show ,  Generic ) instance  Hashable  PassportField type  PassportEntry  =  HM.HashMap  PassportField  String</p><p> {-ï¼ƒLANGUAGE DeriveGenericï¼ƒ-}å¯¼å…¥åˆæ ¼çš„Data.HashMap.Strictä½œä¸ºHMå¯¼å…¥Data.Hashableå¯¼å…¥GHC.Genericsï¼ˆGenericï¼‰æ•°æ®PassportField = BirthYear |å‘è¡Œå¹´ä»½|åˆ°æœŸå¹´ä»½|èº«é«˜|å‘è‰²| EyeColor | PassportId | CountryIdæ´¾ç”Ÿï¼ˆEqï¼ŒShowï¼ŒGenericï¼‰å®ä¾‹Hashable PassportFieldç±»å‹PassportEntry = HM.HashMap PassportFieldå­—ç¬¦ä¸² </p><p> Donâ€™t worry about what weâ€™ve added. Just take them as God-given truths. ğŸ‘¼</p><p>ä¸ç”¨æ‹…å¿ƒæˆ‘ä»¬æ·»åŠ çš„å†…å®¹ã€‚åªè¦æŠŠå®ƒä»¬å½“ä½œä¸Šå¸èµäºˆçš„çœŸç†ã€‚ ğŸ‘¼</p><p>  import Data.Maybe  ( mapMaybe )  import  qualified Data.Char  as Char parseEntry  ::  String  -&gt;  PassportEntry parseEntry  line  =  HM.fromList  $  mapMaybe  parseTag  $  S.splitWhen  Char . isSpace  line parseTag  ::  String  -&gt;  Maybe  ( PassportField ,  String ) parseTag  value  =  case  S.splitOn  &#34;:&#34;  value  of  [ &#34;byr&#34; ,  byr ]  -&gt;  Just  ( BirthYear ,  byr )  [ &#34;iyr&#34; ,  iyr ]  -&gt;  Just  ( IssueYear ,  iyr )  [ &#34;eyr&#34; ,  eyr ]  -&gt;  Just  ( ExpirationYear ,  eyr )  [ &#34;hgt&#34; ,  height ]  -&gt;  Just  ( Height ,  height )  [ &#34;hcl&#34; ,  color ]  -&gt;  Just  ( HairColor ,  color )  [ &#34;ecl&#34; ,  color ]  -&gt;  Just  ( EyeColor ,  color )  [ &#34;pid&#34; ,  pid ]  -&gt;  Just  ( PassportId ,  pid )  [ &#34;cid&#34; ,  cid ]  -&gt;  Just  ( CountryId ,  cid )  _  -&gt;  Nothing</p><p>  import Data.Maybeï¼ˆmapMaybeï¼‰å°†åˆæ ¼çš„Data.Charå¯¼å…¥ä¸ºchar parseEntry :: String-ï¼†gt; PassportEntry parseEntryè¡Œ= HM.fromList $ mapMaybe parseTag $ S.splitWhen Charã€‚ isSpaceè¡ŒparseTag :: String-ï¼†gt;ä¹Ÿè®¸ï¼ˆPassportFieldï¼ŒStringï¼‰parseTagå€¼= case S.splitOnï¼†ï¼ƒ34;ï¼šï¼†ï¼ƒ34; [ï¼†ï¼ƒ34; byrï¼†ï¼ƒ34; ï¼Œbyr]-ï¼†gt;åªæ˜¯ï¼ˆBirthYearï¼Œbyrï¼‰[ï¼†ï¼ƒ34; iyrï¼†ï¼ƒ34; ï¼Œiyr]-ï¼†gt;åªæ˜¯ï¼ˆIssueYearï¼Œiyrï¼‰[ï¼†ï¼ƒ34; eyrï¼†ï¼ƒ34; ï¼Œeyr]-ï¼†gt;åªæ˜¯ï¼ˆExpirationYearï¼Œeyrï¼‰[ï¼†ï¼ƒ34; hgtï¼†ï¼ƒ34; ï¼Œé«˜åº¦]-ï¼†gt;åªæ˜¯ï¼ˆèº«é«˜ï¼Œèº«é«˜ï¼‰[ï¼†ï¼ƒ34; hclï¼†ï¼ƒ34; ï¼Œé¢œè‰²]-ï¼†gt;åªæ˜¯ï¼ˆHairColorï¼Œcolorï¼‰[ï¼†ï¼ƒ34; eclï¼†ï¼ƒ34; ï¼Œé¢œè‰²]-ï¼†gt;åªæ˜¯ï¼ˆEyeColorï¼Œcolorï¼‰[ï¼†ï¼ƒ34; pidï¼†ï¼ƒ34; ï¼Œpid]-ï¼†gt;åªæ˜¯ï¼ˆPassportIdï¼Œpidï¼‰[ï¼†ï¼ƒ34; cidï¼†ï¼ƒ34; ï¼Œcid]-ï¼†gt;åªæ˜¯ï¼ˆCountryIdï¼Œcidï¼‰_-ï¼†gt;æ²¡æœ‰</p><p> We try to parse each field (such as  byr:2002) into a  PassportFieldtype, then end up building a hash using  HM.fromList. We can take this fora spin:</p><p> æˆ‘ä»¬å°è¯•å°†æ¯ä¸ªå­—æ®µï¼ˆä¾‹å¦‚byrï¼š2002ï¼‰è§£æä¸ºPassportFieldtypeï¼Œç„¶åæœ€ç»ˆä½¿ç”¨HM.fromListæ„å»ºå“ˆå¸Œã€‚æˆ‘ä»¬å¯ä»¥è¿›è¡Œä»¥ä¸‹è®¨è®ºï¼š</p><p> Prelude &gt;  : l  Main.hs * Main &gt;  main [  fromList  [  ( CountryId ,  &#34;147&#34; ) ,  ( BirthYear ,  &#34;1937&#34; ) ,  ( IssueYear ,  &#34;2017&#34; ) ,  ( HairColor ,  &#34;#fffffd&#34; ) ,  ( ExpirationYear ,  &#34;2020&#34; ) ,  ( EyeColor ,  &#34;gry&#34; ) ,  ( Height ,  &#34;183cm&#34; ) ,  ( PassportId ,  &#34;860033327&#34; )  ] ,  fromList  [  ( CountryId ,  &#34;350&#34; ) ,  ( BirthYear ,  &#34;1929&#34; ) ,  ( IssueYear ,  &#34;2013&#34; ) ,  ( HairColor ,  &#34;#cfa07d&#34; ) ,  ( ExpirationYear ,  &#34;2023&#34; ) ,  ( EyeColor ,  &#34;amb&#34; ) ,  ( PassportId ,  &#34;028048884&#34; )  ] ,  fromList  [  ( BirthYear ,  &#34;1931&#34; ) ,  ( IssueYear ,  &#34;2013&#34; ) ,  ( HairColor ,  &#34;#ae17e1&#34; ) ,  ( ExpirationYear ,  &#34;2024&#34; ) ,  ( EyeColor ,  &#34;brn&#34; ) ,  ( Height ,  &#34;179cm&#34; ) ,  ( PassportId ,  &#34;760753108&#34; )  ] ,  fromList  [  ( IssueYear ,  &#34;2011&#34; ) ,  ( HairColor ,  &#34;#cfa07d&#34; ) ,  ( ExpirationYear ,  &#34;2025&#34; ) ,  ( EyeColor ,  &#34;brn&#34; ) ,  ( Height ,  &#34;59in&#34; ) ,  ( PassportId ,  &#34;166559648&#34; )  ] ]</p><p> å‰å¥ï¼†gt; ï¼šl Main.hs * Mainï¼†gt; main [fromList [ï¼ˆCountryIdï¼Œï¼†ï¼ƒ34; 147ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆBirthYearï¼Œï¼†ï¼ƒ34; 1937ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆIssueYearï¼Œï¼†ï¼ƒ34; 2017ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆHairColorï¼Œï¼†ï¼ƒ34; ï¼ƒfffffdï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆExpirationYearï¼Œï¼†ï¼ƒ34; 2020ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆEyeColorï¼Œï¼†ï¼ƒ34; gryï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆHeightï¼Œï¼†ï¼ƒ34; 183cmï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆPassportIdï¼Œï¼† ï¼ƒ34; 860033327ï¼†ï¼ƒ34;ï¼‰]ï¼Œä»åˆ—è¡¨[ï¼ˆCountryIdï¼Œï¼†ï¼ƒ34; 350ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆå‡ºç”Ÿå¹´ä»½ï¼Œï¼†ï¼ƒ34; 1929ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆIssueYearï¼Œï¼†ï¼ƒ34; 2013ï¼†ï¼ƒ34;ï¼‰ ï¼Œï¼ˆHairColorï¼Œï¼†ï¼ƒ34;ï¼ƒcfa07dï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆExpirationYearï¼Œï¼†ï¼ƒ34; 2023ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆEyeColorï¼Œï¼†ï¼ƒ34; ambï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆPassportIdï¼Œï¼†ï¼ƒ34; 028048884ï¼†ï¼ƒ 34;ï¼‰]ï¼ŒfromList [ï¼ˆBirthYearï¼Œï¼†ï¼ƒ34; 1931ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆIssueYearï¼Œï¼†ï¼ƒ34; 2013ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆHairColorï¼Œï¼†ï¼ƒ34;ï¼ƒae17e1ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆExpirationYearï¼Œ ï¼†ï¼ƒ34; 2024ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆEyeColorï¼Œï¼†ï¼ƒ34; brnï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆHeightï¼Œï¼†ï¼ƒ34; 179cmï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆPassportIdï¼Œï¼†ï¼ƒ34; 760753108ï¼†ï¼ƒ34;ï¼‰]ï¼Œ fromList [ï¼ˆIssueYearï¼Œï¼†ï¼ƒ34; 2011ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆHairColorï¼Œï¼†ï¼ƒ34;ï¼ƒcfa07dï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆExpirationYearï¼Œï¼†ï¼ƒ34; 2025ï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆEyeColorï¼Œï¼†ï¼ƒ34 ; brnï¼†ï¼ƒ34; ï¼‰ï¼Œï¼ˆé«˜åº¦ï¼Œï¼†ï¼ƒ34; 59inï¼†ï¼ƒ34;ï¼‰ï¼Œï¼ˆPassportIdï¼Œï¼†ï¼ƒ34; 166559648ï¼†ï¼ƒ34;ï¼‰]]]</p><p>  Now our goal is to verify which one of these groups is valid. First of all,we should define a list of required fields:</p><p>  ç°åœ¨ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯éªŒè¯è¿™äº›ç»„ä¸­çš„å“ªä¸€ä¸ªæœ‰æ•ˆã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åº”è¯¥å®šä¹‰ä¸€ä¸ªå¿…å¡«å­—æ®µåˆ—è¡¨ï¼š</p><p>     main  ::  IO  ( ) main  =  do  contents  &lt;-  readFile  &#34;input.txt&#34;  let  entries  =  map  parseEntry  ( S.splitOn  &#34;\n\n&#34;  contents )  print  $  length  $  filter  isEntryValid  entries</p><p>     main :: IOï¼ˆï¼‰main =åšå†…å®¹ï¼†lt;-readFileï¼†ï¼ƒ34; input.txtï¼†ï¼ƒ34;è®©entry =æ˜ å°„parseEntryï¼ˆS.splitOnï¼†ï¼ƒ34; \ n \ nï¼†ï¼ƒ34;å†…å®¹ï¼‰æ‰“å°$é•¿åº¦$è¿‡æ»¤å™¨isEntryValidæ¡ç›®</p><p> Running this yields  2, which is the correct answer! Here isall the code we have written so far, if youâ€™re feeling like you need arefresher.</p><p> è¿è¡Œæ­¤ç”Ÿæˆ2ï¼Œè¿™æ˜¯æ­£ç¡®çš„ç­”æ¡ˆï¼å¦‚æœæ‚¨è§‰å¾—è‡ªå·±éœ€è¦é‡æ–°æ•´ç†ï¼Œè¿™é‡Œæ˜¯åˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬ç¼–å†™çš„æ‰€æœ‰ä»£ç ã€‚ </p><p>   - byr (Birth Year) - four digits; between 1920 and 2002.- iyr (Issue Year) - four digits; between 2010 and 2020.- eyr (Expiration Year) - four digits; between 2020 and 2030.- hgt (Height) - a number followed by either cm or in: - If cm, the number must be between 150 and 193. - If in, the number must be between 59 and 76.- hcl (Hair Color) - a &#39;#&#39; followed by six chars 0-9 or a-f.- ecl (Eye Color) - one of: amb blu brn gry grn hzl oth.- pid (Passport ID) - a nine-digit number.- cid (Country ID) - ignored, missing or not.</p><p>-æ‹œå°”ï¼ˆç”Ÿæ—¥ï¼‰-å››ä½æ•°ï¼›åœ¨1920å¹´è‡³2002å¹´ä¹‹é—´ã€‚-å¹´ï¼ˆå‘è¡Œå¹´ä»½ï¼‰-å››ä½æ•°ï¼›åœ¨2010å¹´è‡³2020å¹´ä¹‹é—´ã€‚-eyrï¼ˆæœ‰æ•ˆå¹´ï¼‰-å››ä½æ•°ï¼›åœ¨2020å¹´è‡³2030å¹´ä¹‹é—´ã€‚-hgtï¼ˆé«˜åº¦ï¼‰-ä¸€ä¸ªæ•°å­—ï¼Œåè·Ÿcmæˆ–inï¼š-å¦‚æœä¸ºcmï¼Œåˆ™è¯¥æ•°å­—å¿…é¡»ä»‹äº150å’Œ193ä¹‹é—´ã€‚-å¦‚æœä¸ºcmï¼Œåˆ™è¯¥æ•°å­—å¿…é¡»ä»‹äº59å’Œ76ä¹‹é—´ã€‚-hclï¼ˆæ¯›å‘é¢œè‰²ï¼‰-ï¼†ï¼ƒ39;ï¼ƒï¼†ï¼ƒ39;åé¢è·Ÿç€å…­ä¸ªå­—ç¬¦0-9æˆ–afã€‚-eclï¼ˆçœ¼ç›é¢œè‰²ï¼‰-ä»¥ä¸‹ä¹‹ä¸€ï¼š-pidï¼ˆæŠ¤ç…§IDï¼‰-ä¹ä½æ•°å­—ã€‚-cidï¼ˆå›½å®¶IDï¼‰-è¢«å¿½ç•¥ï¼Œç¼ºå°‘æˆ–æ²¡æœ‰ã€‚</p><p>    These new requirements are a bit annoying. Our simple approach of checkingif all required fields are present wonâ€™t work any longer. We can insteadimplement a  isFieldValid function to check if all fields are valid.</p><p>    è¿™äº›æ–°è¦æ±‚æœ‰ç‚¹çƒ¦äººã€‚æˆ‘ä»¬æ£€æŸ¥æ‰€æœ‰å¿…å¡«å­—æ®µæ˜¯å¦å­˜åœ¨çš„ç®€å•æ–¹æ³•å°†ä¸å†èµ·ä½œç”¨ã€‚æˆ‘ä»¬å¯ä»¥æ”¹ä¸ºæ‰§è¡ŒisFieldValidå‡½æ•°æ¥æ£€æŸ¥æ‰€æœ‰å­—æ®µæ˜¯å¦æœ‰æ•ˆã€‚</p><p> isFieldValid  ::  ( PassportField ,  String )  -&gt;  Bool isFieldValid  ( field ,  value )  =  case  field  of  BirthYear  -&gt;  let  v  =  toInt  value  in  length  value  ==  4  &amp;&amp;  v  &gt;=  1920  &amp;&amp;  v  &lt;=  2002  IssueYear  -&gt;  let  v  =  toInt  value  in  length  value  ==  4  &amp;&amp;  v  &gt;=  2010  &amp;&amp;  v  &lt;=  2020  ExpirationYear  -&gt;  let  v  =  toInt  value  in  length  value  ==  4  &amp;&amp;  v  &gt;=  2020  &amp;&amp;  v  &lt;=  2030  Height  -&gt;  case  span  Char . isDigit  value  of  ( num ,  &#34;cm&#34; )  -&gt;  let  n  =  toInt  num  in  n  &gt;=  150  &amp;&amp;  n  &lt;=  193  ( num ,  &#34;in&#34; )  -&gt;  let  n  =  toInt  num  in  n  &gt;=  59  &amp;&amp;  n  &lt;=  76  _  -&gt;  False  HairColor  -&gt;  case  ( length  value ,  value )  of  ( 7 ,  &#39;#&#39;  :  rest )  -&gt;  all  (` elem`  allowedHexChars )  rest  _  -&gt;  False  EyeColor  -&gt;  value ` elem`  validEyeColors  PassportId  -&gt;  length  value  ==  9  &amp;&amp;  all  Char . isDigit  value  CountryId  -&gt;  all  Char . isDigit  value toInt  ::  String  -&gt;  Int toInt  =  read validEyeColors  ::  [ String ] validEyeColors  =  [ &#34;amb&#34; ,  &#34;blu&#34; ,  &#34;brn&#34; ,  &#34;gry&#34; ,  &#34;grn&#34; ,  &#34;hzl&#34; ,  &#34;oth&#34; ] allowedHexChars  ::  [ Char ] allowedHexChars  =  [ &#39;0&#39;  ..  &#39;9&#39; ]  &lt;&gt;  [ &#39;a&#39;  ..  &#39;f&#39; ]</p><p> isFieldValid ::ï¼ˆPassportFieldï¼ŒStringï¼‰-ï¼†gt; Bool isFieldValidï¼ˆfieldï¼Œvalueï¼‰= BirthYearçš„caseå­—æ®µ->ä»¤v ï¼é•¿åº¦å€¼ï¼ï¼ 4çš„inIntå€¼ã€‚ vï¼†gt; = 1920ï¼†amp;ï¼†amp; vï¼†lt; = 2002 IssueYear-ï¼†gt;ä»¤v ï¼é•¿åº¦å€¼ï¼ï¼ 4çš„inIntå€¼ã€‚ vï¼†gt; = 2010ï¼†amp;ï¼†amp; vï¼†lt; = 2020å¹´æœ‰æ•ˆæœŸ-ï¼†gt;ä»¤v ï¼é•¿åº¦å€¼ï¼ï¼ 4çš„inIntå€¼ã€‚ vï¼†gt; = 2020ï¼†amp;ï¼†amp; vï¼†lt; = 2030é«˜åº¦-ï¼†gt;æ¡ˆä¾‹è·¨åº¦Charã€‚ ï¼ˆnumï¼Œï¼†ï¼ƒ34; cmï¼†ï¼ƒ34;ï¼‰-ï¼†gt;çš„isDigitå€¼è®¾n = toInt num in nï¼†gt; = 150ï¼†amp; nï¼†lt; = 193ï¼ˆnumï¼Œï¼†ï¼ƒ34; inï¼†ï¼ƒ34;ï¼‰-ï¼†gt;è®¾n = toInt num in nï¼†gt; = 59ï¼†amp;ï¼†amp; nï¼†lt; = 76 _-ï¼†gt;å‡å‘è‰²-ï¼†gt; caseï¼ˆlength valueï¼Œvalueï¼‰ä¸ºï¼ˆ7ï¼Œï¼†ï¼ƒ39;ï¼šrestï¼‰-ï¼†gt;å…¨éƒ¨ï¼ˆ`elem` allowedHexCharsï¼‰å…¶ä½™_-ï¼†gt;å‡EyeColor-ï¼†gt;å€¼`elem` validEyeColors PassportId-ï¼†gt;é•¿åº¦å€¼== 9ï¼†amp;ï¼†amp;æ‰€æœ‰å­—ç¬¦ã€‚ isDigitå€¼CountryId-ï¼†gt;æ‰€æœ‰å­—ç¬¦ã€‚ isDigitå€¼toInt ::å­—ç¬¦ä¸²-ï¼†gt; Int toInt =è¯»å–validEyeColors :: [String] validEyeColors = [ï¼†ï¼ƒ34; ambï¼†ï¼ƒ34; ï¼Œï¼†ï¼ƒ34; bluï¼†ï¼ƒ34; ï¼Œï¼†nbnï¼†ï¼ƒ34; ï¼Œï¼†gryï¼†ï¼ƒ34; ï¼Œï¼†ï¼ƒ34; grnï¼†ï¼ƒ34; ï¼Œï¼†ï¼ƒ34; hzlï¼†ï¼ƒ34; ï¼Œï¼†othï¼†ï¼ƒ34; ] allowedHexChars :: [Char] allowedHexChars = [ï¼†ï¼ƒ39; 0ï¼†ï¼ƒ39; ..ï¼†ï¼ƒ39; 9ï¼†ï¼ƒ39; ]ï¼†lt;ï¼†gt; [ï¼†ï¼ƒ39; aï¼†ï¼ƒ39; ..ï¼†ï¼ƒ39; fï¼†ï¼ƒ39; ]</p><p>  isEntryValid  ::  PassportEntry  -&gt;  Bool isEntryValid  entry  =  requiredFieldsPresent  &amp;&amp;  allFieldsValid  where  requiredFieldsPresent  =  all  ( `HM.member`  entry )  requiredFields  allFieldsValid  =  all  isFieldValid  ( HM.toList  entry )</p><p>  isEntryValid :: PassportEntry-ï¼†gt;å¸ƒå°”isEntryValidæ¡ç›®= requiredFieldsPresentï¼†amp;ï¼†amp; allFieldsValidå…¶ä¸­requiredFieldsPresent =æ‰€æœ‰ï¼ˆâ€œ HM.memberâ€æ¡ç›®ï¼‰requiredFields allFieldsValid =æ‰€æœ‰isFieldValidï¼ˆHM.toListæ¡ç›®ï¼‰</p><p> Running this program on our second data sample yields  1, and it will begood enough to solve the Advent of Code challenge and get us those sweetsweet stars.</p><p> åœ¨æˆ‘ä»¬çš„ç¬¬äºŒä¸ªæ•°æ®æ ·æœ¬ä¸Šè¿è¡Œè¯¥ç¨‹åºå°†å¾—åˆ°1ï¼Œè¿™è¶³ä»¥è§£å†³ä»£ç çš„åˆ°æ¥æŒ‘æˆ˜ï¼Œå¹¶ä¸ºæˆ‘ä»¬èµ¢å¾—é‚£äº›ç”œèœœçš„æ˜Ÿæ˜Ÿã€‚</p><p>   If we look back at the  currentstate ofour code, we can see that we are doing a lot of validations.</p><p>   å¦‚æœæˆ‘ä»¬å›é¡¾ä¸€ä¸‹ä»£ç çš„å½“å‰çŠ¶æ€ï¼Œå¯ä»¥çœ‹åˆ°æˆ‘ä»¬æ­£åœ¨åšå¾ˆå¤šéªŒè¯ã€‚</p><p> We do a lot of work to verify if something is valid, then throw it all outof the window to return a meagre  Bool. German folks from the  sixteenthcenturywould have told us snarkily:</p><p> æˆ‘ä»¬åšäº†å¾ˆå¤šå·¥ä½œæ¥éªŒè¯æŸäº›ä¸œè¥¿æ˜¯å¦æœ‰æ•ˆï¼Œç„¶åå°†å…¶å…¨éƒ¨æ‰”å‡ºçª—å£ä»¥è¿”å›ä¸€ä¸ªå¾®ä¸è¶³é“çš„å¸ƒå°”ã€‚åå…­ä¸–çºªçš„å¾·å›½äººä¼šå·å·åœ°å‘Šè¯‰æˆ‘ä»¬ï¼š </p><p>     With our current code, we know which passport is valid, but we have no wayof extracting the eye color of a valid passport. This is why earlier wewere mentioning this sort of  Passport representation:</p><p>ä½¿ç”¨æˆ‘ä»¬å½“å‰çš„ä»£ç ï¼Œæˆ‘ä»¬çŸ¥é“å“ªæœ¬æŠ¤ç…§æœ‰æ•ˆï¼Œä½†æ˜¯æˆ‘ä»¬æ— æ³•æå–æœ‰æ•ˆæŠ¤ç…§çš„çœ¼ç›é¢œè‰²ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬å‰é¢æåˆ°è¿™ç§Passportè¡¨ç¤ºçš„åŸå› ï¼š</p><p> data  Passport  =  Passport  {  birthYear  ::  Int ,  issueYear  ::  Int ,  expirationYear  ::  Int ,  height  ::  String ,  hairColor  ::  String ,  eyeColor  ::  String ,  passportId  ::  String ,  countryId  ::  Maybe  Int  }</p><p> æ•°æ®Passport = Passport {birthYear :: Intï¼ŒissueYear :: Intï¼ŒexpirationYear :: Intï¼Œheight :: Stringï¼ŒhairColor :: Stringï¼ŒeyeColor :: Stringï¼ŒpassportId :: Stringï¼ŒcountryId :: Maybe Int}</p><p> If we had a function like  parsePassport that went from  String to  MaybePassport we could then write some code like this:</p><p> å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªåƒparsePassportè¿™æ ·çš„å‡½æ•°ï¼Œå®ƒä»Stringå˜ä¸ºMaybePassportï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç¼–å†™å¦‚ä¸‹ä»£ç ï¼š</p><p>  But letâ€™s not get too ahead of ourselves. Letâ€™s try to refactor our currentcode to do something similar. First we can try to write a function likethis one:</p><p>  ä½†æ˜¯ï¼Œä¸è¦è®©è‡ªå·±è¿‡åˆ†é¢†å…ˆã€‚è®©æˆ‘ä»¬å°è¯•é‡æ„å½“å‰ä»£ç ä»¥æ‰§è¡Œç±»ä¼¼çš„æ“ä½œã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•ç¼–å†™ä¸€ä¸ªåƒè¿™æ ·çš„å‡½æ•°ï¼š</p><p>  This function takes the intermediate representation of a collection ofpassport fields and returns a â€˜validatedâ€™ passport. We can also reuse our isFieldValid function by using this trick:</p><p>  æ­¤å‡½æ•°é‡‡ç”¨ä¸€ç³»åˆ—æŠ¤ç…§å­—æ®µçš„ä¸­é—´è¡¨ç¤ºå½¢å¼ï¼Œå¹¶è¿”å›â€œå·²éªŒè¯â€æŠ¤ç…§ã€‚æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æŠ€å·§é‡ç”¨isFieldValidå‡½æ•°ï¼š</p><p> parseField  ::  ( PassportField ,  String )  -&gt;  Maybe  ( PassportField ,  String ) parseField  tuple  =  if  isFieldValid  tuple  then  Just  tuple  else  Nothing</p><p> parseField ::ï¼ˆPassportFieldï¼ŒStringï¼‰-ï¼†gt;ä¹Ÿè®¸ï¼ˆPassportFieldï¼ŒStringï¼‰parseFieldå…ƒç»„=å¦‚æœisFieldValidå…ƒç»„ï¼Œåˆ™åªæ˜¯å…ƒç»„ï¼Œå¦åˆ™</p><p> We are still reusing the validating logic, but we end up returningsomething useful instead. Remember, we are slowly migrating our code fromvalidating data to parsing data.</p><p> æˆ‘ä»¬ä»ç„¶åœ¨é‡ç”¨éªŒè¯é€»è¾‘ï¼Œä½†æ˜¯æœ€ç»ˆè¿”å›äº†ä¸€äº›æœ‰ç”¨çš„ä¸œè¥¿ã€‚è®°ä½ï¼Œæˆ‘ä»¬æ­£åœ¨ç¼“æ…¢åœ°å°†ä»£ç ä»éªŒè¯æ•°æ®è¿ç§»åˆ°è§£ææ•°æ®ã€‚ </p><p> Using our new helper we can finally implement the  entryToPassportfunction. Weâ€™ll do that in two separate steps. First weâ€™ll get all thevalues of the required fields:</p><p>ä½¿ç”¨æ–°çš„å¸®åŠ©ç¨‹åºï¼Œæˆ‘ä»¬æœ€ç»ˆå¯ä»¥å®ç°entryToPassportå‡½æ•°ã€‚æˆ‘ä»¬å°†åˆ†ä¸¤ä¸ªæ­¥éª¤è¿›è¡Œæ“ä½œã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†è·å¾—å¿…å¡«å­—æ®µçš„æ‰€æœ‰å€¼ï¼š</p><p> getAllRequiredFields  ::  PassportEntry  -&gt;  Maybe  [ String ] getAllRequiredFields  e  =  traverse  (  \ field  -&gt;  do  v  &lt;-  HM . lookup  field  e  ( _field ,  text )  &lt;-  parseField  ( field ,  v )  return  text  )  requiredFields</p><p> getAllRequiredFields :: PassportEntry-ï¼†gt;ä¹Ÿè®¸[String] getAllRequiredFields e =éå†ï¼ˆ\ field-ï¼†gt; do vï¼†lt;-HM.lookup field eï¼ˆ_fieldï¼Œtextï¼‰ï¼†lt;-parseFieldï¼ˆfieldï¼Œvï¼‰è¿”å›textï¼‰requiredFields</p><p> The  traverse magic ensures that we either get all the values weâ€™relooking for wrapped in a  Just, or  Nothing if any of those fields wereinvalid. Ok, weâ€™re ready to roll now!</p><p> éå†é­”æœ¯å¯ä»¥ç¡®ä¿æˆ‘ä»¬å°†è¦æŸ¥æ‰¾çš„æ‰€æœ‰å€¼åŒ…è£…åœ¨Justä¸­ï¼Œå¦‚æœå…¶ä¸­ä»»ä½•ä¸€ä¸ªæ— æ•ˆï¼Œåˆ™ä¸ºNothingã€‚å¥½çš„ï¼Œæˆ‘ä»¬ç°åœ¨å°±å¯ä»¥å¼€å§‹æ»šåŠ¨ï¼</p><p> entryToPassport  ::  PassportEntry  -&gt;  Maybe  Passport entryToPassport  entry  =  do  case  getAllRequiredFields  entry  of  Just  [ byr ,  iyr ,  eyr ,  hgt ,  hcl ,  ecl ,  pid ]  -&gt;  Just  $  Passport  {  birthYear  =  toInt  byr ,  issueYear  =  toInt  iyr ,  expirationYear  =  toInt  eyr ,  height  =  hgt ,  hairColor  =  hcl ,  eyeColor  =  ecl ,  passportId  =  pid ,  countryId  =  toInt  &lt;$&gt;  HM . lookup  CountryId  entry  }  _  -&gt;  Nothing</p><p> entryToPassport :: PassportEntry-ï¼†gt;ä¹Ÿè®¸Passport entryToPassport entry = Just [byrï¼Œiyrï¼Œeyrï¼Œhgtï¼Œhclï¼Œeclï¼Œpid]çš„case getAllRequiredFieldsæ¡ç›®->åªéœ€$æŠ¤ç…§{birthYear = toInt byrï¼ŒissueYear = toInt iyrï¼ŒexpirationYear = toInt eyrï¼Œheight = hgtï¼ŒhairColor = hclï¼ŒeyeColor = eclï¼ŒpassportId = pidï¼ŒcountryId = toIntï¼†lt; $ï¼†gt; HMã€‚æŸ¥æ‰¾CountryIdæ¡ç›®} _-ï¼†gt;æ²¡æœ‰</p><p> We end up having to pass  String values around, which need to be parsedagain into the exact types that we desire. Also we need to pass thesevalues into a list and hope not to mess up the ordering of the fields. Soitâ€™s far from perfect, but weâ€™re getting somewhere.</p><p> æˆ‘ä»¬æœ€ç»ˆä¸å¾—ä¸ä¼ é€’å­—ç¬¦ä¸²å€¼ï¼Œéœ€è¦å†æ¬¡å°†å…¶è§£æä¸ºæ‰€éœ€çš„ç¡®åˆ‡ç±»å‹ã€‚å¦å¤–ï¼Œæˆ‘ä»¬éœ€è¦å°†è¿™äº›å€¼ä¼ é€’åˆ°åˆ—è¡¨ä¸­ï¼Œå¹¶å¸Œæœ›ä¸è¦å¼„ä¹±å­—æ®µçš„é¡ºåºã€‚ Soitè¿œéå®Œç¾ï¼Œä½†æˆ‘ä»¬æ­£åœ¨å–å¾—è¿›å±•ã€‚</p><p> In order to use this function in our main, we replace the last line of themain fuction from:</p><p> ä¸ºäº†åœ¨æˆ‘ä»¬çš„mainä¸­ä½¿ç”¨æ­¤åŠŸèƒ½ï¼Œæˆ‘ä»¬ä»ä»¥ä¸‹ä½ç½®æ›¿æ¢mainå‡½æ•°çš„æœ€åä¸€è¡Œï¼š</p><p>    Running this onour test batch still returns  1, which is a good sign we havenâ€™t brokenanything.</p><p>    è¿è¡Œæ­¤ontestæ‰¹å¤„ç†ä»ä¼šè¿”å›1ï¼Œè¿™è¡¨æ˜æˆ‘ä»¬æ²¡æœ‰åšä»»ä½•äº‹æƒ…ã€‚ </p><p> Still, there is one thing that Iâ€™m particularly unhappy about in this code:we use an intermediate representation of the passport that has no realdomain value. Nobody cares about  PassportField and  PassportEntry, butwe need to have these types in order to build our  Passport.</p><p>ä¸è¿‡ï¼Œè¿™æ®µä»£ç ä»¤æˆ‘ç‰¹åˆ«ä¸æ»¡æ„çš„ä¸€ä»¶äº‹ï¼šæˆ‘ä»¬ä½¿ç”¨çš„æŠ¤ç…§çš„ä¸­é—´è¡¨ç¤ºå½¢å¼æ²¡æœ‰å®åŸŸå€¼ã€‚æ²¡æœ‰äººå…³å¿ƒPassportFieldå’ŒPassportEntryï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦å…·æœ‰è¿™äº›ç±»å‹æ‰èƒ½æ„å»ºæˆ‘ä»¬çš„Passportã€‚</p><p> Not only that, but having these intermediate types means that there arebugs waiting to happen when we transform them to our desired data type:</p><p> ä¸ä»…å¦‚æ­¤ï¼Œæ‹¥æœ‰è¿™äº›ä¸­é—´ç±»å‹è¿˜æ„å‘³ç€å½“æˆ‘ä»¬å°†å®ƒä»¬è½¬æ¢ä¸ºæ‰€éœ€çš„æ•°æ®ç±»å‹æ—¶ï¼Œæœ‰ä¸€äº›é”™è¯¯ç­‰å¾…å‘ç”Ÿï¼š</p><p>   Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing codeâ€”throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the â€œbadâ€ cases.</p><p>   Shotgunè§£ææ˜¯ä¸€ç§ç¼–ç¨‹åæ¨¡å¼ï¼Œè§£æå’Œè¾“å…¥éªŒè¯ä»£ç ä¸å¤„ç†ä»£ç æ··åˆå¹¶åˆ†å¸ƒåœ¨å¤„ç†ä»£ç ä¹‹é—´ï¼Œä»è€Œåœ¨è¾“å…¥å¤„æŠ›å‡ºä¸€å †æ£€æŸ¥ï¼Œå¹¶å¸Œæœ›åœ¨æ²¡æœ‰ä»»ä½•ç³»ç»Ÿç†ç”±çš„æƒ…å†µä¸‹ï¼Œä¸€ä¸ªæˆ–å¦ä¸€ä¸ªå°†æ•è·æ‰€æœ‰â€œä¸è‰¯â€ä¿¡æ¯æ¡ˆä»¶ã€‚</p><p> In â€œParse, donâ€™t validateâ€, Alexis King goes on to describe how this isspecifically related to parsing and validating:</p><p> äºšå†å…‹è¥¿æ–¯Â·é‡‘ï¼ˆAlexis Kingï¼‰åœ¨â€œè§£æï¼Œä¸éªŒè¯â€ä¸€ä¹¦ä¸­ç»§ç»­æè¿°äº†å®ƒä¸è§£æå’ŒéªŒè¯ä¹‹é—´çš„ç‰¹å®šå…³ç³»ï¼š</p><p> It may not be immediately apparent what shotgun parsing has to do with validationâ€”after all, if you do all your validation up front, you mitigate the risk of shotgun parsing. The problem is that validation-based approaches make it extremely difficult or impossible to determine if everything was actually validated up front or if some of those so-called â€œimpossibleâ€ cases might actually happen. The entire program must assume that raising an exception anywhere is not only possible, itâ€™s regularly necessary.</p><p> shotå¼¹æªè§£æä¸éªŒè¯æœ‰ä»€ä¹ˆå…³ç³»å¯èƒ½å°šä¸æ˜æ˜¾ï¼Œæ¯•ç«Ÿï¼Œå¦‚æœæ‚¨äº‹å…ˆè¿›è¡Œäº†æ‰€æœ‰éªŒè¯ï¼Œå°±å¯ä»¥å‡è½»ofå¼¹æªè§£æçš„é£é™©ã€‚é—®é¢˜åœ¨äºï¼ŒåŸºäºéªŒè¯çš„æ–¹æ³•ä½¿å¾—å¾ˆéš¾æˆ–ä¸å¯èƒ½ç¡®å®šæ‰€æœ‰äº‹æƒ…æ˜¯å¦éƒ½ç»è¿‡äº†é¢„å…ˆéªŒè¯ï¼Œæˆ–è€…æ˜¯å¦ç¡®å®å¯èƒ½å‘ç”Ÿäº†ä¸€äº›æ‰€è°“çš„â€œä¸å¯èƒ½â€æƒ…å†µã€‚æ•´ä¸ªè®¡åˆ’éƒ½å¿…é¡»å‡è®¾ï¼Œä¸ä»…åœ¨ä»»ä½•åœ°æ–¹éƒ½å¯èƒ½å¼•å‘å¼‚å¸¸ï¼Œè€Œä¸”è¿™æ˜¯ç»å¸¸æ€§çš„ã€‚</p><p>   Weâ€™re going to write the same program using parsec, a monadic parsercombinator library. Iâ€™ve recently bumpedinto this excellent  walkthrough to parsercombinators, whichI thouroughly recommend reading.</p><p>   æˆ‘ä»¬å°†ä½¿ç”¨monsecçš„parsercombinatoråº“parsecç¼–å†™ç›¸åŒçš„ç¨‹åºã€‚æˆ‘æœ€è¿‘æ¥è§¦äº†Parsercombinatorçš„å‡ºè‰²æ¼”ç»ƒï¼Œæˆ‘ä¸€ç›´å»ºè®®é˜…è¯»ã€‚</p><p>   It works by consuming input characters from the input string and returninga tuple with two values:</p><p>   å®ƒé€šè¿‡ä½¿ç”¨è¾“å…¥å­—ç¬¦ä¸²ä¸­çš„è¾“å…¥å­—ç¬¦å¹¶è¿”å›å…·æœ‰ä¸¤ä¸ªå€¼çš„å…ƒç»„æ¥å·¥ä½œï¼š </p><p> The first value is whatâ€™s left of the input string, so that otherparsers can keep parsing the rest of the input.</p><p>ç¬¬ä¸€ä¸ªå€¼æ˜¯è¾“å…¥å­—ç¬¦ä¸²çš„å‰©ä½™å€¼ï¼Œä»¥ä¾¿å…¶ä»–è§£æå™¨å¯ä»¥ç»§ç»­è§£æå…¶ä½™çš„è¾“å…¥ã€‚</p><p> The second value contains either a parse error or a properly parsed value of type  a.</p><p> ç¬¬äºŒä¸ªå€¼åŒ…å«è§£æé”™è¯¯æˆ–ç±»å‹ä¸ºaçš„æ­£ç¡®è§£æå€¼ã€‚</p><p>    -- byr (Birth Year) - four digits; between 1920 and 2002. byrParser  ::  Parser  Int byrParser  =  do  P.string  &#34;byr&#34;  P.char  &#39;:&#39;  value  &lt;-  P.count  4  P.digit  P.spaces  let  int  =  read  value  guard  ( int  &gt;=  1920  &amp;&amp;  int  &lt;=  2002 )  return  int -- iyr (Issue Year) - four digits; between 2010 and 2020. iyrParser  ::  Parser  Int iyrParser  =  do  P.string  &#34;iyr&#34;  P.char  &#39;:&#39;  value  &lt;-  P.count  4  P.digit  P.spaces  let  int  =  read  value  guard  ( int  &gt;=  2010  &amp;&amp;  int  &lt;=  2020 )  return  int -- eyr (Expiration Year) - four digits; between 2020 and 2030. eyrParser  ::  Parser  Int eyrParser  =  do  P.string  &#34;eyr&#34;  P.char  &#39;:&#39;  value  &lt;-  P.count  4  P.digit  P.spaces  let  int  =  read  value  guard  ( int  &gt;=  2020  &amp;&amp;  int  &lt;=  2030 )  return  int</p><p>    -æ‹œå°”ï¼ˆç”Ÿæ—¥ï¼‰-å››ä½æ•°ï¼›åœ¨1920å¹´åˆ°2002å¹´ä¹‹é—´ã€‚byrParser ::è§£æå™¨Int byrParser = do P.stringï¼†ï¼ƒ34; byrï¼†ï¼ƒ34; P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39;å€¼ï¼†lt;-P.count 4ä¸ªP.digit P.spacesï¼Œè®©int =è¯»å–å€¼ä¿æŠ¤ï¼ˆintï¼†gt; = 1920ï¼†amp; intï¼†lt; = 2002ï¼‰return int-iyrï¼ˆIssue Yearï¼‰-å››ä½æ•°å­—;åœ¨2010å¹´è‡³2020å¹´ä¹‹é—´ã€‚iyrParser :: Parser Int iyrParser = do P.stringï¼†ï¼ƒ34; iyrï¼†ï¼ƒ34; P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39;å€¼ï¼†lt;-P.count 4ä¸ªP.digit P.spacesï¼Œè®©int =è¯»å–å€¼ä¿æŠ¤ï¼ˆintï¼†gt; = 2010ï¼†amp; intï¼†lt; = 2020ï¼‰return int-eyrï¼ˆæœ‰æ•ˆå¹´ï¼‰-å››ä½æ•°å­—;åœ¨2020å¹´åˆ°2030å¹´ä¹‹é—´ã€‚eyrParser :: Parser Int eyrParser = do P.stringï¼†ï¼ƒ34; eyrï¼†ï¼ƒ34; P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39;å€¼ï¼†lt;-P.count 4ä¸ªP.digit P.spacesï¼Œè®©int =è¯»å–å€¼ä¿æŠ¤ï¼ˆintï¼†gt; = 2020ï¼†amp;ï¼†amp; intï¼†lt; = 2030ï¼‰è¿”å›int</p><p> Here we use the  guard function to introduce an assertion that will makethe parser fail when the condition is not met. In general I feel that thiscode is quite readable, but we might want to extract a reusable helper toparse years:</p><p> åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ä¿æŠ¤åŠŸèƒ½å¼•å…¥ä¸€ä¸ªæ–­è¨€ï¼Œå½“ä¸æ»¡è¶³æ¡ä»¶æ—¶ï¼Œè¯¥æ–­è¨€å°†ä½¿è§£æå™¨å¤±è´¥ã€‚æ€»çš„æ¥è¯´ï¼Œæˆ‘è§‰å¾—è¿™æ®µä»£ç å¯è¯»æ€§å¾ˆå¼ºï¼Œä½†æ˜¯æˆ‘ä»¬å¯èƒ½æƒ³æå–ä¸€ä¸ªå¯é‡ç”¨çš„å¸®åŠ©å™¨æ¥åˆ†æå‡ å¹´ï¼š</p><p> yearParser  ::  String  -&gt;  ( Int ,  Int )  -&gt;  Parser  Int yearParser  value  ( rangeStart ,  rangeEnd )  =  do  P.string  value  P.char  &#39;:&#39;  value  &lt;-  P.count  4  P.digit  P.spaces  let  int  =  read  value  guard  ( int  &gt;=  rangeStart  &amp;&amp;  int  &lt;=  rangeEnd )  return  int byrParser  ::  Parser  Int byrParser  =  do  yearParser  &#34;byr&#34;  ( 1920 ,  2002 ) iyrParser  ::  Parser  Int iyrParser  =  do  yearParser  &#34;iyr&#34;  ( 2010 ,  2020 ) eyrParser  ::  Parser  Int eyrParser  =  do  yearParser  &#34;eyr&#34;  ( 2020 ,  2030 )</p><p> yearParser ::å­—ç¬¦ä¸²-ï¼†gt; ï¼ˆIntï¼ŒIntï¼‰-> Parser Int yearParserå€¼ï¼ˆrangeStartï¼ŒrangeEndï¼‰=åšP.stringå€¼P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39;å€¼ï¼†lt;-P.count 4ä¸ªP.digit P.spacesï¼Œè®©int =è¯»å–å€¼ä¿æŠ¤ï¼ˆintï¼†gt; = rangeStartï¼†amp;ï¼†amp; intï¼†lt; = rangeEndï¼‰è¿”å›int byrParser :: Parser Int byrParser = do yearParserï¼†ï¼ƒ34 ; byrï¼†ï¼ƒ34; ï¼ˆ1920å¹´ï¼Œ2002å¹´ï¼‰iyrParser :: Parser Int iyrParser = do yearParserï¼†ï¼ƒ34; iyrï¼†ï¼ƒ34; ï¼ˆ2010å¹´ï¼Œ2020å¹´ï¼‰eyrParser :: Parser Int eyrParser = do yearParserï¼†ï¼ƒ34; eyrï¼†ï¼ƒ34; ï¼ˆ2020ï¼Œ2030ï¼‰</p><p>  This is the beauty of writing parser combinators. They are  extremely easy toreuse and combine.</p><p>  è¿™å°±æ˜¯ç¼–å†™è§£æå™¨ç»„åˆå™¨çš„ç¾å¦™ä¹‹å¤„ã€‚å®ƒä»¬éå¸¸æ˜“äºé‡ç”¨å’Œç»„åˆã€‚</p><p> Now we want to write a parser for the height field. It might be nice to usea more specialized data type to represent that:</p><p> ç°åœ¨æˆ‘ä»¬è¦ä¸ºé«˜åº¦å­—æ®µç¼–å†™ä¸€ä¸ªè§£æå™¨ã€‚ä½¿ç”¨æ›´ä¸“ä¸šçš„æ•°æ®ç±»å‹æ¥è¡¨ç¤ºå¯èƒ½ä¼šå¾ˆå¥½ï¼š </p><p>   -- hgt (Height) - a number followed by either cm or in: -- If cm, the number must be between 150 and 193. -- If in, the number must be between 59 and 76. heightParser  ::  Parser  Height heightParser  =  do  P.string  &#34;hgt&#34;  P.char  &#39;:&#39;  digits  &lt;-  P.many1  P.digit  let  value  =  read  digits  result  &lt;-  unitParser  value  case  result  of  InCms  _  -&gt;  guard  ( value  &gt;=  150  &amp;&amp;  value  &lt;=  193 )  InInches  _  -&gt;  guard  ( value  &gt;=  59  &amp;&amp;  value  &lt;=  76 )  P.spaces  return  result</p><p>-hgtï¼ˆé«˜åº¦ï¼‰-ä¸€ä¸ªæ•°å­—ï¼Œåè·Ÿcmæˆ–inï¼šâ€“å¦‚æœä¸ºcmï¼Œåˆ™è¯¥æ•°å­—å¿…é¡»ä»‹äº150å’Œ193ä¹‹é—´ã€‚â€“å¦‚æœä¸ºcmï¼Œåˆ™è¯¥æ•°å­—å¿…é¡»ä»‹äº59å’Œ76ä¹‹é—´ã€‚heightParser :: Parser Height heightParser =åšP.stringï¼†ï¼ƒ34; hgtï¼†ï¼ƒ34; P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39;ä½æ•°ï¼†lt;-P.many1 P.digit let value =è¯»å–çš„æ•°å­—ç»“æœï¼†lt;-InCms _ unitParserå€¼å¤§å°å†™ç»“æœ_-ï¼†gt;ä¿æŠ¤ï¼ˆå€¼ï¼†gt; = 150ï¼†amp;ï¼†amp;å€¼ï¼†lt; = 193ï¼‰InInches _-ï¼†gt;ä¿æŠ¤ï¼ˆå€¼ï¼†gt; = 59ï¼†amp;ï¼†amp;å€¼ï¼†lt; = 76ï¼‰P.spacesè¿”å›ç»“æœ</p><p>  unitParser  ::  Int  -&gt;  Parser  Height unitParser  value  =  let  cmParser  =  do  P.string  &#34;cm&#34;  return  ( InCms  value )  inParser  =  do  P.string  &#34;in&#34;  return  ( InInches  value )  in  P.choice  [ cmParser ,  inParser ]</p><p>  unitParser :: Int-ï¼†gt;åˆ†æå™¨é«˜åº¦unitParserå€¼=è®©cmParser =æ‰§è¡ŒP.stringï¼†ï¼ƒ34; cmï¼†ï¼ƒ34; returnï¼ˆInCms valueï¼‰inParser =åšP.stringï¼†ï¼ƒ34; inï¼†ï¼ƒ34;åœ¨P.choice [cmParserï¼ŒinParser]ä¸­è¿”å›ï¼ˆInIncheså€¼ï¼‰</p><p> The rest of the parsers are basically a step by step translation of therequirements in English:</p><p> å…¶ä½™çš„è§£æå™¨åŸºæœ¬ä¸Šæ˜¯å¯¹è‹±è¯­è¦æ±‚çš„é€æ­¥ç¿»è¯‘ï¼š</p><p> -- hcl (Hair Color) - a &#39;#&#39; followed by six chars 0-9 or a-f. hairColorParser  ::  Parser  String hairColorParser  =  do  P.string  &#34;hcl&#34;  P.char  &#39;:&#39;  P.char  &#39;#&#39;  v  &lt;-  P.count  6  ( P.oneOf  &#34;0123456789abcdef&#34; )  P.spaces  return  v</p><p> -hclï¼ˆå‘è‰²ï¼‰-aï¼†ï¼ƒ39;ï¼ƒï¼†ï¼ƒ39;éšåæ˜¯å…­ä¸ªå­—ç¬¦0-9æˆ–a-fã€‚ hairColorParser ::è§£æå™¨å­—ç¬¦ä¸²hairColorParser = do P.stringï¼†ï¼ƒ34; hclï¼†ï¼ƒ34; P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39;å¤å°”ï¼†ï¼ƒ39;ï¼ƒï¼†ï¼ƒ39; vï¼†lt;-P.count 6ï¼ˆP.oneOfï¼†ï¼ƒ34; 0123456789abcdefï¼†ï¼ƒ34;ï¼‰P.spacesè¿”å›v</p><p> -- pid (Passport ID) - a nine-digit number. passportIdParser  ::  Parser  String passportIdParser  =  do  P.string  &#34;pid&#34;  P.char  &#39;:&#39;  v  &lt;-  P.count  9  P.digit  P.spaces  return  v</p><p> -pidï¼ˆæŠ¤ç…§IDï¼‰-ä¸€ä¸ªä¹ä½æ•°çš„æ•°å­—ã€‚ passwordIdParser ::è§£æå™¨å­—ç¬¦ä¸²passwordIdParser =åšP.stringï¼†ï¼ƒ34; pidï¼†ï¼ƒ34; P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39; vï¼†lt;-P.count 9ä¸ªPä½æ•°å­—P.spacesè¿”å›v</p><p> -- cid (Country ID) - ignored, missing or not. countryIdParser  ::  Parser  Int countryIdParser  =  do  P.string  &#34;cid&#34;  P.char  &#39;:&#39;  value  &lt;-  P.many1  P.digit  P.spaces  return  $  read  value</p><p> -cidï¼ˆå›½å®¶/åœ°åŒºIDï¼‰-å·²å¿½ç•¥ï¼Œç¼ºå¤±æˆ–ç¼ºå¤±ã€‚ countryIdParser ::è§£æå™¨Int countryIdParser =åšP.stringï¼†ï¼ƒ34; cidï¼†ï¼ƒ34; P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39;å€¼ï¼†lt;-P.many1 P.digit P.spacesè¿”å›$è¯»å–å€¼</p><p> -- ecl (Eye Color) - one of: amb blu brn gry grn hzl oth. eyeColorParser  ::  Parser  String eyeColorParser  =  do  P.string  &#34;ecl&#34;  P.char  &#39;:&#39;  v  &lt;-  P.choice  $  map  ( P.try  .  P.string )  [  &#34;amb&#34; ,  &#34;blu&#34; ,  &#34;brn&#34; ,  &#34;gry&#34; ,  &#34;grn&#34; ,  &#34;hzl&#34; ,  &#34;oth&#34;  ]  P.spaces  return  v</p><p> -eclï¼ˆçœ¼ç›é¢œè‰²ï¼‰-å…¶ä¸­ä¹‹ä¸€ï¼šamb blu brn gry grn hzl othã€‚ eyeColorParser ::è§£æå™¨å­—ç¬¦ä¸²eyeColorParser = do P.stringï¼†ï¼ƒ34; eclï¼†ï¼ƒ34; P.charï¼†ï¼ƒ39;ï¼šï¼†ï¼ƒ39; vï¼†lt;-P.choice $ mapï¼ˆP.tryã€‚P.stringï¼‰[ï¼†ï¼ƒ34; ambï¼†ï¼ƒ34; ï¼Œï¼†ï¼ƒ34; bluï¼†ï¼ƒ34; ï¼Œï¼†nbnï¼†ï¼ƒ34; ï¼Œï¼†gryï¼†ï¼ƒ34; ï¼Œï¼†ï¼ƒ34; grnï¼†ï¼ƒ34; ï¼Œï¼†ï¼ƒ34; hzlï¼†ï¼ƒ34; ï¼Œï¼†othï¼†ï¼ƒ34; P.spacesè¿”å›v </p><p> You will notice we had to use this mysterious  P.try function in the lastsnippet. This is very useful when we need to look ahead in the inputstring. Consider the example of  blu and  brn: after consuming an initial b character we land in the  blu branch. If at that point we encounter a r character, we realize we need to go back and choose the  brn branchinstead. But by default the parsing would stop because we have alreadyconsumed the first character.  P.try will make it so our parser pretendsit hasnâ€™t consumed any input so that we can keep trying otheralternatives.</p><p>æ‚¨ä¼šæ³¨æ„åˆ°æˆ‘ä»¬å¿…é¡»åœ¨æœ€åä¸€ä¸ªç‰‡æ®µä¸­ä½¿ç”¨æ­¤ç¥ç§˜çš„P.tryå‡½æ•°ã€‚å½“æˆ‘ä»¬éœ€è¦åœ¨è¾“å…¥å­—ç¬¦ä¸²ä¸­å‘å‰çœ‹æ—¶ï¼Œè¿™éå¸¸æœ‰ç”¨ã€‚è€ƒè™‘ä¸€ä¸‹bluå’Œbrnçš„ç¤ºä¾‹ï¼šæ¶ˆè´¹äº†åˆå§‹bå­—ç¬¦åï¼Œæˆ‘ä»¬è¿›å…¥äº†bluåˆ†æ”¯ã€‚å¦‚æœæ­¤æ—¶é‡åˆ°rå­—ç¬¦ï¼Œæˆ‘ä»¬æ„è¯†åˆ°æˆ‘ä»¬éœ€è¦è¿”å›å¹¶é€‰æ‹©brnåˆ†æ”¯ã€‚ä½†æ˜¯é»˜è®¤æƒ…å†µä¸‹ï¼Œè§£æå°†åœæ­¢ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»æ¶ˆè€—äº†ç¬¬ä¸€ä¸ªå­—ç¬¦ã€‚ P.tryä¼šè¿™æ ·åšï¼Œå› æ­¤æˆ‘ä»¬çš„è§£æå™¨ä¸ä¼šå‡è£…ä½¿ç”¨ä»»ä½•è¾“å…¥ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç»§ç»­å°è¯•å…¶ä»–æ›¿ä»£æ–¹æ¡ˆã€‚</p><p> We have now written parsers for each individual field. So now itâ€™s time tocombine them all togetherâ€¦</p><p> ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»ä¸ºæ¯ä¸ªå­—æ®µç¼–å†™äº†è§£æå™¨ã€‚ç°åœ¨æ˜¯æ—¶å€™å°†å®ƒä»¬ç»„åˆåœ¨ä¸€èµ·äº†â€¦â€¦</p><p>   Since our parser tries to consume input one character at a time, how theheck can we write one that has to deal with randomly ordered input?</p><p>   ç”±äºæˆ‘ä»¬çš„è§£æå™¨å°è¯•ä¸€æ¬¡æ¶ˆè€—ä¸€ä¸ªå­—ç¬¦ï¼Œå› æ­¤æˆ‘ä»¬è¯¥å¦‚ä½•ç¼–å†™ä¸€ä¸ªå¿…é¡»å¤„ç†éšæœºè¾“å…¥çš„å­—ç¬¦å‘¢ï¼Ÿ</p><p>    This module implements permutation parsers. A permutation phrase is asequence of elements (possibly of different types) in which each elementoccurs exactly once and the order is irrelevant. Some of the permutableelements may be optional.</p><p>    æ­¤æ¨¡å—å®ç°ç½®æ¢è§£æå™¨ã€‚æ’åˆ—çŸ­è¯­æ˜¯å…ƒç´ ï¼ˆå¯èƒ½æ˜¯ä¸åŒç±»å‹ï¼‰çš„åºåˆ—ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ æ°å¥½å‡ºç°ä¸€æ¬¡ä¸”é¡ºåºæ— å…³ç´§è¦ã€‚ä¸€äº›ç½®æ¢å…ƒç´ å¯èƒ½æ˜¯å¯é€‰çš„ã€‚</p><p>    permute is the last call that will wrap everything up and return aparser of something.</p><p>    permuteæ˜¯æœ€åä¸€ä¸ªè°ƒç”¨ï¼Œå®ƒå°†åŒ…è£…æ‰€æœ‰å†…å®¹å¹¶è¿”å›æŸäº›è§£æå™¨ã€‚</p><p> &lt;$$&gt; is used to assign all the fields that we parsed to something. Inour case it will be a  Passport.</p><p> ï¼†lt; $$ï¼†gt;ç”¨äºå°†æˆ‘ä»¬è§£æçš„æ‰€æœ‰å­—æ®µåˆ†é…ç»™æŸäº›å†…å®¹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒå°†æ˜¯æŠ¤ç…§ã€‚</p><p>  passportParser  ::  Parser  Passport passportParser  =  permute  $  Passport  &lt;$$&gt;  byrParser  &lt;||&gt;  iyrParser  &lt;||&gt;  P.try  eyrParser  &lt;||&gt;  P.try  heightParser  &lt;||&gt;  P.try  hairColorParser  &lt;||&gt;  P.try  eyeColorParser  &lt;||&gt;  passportIdParser  &lt;|?&gt;  ( Nothing ,  Just  &lt;$&gt;  countryId</p><p>  PassportParser :: Parser Passport PassportParser =ç½®æ¢$ Passportï¼†lt; $$ï¼†gt; byrParserï¼†lt; ||ï¼†gt; iyrParserï¼†lt; ||ï¼†gt; P.try eyrParserï¼†lt; ||ï¼†gt; P.try heightParserï¼†lt; ||ï¼†gt; P.try hairColorParserï¼†lt; ||ï¼†gt; P.try eyeColorParserï¼†lt; ||ï¼†gt; PassportIdParserï¼†lt; |ï¼Ÿï¼†gt; ï¼ˆæ²¡ä»€ä¹ˆï¼Œåªè¦ï¼†lt; $ï¼†gt; countryId </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://juliu.is/permutate-parsers/">https://juliu.is/permutate-parsers/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ç½®æ¢/">#ç½®æ¢</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsers/">#parsers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/è§£æ/">#è§£æ</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>