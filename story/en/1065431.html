<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>æƒ¯ç”¨çš„ç”Ÿé”ˆï¼Ÿ å®æ–½äºŒè¿›åˆ¶æœç´¢ï¼ˆç¬¬2éƒ¨åˆ†ï¼‰ Idiomatic Rust? Implementing binary search (part 2)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Idiomatic Rust? Implementing binary search (part 2)<br/>æƒ¯ç”¨çš„ç”Ÿé”ˆï¼Ÿ å®æ–½äºŒè¿›åˆ¶æœç´¢ï¼ˆç¬¬2éƒ¨åˆ†ï¼‰ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-13 08:51:23</div><div class="page_narrow text-break page_content"><p>This is a follow-up to the  original article where I looked at a few waysto improve my Rust implementation of Binary search - with a focus on removing &#39;mistakes&#39;and making it as &#39;idiomatic&#39; as possible.</p><p>è¿™æ˜¯åŸå§‹æ–‡ç« çš„åç»­è¡ŒåŠ¨ï¼Œæˆ‘çœ‹å‡ ç§Wathstoæé«˜äº†æˆ‘çš„äºŒè¿›åˆ¶æœç´¢çš„ç”Ÿé”ˆå®æ–½ - é‡ç‚¹åˆ é™¤ï¼†ï¼ƒ39;é”™è¯¯ï¼†ï¼ƒ39;å¹¶ä½¿å®ƒæˆä¸ºï¼†ï¼ƒ39;æƒ¯ç”¨ï¼†ï¼ƒ39;å°½å¯èƒ½ã€‚</p><p> The most common piece of feedback I received on the first articlewas related to the comparison between the  middle value and  high/ low cursors.</p><p> æˆ‘åœ¨ç¬¬ä¸€ä¸ªä¸ä¸­é—´å€¼å’Œé«˜/ä½å…‰æ ‡ä¹‹é—´çš„æ¯”è¾ƒç›¸å…³çš„ç¬¬ä¸€ç¯‡æ–‡ç« ä¸­æ”¶åˆ°çš„æœ€å¸¸è§çš„åé¦ˆã€‚</p><p>  In my  original Tweet (even before the first article) I had presented a variant of the algorithmthat used pattern matching for this comparison via Rust&#39;s  match construct.</p><p>  åœ¨æˆ‘çš„åŸå§‹æ¨æ–‡ä¸­ï¼ˆç”šè‡³åœ¨ç¬¬ä¸€ç¯‡æ–‡ç« ä¹‹å‰ï¼‰æˆ‘ä»‹ç»äº†é€šè¿‡ç”Ÿé”ˆï¼†ï¼ƒ39; såŒ¹é…æ„é€ å¯¹æ­¤æ¯”è¾ƒçš„ç®—æ³•çš„å˜ç§ã€‚</p><p>  rust  pub   fn  (k:  i32, items: &amp;[ i32]) -&gt;  Option&lt; i32&gt; {  let  mut low:  i32 =  0;  let  mut high:  i32 = items.len()  as  i32 -  1;  while low &lt;= high {  let middle = (((high + low) /  2)  as  f64).floor()  as  i32;  match items.get(middle  as  usize) {  Some(current)  if *current == k =&gt;  return  Some(middle),  Some(current)  if *current &gt; k =&gt; high = middle -  1,  Some(current)  if *current &lt; k =&gt; low = middle +  1, _ =&gt; {} } }  None}</p><p>  é“é”ˆé…’å§fnï¼ˆkï¼ši32ï¼Œé¡¹ç›®ï¼šï¼†amp; [i32]ï¼‰ - ï¼†gt;é€‰æ‹©ï¼†lt; I32ï¼†gt; {è®©MUT LOWï¼šI32 = 0;è®©MUT HIGHï¼šI32 = items.lenï¼ˆï¼‰ä½œä¸ºi32  -  1;è™½ç„¶ä½<lt; =é«˜{è®©ä¸­é—´=ï¼ˆï¼ˆï¼ˆé«˜+ä½ï¼‰/ 2ï¼‰ä¸ºf64ï¼‰.floorï¼ˆï¼‰ä½œä¸ºi32;åŒ¹é…é¡¹ç›®ã€‚é‡ç‚¹ï¼ˆä¸­é—´ä¸ºå¤§å°ï¼‰{æŸäº›ï¼ˆå½“å‰ï¼‰å¦‚æœ* current == k =ï¼†gt;è¿”å›ä¸€äº›ï¼ˆä¸­é—´ï¼‰ï¼Œå¦‚æœ*å½“å‰ï¼†gt; k =ï¼†gt;é«˜=ä¸­é—´ -  1ï¼Œä¸€äº›ï¼ˆç”µæµï¼‰å¦‚æœ*ç”µæµï¼†lt; k =ï¼†gt;ä½=ä¸­é—´+ 1ï¼Œ_ =ï¼†gt; {} } }  æ²¡æœ‰ä»»ä½•}</p><p> If we apply the feedback from the  first article to this implementation,we&#39;d end up with the following - which is just a bit cleaner since it removes some casting along with the manual&#39;flooring&#39; I was originally doing.</p><p> å¦‚æœæˆ‘ä»¬å°†ç¬¬ä¸€ç¯‡æ–‡ç« çš„åé¦ˆåº”ç”¨äºè¿™ä¸€å®æ–½ï¼Œæˆ‘ä»¬å°†ï¼†ï¼ƒ39ï¼†ï¼ƒ39; Dç»“æŸäº†ä»¥ä¸‹ - è¿™åªæ˜¯ä¸€ä¸ªç°å°˜ï¼Œå› ä¸ºå®ƒå¯ä»¥æ¶ˆé™¤ä¸€äº›é“¸ä»¶ä»¥åŠæ‰‹å†Œï¼†ï¼ƒ39;åœ°æ¿ï¼†ï¼ƒ39;æˆ‘æœ€åˆåœ¨åšã€‚</p><p> rust  pub   fn  (k:  i32, items: &amp;[ i32]) -&gt;  Option&lt; usize&gt; {  let  mut low:  usize =  0;  let  mut high:  usize = items.len() -  1;  while low &lt;= high {  let middle = (high + low) /  2;  match items.get(middle) {  Some(current)  if *current == k =&gt;  return  Some(middle),  Some(current)  if *current &gt; k =&gt; {  if middle ==  0 {  return  None; }; high = middle -  1 }  Some(current)  if *current &lt; k =&gt; { low = middle +  1; } _ =&gt; {} } }  None}</p><p> é“é”ˆé…’å§fnï¼ˆkï¼ši32ï¼Œé¡¹ç›®ï¼šï¼†amp; [i32]ï¼‰ - ï¼†gt;é€‰æ‹©ï¼†lt; Usizeï¼†gt; {è®©MUTä½ï¼šUSIZE = 0;è®©muté«˜ï¼šUsize = items.lenï¼ˆï¼‰ -  1;è™½ç„¶ä½<lt; =é«˜{è®©ä¸­é—´=ï¼ˆé«˜+ä½ï¼‰/ 2;åŒ¹é…é¡¹ç›®ã€‚é‡ç‚¹ï¼ˆä¸­é—´ï¼‰{ä¸€äº›ï¼ˆå½“å‰ï¼‰å¦‚æœ* current == k =ï¼†gt;è¿”å›ä¸€äº›ï¼ˆä¸­é—´ï¼‰ï¼Œå¦‚æœ*å½“å‰ï¼†gt; k =ï¼†gt; {å¦‚æœä¸­é—´== 0 {è¿”å›æ— ; };é«˜=ä¸­é—´ -  1}å¦‚æœ*ç”µæµï¼†lt; k =ï¼†gt; {Low =ä¸­é—´+ 1; } _ =ï¼†gt; {} } }  æ²¡æœ‰ä»»ä½•}</p><p>  This is where it became a bit complicated. I originally received some feedback on Twitterthat suggested because I&#39;m not using the return value of the  match block in any of the arms, along withthe fact that I&#39;m only using it to mutate the high/low cursors, that this could be deemed  not idiomatic Rust...</p><p>  è¿™æ˜¯å®ƒå˜å¾—æœ‰ç‚¹å¤æ‚çš„åœ°æ–¹ã€‚æˆ‘æœ€åˆæ¥å—äº†Twitterthatçš„ä¸€äº›åé¦ˆï¼Œå»ºè®®ï¼Œå› ä¸ºIï¼†ï¼ƒ39; mä¸ä½¿ç”¨ä»»ä½•è‡‚ä¸­çš„åŒ¹é…å—çš„è¿”å›å€¼ï¼Œä»¥åŠæˆ‘ï¼†ï¼ƒ39; måªä½¿ç”¨å®ƒæ¥çªå˜é«˜/ä½å…‰æ ‡ï¼Œè¿™è¿™å¯èƒ½è¢«è§†ä¸ºä¸æƒ¯ç„¶çš„ç”Ÿé”ˆ...... </p><p> I fully understood that feedback, and to rectify the match could be written like so:</p><p>æˆ‘å®Œå…¨æ˜ç™½åé¦ˆï¼Œå¹¶çº æ­£åŒ¹é…å¯ä»¥å†™å¾—å¦‚æ­¤ï¼š</p><p> rust  match items.get(middle  as  usize) {  Some(current)  if *current == k =&gt; {  return  Some(middle); },  Some(current)  if *current &gt; k =&gt; {  if middle ==  0 {  return  None }; high = middle -  1; },  Some(current)  if *current &lt; k =&gt; { low = middle +  1; }, _ =&gt; {}}</p><p> RuståŒ¹é…é¡¹ç›®ã€‚ï¼ˆä¸­é—´ä¸ºå¤§å°ï¼‰{ä¸€äº›ï¼ˆå½“å‰ï¼‰å¦‚æœ* Current == k =ï¼†gt; {è¿”å›ä¸€äº›ï¼ˆä¸­é—´ï¼‰; }ï¼Œä¸€äº›ï¼ˆå½“å‰ï¼‰å¦‚æœ*å½“å‰ï¼†gt; k =ï¼†gt; {å¦‚æœä¸­é—´== 0 {è¿”å›æ— };é«˜=ä¸­é—´ -  1; }ï¼ŒæŸäº›ï¼ˆç”µæµï¼‰å¦‚æœ*ç”µæµï¼†lt; k =ï¼†gt; {Low =ä¸­é—´+ 1; }ï¼Œ_ =ï¼†gt; {}}</p><p> Now each match arm has no trailing expression, possibly making it clearer to thenext developer that we didn&#39;t intend on returning a value here from the match block.</p><p> ç°åœ¨ï¼Œæ¯ä¸ªåŒ¹é…è‡‚éƒ½æ²¡æœ‰å°¾éšè¡¨è¾¾å¼ï¼Œå¯èƒ½ä¼šæ›´æ¸…æ¥šæˆ‘ä»¬åœ¨é‚£é‡Œï¼†ï¼ƒ39; tæ‰“ç®—ä»åŒ¹é…å—è¿”å›è¿™é‡Œçš„å€¼ã€‚</p><p>    1: Rust makes heavy use of pattern matching, and whilst  match is technically an expressionitself (and therefore can be used as a value), I don&#39;t think it&#39;s an issue if it&#39;s not  always used as a value?.</p><p>    1ï¼šrustè‡´åŠ›äºä½¿ç”¨æ¨¡å¼åŒ¹é…ï¼Œè€ŒåŒ¹é…åœ¨æŠ€æœ¯ä¸Šæ˜¯æŠ€æœ¯æ€§çš„ï¼ˆå› æ­¤å¯ä»¥ç”¨ä½œä¸€ä¸ªå€¼ï¼‰ï¼Œæˆ‘ä¸è§‰å¾—å®ƒè§‰å¾—å®ƒï¼†ï¼ƒ39;å¦‚æœå®ƒå¹¶éæ€»æ˜¯å¦‚æ­¤ç”¨ä½œä»·å€¼ï¼Ÿ</p><p> 2: It seems like it would be more of an issue if each arm of the match had different semantics. For example, if onearm returned a value and another didn&#39;t. This would make the implementation inconsistent,and the viewpoint may hold more water, but Rust&#39;s type system will not allow this anyway since eacharm of the  match  must return the same value.</p><p> 2ï¼šå¦‚æœåŒ¹é…çš„æ¯ä¸ªARMå…·æœ‰ä¸åŒçš„è¯­ä¹‰ï¼Œé‚£ä¼¼ä¹ä¼šæ›´å¤šçš„é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œå¦‚æœOnearmè¿”å›ä¸€ä¸ªå€¼ï¼Œå¦ä¸€ä¸ªDidnï¼†ï¼ƒ39; tã€‚è¿™å°†ä½¿å®æ–½ä¸ä¸€è‡´ï¼Œå¹¶ä¸”è¯¥è§‚ç‚¹å¯ä»¥æŒæœ‰æ›´å¤šçš„æ°´ï¼Œä½†æ˜¯Rustï¼†ï¼ƒ39; så‹ç³»ç»Ÿæ— è®ºå¦‚ä½•éƒ½ä¸ä¼šå…è®¸è¿™ç§æƒ…å†µï¼Œå› ä¸ºåŒ¹é…çš„æ¯ä¸ªarmå¿…é¡»è¿”å›ç›¸åŒçš„å€¼ã€‚</p><p> For those 2 reasons, the rest of this post will focus on further improving our algorithmto fully utilize  match - but please reach out on  Twitter if you disagree, I&#39;d loveto continue the conversation ğŸ˜€</p><p> å¯¹äºé‚£äº›ä¸¤ä¸ªåŸå› ï¼Œè¿™ç¯‡æ–‡ç« çš„å…¶ä½™éƒ¨åˆ†å°†ä¸“æ³¨äºè¿›ä¸€æ­¥æ”¹è¿›æˆ‘ä»¬çš„ç®—æ³•ï¼Œå……åˆ†åˆ©ç”¨åŒ¹é… - ä½†å¦‚æœä½ ä¸åŒæ„ï¼Œæˆ‘ä¼šåœ¨Twitterä¸Šä¼¸å‡ºæ´æ‰‹ï¼Œæˆ‘ï¼†ï¼ƒ39; D Loveveç»§ç»­è°ˆè¯â™¥</p><p>   Our algorithm is searching within a slice of  i32 values. On each iteration we are accessing a value from the slicewith the  .get() method. This was done for safety since a runtime panic can occur if you attemptan index-access with a value that would be out-of-bounds.</p><p>   æˆ‘ä»¬çš„ç®—æ³•åœ¨I32å€¼çš„ä¸€ç‰‡ä¸­æœç´¢ã€‚åœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼Œæˆ‘ä»¬æ­£åœ¨è®¿é—®.getï¼ˆï¼‰æ–¹æ³•çš„Sliceä¸­çš„å€¼ã€‚è¿™æ˜¯ä¸ºäº†å®‰å…¨å®Œæˆï¼Œå› ä¸ºå¦‚æœæ‚¨å°è¯•ç´¢å¼• - ä½¿ç”¨ç¼ºå¤±çš„å€¼ï¼Œå¯ä»¥å‘ç”Ÿè¿è¡Œæ—¶ææ…Œã€‚ </p><p> rust   fn  () {  let items =  vec![ 10,  40,  90];  let forth_item = items[ 3];  println!( &#34;{:?}&#34;, forth_item)  // &#39;main&#39; panicked at &#39;index out of bounds:  // the len is 3 but the index is 3&#39;}</p><p>rust fnï¼ˆï¼‰{è®©é¡¹ç›®= vecï¼[10,40,90];è®©rest_item =é¡¹ç›®[3]; printlnï¼ï¼ˆï¼†ï¼ƒ34; {ï¼šï¼Ÿ}ï¼†ï¼ƒ34;ï¼Œthath_itemï¼‰//ï¼ƒ39; mainï¼†ï¼ƒ39; ï¼†ï¼ƒ39ææ…Œ;ç´¢å¼•è¶…å‡ºç•Œé™ï¼š// lenæ˜¯3ä½†ç´¢å¼•æ˜¯3ï¼†ï¼ƒ39;}</p><p> rust   fn  () {  let items =  vec![ 10,  40,  90];  let first_item = items.get( 0);  println!( &#34;{:?}&#34;, first_item);  // prints `Some(10)`  let forth_item = items.get( 3);  println!( &#34;{:?}&#34;, forth_item)  // prints `None`}</p><p> rust fnï¼ˆï¼‰{è®©é¡¹ç›®= vecï¼[10,40,90];è®©First_Item = Items.getï¼ˆ0ï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34; {ï¼šï¼Ÿ}ï¼†ï¼ƒ34;ï¼Œfirst_itemï¼‰; //æ‰“å°`æŸäº›ï¼ˆ10ï¼‰`letth_item = items.getï¼ˆ3ï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34; {ï¼šï¼Ÿ}ï¼†ï¼ƒ34;ï¼Œthath_itemï¼‰//æ‰“å°`none`}</p><p> So the second way of accessing a value may be safer, but it comes at the cost of an additional layerof indirection in the form of that  Option type.</p><p> å› æ­¤ï¼Œè®¿é—®å€¼çš„ç¬¬äºŒç§æ–¹å¼å¯ä»¥æ›´å®‰å…¨ï¼Œä½†å®ƒä»¥è¯¥é€‰é¡¹ç±»å‹çš„å½¢å¼çš„é¢å¤–å±‚é—´é—´æ¥ä»¥æˆæœ¬ä¸ºä»£ä»·ã€‚</p><p> rust  // return type is Option&lt;i32&gt; let item = items.get( 4) // return type is i32, but may panic let item = items[ 4]</p><p> Rust //è¿”å›ç±»å‹æ˜¯é€‰é¡¹ï¼†lt; i32ï¼†gt;è®©é¡¹ç›®= items.getï¼ˆ4ï¼‰//è¿”å›ç±»å‹æ˜¯i32ï¼Œä½†å¯èƒ½ä¼šææ…Œè®©é¡¹ç›®=é¡¹ç›®[4]</p><p> This affected our algorithm in the  first article since we needed to use an   if letexpression to expose the current value via the  Some(current) pattern.</p><p> è¿™åœ¨ç¬¬ä¸€ç¯‡æ–‡ç« ä¸­å½±å“äº†æˆ‘ä»¬çš„ç®—æ³•ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ä½¿ç”¨å¦‚æœLetExpressioné€šè¿‡æŸäº›ï¼ˆå½“å‰ï¼‰æ¨¡å¼æš´éœ²å½“å‰å€¼ã€‚</p><p> rust  // â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“ if  let  Some(current) = items.get(middle) {  if *current == k {  // snip }  if *current &gt; k {  // snip }  if *current &lt; k {  // snip }}</p><p> rust //â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“å¦‚æœè®©æŸäº›ï¼ˆå½“å‰ï¼‰= items.getï¼ˆä¸­é—´ï¼‰{if * current == k {// snip}å¦‚æœ* currentï¼†gt; k {// snip}å¦‚æœ*å½“å‰ï¼†lt; k {// snip}}</p><p> So, to remove the  Option and therefore also remove  .get() and  Some(current), we&#39;d need to be mathematicallysure to be within the slice bounds - otherwise we&#39;d get a runtime panic! Well it turns out that our originalalgorithm was actually doing all the checks we need - it always ensures the next index access is above zero and is belowthe max length of the slice.</p><p> å› æ­¤ï¼Œè¦åˆ é™¤é€‰é¡¹ï¼Œå› æ­¤è¿˜åˆ é™¤äº†.getï¼ˆï¼‰å’Œä¸€äº›ï¼ˆå½“å‰ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ•°å­¦ä¸Šè¿›è¡Œæ•°å­¦ä¸Šçš„ç•Œé™ - å¦åˆ™æˆ‘ä»¬ï¼†ï¼ƒ39; d and to and andï¼ƒ39;äº‹å®è¯æ˜ï¼Œæˆ‘ä»¬çš„åŸå§‹ç®—æ³•å®é™…ä¸Šæ­£åœ¨æ‰§è¡Œæˆ‘ä»¬æ‰€éœ€çš„æ‰€æœ‰æ£€æŸ¥ - å®ƒå§‹ç»ˆç¡®ä¿ä¸‹ä¸€ä¸ªç´¢å¼•è®¿é—®é«˜äºé›¶ï¼Œå¹¶ä¸”ä½äºåˆ‡ç‰‡çš„æœ€å¤§é•¿åº¦ã€‚ </p><p> This means that in terms of the original article, we could&#39;ve replaced the  if let Some(current) with a simple indexaccess which makes the solution less syntactically noisy and is simpler overall.</p><p>è¿™æ„å‘³ç€åœ¨åŸå§‹æ–‡ç« æ–¹é¢ï¼Œæˆ‘ä»¬å¯ä»¥ï¼†ï¼ƒ39æ›´æ¢äº†å¦‚æœè®©æŸäº›ï¼ˆå½“å‰ï¼‰ç”¨ä¸€ä¸ªç®€å•çš„ç´¢å¼•ä¼ æ’­ï¼Œè¿™ä½¿å¾—è§£å†³æ–¹æ¡ˆè¾ƒå°‘å˜ˆæ‚å¹¶ä¸”æ•´ä½“æ›´ç®€å•ã€‚</p><p> rust  // we know this won&#39;t panic since we control &#39;middle&#39; // â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“ let current = items[middle] if current == k {  // snip}</p><p> ç”Ÿé”ˆ//æˆ‘ä»¬çŸ¥é“è¿™æ˜¯èµ¢å¾—ï¼†ï¼ƒ39;è‡ªä»æˆ‘ä»¬æ§åˆ¶ï¼†ï¼ƒ39;ä¸­é—´ï¼†ï¼ƒ39; //â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“â†“å½“Current == k {// Snip}</p><p> Now we can be confident that a direct index access is always safe, since we control the  middle value, but how doesthis help us with the match expression mentioned previously?</p><p> ç°åœ¨æˆ‘ä»¬å¯ä»¥ç›¸ä¿¡ç›´æ¥ç´¢å¼•è®¿é—®å§‹ç»ˆæ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ§åˆ¶äº†ä¸­é—´ä»·å€¼ï¼Œä½†Doesthiså¦‚ä½•å¸®åŠ©æˆ‘ä»¬æåˆ°çš„åŒ¹é…è¡¨è¾¾å¼ï¼Ÿ</p><p>  If all we did was take the  match expression from the beginning of this article, and remove the  Option as mentionedabove, we&#39;d end up with something that looked like this</p><p>  å¦‚æœæˆ‘ä»¬æ‰€åšçš„ä¸€åˆ‡éƒ½ä»æœ¬æ–‡çš„å¼€å¤´å–å‡ºæ¯”èµ›è¡¨è¾¾å¼ï¼Œå¹¶å°†é€‰é¡¹åˆ é™¤ä¸ºæåˆ°çš„ï¼Œæˆ‘ä»¬ï¼†ï¼ƒ39; dæœ€ç»ˆå¾—åˆ°äº†è¿™æ ·çš„ä¸œè¥¿</p><p> rust  // before match items.get(middle) {  Some(current)  if *current == k =&gt;  return  Some(middle),  Some(current)  if *current &gt; k =&gt; {  if middle ==  0 {  return  None }; high = middle -  1 },  Some(current)  if *current &lt; k =&gt; { low = middle +  1; }, _ =&gt; {}} // after match items[middle] { current  if current == k =&gt; {  return  Some(middle); }, current  if *current &gt; k =&gt; {  if middle ==  0 {  return  None }; high = middle -  1 }, current  if *current &lt; k =&gt; { low = middle +  1; }, _ =&gt; {}}</p><p> rust //åœ¨åŒ¹é…é¡¹ç›®ä¹‹å‰ã€‚æ³¨ï¼ˆä¸­é—´ï¼‰{æŸäº›ï¼ˆå½“å‰ï¼‰å¦‚æœ* current == k =ï¼†gt;è¿”å›ä¸€äº›ï¼ˆä¸­é—´ï¼‰ï¼Œå¦‚æœ*å½“å‰ï¼†gt; k =ï¼†gt; {å¦‚æœä¸­é—´== 0 {è¿”å›æ— }; HIGH =ä¸­é—´ -  1}ï¼Œå¦‚æœ*ç”µæµï¼†lt; k =ï¼†gt; {Low =ä¸­é—´+ 1; }ï¼Œ_ =ï¼†gt; {}} //åŒ¹é…é¡¹ç›®[ä¸­é—´] {å½“å‰ç”µæµ== k =ï¼†gt; {è¿”å›ä¸€äº›ï¼ˆä¸­é—´ï¼‰; }ï¼Œå½“å‰if * currentï¼†gt; k =ï¼†gt; {å¦‚æœä¸­é—´== 0 {è¿”å›æ— };é«˜=ä¸­é—´ -  1}ï¼Œç”µæµIF *ç”µæµï¼†lt; k =ï¼†gt; {Low =ä¸­é—´+ 1; }ï¼Œ_ =ï¼†gt; {}}</p><p> Which is barely even an improvement ğŸ™! If anything, I&#39;d say it&#39;s actually harder to read.</p><p> è¿™å‡ ä¹ç”šè‡³æ˜¯ä¸€ä¸ªæ”¹å–„â™¥ï¼å¦‚æœæœ‰çš„è¯ï¼Œæˆ‘ï¼†ï¼ƒ39; dè¯´å®ƒï¼†ï¼ƒ39å®é™…ä¸Šæ›´éš¾é˜…è¯»ã€‚</p><p> It&#39;s missing the next big step, which is also another move towards more idiomatic Rust - and that&#39;s to take advantageof the fact that the  Ord trait is implemented for  i32 in the standard library.</p><p> å®ƒç¼ºå°‘ä¸‹ä¸€ä¸ªå¤§æ­¥éª¤ï¼Œè¿™ä¹Ÿæ˜¯å¦ä¸€ä¸ªæœå‘æ›´æƒ¯ç”¨çš„ç”Ÿé”ˆ - è€Œä¸”è¾¾åˆ°äº†ordç‰¹å¾åœ¨æ ‡å‡†å›¾ä¹¦é¦†çš„i32å®æ–½çš„äº‹å®ã€‚ </p><p> The  Ord trait has a  .cmp(other) method which returns a variant of the  Ordering enum, it&#39;s definitionlooks like this...</p><p>ordç‰¹æ€§æœ‰ä¸€ä¸ª.cmpï¼ˆå…¶ä»–ï¼‰æ–¹æ³•ï¼Œå®ƒè¿”å›è®¢è´­æšä¸¾çš„å˜ä½“ï¼Œå®ƒï¼†ï¼ƒ39; så®šä¹‰åˆ—è¡¨...</p><p> rust  // std::cmp pub   trait  :  Eq +  PartialOrd&lt; Self&gt; {   fn  (&amp; self, other: &amp; Self) -&gt; Ordering;  // snip}</p><p> rust // std :: cmp pubç‰¹æ€§ï¼šeq + partialordï¼†lt;è‡ªæˆ‘ï¼†gt; {FNï¼ˆï¼†amp;è‡ªæˆ‘ï¼Œå…¶ä»–ï¼šï¼†amp; selfï¼‰ - ï¼†gt;è®¢è´­; // Snip}</p><p>  rust   fn  () {  let first:  i32 =  1;  let second:  i32 =  3;  let result = first.cmp(&amp;second);  println!( &#34;result = {}&#34;, result)  // outputs `Less`, `Greater` or `Equal` respectively}</p><p>  rust fnï¼ˆï¼‰{è®©ç¬¬ä¸€ï¼ši32 = 1;è®©ç¬¬äºŒï¼ši32 = 3;è®©ç»“æœ= First.cmpï¼ˆï¼†amp;ç¬¬äºŒï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34;ç»“æœ= {}ï¼†ï¼ƒ34;ç»“æœï¼‰//è¾“å‡º`å°‘ï¼Œ`æ›´å¤§çš„`æˆ–`ç­‰äº}</p><p> Notice how this is consolidating 3 separate comparisons into a single method call -it removes the need to manually check  equal,  greater, and  less in an imperative style and instead it endsup being more  declarative since we&#39;re no longer defining the actual implementation.</p><p> è¯·æ³¨æ„ï¼Œå¦‚ä½•å°†3ä¸ªå•ç‹¬çš„æ¯”è¾ƒåˆå¹¶ä¸ºå•ä¸ªæ–¹æ³•è°ƒç”¨ -  itåˆ é™¤æ‰‹åŠ¨æ£€æŸ¥ç­‰äºçš„éœ€è¦ï¼Œæ›´å¤§ï¼Œæ›´å°‘ï¼Œæ›´ä½ï¼Œè€Œæ˜¯è‡ªæˆ‘ä»¬ï¼†ï¼ƒ39ä»¥æ¥çš„æ›´é«˜çš„å£°æ˜æ€§;é‡æ–°ç¡®å®šå®é™…å®ç°ã€‚</p><p> After the call to  .cmp(other) we now have a value which is equal to one of  Ordering&#39;s 3 enum variantsand this is where languages with Pattern Matching really shine since we can do a  match on the variant andsimplify our code quite a bit.</p><p> è°ƒç”¨å.CMPï¼ˆå…¶ä»–ï¼‰æˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ªå€¼ç­‰äºè®¢è´­çš„ä¸€ä¸ªå€¼å’Œï¼ƒ39; S 3 Enum Variantsandï¼Œè¿™æ˜¯ä¸æ¨¡å¼åŒ¹é…çš„è¯­è¨€éå¸¸é—ªè€€ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥åœ¨å˜ä½“ä¸ŠåšåŒ¹é…ï¼Œå¹¶å®ç°äº†åŒ¹é…ä¸€ç‚¹ç‚¹ã€‚</p><p> rust  match items[middle].cmp(&amp;k) { Ordering::Equal =&gt;  return  Some(middle), Ordering::Greater =&gt; {  if middle ==  0 {  return  None }; high = middle -  1 }, Ordering::Less =&gt; low = middle +  1}</p><p> é”ˆåŒ¹é…é¡¹ç›®[ä¸­é—´] .cmpï¼ˆï¼†amp; kï¼‰{è®¢è´­::ç­‰äº=ï¼†gt;è¿”å›ä¸€äº›ï¼ˆä¸­é—´ï¼‰ï¼Œè®¢è´­::æ›´é«˜=ï¼†gt; {å¦‚æœä¸­é—´== 0 {è¿”å›æ— }; high = middle  -  1}ï¼Œè®¢è´­::å°‘=ï¼†gt;ä½=ä¸­é—´+ 1}</p><p> Along with being a more declarative style, it&#39;s also much less noisy with far fewer things to mentally parse. ğŸ˜‡</p><p> éšç€æ›´å®£è¨€çš„é£æ ¼ï¼Œå®ƒï¼†ï¼ƒ39; Sä¹Ÿè¿œè¿œå°‘å¾—å¤šï¼Œä»¤äººæ²®ä¸§åœ°è§£æã€‚ ğŸ˜‡ </p><p> Also, since the matching on the  Ordering enum is exhaustive, we no-longer needthe empty  _ =&gt; {} as a final catch-all match arm either. ğŸ™</p><p>æ­¤å¤–ï¼Œç”±äºè®¢è´­æšä¸¾ä¸Šçš„åŒ¹é…æ˜¯ç©·çš„ï¼Œå› æ­¤æˆ‘ä»¬ä¸å†éœ€è¦ç©º_ =ï¼†gt; {}ä½œä¸ºæœ€ç»ˆæ•è· - æ‰€æœ‰åŒ¹é…è‡‚ã€‚ ğŸ™</p><p> A final thing to note here is that since we&#39;re invoking a method implemented for the  Ord trait, it means thatour algorithm could be made more generic in the future to include searching for any type that implements  Ord, andnot just  i32 as in our example. This would make a great follow-on blog post, highlighting the power of traits in Rust, pleasereach out to me on  Twitter if you&#39;d like to see that post happen ğŸ¦</p><p> æ­¤å¤„çš„æœ€åä¸€ä»¶äº‹æ˜¯å› ä¸ºï¼†ï¼ƒ39;é‡æ–°è°ƒç”¨ä¸ºordç‰¹å¾å®ç°çš„æ–¹æ³•ï¼Œè¿™æ„å‘³ç€åœ¨å°†æ¥å¯ä»¥æ›´é€šç”¨ï¼Œä»¥ä¾¿åœ¨å¯»æ‰¾å®ç°ordçš„ä»»ä½•ç±»å‹ï¼Œè€Œä¸æ˜¯i32çš„ç®—æ³•æˆ‘ä»¬çš„ä¾‹å­ã€‚è¿™å°†ä½¿è¿™æ˜¯ä¸€ä¸ªä¼Ÿå¤§çš„åç»­åšå®¢æ–‡ç« ï¼Œçªå‡ºäº†Rustçš„ç‰¹å¾çš„åŠ›é‡ï¼Œå¦‚æœä½ å–œæ¬¢çœ‹åˆ°è¿™ä¸ªå¸–å­å‘ç”Ÿåœ¨Twitterä¸Šï¼Œè¯·åœ¨Twitterä¸Šå‘å‡ºç‰¹å¾ã€‚</p><p>  After applying both improvements documented so far (removing  Option + doing a single comparison) we end up withthe following implementation - which is clearly a big improvement ğŸ‘Œ.</p><p>  åˆ°ç›®å‰ä¸ºæ­¢ç”³è¯·ä¸¤ç§æ”¹è¿›åï¼ˆå»é™¤é€‰é¡¹+åšå•ä¸€æ¯”è¾ƒï¼‰ï¼Œæˆ‘ä»¬æœ€ç»ˆå¾—åˆ°äº†ä»¥ä¸‹å®ç° - è¿™æ˜¾ç„¶æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ”¹å–„â™¥ã€‚</p><p> rust use std::cmp::Ordering;  fn  (k:  i32, items: &amp;[ i32]) -&gt;  Option&lt; usize&gt; {  if items.is_empty() {  return  None }  let  mut low:  usize =  0;  let  mut high:  usize = items.len() -  1;  while low &lt;= high {  let middle = (high + low) /  2;  match items[middle].cmp(&amp;k) { Ordering::Equal =&gt;  return  Some(middle), Ordering::Greater =&gt; {  if middle ==  0 {  return  None }; high = middle -  1 }, Ordering::Less =&gt; low = middle +  1 } }  None}</p><p> Rustä½¿ç”¨STD :: CMP ::è®¢è´­; FNï¼ˆkï¼šI32ï¼Œé¡¹ç›®ï¼šï¼†amp; [I32]ï¼‰ - ï¼†gt;é€‰æ‹©ï¼†lt; Usizeï¼†gt; {å¦‚æœé¡¹ç›®.is_emptyï¼ˆï¼‰{return none}è®©mutä½ï¼šUsize = 0;è®©muté«˜ï¼šUsize = items.lenï¼ˆï¼‰ -  1;è™½ç„¶ä½<lt; =é«˜{è®©ä¸­é—´=ï¼ˆé«˜+ä½ï¼‰/ 2;åŒ¹é…é¡¹ç›®[ä¸­é—´] .cmpï¼ˆï¼†amp; kï¼‰{è®¢è´­::ç­‰äº=ï¼†gt;è¿”å›ä¸€äº›ï¼ˆä¸­é—´ï¼‰ï¼Œè®¢è´­::æ›´é«˜=ï¼†gt; {å¦‚æœä¸­é—´== 0 {è¿”å›æ— }; high = middle  -  1}ï¼Œè®¢è´­::å°‘=ï¼†gt; Low = Middle + 1}}æ— }</p><p>  There are 2 lines in our implementation that still feel &#39;over-engineered&#39; - or rather, it feels likethey could be improved, or removed.</p><p>  æˆ‘ä»¬çš„å®æ–½ä¸­æœ‰2æ¡çº¿æ¡ä»ç„¶æ„Ÿè§‰ï¼†ï¼ƒ39;è¿‡åº¦è®¾è®¡çš„ï¼†ï¼ƒ39; - æˆ–è€…ç›¸åï¼Œå®ƒæ„Ÿè§‰å¯èƒ½ä¼šæ”¹å–„æˆ–ç§»é™¤ã€‚</p><p> rust  // this is the opening check in the function if items.is_empty() {  return  None } // part of the `Greater` match arm, need to // ensure we don&#39;t subtract below zero if middle ==  0 {  return  None };</p><p> Frose //è¿™æ˜¯å‡½æ•°ä¸­çš„å¼€å¤´æ£€æŸ¥å¦‚æœItems.Is_emptyï¼ˆï¼‰{è¿”å›None} //éƒ¨åˆ†ï¼‰éœ€è¦//ç¡®ä¿æˆ‘ä»¬åœ¨ä¸­é—´==ä¸­çš„DONï¼†ï¼ƒ39; Tå‡å»ä½äºé›¶ç‚¹0 {è¿”å›none};</p><p> To solve this, we need to address the core algorithm. If we define  high as the exclusive upper boundand only ever re-assign it to either the length of the slice at the start of the function, or to a subsequentmiddle value, we can be sure that we&#39;ll never decrease its value below zero, and therefore we can removeboth of the checks mentioned above.</p><p> è¦è§£å†³æ­¤é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦è§£å†³æ ¸å¿ƒç®—æ³•ã€‚å¦‚æœæˆ‘ä»¬å°†é«˜åº¦å®šä¹‰ä¸ºç‹¬å çš„ä¸Šä¸ªè¾¹ç•Œï¼Œåªéœ€å°†å…¶é‡æ–°åˆ†é…ç»™å‡½æ•°å¼€å§‹æ—¶åˆ‡ç‰‡çš„é•¿åº¦ï¼Œæˆ–è€…åˆ°ååŸŸå€¼ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šæˆ‘ä»¬ï¼†ï¼ƒ39; llæ°¸è¿œä¸ä¼šå‡å°‘å®ƒçš„å€¼é›¶ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åˆ é™¤ä¸Šé¢æåˆ°çš„æ£€æŸ¥ã€‚ </p><p> We&#39;d be ensuring that none of the mutable  usize cursors can ever drop below zero, and that would allow us to remove thosetwo manual checks.</p><p>æˆ‘ä»¬ï¼†ï¼ƒ39; Dæ˜¯ç¡®ä¿æ²¡æœ‰ä¸€ä¸ªå¯å˜çš„ä½¿ç”¨å…‰æ ‡å¯ä»¥ä¸‹é™åˆ°é›¶ä»¥ä¸‹ï¼Œè¿™å°†å…è®¸æˆ‘ä»¬åˆ é™¤Thosetwoæ‰‹åŠ¨æ£€æŸ¥ã€‚</p><p>  That leaves us with the following, which I&#39;m starting to feel happy aboutafter these 2 long blog posts &amp; the feedback I received on Twitter ğŸ™</p><p>  è¿™è®©æˆ‘ä»¬ç•™ä¸‹äº†ä»¥ä¸‹å†…å®¹ï¼Œå…¶ä¸­æˆ‘å¼€å§‹æ„Ÿåˆ°å¿«ä¹ï¼Œè¿™ä¸¤ä¸ªé•¿çš„åšå®¢å¸–å­ï¼†amp;æˆ‘åœ¨Twitterä¸Šæ”¶åˆ°çš„åé¦ˆğŸ™</p><p> rust use std::cmp::Ordering;  fn  (k:  i32, items: &amp;[ i32]) -&gt;  Option&lt; usize&gt; {  let  mut low:  usize =  0;  let  mut high:  usize = items.len();  while low &lt; high {  let middle = (high + low) /  2;  match items[middle].cmp(&amp;k) { Ordering::Equal =&gt;  return  Some(middle), Ordering::Greater =&gt; high = middle, Ordering::Less =&gt; low = middle +  1 } }  None}</p><p> Rustä½¿ç”¨STD :: CMP ::è®¢è´­; FNï¼ˆkï¼šI32ï¼Œé¡¹ç›®ï¼šï¼†amp; [I32]ï¼‰ - ï¼†gt;é€‰æ‹©ï¼†lt; Usizeï¼†gt; {è®©MUTä½ï¼šUSIZE = 0;è®©muté«˜ï¼šUsize = items.lenï¼ˆï¼‰;è™½ç„¶ä½ï¼†lt;é«˜{è®©ä¸­é—´=ï¼ˆé«˜+ä½ï¼‰/ 2;åŒ¹é…é¡¹ç›®[ä¸­é—´] .cmpï¼ˆï¼†amp; kï¼‰{è®¢è´­::ç­‰äº=ï¼†gt;è¿”å›ä¸€äº›ï¼ˆä¸­é—´ï¼‰ï¼Œè®¢è´­::æ›´é«˜=ï¼†gt;é«˜=ä¸­é—´ï¼Œè®¢è´­::å°‘=ï¼†gt; Low = Middle + 1}}æ— }</p><p>  This first visualization here shows how all the demos across both posts (apart from thefinal change) play out</p><p>  æ­¤å¤„çš„ç¬¬ä¸€æ¬¡å¯è§†åŒ–å±•ç¤ºäº†ä¸¤ä¸ªå¸–å­ä¸­çš„æ‰€æœ‰æ¼”ç¤ºï¼ˆé™¤äº†æ¥è‡ªThe File Changeï¼‰çš„æ‰€æœ‰æ¼”ç¤º</p><p>  This next visualization shows how much simpler everything becomes when you have  highas the exclusive upper bound - fewer steps are taken overall. Also note how the  highcursor begins at 1 index higher than the end of the list, whereas previously it beganon the last element directly.</p><p>  ä¸‹ä¸€ä¸ªå¯è§†åŒ–æ˜¾ç¤ºï¼Œå½“æ‚¨é«˜åˆ†ä¹‹ç±»æ—¶ï¼Œä¸€åˆ‡éƒ½å˜å¾—æ›´åŠ ç®€å•ï¼Œæ•´ä½“ä¸Šå ç”¨äº†è¾ƒå°‘çš„æ­¥éª¤ã€‚å¦è¯·æ³¨æ„HighCursorå¦‚ä½•ä»¥æ¯”åˆ—è¡¨ç»“å°¾çš„1ç´¢å¼•å¼€å§‹ï¼Œè€Œå…ˆå‰åˆ™ç›´æ¥æ¤å…¥æœ€åä¸€ä¸ªå…ƒç´ ã€‚</p><p>   A huge thanks to  Wiebe Cnossen and  Basile Henryfor providing the feedback that inspired this follow-up post.</p><p>   æ„Ÿè°¢Wiebe Cnossenå’ŒPasile Henry foræä¾›æ¿€å‘æ­¤åç»­å¸–å­çš„åé¦ˆã€‚</p><p>  I&#39;d love to hear any feedback or alternative ways to implement this algorithm in Rust - so please reachout on  Twitter if you have any thoughts ğŸ¦€</p><p>  æˆ‘å–œæ¬¢å¬åˆ°ä»»ä½•åé¦ˆæˆ–æ›¿ä»£æ–¹æ³•æ¥å®ç°è¿™ç§ç®—æ³• - æ‰€ä»¥å¦‚æœä½ æœ‰ä»»ä½•æƒ³æ³•ï¼Œè¯·åœ¨Twitterä¸Šä¼¸å‡º </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://shane-o.dev/blog/binary-search-rust-part-2">https://shane-o.dev/blog/binary-search-rust-part-2</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/äºŒè¿›åˆ¶/">#äºŒè¿›åˆ¶</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/binary/">#binary</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/åŒ¹é…/">#åŒ¹é…</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>