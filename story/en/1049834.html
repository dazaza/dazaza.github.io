<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>å¹»å½±ä¸­çš„å¹»å½±ç±»å‹ Phantom Types in Gleam</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Phantom Types in Gleam<br/>å¹»å½±ä¸­çš„å¹»å½±ç±»å‹ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-28 09:37:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/34879b4bb5fbe0a81b007c53773a3dfa.png"><img src="http://img2.diglog.com/img/2021/2/34879b4bb5fbe0a81b007c53773a3dfa.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In this post we&#39;re going to be looking at a more advanced use of  Gleam&#39;s type system, known as phantom types. Hopefully by the end of this you&#39;ll have another tool in your belt to help you better model data in your programs. And fear not, because many languages support phantom types (most common functional programming languages support them, but so do others like Rust, and TypeScript, and even  PHP) so you can apply this knowledge elsewhere!</p><p>åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†ç ”ç©¶Gleamçš„ç±»å‹ç³»ç»Ÿï¼ˆç§°ä¸ºå¹»åƒç±»å‹ï¼‰çš„æ›´é«˜çº§ç”¨æ³•ã€‚å¸Œæœ›åˆ°æœ¬æ–‡ç»“æŸæ—¶ï¼Œæ‚¨å°†æ‹¥æœ‰å¦ä¸€ä¸ªå·¥å…·ï¼Œå¯ä»¥å¸®åŠ©æ‚¨åœ¨ç¨‹åºä¸­æ›´å¥½åœ°å»ºæ¨¡æ•°æ®ã€‚ä¸ç”¨æ‹…å¿ƒï¼Œå› ä¸ºè®¸å¤šè¯­è¨€éƒ½æ”¯æŒå¹»åƒç±»å‹ï¼ˆå¤§å¤šæ•°å¸¸ç”¨çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€éƒ½æ”¯æŒå®ƒä»¬ï¼Œä½†æ˜¯Rustï¼ŒTypeScriptç”šè‡³PHPç­‰å…¶ä»–è¯­è¨€ä¹Ÿæ”¯æŒå¹»åƒç±»å‹ï¼‰ï¼Œå› æ­¤æ‚¨å¯ä»¥å°†è¿™äº›çŸ¥è¯†åº”ç”¨äºå…¶ä»–åœ°æ–¹ï¼</p><p>    A phantom type is a type parameter that appears on the left hand side of a type&#39;s definition but not on the right hand side. In other words, it&#39;s a type parameter that is never used by any of a type&#39;s constructors.</p><p>    å¹»åƒç±»å‹æ˜¯ä¸€ç§ç±»å‹å‚æ•°ï¼Œå®ƒæ˜¾ç¤ºåœ¨ç±»å‹å®šä¹‰çš„å·¦ä¾§ï¼Œä½†ä¸æ˜¾ç¤ºåœ¨å³ä¾§ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒæ˜¯ä¸€ä¸ªç±»å‹å‚æ•°ï¼Œä»»ä½•ç±»å‹çš„æ„é€ å‡½æ•°éƒ½ä¸ä¼šä½¿ç”¨å®ƒã€‚</p><p>  In the  Example type we have a type parameter,  phantom, that isn&#39;t used in the type&#39;s constructor. Phantom types can be used to provide additional safety or context to values without paying the runtime cost of carrying additional data around. Everything is handled at compile time!</p><p>  åœ¨Exampleç±»å‹ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªç±»å‹å‚æ•°phantomï¼Œå®ƒåœ¨ç±»å‹çš„æ„é€ å‡½æ•°ä¸­æœªä½¿ç”¨ã€‚å¹»åƒç±»å‹å¯ç”¨äºä¸ºå€¼æä¾›é¢å¤–çš„å®‰å…¨æ€§æˆ–ä¸Šä¸‹æ–‡ï¼Œè€Œæ— éœ€æ”¯ä»˜æºå¸¦é¢å¤–æ•°æ®çš„è¿è¡Œæ—¶æˆæœ¬ã€‚ä¸€åˆ‡éƒ½åœ¨ç¼–è¯‘æ—¶å¤„ç†ï¼</p><p> ğŸ’¡ In some languages, the compiler may emit a warning (or refuse to compile at all) when a type has unused type parameters. Often there are language-specific solutions to this, like  PhantomData in Rust or  impossible fields in TypeScript.</p><p> ğŸ’¡åœ¨æŸäº›è¯­è¨€ä¸­ï¼Œå½“ç±»å‹å…·æœ‰æœªä½¿ç”¨çš„ç±»å‹å‚æ•°æ—¶ï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šå‘å‡ºè­¦å‘Šï¼ˆæˆ–å®Œå…¨æ‹’ç»ç¼–è¯‘ï¼‰ã€‚é€šå¸¸ï¼Œæœ‰é’ˆå¯¹ç‰¹å®šè¯­è¨€çš„è§£å†³æ–¹æ¡ˆï¼Œä¾‹å¦‚Rustä¸­çš„PhantomDataæˆ–TypeScriptä¸­ä¸å¯èƒ½çš„å­—æ®µã€‚</p><p> The rest of this article will see us going over  four different scenarios where phantom types can come in to play. The whole article is a bit long so if any of the examples describes a scenario that fits you perfectly, feel free to jump straight to it!</p><p> æœ¬æ–‡çš„å…¶ä½™éƒ¨åˆ†å°†ä½¿æˆ‘ä»¬äº†è§£åˆ°å¹»åƒç±»å‹å¯ä»¥å‘æŒ¥ä½œç”¨çš„å››ç§ä¸åŒæƒ…å†µã€‚æ•´ç¯‡æ–‡ç« æœ‰ç‚¹é•¿ï¼Œå› æ­¤ï¼Œå¦‚æœæœ‰ä»»ä½•ç¤ºä¾‹æè¿°äº†ä¸€ä¸ªéå¸¸é€‚åˆæ‚¨çš„æ–¹æ¡ˆï¼Œè¯·ç›´æ¥è·³è½¬è‡³æ­¤ï¼</p><p>   To understand why phantom types might be useful, let&#39;s start with a common scenario. Imagine we&#39;re building a social blogging platform like  dev.to or  medium.com. We want to support different users and blog posts, so we assign a unique id to all of these things.</p><p>   ä¸ºäº†ç†è§£ä¸ºä»€ä¹ˆå¹»è±¡ç±»å‹å¯èƒ½æœ‰ç”¨ï¼Œè®©æˆ‘ä»¬ä»ä¸€ä¸ªå¸¸è§çš„åœºæ™¯å¼€å§‹ã€‚æƒ³è±¡æˆ‘ä»¬æ­£åœ¨å»ºç«‹ä¸€ä¸ªåƒdev.toæˆ–medium.comè¿™æ ·çš„ç¤¾äº¤åšå®¢å¹³å°ã€‚æˆ‘ä»¬å¸Œæœ›æ”¯æŒä¸åŒçš„ç”¨æˆ·å’Œåšå®¢æ–‡ç« ï¼Œå› æ­¤æˆ‘ä»¬ä¸ºæ‰€æœ‰è¿™äº›äº‹ç‰©åˆ†é…äº†å”¯ä¸€çš„IDã€‚</p><p> We&#39;re a scrappy, fast-moving startup so we implement the simplest possible system for managing IDs: just type aliasing  Ints to get things going.</p><p> æˆ‘ä»¬æ˜¯ä¸€å®¶è“¬å‹ƒå‘å±•çš„å¿«é€Ÿå‘å±•çš„å…¬å¸ï¼Œå› æ­¤æˆ‘ä»¬å®ç°äº†ç”¨äºç®¡ç†IDçš„æœ€ç®€å•çš„ç³»ç»Ÿï¼šåªéœ€é”®å…¥åˆ«åIntså³å¯ä½¿äº‹æƒ…é¡ºåˆ©è¿›è¡Œã€‚ </p><p> pub type Id = Intpub fn next (id: Id) -&gt; Id { id + 1}</p><p>pub type Id = Intpub fn nextï¼ˆidï¼šIdï¼‰-> ID {id + 1}</p><p> Our platform supports Reddit-style upvoting or liking of posts, and we have a function just for that. It takes in the  Id of a post to upvote and the  Id of the user that upvoted it, and does some magic to make the upvote happen.</p><p> æˆ‘ä»¬çš„å¹³å°æ”¯æŒReddité£æ ¼çš„å¸–å­ä¸Šè½½æˆ–å–œæ¬¢ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªä¸“é—¨çš„åŠŸèƒ½ã€‚å®ƒæ¥å—è¦æŠ•ç¥¨çš„å¸–å­çš„IDå’Œå¯¹å…¶è¿›è¡ŒæŠ•ç¥¨çš„ç”¨æˆ·çš„IDï¼Œå¹¶åšäº†ä¸€äº›é­”æœ¯ä½¿æŠ•ç¥¨å¾—ä»¥å®ç°ã€‚</p><p> pub fn upvote_post (user_id: Id, post_id: Id) -&gt; Nil { // Get a post from the database and upvote it. ...}</p><p> pub fn upvote_postï¼ˆç”¨æˆ·IDï¼šIdï¼Œpost_idï¼šIdï¼‰-ï¼†gt; Nil {//ä»æ•°æ®åº“ä¸­è·å–å¸–å­å¹¶å¯¹å…¶è¿›è¡ŒæŠ•ç¥¨ã€‚ ...}</p><p> This lets us rush to production, but maybe you&#39;ve already spotted a potential problem with what we have so far. It&#39;s only a matter of time until someone gets the parameters the wrong way round and now a totally unrelated user has upvoted a random post.</p><p> è¿™å¯ä»¥è®©æˆ‘ä»¬ç€æ€¥è¿›è¡Œç”Ÿäº§ï¼Œä½†æ˜¯åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‚¨å¯èƒ½å·²ç»å‘ç°æˆ‘ä»¬æ‰€æ‹¥æœ‰çš„æ½œåœ¨é—®é¢˜ã€‚ç›´åˆ°æœ‰äººä»¥é”™è¯¯çš„æ–¹å¼è·å–å‚æ•°ï¼Œè€Œç°åœ¨ä¸€ä¸ªå®Œå…¨ä¸ç›¸å…³çš„ç”¨æˆ·æ‰æŠ•ç¥¨æ”¯æŒä¸€ä¸ªéšæœºå¸–å­ï¼Œè¿™åªæ˜¯æ—¶é—´é—®é¢˜ã€‚</p><p> One solution would be to stop aliasing  Int and define new types for  PostId and  UserId instead.</p><p> ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯åœæ­¢ä¸ºIntåˆ«åï¼Œå¹¶æ”¹ä¸ºä¸ºPostIdå’ŒUserIdå®šä¹‰æ–°ç±»å‹ã€‚</p><p>  Now the two id types are successfully disjoint, but as a consequence we&#39;ll end up with a lot more duplicated code. We&#39;ll have to have separate  next methods to increment each id type, similarly if we want to unwrap the type we&#39;ll need separate  to_int functions, and the story is the same for  to_string, and so on...</p><p>  ç°åœ¨ï¼Œä¸¤ç§idç±»å‹å·²æˆåŠŸè„±èŠ‚ï¼Œä½†æ˜¯ç»“æœï¼Œæˆ‘ä»¬å°†å¾—åˆ°å¤§é‡é‡å¤çš„ä»£ç ã€‚æˆ‘ä»¬å¿…é¡»æœ‰å•ç‹¬çš„nextæ–¹æ³•æ¥å¢åŠ æ¯ä¸ªidç±»å‹ï¼Œç±»ä¼¼åœ°ï¼Œå¦‚æœæˆ‘ä»¬è¦è§£å¼€ç±»å‹ï¼Œæˆ‘ä»¬å°†éœ€è¦å•ç‹¬çš„to_intå‡½æ•°ï¼Œå¹¶ä¸”to_stringçš„æƒ…å†µä¹Ÿæ˜¯å¦‚æ­¤ï¼Œä¾æ­¤ç±»æ¨ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚</p><p> Really, the underlying representation of an  Id stays the same no matter how we use it. Instead, we&#39;d like the context an  Id is used in to determine whether it is valid or not.</p><p> å®é™…ä¸Šï¼Œæ— è®ºæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨ï¼ŒIdçš„åŸºç¡€è¡¨ç¤ºå½¢å¼éƒ½ä¿æŒä¸å˜ã€‚ç›¸åï¼Œæˆ‘ä»¬å–œæ¬¢ä½¿ç”¨IDæ¥ç¡®å®šå…¶æ˜¯å¦æœ‰æ•ˆçš„ä¸Šä¸‹æ–‡ã€‚ </p><p>  We&#39;ve now redefined our  Id type to include a type parameter,  a, but notice how that parameter isn&#39;t used in the type&#39;s constructor: this is where the name  phantom type comes from. The second thing to notice is that our  new function returns an id with that generic  a parameter. This lets  callers of the function determine what the type of  a should be.</p><p>ç°åœ¨ï¼Œæˆ‘ä»¬é‡æ–°å®šä¹‰äº†IDç±»å‹ï¼Œä»¥åŒ…æ‹¬ç±»å‹å‚æ•°aï¼Œä½†æ˜¯è¯·æ³¨æ„ï¼Œè¯¥å‚æ•°åœ¨ç±»å‹æ„é€ å‡½æ•°ä¸­çš„ä½¿ç”¨æ–¹å¼ï¼šè¿™æ˜¯åç§°phantom typeçš„æ¥æºã€‚æ³¨æ„çš„ç¬¬äºŒä»¶äº‹æ˜¯æˆ‘ä»¬çš„æ–°å‡½æ•°è¿”å›ä¸€ä¸ªå¸¦æœ‰è¯¥æ³›å‹å‚æ•°çš„idã€‚è¿™ä½¿å‡½æ•°çš„è°ƒç”¨è€…å¯ä»¥ç¡®å®šaçš„ç±»å‹ã€‚</p><p>  Now,  foo,  bar, and  baz are all incompatible with each other. We couldn&#39;t check them for equality, for example, because the types don&#39;t match up. Fundamental to phantom types is the fact that there is no runtime component,  foo may be annotated as  Id(String) but no such string exists at runtime, the same for  Id(Float) or any other parameter.</p><p>  ç°åœ¨ï¼Œfooï¼Œbarå’Œbazå½¼æ­¤ä¸å…¼å®¹ã€‚ä¾‹å¦‚ï¼Œå› ä¸ºç±»å‹ä¸åŒ¹é…ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•æ£€æŸ¥å®ƒä»¬æ˜¯å¦ç›¸ç­‰ã€‚å¹»åƒç±»å‹çš„åŸºç¡€æ˜¯æ²¡æœ‰è¿è¡Œæ—¶ç»„ä»¶çš„äº‹å®ï¼Œå¯ä»¥å°†fooæ³¨é‡Šä¸ºIdï¼ˆStringï¼‰ï¼Œä½†åœ¨è¿è¡Œæ—¶ä¸å­˜åœ¨è¿™æ ·çš„å­—ç¬¦ä¸²ï¼Œå¯¹äºIdï¼ˆFloatï¼‰æˆ–ä»»ä½•å…¶ä»–å‚æ•°ä¹Ÿæ˜¯å¦‚æ­¤ã€‚</p><p>  This is powerful because we gain the ability to tell the compiler a fact about a particular  Id, and the compiler will do extra work to ensure we don&#39;t make any mistakes.</p><p>  ä¹‹æ‰€ä»¥å¼ºå¤§ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨æœ‰å…³ç‰¹å®šIDçš„äº‹å®ï¼Œå¹¶ä¸”ç¼–è¯‘å™¨å°†åšé¢å¤–çš„å·¥ä½œä»¥ç¡®ä¿æˆ‘ä»¬ä¸ä¼šçŠ¯ä»»ä½•é”™è¯¯ã€‚</p><p> pub type User { User(id: Id(User), name: String)}pub type Post { Post(id: Id(Post), content: String)}pub fn upvote_post (user_id: Id(User), post_id: Id(Post)) -&gt; Nil { // Get a post from the database and upvote it. ...}</p><p> pubç±»å‹User {Userï¼ˆç”¨æˆ·ï¼ˆidï¼šIdï¼ˆUserï¼‰ï¼Œåç§°ï¼šå­—ç¬¦ä¸²ï¼‰}} pubç±»å‹Post {Postï¼ˆidï¼šIdï¼ˆPostï¼‰ï¼Œå†…å®¹ï¼šStringï¼‰} pub fn upvote_postï¼ˆuser_idï¼šIdï¼ˆUserï¼‰ï¼Œpost_idï¼šId ï¼ˆå‘å¸ƒï¼‰ï¼‰-ï¼†gt; Nil {//ä»æ•°æ®åº“ä¸­è·å–å¸–å­å¹¶å¯¹å…¶è¿›è¡ŒæŠ•ç¥¨ã€‚ ...}</p><p> In the snippet above, we&#39;ve defined  User and  Post types and parameterised the  Id type accordingly. Knowing what we know so far about phantom types, we can see that the new type signature for  upvote_post will prevent us from accidentally swapping the order of the ids.</p><p> åœ¨ä¸Šé¢çš„ä»£ç æ®µä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ç”¨æˆ·å’Œå¸–å­ç±»å‹ï¼Œå¹¶ç›¸åº”åœ°è®¾ç½®äº†IDç±»å‹ã€‚äº†è§£åˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬å¯¹å¹»å½±ç±»å‹çš„äº†è§£ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°upvote_postçš„æ–°ç±»å‹ç­¾åå°†é˜²æ­¢æˆ‘ä»¬æ„å¤–åœ°äº¤æ¢IDçš„é¡ºåºã€‚</p><p> let user = User(id: new(), name: &#34;pd-andy&#34;)let post = Post(id: new(), content: &#34;Phantom Types in Gleam...&#34;)upvote_post(post.id, user.id) // Uh oh, compile error!</p><p> let user = Userï¼ˆidï¼šnewï¼ˆï¼‰ï¼Œåç§°ï¼šï¼†ï¼ƒ34; pd-andyï¼†ï¼ƒ34;ï¼‰let post = Postï¼ˆidï¼šnewï¼ˆï¼‰ï¼Œå†…å®¹ï¼šï¼†ï¼ƒ34; Gleamä¸­çš„å¹»åƒç±»å‹...ï¼†ï¼ƒ 34;ï¼‰upvote_postï¼ˆpost.idï¼Œuser.idï¼‰//å“¦ï¼Œç¼–è¯‘é”™è¯¯ï¼</p><p> Even though our phantom type lets us specialise the  Id type, we can still write functions that work on  all ids by leaving the type parameter as a variable.</p><p> å³ä½¿æˆ‘ä»¬çš„å¹»åƒç±»å‹ä½¿æˆ‘ä»¬å¯ä»¥ä¸“é—¨ä½¿ç”¨Idç±»å‹ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥é€šè¿‡å°†typeå‚æ•°ä¿ç•™ä¸ºå˜é‡æ¥ç¼–å†™é€‚ç”¨äºæ‰€æœ‰idçš„å‡½æ•°ã€‚ </p><p>  The ability to restrict or open up functions to different  Ids is where a lot of the power with phantom types comes from.</p><p>é™åˆ¶æˆ–å¼€æ”¾åŠŸèƒ½ä»¥ä½¿ç”¨ä¸åŒIDçš„èƒ½åŠ›æ˜¯å¹»åƒç±»å‹å¼ºå¤§åŠŸèƒ½çš„æ¥æºã€‚</p><p>  Let&#39;s consider another scenario. We want to build an application that can handle monetary transactions such that we can easily work with currencies of the same type, but different currencies must be explicitly converted via an exchange rate before they can be used together.</p><p>  è®©æˆ‘ä»¬è€ƒè™‘å¦ä¸€ç§æƒ…å†µã€‚æˆ‘ä»¬å¸Œæœ›æ„å»ºä¸€ä¸ªå¯ä»¥å¤„ç†è´§å¸äº¤æ˜“çš„åº”ç”¨ç¨‹åºï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥è½»æ¾ä½¿ç”¨ç›¸åŒç±»å‹çš„è´§å¸ï¼Œä½†æ˜¯å¿…é¡»å…ˆé€šè¿‡æ±‡ç‡æ˜ç¡®è½¬æ¢ä¸åŒçš„è´§å¸ï¼Œç„¶åæ‰èƒ½ä¸€èµ·ä½¿ç”¨å®ƒä»¬ã€‚</p><p> Similar to our id scenario, the underlying representation for a value of currency is always the same.</p><p> ç±»ä¼¼äºæˆ‘ä»¬çš„idæ–¹æ¡ˆï¼Œè´§å¸å€¼çš„åŸºæœ¬è¡¨ç¤ºå½¢å¼å§‹ç»ˆç›¸åŒã€‚</p><p>  As before, our  Currency type has a single type parameter that we&#39;ll use to  tag values with a particular type of currency. We also need to define some types to act as our currency tags. Because these types are only used for annotations, we&#39;ll make them opaque.</p><p>  å’Œä»¥å‰ä¸€æ ·ï¼Œæˆ‘ä»¬çš„Currencyç±»å‹åªæœ‰ä¸€ä¸ªç±»å‹å‚æ•°ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å®ƒæ¥æ ‡è®°å…·æœ‰ç‰¹å®šè´§å¸ç±»å‹çš„å€¼ã€‚æˆ‘ä»¬è¿˜éœ€è¦å®šä¹‰ä¸€äº›ç±»å‹æ¥å……å½“æˆ‘ä»¬çš„è´§å¸æ ‡ç­¾ã€‚ç”±äºè¿™äº›ç±»å‹ä»…ç”¨äºæ³¨é‡Šï¼Œå› æ­¤æˆ‘ä»¬å°†å…¶è®¾ä¸ºä¸é€æ˜ã€‚</p><p>    Right now we have some currency values, but we can&#39;t do a whole lot with them. While they&#39;re wrapped up in our  Currency type, we can&#39;t use any arithmetic operators or pass these values to functions expecting  Floats.</p><p>    ç›®å‰ï¼Œæˆ‘ä»¬æœ‰ä¸€äº›è´§å¸ä»·å€¼ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸èƒ½å¯¹å®ƒä»¬åšå¾ˆå¤šäº‹æƒ…ã€‚å½“å®ƒä»¬è¢«åŒ…è£…æˆæˆ‘ä»¬çš„Currencyç±»å‹æ—¶ï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ä»»ä½•ç®—æœ¯è¿ç®—ç¬¦æˆ–å°†è¿™äº›å€¼ä¼ é€’ç»™éœ€è¦Floatsçš„å‡½æ•°ã€‚</p><p> Let&#39;s remedy that by writing two functions,  update and  combine. We&#39;ll use  update to apply a function to the value wrapped by a  Currency, and we&#39;ll use  combine to apply a function to two  Currency values.</p><p> è®©æˆ‘ä»¬è¡¥æ•‘ä¸€ä¸‹ï¼Œé€šè¿‡ç¼–å†™ä¸¤ä¸ªå‡½æ•°è¿›è¡Œæ›´æ–°å’Œåˆå¹¶ã€‚æˆ‘ä»¬å°†ä½¿ç”¨updateå°†åŠŸèƒ½åº”ç”¨äºç”±Currencyæ¢è¡Œçš„å€¼ï¼Œè€Œæˆ‘ä»¬å°†ä½¿ç”¨Combineå°†åŠŸèƒ½åº”ç”¨äºä¸¤ä¸ªCurrencyå€¼ã€‚</p><p> ğŸ’¡ For other data structures these functions might be called  map and  map2. These imply the type can change, for example  list.map can be used to turn a  List(a) into a  List(b).</p><p> ğŸ’¡å¯¹äºå…¶ä»–æ•°æ®ç»“æ„ï¼Œè¿™äº›åŠŸèƒ½å¯èƒ½ç§°ä¸ºmapå’Œmap2ã€‚è¿™äº›æ„å‘³ç€ç±»å‹å¯ä»¥æ›´æ”¹ï¼Œä¾‹å¦‚list.mapå¯ç”¨äºå°†Listï¼ˆaï¼‰è½¬æ¢ä¸ºListï¼ˆbï¼‰ã€‚ </p><p> Because we want to preserve the type (so we can&#39;t convert  Currency(USD) to  Currency(GBP)) we give these functions different names so there aren&#39;t any mismatched expectations.</p><p>å› ä¸ºæˆ‘ä»¬è¦ä¿ç•™ç±»å‹ï¼ˆå› æ­¤æˆ‘ä»¬ä¸èƒ½å°†Currencyï¼ˆUSDï¼‰è½¬æ¢ä¸ºCurrencyï¼ˆGBPï¼‰ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ºè¿™äº›å‡½æ•°æŒ‡å®šäº†ä¸åŒçš„åç§°ï¼Œå› æ­¤ä¸ä¼šå‡ºç°ä»»ä½•ä¸åŒ¹é…çš„æœŸæœ›ã€‚</p><p> pub fn update (a: Currency(a), f: fn (Float) -&gt; Float) -&gt; Currency(a) { let Currency(x) = a x |&gt; f |&gt; from_float}pub fn combine (a: Currency(a), b: Currency(a), f: fn (Float, Float) -&gt; Float) -&gt; Currency(a) { let Currency(x) = a let Currency(y) = b f(x, y) |&gt; from_float}</p><p> pub fn updateï¼ˆaï¼šCurrencyï¼ˆaï¼‰ï¼Œfï¼šfnï¼ˆFloatï¼‰-> Floatï¼‰-> Currencyï¼ˆaï¼‰{è®©Currencyï¼ˆxï¼‰= a x |ï¼†gt; f |ï¼†gt; from_float} pub fn Combineï¼ˆaï¼šCurrencyï¼ˆaï¼‰ï¼Œbï¼šCurrencyï¼ˆaï¼‰ï¼Œfï¼šfnï¼ˆFloatï¼ŒFloatï¼‰-> Floatï¼‰->ï¼›è´§å¸ï¼ˆaï¼‰{ä»¤è´§å¸ï¼ˆxï¼‰=ä»¤è´§å¸ï¼ˆyï¼‰= b fï¼ˆxï¼Œyï¼‰|ï¼†gt; from_float}</p><p> Because the type parameter for  Currency doesn&#39;t change (these function take a  Currency(a) and return a  Currency(a)), they can&#39;t change the tag of any currency passed in.</p><p> å› ä¸ºCurrencyçš„ç±»å‹å‚æ•°ä¸å˜ï¼ˆè¿™äº›å‡½æ•°é‡‡ç”¨Currencyï¼ˆaï¼‰å¹¶è¿”å›Currencyï¼ˆaï¼‰ï¼‰ï¼Œæ‰€ä»¥å®ƒä»¬ä¸èƒ½æ›´æ”¹ä¼ å…¥çš„ä»»ä½•è´§å¸çš„æ ‡è®°ã€‚</p><p> ğŸ’¡ Both  update and  combine are examples of  higher-order functions. That is, they are functions that take  other functions as one of their arguments (or return a new function themselves).</p><p> updateæ›´æ–°å’Œåˆå¹¶éƒ½æ˜¯é«˜é˜¶å‡½æ•°çš„ç¤ºä¾‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬æ˜¯å°†å…¶ä»–å‡½æ•°ä½œä¸ºå…¶å‚æ•°ä¹‹ä¸€çš„å‡½æ•°ï¼ˆæˆ–è‡ªå·±è¿”å›ä¸€ä¸ªæ–°å‡½æ•°ï¼‰ã€‚</p><p> We can use these two functions to define some more functions so we can actually  do things with currency values, like doubling something or adding two currencies together.</p><p> æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™ä¸¤ä¸ªå‡½æ•°æ¥å®šä¹‰æ›´å¤šçš„å‡½æ•°ï¼Œä»¥ä¾¿å®é™…ä¸Šå¯ä»¥ä½¿ç”¨è´§å¸å€¼æ¥è¿›è¡Œæ“ä½œï¼Œä¾‹å¦‚å°†å†…å®¹åŠ å€æˆ–å°†ä¸¤ç§è´§å¸åŠ åœ¨ä¸€èµ·ã€‚</p><p> pub fn double (a: Currency(a)) -&gt; Currency(a) { update(a, fn (x) { x * 2 })}pub fn add (a: Currency(a), b: Currency(a)) -&gt; Currency(a) { combine(a, b, fn (x, y) { x + y })}</p><p> pub fn doubleï¼ˆaï¼šCurrencyï¼ˆaï¼‰ï¼‰-> Currencyï¼ˆaï¼‰{updateï¼ˆaï¼Œfnï¼ˆxï¼‰{x * 2}ï¼‰} pub fn addï¼ˆaï¼šCurrencyï¼ˆaï¼‰ï¼Œbï¼šCurrencyï¼ˆaï¼‰ï¼‰-ï¼†gt;è´§å¸ï¼ˆaï¼‰{ç»„åˆï¼ˆaï¼Œbï¼Œfnï¼ˆxï¼Œyï¼‰{x + y}}}}</p><p> We can call these functions with any type of currency, but for something like  add we get compile-time safety that ensures we only add two currencies of the same type.</p><p> æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»»ä½•ä¸€ç§è´§å¸æ¥è°ƒç”¨è¿™äº›å‡½æ•°ï¼Œä½†æ˜¯å¯¹äºè¯¸å¦‚addä¹‹ç±»çš„ä¸œè¥¿ï¼Œæˆ‘ä»¬å°†è·å¾—ç¼–è¯‘æ—¶å®‰å…¨æ€§ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬ä»…æ·»åŠ ä¸¤ç§ç›¸åŒç±»å‹çš„è´§å¸ã€‚ </p><p>  But what if we  want to add two currencies together? To do that we need a way of converting one currency to another with an exchange rate. We can use phantom types again here to define an</p><p>ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æƒ³å°†ä¸¤ç§è´§å¸åŠ åœ¨ä¸€èµ·æ€ä¹ˆåŠï¼Ÿä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§ä»¥æ±‡ç‡å°†ä¸€ç§è´§å¸è½¬æ¢ä¸ºå¦ä¸€ç§è´§å¸çš„æ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œå†æ¬¡ä½¿ç”¨å¹»åƒç±»å‹æ¥å®šä¹‰</p><p>  pub opaque type Exchange (from, to) { Exchange(Float)}pub fn exchange_rate (r: Float) -&gt; Exchange(from, to) { Exchange(r)}</p><p>  pubä¸é€æ˜ç±»å‹Exchangeï¼ˆä»ï¼Œåˆ°ï¼‰{Exchangeï¼ˆFloatï¼‰} pub fn exchange_rateï¼ˆrï¼šFloatï¼‰->äº¤æ¢ï¼ˆä»ï¼Œåˆ°ï¼‰{äº¤æ¢ï¼ˆrï¼‰}</p><p> Now, just like we did for currencies, we can define an exchange rate to go from  GBP to  USD (and vice versa).</p><p> ç°åœ¨ï¼Œå°±åƒæˆ‘ä»¬å¯¹è´§å¸æ‰€åšçš„ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ±‡ç‡å®šä¹‰ä¸ºä»GBPåˆ°USDï¼ˆåä¹‹äº¦ç„¶ï¼‰ã€‚</p><p>  Using everything we know about phantom types, we can define a  convert function that is type safe; we&#39;ll never be able to pass in the wrong exchange rate because all the phantom types have to match up!</p><p>  ä½¿ç”¨æˆ‘ä»¬å¯¹å¹»åƒç±»å‹çš„æ‰€æœ‰äº†è§£ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªç±»å‹å®‰å…¨çš„convertå‡½æ•°ï¼›æˆ‘ä»¬å°†æ°¸è¿œæ— æ³•ä¼ é€’é”™è¯¯çš„æ±‡ç‡ï¼Œå› ä¸ºæ‰€æœ‰å¹»åƒç±»å‹éƒ½å¿…é¡»åŒ¹é…ï¼</p><p> pub fn convert (a: Currency(from), e: Exchange(from, to)) -&gt; Currency(to) { let Currency(x) = a let Exchange(r) = e x *. r |&gt; from_float}</p><p> pub fn convertï¼ˆaï¼šCurrencyï¼ˆfromï¼‰ï¼Œeï¼šExchangeï¼ˆfromï¼Œtoï¼‰ï¼‰-ï¼†gt; Currencyï¼ˆtoï¼‰{let Currencyï¼ˆxï¼‰= let Exchangeï¼ˆrï¼‰= e x *ã€‚ r |ï¼†gt; from_float}</p><p> Although our module provided the  USD and  GBP types to act as currency tags, the functions we&#39;ve written are general to all currencies but retain their type safety. If consumers of the module want to define another type of currency, they can do that and our functions will still work.</p><p> å°½ç®¡æˆ‘ä»¬çš„æ¨¡å—æä¾›äº†å……å½“è´§å¸æ ‡ç­¾çš„USDå’ŒGBPç±»å‹ï¼Œä½†æ˜¯æˆ‘ä»¬ç¼–å†™çš„åŠŸèƒ½æ˜¯æ‰€æœ‰è´§å¸é€šç”¨çš„ï¼Œä½†ä¿ç•™å…¶ç±»å‹å®‰å…¨æ€§ã€‚å¦‚æœè¯¥æ¨¡å—çš„ä½¿ç”¨è€…æƒ³è¦å®šä¹‰å¦ä¸€ç§è´§å¸ï¼Œåˆ™å¯ä»¥è¿™æ ·åšï¼Œå¹¶ä¸”æˆ‘ä»¬çš„åŠŸèƒ½ä»å°†èµ·ä½œç”¨ã€‚</p><p>   So far the two examples we have seen in  Id and  Currency have been used to provide a general API across types that share the same underlying representation. Callers have been able to assert to the compiler what the type of something is simply by providing a type annotation. In doing so, the compiler will stop two disjoint values being used in the wrong places.</p><p>   åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»åœ¨Idå’ŒCurrencyä¸­çœ‹åˆ°çš„ä¸¤ä¸ªç¤ºä¾‹å·²ç”¨äºä¸ºå…±äº«ç›¸åŒåŸºç¡€è¡¨ç¤ºå½¢å¼çš„ç±»å‹æä¾›é€šç”¨APIã€‚è°ƒç”¨è€…å·²ç»èƒ½å¤Ÿé€šè¿‡æä¾›ç±»å‹æ³¨é‡Šç®€å•åœ°å‘ç¼–è¯‘å™¨æ–­è¨€æŸç§äº‹ç‰©çš„ç±»å‹ã€‚è¿™æ ·ï¼Œç¼–è¯‘å™¨å°†åœæ­¢åœ¨é”™è¯¯çš„ä½ç½®ä½¿ç”¨ä¸¤ä¸ªä¸ç›¸äº¤çš„å€¼ã€‚ </p><p> But we can use phantom types for the opposite purpose, to  restrict the type of values consumers can create and push them through our validation code.</p><p>ä½†æ˜¯æˆ‘ä»¬å¯ä»¥å°†å¹»åƒç±»å‹ç”¨äºç›¸åçš„ç›®çš„ï¼Œä»¥é™åˆ¶æ¶ˆè´¹è€…å¯ä»¥åˆ›å»ºçš„å€¼çš„ç±»å‹ï¼Œå¹¶é€šè¿‡æˆ‘ä»¬çš„éªŒè¯ä»£ç æ¥æ¨é€å®ƒä»¬ã€‚</p><p> pub opaque type Password(unvalidated) { Password(String)}pub opaque type Invalid { Invalid }pub opaque type Valid { Valid }pub fn from_string (s: String) -&gt; Password(Invalid) { Password(s)}</p><p> pub opaqueç±»å‹å¯†ç ï¼ˆæœªéªŒè¯ï¼‰{å¯†ç ï¼ˆå­—ç¬¦ä¸²ï¼‰} pub opaqueç±»å‹æ— æ•ˆ{æ— æ•ˆ} pub opaqueç±»å‹æœ‰æ•ˆ{Valid} pub fn from_stringï¼ˆsï¼šStringï¼‰-ï¼†gt;å¯†ç ï¼ˆæ— æ•ˆï¼‰{å¯†ç }</p><p> Unlike the previous examples, the  from_string function here returns a  Password(Invalid) rather than a general type that the caller can assert manually. This is another powerful aspect of phantom types. The  Password type is opaque in this example, so consumers of this module  must go through the  from_string function if they want to create passwords.</p><p> ä¸å‰é¢çš„ç¤ºä¾‹ä¸åŒï¼Œè¿™é‡Œçš„from_stringå‡½æ•°è¿”å›ä¸€ä¸ªPasswordï¼ˆInvalidï¼‰è€Œä¸æ˜¯è°ƒç”¨è€…å¯ä»¥æ‰‹åŠ¨æ–­è¨€çš„å¸¸è§„ç±»å‹ã€‚è¿™æ˜¯å¹»åƒç±»å‹çš„å¦ä¸€ä¸ªå¼ºå¤§æ–¹é¢ã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œå¯†ç ç±»å‹æ˜¯ä¸é€æ˜çš„ï¼Œå› æ­¤ï¼Œå¦‚æœè¯¥æ¨¡å—çš„ä½¿ç”¨è€…æƒ³è¦åˆ›å»ºå¯†ç ï¼Œåˆ™å¿…é¡»é€šè¿‡from_stringå‡½æ•°ã€‚</p><p> In doing so, they will have created an invalid password. We can design the rest of our API around this fact, writing functions that work on only  Valid passwords and pushing users through our validation logic.</p><p> è¿™æ ·ï¼Œä»–ä»¬å°†åˆ›å»ºä¸€ä¸ªæ— æ•ˆçš„å¯†ç ã€‚æˆ‘ä»¬å¯ä»¥å›´ç»•è¿™ä¸ªäº‹å®è®¾è®¡å…¶ä½™çš„APIï¼Œç¼–å†™ä»…å¯¹æœ‰æ•ˆå¯†ç æœ‰æ•ˆçš„å‡½æ•°ï¼Œå¹¶é€šè¿‡éªŒè¯é€»è¾‘æ¥â€‹â€‹æ¨åŠ¨ç”¨æˆ·ã€‚</p><p> pub fn validate (p: Password(a)) -&gt; Result(Password(Valid), Password(Invalid)) { let Password(s) = p case is_valid(s) { True -&gt; Ok(p) False -&gt; Error(p) }}</p><p> pub fn validateï¼ˆpï¼šPasswordï¼ˆaï¼‰ï¼‰-ï¼†gt;ç»“æœï¼ˆå¯†ç ï¼ˆæœ‰æ•ˆï¼‰ï¼Œå¯†ç ï¼ˆæ— æ•ˆï¼‰ï¼‰{è®©å¯†ç = på¤§å°å†™is_valid {True-ï¼†gt; Okï¼ˆpï¼‰é”™è¯¯->é”™è¯¯ï¼ˆpï¼‰}}</p><p> We could end up with an API that makes use of  Invalid,  Valid, or  any passwords that has functions like:</p><p> æˆ‘ä»¬å¯ä»¥æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªä½¿ç”¨Invalidï¼ŒValidæˆ–å…·æœ‰ä»¥ä¸‹åŠŸèƒ½çš„å¯†ç çš„APIï¼š</p><p> pub fn create_account (p: Password(Valid), email: String) -&gt; Userpub fn suggest_better (p: Password(Invalid)) -&gt; Stringpub fn to_string (p: Password(any)) -&gt; String</p><p> pub fn create_accountï¼ˆpï¼šå¯†ç ï¼ˆæœ‰æ•ˆï¼‰ï¼Œç”µå­é‚®ä»¶ï¼šå­—ç¬¦ä¸²ï¼‰-ï¼†gt; Userpub fn proposal_betterï¼ˆpï¼šå¯†ç ï¼ˆæ— æ•ˆï¼‰ï¼‰-ï¼†gt; Stringpub fn to_stringï¼ˆpï¼šå¯†ç ï¼ˆä»»æ„ï¼‰ï¼‰-ï¼†gt;ç»†ç»³ </p><p> In the real world you probably won&#39;t be handling passwords like this (right... right?) but the idea transfers to any sort of data you might want to validate.</p><p>åœ¨ç°å®ä¸–ç•Œä¸­ï¼Œæ‚¨å¯èƒ½ä¸ä¼šåƒè¿™æ ·å¤„ç†å¯†ç ï¼ˆå¯¹å—ï¼Ÿå¯¹å—ï¼Ÿï¼‰ï¼Œä½†æ˜¯è¿™ç§æƒ³æ³•ä¼šè½¬ç§»åˆ°æ‚¨å¯èƒ½è¦éªŒè¯çš„ä»»ä½•ç±»å‹çš„æ•°æ®ä¸Šã€‚</p><p>   A recent discussion cropped up on the Gleam Discord server (which you should totally  join if you haven&#39;t already) where a user was attempting to write a wrapper around an existing Erlang library that potentially threw various errors from different functions.</p><p>   æœ€è¿‘çš„è®¨è®ºå‡ºç°åœ¨Gleam DiscordæœåŠ¡å™¨ä¸Šï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼Œåº”è¯¥å®Œå…¨åŠ å…¥ï¼‰ï¼Œåœ¨è¯¥æœåŠ¡å™¨ä¸Šï¼Œç”¨æˆ·è¯•å›¾å›´ç»•ç°æœ‰çš„Erlangåº“ç¼–å†™åŒ…è£…ï¼Œè¿™å¯èƒ½ä¼šå¼•å‘æ¥è‡ªä¸åŒåŠŸèƒ½çš„å„ç§é”™è¯¯ã€‚</p><p> In Gleam, these error-throwing functions are typically modelled with the  Result type and a specific  Error type that describes all the possible reasons that function could have failed. A problem arose when two functions â€“  accept and  listen â€“ could throw different errors, but one error was shared between them both.</p><p> åœ¨Gleamä¸­ï¼Œé€šå¸¸ä½¿ç”¨Resultç±»å‹å’Œç‰¹å®šçš„Errorç±»å‹å¯¹è¿™äº›å¼•å‘é”™è¯¯çš„å‡½æ•°è¿›è¡Œå»ºæ¨¡ï¼Œè¯¥é”™è¯¯ç±»å‹æè¿°äº†è¯¥å‡½æ•°å¯èƒ½å¤±è´¥çš„æ‰€æœ‰å¯èƒ½åŸå› ã€‚å½“ä¸¤ä¸ªå‡½æ•°ï¼ˆæ¥å—å’Œä¾¦å¬ï¼‰å¯èƒ½å¼•å‘ä¸åŒçš„é”™è¯¯ï¼Œä½†åœ¨ä¸¤è€…ä¹‹é—´å…±äº«äº†ä¸€ä¸ªé”™è¯¯æ—¶ï¼Œå‡ºç°äº†é—®é¢˜ã€‚</p><p>  pub type AcceptError = { SystemLimit Closed Timeout Posix(inet.Posix)}pub type ListenError = { SystemLimit Posix(inet.Posix)}</p><p>  pubç±»å‹AcceptError = {SystemLimitå…³é—­è¶…æ—¶Posixï¼ˆinet.Posixï¼‰} pubç±»å‹listenError = {SystemLimit Posixï¼ˆinet.Posixï¼‰}</p><p> It&#39;s not possible for different types in the same module to have variants that share the same name (otherwise how would the compiler know what  SystemLimit meant!) so we need to approach the problem differently. We have a few options:</p><p> åŒä¸€æ¨¡å—ä¸­çš„ä¸åŒç±»å‹ä¸å¯èƒ½å…·æœ‰ç›¸åŒçš„åç§°ï¼ˆå¦åˆ™ï¼Œç¼–è¯‘å™¨å°†å¦‚ä½•çŸ¥é“SystemLimitçš„å«ä¹‰ï¼ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä»¥ä¸åŒçš„æ–¹å¼è§£å†³è¯¥é—®é¢˜ã€‚æˆ‘ä»¬æœ‰å‡ ç§é€‰æ‹©ï¼š</p><p> Rename all the constructors with an  Accept or  Listen prefix to disambiguate them. We&#39;d end up with constructors  AcceptSystemLimit and  ListenSystemLimit which would certainly satisfy the compiler but feels a bit redundant. It also potentially confuses or un-focuses the API.</p><p> å°†æ‰€æœ‰æ„é€ å‡½æ•°é‡å‘½åä¸ºAcceptæˆ–Listenå‰ç¼€ä»¥æ¶ˆé™¤å®ƒä»¬çš„æ­§ä¹‰ã€‚æˆ‘ä»¬æœ€ç»ˆå¾—åˆ°äº†æ„é€ å‡½æ•°AcceptSystemLimitå’ŒListenSystemLimitï¼Œå®ƒä»¬è‚¯å®šä¼šè®©ç¼–è¯‘å™¨æ»¡æ„ï¼Œä½†æ„Ÿè§‰æœ‰äº›å¤šä½™ã€‚å®ƒè¿˜å¯èƒ½ä½¿APIæ··ä¹±æˆ–å¤±å»é‡ç‚¹ã€‚</p><p> Create separate modules for both of these functions, which would avoid the type constructors from clashing with one-another. Doing so, however, makes our API more difficult to consume and may complicate things further if types or other functions need to be shared.</p><p> ä¸ºè¿™ä¸¤ä¸ªå‡½æ•°åˆ›å»ºå•ç‹¬çš„æ¨¡å—ï¼Œè¿™å°†é¿å…ç±»å‹æ„é€ å‡½æ•°å½¼æ­¤å†²çªã€‚ä½†æ˜¯ï¼Œè¿™æ ·åšä¼šä½¿æˆ‘ä»¬çš„APIæ›´åŠ éš¾ä»¥ä½¿ç”¨ï¼Œå¹¶ä¸”å¦‚æœéœ€è¦å…±äº«ç±»å‹æˆ–å…¶ä»–åŠŸèƒ½ï¼Œå¯èƒ½ä¼šä½¿äº‹æƒ…æ›´åŠ å¤æ‚ã€‚ </p><p> Abandon function-specific types and instead create a single  Error type for the entire module/API. We lose the ability to express function-specific errors, but we have gained simplicity and a way of sharing error types between functions.</p><p>æ”¾å¼ƒç‰¹å®šäºå‡½æ•°çš„ç±»å‹ï¼Œè€Œæ˜¯ä¸ºæ•´ä¸ªæ¨¡å—/ APIåˆ›å»ºå•ä¸ªé”™è¯¯ç±»å‹ã€‚æˆ‘ä»¬å¤±å»äº†è¡¨è¾¾ç‰¹å®šäºå‡½æ•°çš„é”™è¯¯çš„èƒ½åŠ›ï¼Œä½†æ˜¯æˆ‘ä»¬å·²ç»è·å¾—äº†ç®€å•æ€§ä»¥åŠåœ¨å‡½æ•°ä¹‹é—´å…±äº«é”™è¯¯ç±»å‹çš„æ–¹å¼ã€‚</p><p> If we apply what we now know about phantom types, we could expand this third option to include a phantom type that acts as a hint for what function an error came from.</p><p> å¦‚æœåº”ç”¨æˆ‘ä»¬ç°åœ¨å¯¹å¹»å½±ç±»å‹çš„äº†è§£ï¼Œåˆ™å¯ä»¥æ‰©å±•ç¬¬ä¸‰ä¸ªé€‰é¡¹ï¼Œä»¥åŒ…å«ä¸€ä¸ªå¹»å½±ç±»å‹ï¼Œè¯¥ç±»å‹å¯ä»¥æç¤ºé”™è¯¯æ¥è‡ªä½•åŠŸèƒ½ã€‚</p><p> pub type Error(from) { SystemLimit Closed Timeout Posix(inet.Posix)}pub opaque type AcceptFn { AcceptFn }pub opaque type ListenFn { ListenFn }pub fn accept (...) -&gt; Error(AcceptFn) { ...}pub fn listen (...) -&gt; Error(ListenFn) { ...}</p><p> pubç±»å‹é”™è¯¯ï¼ˆæ¥è‡ªï¼‰{SystemLimitå…³é—­è¶…æ—¶Posixï¼ˆinet.Posixï¼‰} pubä¸é€æ˜ç±»å‹AcceptFn {AcceptFn} pubä¸é€æ˜ç±»å‹ListenFn {ListenFn} pub fn acceptï¼ˆ...ï¼‰-ï¼†gt; Errorï¼ˆAcceptFnï¼‰{...} pub fn listenï¼ˆ...ï¼‰-ï¼†gt;é”™è¯¯ï¼ˆListenFnï¼‰{...}</p><p> While this approach doesn&#39;t give us any additional safety, it does provide a  context clue for developers consuming this function. When handling errors thrown by  listen, they know they can safely ignore the  Closed and  Timeout errors and focus only on the relevant ones.</p><p> å°½ç®¡æ­¤æ–¹æ³•ä¸ä¼šç»™æˆ‘ä»¬å¸¦æ¥ä»»ä½•é¢å¤–çš„å®‰å…¨æ€§ï¼Œä½†ç¡®å®ä¸ºä½¿ç”¨æ­¤åŠŸèƒ½çš„å¼€å‘äººå‘˜æä¾›äº†ä¸Šä¸‹æ–‡çº¿ç´¢ã€‚å½“å¤„ç†ç”±ç›‘å¬å¼•å‘çš„é”™è¯¯æ—¶ï¼Œä»–ä»¬çŸ¥é“ä»–ä»¬å¯ä»¥å®‰å…¨åœ°å¿½ç•¥Closedå’ŒTimeouté”™è¯¯ï¼Œè€Œåªå…³æ³¨ç›¸å…³çš„é”™è¯¯ã€‚</p><p> ğŸ’¡ In languages with even fancier type systems, we could make use of something called a  [generalised algebraic data type (GADT) ]( en.wikibooks.org/wiki/Haskell/GADT)**to achieve the same thing but with type safety to boot!</p><p> ğŸ’¡åœ¨ç±»å‹ç³»ç»Ÿç”šè‡³æ›´é«˜çº§çš„è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§ç§°ä¸º[ä¸€èˆ¬ä»£æ•°æ•°æ®ç±»å‹ï¼ˆGADTï¼‰]çš„ä¸œè¥¿ï¼ˆen.wikibooks.org/wiki/Haskell/GADT)**ä»¥å®ç°ç›¸åŒçš„ç›®çš„ä½†å…·æœ‰ç±»å‹å®‰å…¨æ€§å¼€æœºï¼</p><p> In fact, GADTs are also known as   first-class phantom types. Gleam doesn&#39;t support them, and it&#39;s unclear if it ever will, but if you&#39;re interested in this sort of thing you might want to check out OCaml or Haskell.</p><p> å®é™…ä¸Šï¼ŒGADTä¹Ÿè¢«ç§°ä¸ºä¸€æµçš„å¹»åƒç±»å‹ã€‚ Gleamä¸æ”¯æŒå®ƒä»¬ï¼Œç›®å‰å°šä¸æ¸…æ¥šå®ƒæ˜¯å¦ä¼šæ”¯æŒï¼Œä½†æ˜¯å¦‚æœæ‚¨å¯¹è¿™ç§äº‹æƒ…æ„Ÿå…´è¶£ï¼Œæ‚¨å¯èƒ½éœ€è¦æŸ¥çœ‹OCamlæˆ–Haskellã€‚</p><p> Providing context clues via phantom types may not always be the best design decision, but sometimes it can strike the right balance between simplicity and expressive power.</p><p> é€šè¿‡å¹»åƒç±»å‹æä¾›ä¸Šä¸‹æ–‡çº¿ç´¢å¯èƒ½å¹¶ä¸æ€»æ˜¯æœ€ä½³çš„è®¾è®¡å†³ç­–ï¼Œä½†æœ‰æ—¶å®ƒå¯ä»¥åœ¨ç®€å•æ€§å’Œè¡¨è¾¾èƒ½åŠ›ä¹‹é—´æ‰¾åˆ°é€‚å½“çš„å¹³è¡¡ã€‚ </p><p>   At this point you might be itching to apply phantom types to all your code and cash in on additional compile-time safety, but there is one major caveat to using phantom types in your code.</p><p>åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæ‚¨å¯èƒ½æƒ³å°†å¹»å½±ç±»å‹åº”ç”¨äºæ‰€æœ‰ä»£ç å¹¶ä»ä¸­è·å¾—é¢å¤–çš„ç¼–è¯‘æ—¶å®‰å…¨æ€§ï¼Œä½†æ˜¯åœ¨ä»£ç ä¸­ä½¿ç”¨å¹»å½±ç±»å‹æœ‰ä¸€ä¸ªä¸»è¦è­¦å‘Šã€‚</p><p> We cannot branch the behaviour of a function based on a phantom type. To exemplify this, consider an impossible implementation of a  to_string function for our  Currency type.</p><p> æˆ‘ä»¬æ— æ³•åŸºäºå¹»åƒç±»å‹åˆ†æ”¯åŠŸèƒ½çš„è¡Œä¸ºã€‚ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œè¯·è€ƒè™‘å¯¹æˆ‘ä»¬çš„Currencyç±»å‹å®ç°to_stringå‡½æ•°çš„ä¸å¯èƒ½å®ç°ã€‚</p><p> pub fn to_string (a: Currency(a)) -&gt; String { let Currency(val) = a case a.phantom_type { USD -&gt; string.concat(&#34;$&#34;, float.to_string(val)) GBP -&gt; string.concat(&#34;Â£&#34;, float.to_string(val)) ... }}</p><p> pub fn to_stringï¼ˆaï¼šCurrencyï¼ˆaï¼‰ï¼‰-ï¼†gt;å­—ç¬¦ä¸²{è®©Currencyï¼ˆvalï¼‰=ä¸€ç§æƒ…å†µa.phantom_type {USD-ï¼†gt; string.concatï¼ˆï¼†ï¼ƒ34; $ï¼†ï¼ƒ34 ;, float.to_stringï¼ˆvalï¼‰ï¼‰GBP-ï¼†gt; string.concatï¼ˆï¼†ï¼ƒ34;Â£ï¼†ï¼ƒ34 ;, float.to_stringï¼ˆvalï¼‰ï¼‰...}}</p><p> We&#39;ve hit the limits of what phantom types can help us express now. Because the  to_string function has to be general to  all values of  a in a  Currency(a), we cannot change behaviour based on the type of  a.</p><p> æˆ‘ä»¬å·²ç»è¾¾åˆ°äº†å¹»åƒç±»å‹å¯ä»¥å¸®åŠ©æˆ‘ä»¬è¡¨è¾¾çš„æé™ã€‚å› ä¸ºto_stringå‡½æ•°å¿…é¡»å¯¹Currencyï¼ˆaï¼‰ä¸­açš„æ‰€æœ‰å€¼é€šç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½åŸºäºaçš„ç±»å‹æ›´æ”¹è¡Œä¸ºã€‚</p><p>   Before we wrap up and consolidate what we know about phantom types, I want to briefly touch on a property of some languages that makes phantom types even cooler (slightly). In some languages, simple wrapper types around another type can remove the boxing entirely at runtime. The ceremony of wrapping and unwrapping the type with pattern matching stays, but at runtime only the wrapped value remains.</p><p>   åœ¨æ€»ç»“å’Œå·©å›ºæˆ‘ä»¬å¯¹å¹»è±¡ç±»å‹çš„äº†è§£ä¹‹å‰ï¼Œæˆ‘æƒ³ç®€è¦ä»‹ç»ä¸€ä¸‹ä¸€äº›ä½¿å¹»è±¡ç±»å‹æ›´åŠ å‡‰çˆ½ï¼ˆç•¥ï¼‰çš„è¯­è¨€çš„å±æ€§ã€‚åœ¨æŸäº›è¯­è¨€ä¸­ï¼Œå›´ç»•å¦ä¸€ç§ç±»å‹çš„ç®€å•åŒ…è£…å™¨ç±»å‹å¯ä»¥åœ¨è¿è¡Œæ—¶å®Œå…¨åˆ é™¤è£…ç®±ã€‚ä½¿ç”¨æ¨¡å¼åŒ¹é…å¯¹ç±»å‹è¿›è¡ŒåŒ…è£…å’Œè§£åŒ…çš„è¿‡ç¨‹ä¿æŒä¸å˜ï¼Œä½†åœ¨è¿è¡Œæ—¶ä»…ä¿ç•™åŒ…è£…çš„å€¼ã€‚</p><p>     There&#39;s a work-in-progress  pull request to add support for this sort of thing to Gleam via an  inline keyword. What does this have to do with phantom types? At the moment we pay a slight performance cost for these wrapper types in Gleam, as we have to constantly box and unbox them. With the proposed  inline modifier, this (un)boxing can be removed at compile time, along with our phantom type annotations. We&#39;ll get all of the type benefits and pay no runtime cost!</p><p>     æœ‰ä¸€ä¸ªè¿›è¡Œä¸­çš„æ‹‰å–è¯·æ±‚ï¼Œç”¨äºé€šè¿‡å†…è”å…³é”®å­—ä¸ºGleamæ·»åŠ å¯¹æ­¤ç±»å‹çš„æ”¯æŒã€‚è¿™ä¸å¹»åƒç±»å‹æœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿç›®å‰ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºGleamä¸­çš„è¿™äº›åŒ…è£…ç±»å‹æ”¯ä»˜å°‘é‡æ€§èƒ½æˆæœ¬ï¼Œå› ä¸ºæˆ‘ä»¬å¿…é¡»ä¸æ–­å¯¹å®ƒä»¬è¿›è¡Œè£…ç®±å’Œæ‹†ç®±ã€‚ä½¿ç”¨å»ºè®®çš„å†…è”ä¿®é¥°ç¬¦ï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶å°†è¿™ä¸ªï¼ˆå–æ¶ˆï¼‰è£…ç®±ä»¥åŠæˆ‘ä»¬çš„å¹»åƒç±»å‹æ³¨é‡Šä¸€èµ·åˆ é™¤ã€‚æˆ‘ä»¬å°†è·å¾—æ‰€æœ‰ç±»å‹ä¸Šçš„å¥½å¤„ï¼Œå¹¶ä¸”æ— éœ€æ”¯ä»˜ä»»ä½•è¿è¡Œæ—¶è´¹ç”¨ï¼</p><p>    A  phantom type is a type variable that appears on the left-hand side of a type&#39;s definition but is not used on the right-hand side.</p><p>    å¹»åƒç±»å‹æ˜¯ä¸€ç§ç±»å‹å˜é‡ï¼Œå®ƒå‡ºç°åœ¨ç±»å‹å®šä¹‰çš„å·¦ä¾§ï¼Œä½†æœªåœ¨å³ä¾§ä½¿ç”¨ã€‚ </p><p> We can use phantom types to  disambiguate values that share the same underlying structure:  Id(a) or  Currency(code).</p><p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¹»åƒç±»å‹æ¥æ¶ˆé™¤å…·æœ‰ç›¸åŒåŸºç¡€ç»“æ„çš„å€¼çš„æ­§ä¹‰ï¼šIdï¼ˆaï¼‰æˆ–Currencyï¼ˆcodeï¼‰ã€‚</p><p>  We can use phantom types to provide  context clues to developers about where a particular value came from or what values are possible:  Error(from).</p><p>  æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¹»åƒç±»å‹å‘å¼€å‘äººå‘˜æä¾›æœ‰å…³ç‰¹å®šå€¼æ¥è‡ªä½•å¤„æˆ–å¯èƒ½å‡ºç°å“ªäº›å€¼çš„ä¸Šä¸‹æ–‡çº¿ç´¢ï¼šErrorï¼ˆfromï¼‰ã€‚</p><p> And that&#39;s about it. We&#39;ve covered the main use-cases for phantom types but there are others, like an  interpreter for a small language or a type-safe implementation of the  builder pattern. If you&#39;re still a bit stumped, you can drop a message on the Gleam discord (which you&#39;ve  joined already, right?) and I&#39;ll probably see it.</p><p> å°±æ˜¯è¿™æ ·ã€‚æˆ‘ä»¬å·²ç»ä»‹ç»äº†å¹»å½±ç±»å‹çš„ä¸»è¦ç”¨ä¾‹ï¼Œä½†è¿˜æœ‰å…¶ä»–ä¸€äº›ç”¨ä¾‹ï¼Œä¾‹å¦‚ç”¨äºå°è¯­è¨€çš„è§£é‡Šå™¨æˆ–æ„å»ºå™¨æ¨¡å¼çš„ç±»å‹å®‰å…¨çš„å®ç°ã€‚å¦‚æœæ‚¨ä»ç„¶æ„Ÿåˆ°å›°æƒ‘ï¼Œå¯ä»¥åœ¨Gleamä¸å’Œè°ï¼ˆæ‚¨å·²ç»åŠ å…¥äº†ï¼Œå¯¹å—ï¼Ÿï¼‰ä¸Šæ”¾ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ‘å¾ˆå¯èƒ½ä¼šçœ‹åˆ°å®ƒã€‚</p><p>   There are  plenty of articles scattered across the Internet that discuss phantom types. Many of them typically use the same examples that I&#39;ve used here, but if my writing didn&#39;t really hit the idea home you might be well served seeing the same thing explained by someone else. Below is a collection of articles that I think are particularly well written:</p><p>   äº’è”ç½‘ä¸Šæ•£å¸ƒç€è®¸å¤šè®¨è®ºå¹»åƒç±»å‹çš„æ–‡ç« ã€‚ä»–ä»¬ä¸­çš„è®¸å¤šäººé€šå¸¸ä½¿ç”¨ä¸æˆ‘åœ¨æ­¤å¤„ä½¿ç”¨çš„ç¤ºä¾‹ç›¸åŒçš„ç¤ºä¾‹ï¼Œä½†æ˜¯å¦‚æœæˆ‘çš„å†™ä½œæ²¡æœ‰çœŸæ­£ä½¿è¿™ä¸ªæƒ³æ³•æˆä¸ºç°å®ï¼Œé‚£ä¹ˆçœ‹åˆ°åˆ«äººè§£é‡Šçš„ç›¸åŒå†…å®¹å¯èƒ½ä¼šå¾ˆæœ‰ç›Šã€‚ä»¥ä¸‹æ˜¯æˆ‘è®¤ä¸ºå†™å¾—ç‰¹åˆ«å¥½çš„æ–‡ç« é›†ï¼š</p><p>  If you&#39;re just getting started with Gleam and you&#39;ve stumbled across this article, firstly, well done for making it to the end. Secondly, if you&#39;re scratching your head a bit over what any of this means, here are some of the language features we&#39;ve made use of:</p><p>  å¦‚æœæ‚¨åªæ˜¯åˆšå¼€å§‹ä½¿ç”¨Gleamï¼Œè€Œæ‚¨å¶ç„¶å‘ç°äº†è¿™ç¯‡æ–‡ç« ï¼Œé‚£ä¹ˆé¦–å…ˆï¼Œè¯·åšå¥½è¿™ç¯‡æ–‡ç« ã€‚å…¶æ¬¡ï¼Œå¦‚æœæ‚¨å¯¹è¿™æ„å‘³ç€ä»€ä¹ˆæœ‰äº›æŒ å¤´ï¼Œä»¥ä¸‹æ˜¯æˆ‘ä»¬ä½¿ç”¨çš„ä¸€äº›è¯­è¨€åŠŸèƒ½ï¼š </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.pd-andy.dev/phantom-types-in-gleam">https://blog.pd-andy.dev/phantom-types-in-gleam</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/å¹»å½±/">#å¹»å½±</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/types/">#types</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ç±»å‹/">#ç±»å‹</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>