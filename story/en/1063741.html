<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ä»æœ±è‰å¨…åˆ°ç”Ÿé”ˆ From Julia to Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">From Julia to Rust<br/>ä»æœ±è‰å¨…åˆ°ç”Ÿé”ˆ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 06:52:07</div><div class="page_narrow text-break page_content"><p>I&#39;ve been more serious about learning Rust recently, after dragging on with passive learning for a while. My first real programming language was Julia, and I know other Julians interested in Rust. I&#39;ve written this article for those people in mind, because Rust and Julia are good performance sparring partners, but Rust has a different mindset and tradeoffs that are worth considering.</p><p>åœ¨ç”¨è¢«åŠ¨å­¦ä¹ æŒç»­ä¸€æ®µæ—¶é—´åï¼Œæˆ‘æœ€è¿‘ä¸€ç›´éå¸¸è®¤çœŸåœ°å­¦ä¹ ç”Ÿé”ˆã€‚æˆ‘çš„ç¬¬ä¸€ä¸ªçœŸæ­£çš„ç¼–ç¨‹è¯­è¨€æ˜¯æœ±è‰å¨…ï¼Œæˆ‘çŸ¥é“å…¶ä»–å¯¹ç”Ÿé”ˆæ„Ÿå…´è¶£çš„æœ±åˆ©å®‰ã€‚æˆ‘ä¸ºé‚£äº›äººå†™äº†è¿™ç¯‡æ–‡ç« ï¼Œå› ä¸ºç”Ÿé”ˆå’Œæœ±è‰å¨…æ˜¯è‰¯å¥½çš„è¡¨æ¼”ä¼™ä¼´ï¼Œä½†Rustæœ‰ä¸€ä¸ªä¸åŒçš„æ€æƒ³å’Œæƒè¡¡ï¼Œå€¼å¾—è€ƒè™‘ã€‚</p><p>        There are 3 talks that sold me on Rust being worth learning, the first is  by Carol Nichols and the  second is a lecture by Ryan Eberhardt and Armin Nanavari. The first talks about how about ~70% of all bugs from the big tech corporations are from memory safety and that trains used to not have emergency brakes. The second explains how sytems programming codebases already impose the invariants of resource ownership on the coders - but that reasoning can be horribly error prone, tedious, and automated.</p><p>        æœ‰3ä¸ªè°ˆåˆ¤å¯ä»¥å–æ‰æˆ‘çš„ç”Ÿé”ˆå€¼å¾—å­¦ä¹ ï¼Œç¬¬ä¸€ä¸ªæ˜¯Carol Nicholsï¼Œç¬¬äºŒä¸ªæ˜¯Ryan Eberhardtå’ŒArmin Nanavariçš„è®²åº§ã€‚ç¬¬ä¸€æ¬¡è°ˆè®ºå¤§ç§‘æŠ€å…¬å¸çš„æ‰€æœ‰é”™è¯¯è¾¾åˆ°çº¦70ï¼…æ¥è‡ªå†…å­˜å®‰å…¨ï¼Œæ›¾ç»æ²¡æœ‰ç´§æ€¥åˆ¹è½¦çš„ç«è½¦ã€‚ç¬¬äºŒæ¬¡è§£é‡Šäº†ç³»ç»Ÿç¼–ç¨‹ç æ¡çš„ç¼–ç¨‹å¦‚ä½•å¯¹ç¼–ç å™¨ä¸­çš„èµ„æºæ‰€æœ‰æƒçš„ä¸å˜æ€§äº§ç”Ÿäº†æ™®åŠï¼Œä½†æ¨ç†å¯èƒ½ä¼šæ˜“äºé”™è¯¯ï¼Œç¹çå’Œè‡ªåŠ¨åŒ–ã€‚</p><p>  That&#39;s the point of technology! To not have to worry about the previous generations problems because we figured out a way to offload that thinking to a machine.</p><p>  é‚£ä¸ªï¼†ï¼ƒ39;å®ƒçš„æŠ€æœ¯ç‚¹ï¼ä¸å¿…æ‹…å¿ƒä»¥å‰çš„å‡ ä»£é—®é¢˜ï¼Œå› ä¸ºæˆ‘ä»¬å‘ç°äº†ä¸€ç§å¸è½½åˆ°æœºå™¨çš„æ–¹æ³•ã€‚</p><p>  The third talk that really sold me on Rust was  Alex Gaynor&#39;s. It&#39;s bad enough that a bank or a school web site could crash because of memory bugs, but once you take into account the fact that not even the best programmers in the world (sorted by salaries, roughly) can ship safe code, you start to despair a little. Then you hear about the incredibly battle-tested libraries like  sudo  and, as the moral argument goes, you are likely going to put vulnerable people in harm&#39;s way if you keep shipping a broken tool. I buy the urgency of that argument more and more when journalists or human rights advocates get targeted by state actors due to a trivial (but buried) C mistake.</p><p>  çœŸæ­£å–æ‰æˆ‘çš„ç¬¬ä¸‰ä¸ªè°ˆè¯æ˜¯äºšå†å…‹æ–¯gaynorï¼†ï¼ƒ39; sã€‚å®ƒï¼†ï¼ƒ39æ˜¯è¶³å¤Ÿçš„ï¼Œé“¶è¡Œæˆ–å­¦æ ¡ç½‘ç«™å¯èƒ½å› å†…å­˜é”™è¯¯è€Œå´©æºƒï¼Œä½†ä¸€æ—¦ä½ è€ƒè™‘åˆ°ä¸–ç•Œä¸Šæœ€å¥½çš„ç¨‹åºå‘˜ï¼ˆç”±å·¥èµ„æ’åºï¼Œå¤§è‡´æ’åºï¼‰å¯ä»¥å‘è´§å®‰å…¨ä»£ç ï¼Œä½ å¼€å§‹ç»æœ›ä¸€ç‚¹ã€‚ç„¶åä½ å¬åˆ°äº†åƒsudoè¿™æ ·çš„ä»¤äººéš¾ä»¥ç½®ä¿¡çš„æˆ˜æ–—åº“ï¼Œå¹¶ä¸”éšç€é“å¾·äº‰è®ºçš„æ–¹å¼ï¼Œä½ å¯èƒ½ä¼šæŠŠè„†å¼±çš„äººæ”¾åœ¨ä¼¤å®³ä¸­ï¼Œå¦‚æœä½ ç»§ç»­è¿é€ä¸€ä¸ªç ´ç¢çš„å·¥å…·ï¼Œé‚£å°±ä¼šä¼¤å®³ä¼¤å®³ã€‚æˆ‘è¶Šæ¥è¶Šå¤šåœ°è´­ä¹°è¯¥è®ºè¯çš„ç´§è¿«æ€§ï¼Œå½“äº‹å‘˜æˆ–äººæƒå€¡å¯¼è€…ç”±äºçç¢çš„ï¼ˆä½†åŸ‹è‘¬ï¼‰Cé”™è¯¯è€Œå—åˆ°å›½å®¶è¡Œä¸ºè€…çš„ç›®æ ‡ã€‚</p><p>  So that&#39;s the spiel for jumping on the Rust train when I argue with myself in the shower. What&#39;s the Rust&#39;s philosophy?</p><p>  æ‰€ä»¥å½“æˆ‘åœ¨æ·‹æµ´æ—¶äº‰è®ºç”Ÿé”ˆç«è½¦æ—¶ï¼Œå®ƒçš„æ–¯åŸºè¾›èµ›è·³è·ƒã€‚ä»€ä¹ˆï¼†ï¼ƒ39;ç”Ÿé”ˆï¼†ï¼ƒ39;å“²å­¦ï¼Ÿ</p><p>        You might know Julia&#39;s origin story - there were a gajillion DSLs for scientific computing, BLAS is a mess but implements polymorphism through namespacing for performance needs, and other libraries re-implemented a poor man&#39;s version of multiple dispatch because of the performance constraints. If you add a clever JIT to multiple dispatch capabilites, you can get ~C performance with ease if types can be inferred, and fortunately you can build a general programming language around that paradigm and those trade offs. Eventually, they baptized the language to honor the one true queen of  algorithms.</p><p>        æ‚¨å¯èƒ½çŸ¥é“æœ±è‰å¨…ï¼†ï¼ƒ39;è‹æ ¼å…°çš„æ•…äº‹ - æœ‰ä¸€ä¸ªgajiltionçš„ç§‘å­¦æ•°æ®åº“ï¼ŒBlasæ˜¯ä¸€å›¢ç³Ÿï¼Œä½†é€šè¿‡å‘½åä¸ºç»©æ•ˆéœ€æ±‚æ¥å®ç°å¤šæ€æ€§ï¼Œè€Œå…¶ä»–å›¾ä¹¦é¦†é‡æ–°å®æ–½è¿‡è´«ç©·çš„äººå’Œç¬¬39æ—ç‰ˆæœ¬å› ä¸ºæ€§èƒ½çº¦æŸã€‚å¦‚æœå°†èªæ˜çš„JITæ·»åŠ åˆ°å¤šä¸ªè°ƒåº¦CapabiLitesï¼Œåˆ™å¯ä»¥è½»æ¾è·å–ã€œCæ€§èƒ½ï¼Œå¦‚æœå¯ä»¥æ¨æ–­å‡ºç±»å‹ï¼Œå¹¸è¿çš„æ˜¯ï¼Œæ‚¨å¯ä»¥åœ¨è¯¥èŒƒä¾‹å’Œè¿™äº›æƒè¡¡ä¸­å»ºç«‹ä¸€èˆ¬çš„ç¼–ç¨‹è¯­è¨€ã€‚æœ€ç»ˆï¼Œä»–ä»¬å‘è¯­è¨€æ–½æ´—äº†è¯­è¨€ï¼Œä»¥çºªå¿µç®—æ³•çš„ä¸€ä¸ªçœŸæ­£çš„å¥³ç‹ã€‚</p><p>  Rust comes from a different place: Some years ago in Mozilla, Graydon Hoare and the team got fed up with systems programming and the C/C++ tool chain. They were working on a language that allowed for programmers to be productive in low-level systems, harness concurrency performance without the foot-bazookas, and avoid errors during run time. At first they had different systems for handling the previous problems, until the team pieced together that an ownership system, with a borrow checker at compile time, could kill 2 birds with one stone. Eventually, they named the language after the  fungus.</p><p>  Rustæ¥è‡ªä¸åŒçš„åœ°æ–¹ï¼šå‡ å¹´å‰ï¼Œåœ¨Mozillaï¼ŒGraydon Honareå’Œå›¢é˜ŸåŒå€¦äº†ç³»ç»Ÿç¼–ç¨‹å’ŒC / C ++å·¥å…·é“¾ã€‚ä»–ä»¬æ­£åœ¨ç ”ç©¶ä¸€ç§è¯­è¨€ï¼Œå…è®¸ç¨‹åºå‘˜åœ¨ä½çº§ç³»ç»Ÿä¸­å¯Œæœ‰æˆæ•ˆï¼Œæ²¡æœ‰è¶³è¿¹çš„æƒ…å†µä¸‹åœç”¨å¹¶å‘æ€§èƒ½ï¼Œå¹¶åœ¨è¿è¡Œæ—¶é¿å…é”™è¯¯ã€‚èµ·åˆï¼Œä»–ä»¬æœ‰ä¸åŒçš„ç³»ç»Ÿæ¥å¤„ç†ä»¥å‰çš„é—®é¢˜ï¼Œç›´åˆ°å›¢é˜Ÿæ‹¼å‡‘åœ¨ä¸€èµ·çš„æ‰€æœ‰æƒç³»ç»Ÿï¼Œåœ¨ç¼–è¯‘æ—¶å€Ÿç”¨æ£€æŸ¥å‘˜ï¼Œå¯ä»¥ç”¨ä¸€å—çŸ³å¤´æ€æ­»2åªé¸Ÿã€‚æœ€ç»ˆï¼Œä»–ä»¬åœ¨çœŸèŒåå‘½åçš„è¯­è¨€ã€‚ </p><p>  Recap: Julians were sick of unreusable code, niche DSLs and hacky polymorphism. With multiple dispatch as the central design feature they solved those problems. Rustaceans were sick of the C/C++ minefields and trying to keep all the invariants of large, error-prone codebases in their head. The idea of ownership and a borrow checker to know those errors  at compile time and be data-race free is what&#39;s got them to where they are now.</p><p>RECAPï¼šæœ±è‰å®‰æ‚£äº†ä¸å¯ç”¨çš„ä»£ç ï¼Œåˆ©åŸºDSLå’Œè´ºå¡å¤šæ€æ€§ã€‚éšç€ä¸­å¤®è®¾è®¡çš„å¤šæ¬¡è°ƒåº¦ï¼Œä»–ä»¬è§£å†³äº†è¿™äº›é—®é¢˜ã€‚ RiraceansåŒå€¦äº†C / C ++é›·åŒºï¼Œå¹¶è¯•å›¾åœ¨ä»–ä»¬çš„å¤´è„‘ä¸­ä¿ç•™å¤§å‹é”™è¯¯æ˜“äºç ç çš„æ‰€æœ‰ä¸å˜æ€§ã€‚æ‰€æœ‰æƒçš„æ¦‚å¿µå’Œå€Ÿä¹¦æ£€æŸ¥è€…çŸ¥é“åœ¨ç¼–è¯‘æ—¶çš„é”™è¯¯ï¼Œå¹¶ä¸”æ˜¯æ•°æ®ç§ç±»çš„é”™è¯¯æ˜¯ä»€ä¹ˆï¼†ï¼ƒ39;è®©ä»–ä»¬åˆ°ç°åœ¨çš„ä½ç½®ã€‚</p><p>  There&#39;s obviously important details missing on both stories - you can get it from proper historians if you like, this is a brief and informal introduction. I will however, mention the other big Rustian idea of affine types when I talk about how they get a version of generic code we&#39;ve come to know and love in Julia land. Spoiler alert: you can get generic code if you pay the price of a Julia runtime, and that&#39;s not something Rustaceans want. If you want generics at compile time, you have to &#34;prove&#34; to the compiler that your types are constrained to some extent, and you relay that information by tacking on affine types to your code.</p><p>  ä¸¤å±‚æ•…äº‹ä¸­ç¼ºå°‘çš„é‡è¦ç»†èŠ‚æ˜¾ç„¶æœ‰æ˜æ˜¾çš„ç»†èŠ‚ - å¦‚æœæ‚¨æ„¿æ„ï¼Œæ‚¨å¯ä»¥ä»é€‚å½“çš„å†å²å­¦å®¶é‚£é‡Œå¾—åˆ°å®ƒï¼Œè¿™æ˜¯ä¸€ä¸ªç®€çŸ­è€Œéæ­£å¼çš„ä»‹ç»ã€‚ç„¶è€Œï¼Œå½“æˆ‘è°ˆè®ºä»–ä»¬å¦‚ä½•è·å¾—ä¸€ç‰ˆæœ¬çš„é€šç”¨ä»£ç æ—¶ï¼Œæˆ‘ä¼šæåˆ°å¦ä¸€ä¸ªå¤§å‹Ristianç±»å‹çš„ä»¿å°„ç±»å‹ï¼†ï¼ƒ39;åœ¨æœ±è‰å¨…çš„åœŸåœ°ä¸Šæ¥äº†è§£å’Œçˆ±ã€‚ SPOILER ALERTï¼šå¦‚æœæ‚¨æ”¯ä»˜Juliaè¿è¡Œæ—¶çš„ä»·æ ¼ï¼Œåˆ™å¯ä»¥è·å¾—é€šç”¨ä»£ç ï¼Œè€Œä¸”ï¼†ï¼ƒ39;ä¸æ˜¯é²è¥¿ç“¦æ–¯çš„ä¸œè¥¿ã€‚å¦‚æœæ‚¨å¸Œæœ›åœ¨ç¼–è¯‘æ—¶æ³›å‹ï¼Œåˆ™å¿…é¡»ï¼†ï¼ƒ34;è¯æ˜ï¼†ï¼ƒ34;å¯¹äºç¼–è¯‘å™¨ï¼Œæ‚¨çš„ç±»å‹åœ¨æŸç§ç¨‹åº¦ä¸Šå—åˆ°çº¦æŸï¼Œå¹¶ä¸”æ‚¨é€šè¿‡åœ¨ä»£ç ä¸Šè¿›è¡Œä»¿å°„ç±»å‹æ¥ä¼ é€’è¯¥ä¿¡æ¯ã€‚</p><p>          If for some reason you&#39;ve already decided that learning Rust is a worthy endeavour, here&#39;s my list of resources to learn. I think they are a good resource to follow in approximate order, but use whatever works, and if it doesn&#39;t, skip it.</p><p>          å¦‚æœå‡ºäºæŸç§åŸå› ï¼Œä½ å·²ç»å†³å®šå­¦ä¹ ç”Ÿé”ˆæ˜¯ä¸€ä¸ªå€¼å¾—çš„åŠªåŠ›ï¼Œè¿™é‡Œæˆ‘çš„èµ„æºåˆ—è¡¨ã€‚æˆ‘è®¤ä¸ºä»–ä»¬æ˜¯è¿‘ä¼¼é¡ºåºéµå¾ªçš„å¥½èµ„æºï¼Œä½†ä½¿ç”¨ä»»ä½•ä½œç”¨ï¼Œå¦‚æœå®ƒæ²¡æœ‰ï¼Œè·³è¿‡å®ƒã€‚</p><p>  The Rust book: Click the link to get started with installation and IDE setup. It pays to read it at least once cover to cover and not fret about coming back to the thorny bits.</p><p>  ç”Ÿé”ˆä¹¦ï¼šå•å‡»é“¾æ¥ä»¥å¯åŠ¨å®‰è£…å’ŒIDEè®¾ç½®ã€‚åªéœ€ä¸€æ—¦ç›–å­è¦†ç›–å³å¯è¦†ç›–å³å¯è¦†ç›–å³å¯æ‰èƒ½å›åˆ°æ£˜æ‰‹çš„æ¯”ç‰¹ã€‚</p><p>  VSCode Error Lens and  Rustanalyzer: The quicker the feedback loop you get from the compiler, the sooner you can spot mistakes and keep going. These aren&#39;t mandatory but it&#39;s the easiest way to make the feedback loop faster.</p><p>  vscodeé”™è¯¯é•œå¤´å’ŒrustAnalyzerï¼šä»ç¼–è¯‘å™¨ä¸­è·å¾—çš„åé¦ˆå¾ªç¯æ›´å¿«ï¼Œæ‚¨è¶Šæ—©å¯ä»¥å‘ç°é”™è¯¯å¹¶ç»§ç»­å‰è¿›ã€‚è¿™äº›arenï¼†ï¼ƒ39; tå¼ºåˆ¶æ€§ä½†å®ƒï¼†ï¼ƒ39; sæ›´å¿«åœ°åˆ¶ä½œåé¦ˆå¾ªç¯çš„æœ€ç®€å•æ–¹æ³•ã€‚</p><p>  Rust docs: Their version of the Julia manual. Make sure to click the  [+] to see how the code drops down. I still spend time looking at the iterators page.</p><p>  Rust Docsï¼šä»–ä»¬çš„Juliaæ‰‹å†Œç‰ˆæœ¬ã€‚ç¡®ä¿å•å‡»[+]ä»¥æŸ¥çœ‹ä»£ç å¦‚ä½•ä¸‹é™ã€‚æˆ‘ä»ç„¶èŠ±æ—¶é—´çœ‹è¿­ä»£å™¨é¡µé¢ã€‚</p><p>  Exercism: If you want to get into some guided learning, Exercisms is great, but focuses too much on strings at the beginning for my liking. Make sure to look at the community solutions when you&#39;re done.</p><p>  è¡Œä¸šä¸»ä¹‰ï¼šå¦‚æœä½ æƒ³è¿›å…¥ä¸€äº›å¯¼æ¸¸çš„å­¦ä¹ ï¼Œè¿åŠ¨å°±æ˜¯å¾ˆæ£’çš„ï¼Œä½†åœ¨å¼€å§‹æ—¶ï¼Œä¸“æ³¨äºå¼¦ä¹çš„å¼¦ä¹ã€‚å½“ä½ å®Œæˆæ—¶ï¼Œè¯·åŠ¡å¿…æŸ¥çœ‹ç¤¾åŒºè§£å†³æ–¹æ¡ˆã€‚ </p><p>  Advent of Code 2020 by Amos: This was my first &#34;get your hands dirty&#34; with Rust experience. Other articles by Amos are great and friendly too, but this series was useful for figuring out a Rustian workflow and design thinking.</p><p>ä»£ç 2020ç”±AMOSå‡ºå‘ï¼šè¿™æ˜¯æˆ‘çš„ç¬¬ä¸€ä¸ªï¼†ï¼ƒ34;è®©ä½ çš„æ‰‹è„ï¼†ï¼ƒ34;ç»éªŒä¸°å¯Œã€‚ AMOSçš„å…¶ä»–æ–‡ç« ä¹Ÿéå¸¸å‹å¥½ï¼Œä½†è¯¥ç³»åˆ—å¯¹äºå¼„æ¸…æ¥šæ¢ç´¢çš„å·¥ä½œæµç¨‹å’Œè®¾è®¡æ€ç»´æ˜¯æœ‰ç”¨çš„ã€‚</p><p>  Ryan Eberhardt Stanford course: University course that gets you up and running with systems programming constraints and problem solving. I&#39;m not its target audience but it was great for understanding Rust&#39;s domain.</p><p>  Ryan Eberhardt Stanfordè¯¾ç¨‹ï¼šå¤§å­¦è¯¾ç¨‹è®©æ‚¨å¯åŠ¨å’Œè¿è¡Œç³»ç»Ÿç¼–ç¨‹çº¦æŸå’Œè§£å†³é—®é¢˜ã€‚æˆ‘ä¸æ˜¯å®ƒçš„ç›®æ ‡å—ä¼—ï¼Œä½†å®ƒéå¸¸é€‚åˆç†è§£ç”Ÿé”ˆï¼†ï¼ƒ39; såŸŸã€‚</p><p>  Jeff Zarnett programming for performance course repo, with a  full youtube playlist: Another good course for stepping in directly into high performance computing - not done with it yet, but the professor is friendly and enthusiastic.</p><p>  Jeff Zarnettä¸ºç»©æ•ˆè¯¾ç¨‹ç¼–ç¨‹è¿›è¡Œç¼–ç¨‹ï¼Œæ‹¥æœ‰ä¸€ä¸ªå®Œæ•´çš„YouTubeæ’­æ”¾åˆ—è¡¨ï¼šå¦ä¸€ä¸ªè‰¯å¥½çš„è¯¾ç¨‹ï¼Œç”¨äºç›´æ¥è¿›å…¥é«˜æ€§èƒ½è®¡ç®— - è¿˜æ²¡æœ‰å®Œæˆå®ƒï¼Œä½†æ•™æˆæ˜¯å‹å¥½å’Œçƒ­æƒ…çš„ã€‚</p><p>  Rustlings: I found some exercises too hard the first time I picked up the Rust book. Your Mileage May Vary but I did them solo and suffered. I would recommend pairing up with a buddy before attempting all of it.</p><p>  rustlingsï¼šæˆ‘å‘ç°ä¸€äº›ç»ƒä¹ å¤ªéš¾äº†æˆ‘ç¬¬ä¸€æ¬¡æ‹¿èµ·é“é”ˆä¹¦ã€‚ä½ çš„é‡Œç¨‹å¯èƒ½æœ‰æ‰€ä¸åŒï¼Œä½†æˆ‘åšäº†ç‹¬å¥å’Œé­å—çš„ã€‚åœ¨å°è¯•æ‰€æœ‰å†…å®¹ä¹‹å‰ï¼Œæˆ‘å»ºè®®ä¸ä¼™ä¼´é…å¯¹ã€‚</p><p>  Too many linked lists: Another great walkthrough once you feel more comfortable reading and writing Rust.</p><p>  æœ‰å¤ªå¤šçš„é“¾æ¥åå•ï¼šä¸€æ—¦ä½ è§‰å¾—æ›´èˆ’é€‚çš„é˜…è¯»å’Œå†™ä½œé”ˆï¼Œå¦ä¸€ä¸ªä¼Ÿå¤§çš„æ¼”ç»ƒã€‚</p><p>  Jon Gjengset&#39;s streams: Jon Gjengset is a well-known Rust community member and has amazing quality streams - if you want to see a proficient Rustacean code, this is a good place to start.</p><p>  Jon Gjengsetï¼†ï¼ƒ39; Sæºªæµï¼šJon Gjengsetæ˜¯ä¸€ä¸ªç€åçš„ç”Ÿé”ˆç¤¾åŒºæˆå‘˜ï¼Œå…·æœ‰æƒŠäººçš„è´¨é‡æµ - å¦‚æœæ‚¨æƒ³çœ‹åˆ°ç†Ÿç»ƒçš„rustaceanä»£ç ï¼Œè¿™æ˜¯ä¸€ä¸ªå§‹äºä¸€ä¸ªå¥½çš„åœ°æ–¹ã€‚</p><p>  multicore and atomics: Gets into the weeds about all the pain that Rust can save you when you&#39;re implementing low-level tricky concurrency.</p><p>  å¤šèŠ¯å’ŒåŸå­ï¼šè¿›å…¥æ‚è‰å…³äºç”Ÿé”ˆå¯ä»¥æ‹¯æ•‘ä½ çš„æ‰€æœ‰ç—›è‹¦ï¼Œå½“ä½ å®ç°ä½çº§æ£˜æ‰‹çš„å¹¶å‘æ€§å¹¶å‘ã€‚ </p><p>    Alright, so you&#39;re set up to go on a learning journey. What&#39;s Rust look like anyway when compared to Julia?</p><p>å¥½çš„ï¼Œæ‰€ä»¥ä½ ï¼†ï¼ƒ39;é‡æ–°å¼€å§‹å‚åŠ å­¦ä¹ ä¹‹æ—…ã€‚ä¸æœ±è‰å¨…ç›¸æ¯”ï¼Œï¼†ï¼ƒ39;æ— è®ºå¦‚ä½•éƒ½æ˜¯å¦‚æ­¤ï¼Ÿ</p><p>    We love composability and multiple dispatch, so let&#39;s look at a short example of how to get the good ol&#39; Julia bang-for-buck, with a 1D point:</p><p>    æˆ‘ä»¬å–œæ¬¢å¯ç»„è£…æ€§å’Œå¤šæ¬¡è°ƒåº¦ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•è·â€‹â€‹å¾—è‰¯å¥½çš„OLï¼†ï¼ƒ39çš„ç®€çŸ­ç¤ºä¾‹; Julia Bang-for-Buckï¼Œæœ‰ä¸€ä¸ª1Dç‚¹ï¼š</p><p>  import Base: + struct Point{T&lt;: Real} val::T end+(x::Point{T}, y::Point{T})  where T&lt;: Real = Point{T}(x.val + y.val)a = Point{ Int32}( 1)b = Point{ Int32}( 2)a + b  # worksc = Point{ Float32}( 1.0)d = Point{ Float32}( 2.0)c + d  # Also works!</p><p>  å¯¼å…¥åŸºç¡€ï¼š+ struct point {tï¼†lt;ï¼šreal} val :: t end +ï¼ˆx :: point {t}ï¼Œy :: point {t}ï¼‰å…¶ä¸­tï¼†lt;ï¼šreal = point {t}ï¼ˆx.val + y .valï¼‰a = point {int32}ï¼ˆ1ï¼‰b = point {int32}ï¼ˆ2ï¼‰a + bï¼ƒworksc = point {float32}ï¼ˆ1.0ï¼‰d = point {float32}ï¼ˆ2.0ï¼‰c + dï¼ƒä¹Ÿæœ‰æ•ˆï¼</p><p>    I make sure to not use any explicit types and let the dispatch system do the rest. You use functions like  zero(...),  eltype(...). With the dispatches, I add them to the appropriate subtype with  where T&lt;:Foo. If I define the appropriate methods, the others get composed atop of them , so I don&#39;t need to define  += once I&#39;ve defined  +. Duck type all the way - when something errors at runtime because I forgot a case (like the fact there&#39;s no type promotion rules above) I just write a function per call I missed and keep hacking on.</p><p>    æˆ‘ç¡®ä¿ä¸ä½¿ç”¨ä»»ä½•æ˜¾å¼ç±»å‹ï¼Œè®©è°ƒåº¦ç³»ç»Ÿä¼‘æ¯ã€‚æ‚¨ä½¿ç”¨åƒé›¶ï¼ˆ...ï¼‰ï¼ŒEltypeï¼ˆ...ï¼‰è¿™æ ·çš„åŠŸèƒ½ã€‚é€šè¿‡è°ƒåº¦ï¼Œæˆ‘å°†å®ƒä»¬æ·»åŠ åˆ°é€‚å½“çš„å­ç±»å‹ï¼Œå…¶ä¸­tï¼†lt;ï¼šfooã€‚å¦‚æœæˆ‘å®šä¹‰äº†ç›¸åº”çš„æ–¹æ³•ï¼Œåˆ™å…¶ä»–äººä¼šè¢«ä»–ä»¬ç»„æˆï¼Œæ‰€ä»¥æˆ‘ä¸éœ€è¦å®šä¹‰+ =ä¸€æ—¦iï¼†ï¼ƒ39; veå®šä¹‰+ã€‚é¸­å­ç±»å‹ä¸€è·¯ - å½“è¿è¡Œæ—¶çš„ä¸œè¥¿æ—¶å‡ºç°é”™è¯¯ï¼Œå› ä¸ºæˆ‘å¿˜è®°äº†ä¸€ä¸ªæ¡ˆä¾‹ï¼ˆå°±åƒä¸Šé¢çš„äº‹å®ä¸€æ ·ï¼Œæˆ‘åªå†™äº†ä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘é”™è¿‡äº†ï¼Œå¹¶ç»§ç»­é»‘å®¢ã€‚</p><p>  Setup a simple type hierarchy, define some functions on your types without using them explicitly, profit from not rewriting all the code, plug and chug as you run into errors or perf hits, look at docstrings in the REPL to help you out. Happy life.</p><p>  è®¾ç½®ä¸€ä¸ªç®€å•ç±»å‹çš„å±‚æ¬¡ç»“æ„ï¼Œåœ¨ç±»å‹ä¸Šå®šä¹‰æŸäº›åŠŸèƒ½è€Œä¸æ˜ç¡®ä½¿ç”¨å®ƒä»¬ï¼Œä»æœªé‡å†™æ‰€æœ‰ä»£ç ï¼Œå³æ—¶é‡å†™æ‰€æœ‰ä»£ç ï¼Œå³æ’å³ç”¨æˆ–perfå‘½ä¸­ï¼ŒæŸ¥çœ‹Reptä¸­çš„Docstringsä»¥å¸®åŠ©æ‚¨ã€‚å¿«ä¹çš„äººç”Ÿã€‚</p><p>    use std::ops::Add;  struct  &lt;T&gt; { val: T} impl&lt;T: Add&lt;Output = T&gt;&gt; Add  for  &lt;T&gt; {  type   =  Self;  fn  ( self, b:  Self)  -&gt;  Self::Output {  Self { val:  self.val + b.val } }} fn  () {  let  a = Point::&lt; i32&gt;{val:  1};  let  b = Point::&lt; i32&gt;{val:  2};  let  c = Point::&lt; f32&gt;{val:  1.0};  println!( &#34;{:?}&#34;, a + b);  println!( &#34;{:?}&#34;, c == c);}</p><p>    ä½¿ç”¨std :: ops ::æ·»åŠ ;ç»“æ„ï¼†lt; tï¼†gt; {valï¼št} imagr; tï¼šæ·»åŠ ï¼†lt;è¾“å‡º= tï¼†gt;ï¼†gt;æ·»åŠ ï¼†lt; tï¼†gt; {type = self; FNï¼ˆè‡ªæˆ‘ï¼ŒBï¼šè‡ªæˆ‘ï¼‰ - ï¼†gt; self ::è¾“å‡º{self {valï¼šself.val + b.val}} fnï¼ˆï¼‰{let a = point ::ï¼†lt; I32ï¼†gt; {valï¼š1};è®©B =ç‚¹::ï¼†lt; I32ï¼†gt; {valï¼š2};è®©c = point ::ï¼†lt; F32ï¼†gt; {valï¼š1.0}; Printlnï¼ï¼ˆï¼†ï¼ƒ34; {ï¼šï¼Ÿ}ï¼†ï¼ƒ34; a + bï¼‰; Printlnï¼ï¼ˆï¼†ï¼ƒ34; {ï¼šï¼Ÿ}ï¼†ï¼ƒ34;ï¼Œc == cï¼‰;}</p><p>    I worked on like half of this code and then had to  look it up. You can run it in the  Rust Playground here. Avid readers will notice the following:</p><p>    æˆ‘åƒè¿™æ®µä»£ç çš„ä¸€åŠä¸€æ ·å·¥ä½œï¼Œç„¶åä¸å¾—ä¸æŸ¥æ‰¾å®ƒã€‚æ‚¨å¯ä»¥åœ¨æ­¤å¤„åœ¨Rust Playgroundä¸­è¿è¡Œå®ƒã€‚ç‹‚çƒ­è¯»è€…å°†æ³¨æ„åˆ°ä»¥ä¸‹å†…å®¹ï¼š </p><p>  To get generics, you need a  struct for your type, an  impl&lt;T&gt; $TRAIT for Point&lt;T&gt; block where the  add function is defined, and type annotations like  Self::Output,  Add&lt;Output = T&gt;.</p><p>è¦è·å¾—æ³›å‹ï¼Œéœ€è¦ä¸ºæ‚¨çš„ç±»å‹æä¾›ä¸€ä¸ªç»“æ„ï¼ŒAlichï¼†lt; tï¼†gt;ç‚¹å‡»ç‚¹ï¼†lt; tï¼†gt;å—åœ¨å…¶ä¸­å®šä¹‰çš„æ·»åŠ å‡½æ•°ï¼Œé”®å…¥Self ::è¾“å‡ºç­‰æ³¨é‡Šï¼Œæ·»åŠ ï¼†lt;è¾“å‡º= tï¼†gt ;.</p><p>  There&#39;s a sort of &#34;name spacing&#34; with the turbo fish operator:  ::&lt;this one!&gt;. We don&#39;t get functions that can share names but differ in behaviour. Bummer. (We get this in Julia with some nicer outer constructors, but I think it takes from the thrust of the argument.)</p><p>  æœ‰ä¸€ç§ï¼†ï¼ƒ34;åç§°é—´è·å’Œï¼ƒ34;ä¸æ¶¡è½®é€é±¼æ“ä½œå‘˜:::ï¼†lt;è¿™ä¸ªï¼ï¼†gt ;.æˆ‘ä»¬ä¸è¦è·å¾—å¯ä»¥å…±äº«åç§°ä½†åœ¨è¡Œä¸ºä¸­ä¸åŒçš„å‡½æ•°ã€‚ bummerã€‚ ï¼ˆæˆ‘ä»¬ç”¨ä¸€äº›æ›´å¥½çš„å¤–éƒ¨æ„é€ å‡½æ•°æ¥åˆ°Juliaï¼Œä½†æˆ‘è®¤ä¸ºè¿™æ˜¯äº‰è®ºçš„æ¨åŠ›ã€‚ï¼‰</p><p>  The  println! function is different - it&#39;s a macro, and it runs at parse time, also like Julia&#39;s macros. The chars inside the  {:?} signal that we want debug printing, that we got above with the  #[derive(Debug)]. Rust doesn&#39;t know how to print new structs if you don&#39;t define it,  which, as Lyndon White points out, is one of the problems solved by multiple dispatch .</p><p>  printlnï¼åŠŸèƒ½æ˜¯ä¸åŒçš„ - å®ƒï¼†ï¼ƒ39; så®ï¼Œå®ƒåœ¨è§£ææ—¶é—´ï¼Œä¹Ÿåƒæœ±è‰å¨…ï¼†ï¼ƒ39;å®ã€‚æˆ‘ä»¬å¸Œæœ›è°ƒè¯•æ‰“å°çš„{ï¼šï¼Ÿ}ä¿¡å·å†…çš„å­—ç¬¦ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸Šé¢çš„ï¼ƒ[æ´¾ç”Ÿï¼ˆdebugï¼‰]ã€‚ Rustnï¼†ï¼ƒ39;å¦‚æœæ‚¨æ²¡æœ‰å®šä¹‰å®ƒï¼Œé‚£å°±åƒLyndon WhiteæŒ‡å‡ºçš„é‚£æ ·ï¼Œå®ƒæ˜¯å¦‚ä½•æ‰“å°æ–°çš„ç»“æ„ã€‚å®ƒæ˜¯å¤šæ¬¡è°ƒåº¦è§£å†³çš„é—®é¢˜ä¹‹ä¸€ã€‚</p><p>  Oh, those  #[things(above_the_struct)] are also macros. I still don&#39;t know how they&#39;re different, but they seem to affect how the compiler interacts with the crate too. Since some traits (like the ones for copying or printing) are so boilerplate heavy and predictable, you can get some behaviour for &#34;free&#34; if you add the right  #[derive(...)] stuff in the declaration. That&#39;s how the  c == c works actually, it&#39;s due to the  PartialEq.</p><p>  å“¦ï¼Œé‚£äº›ï¼ƒ[ä¸œè¥¿ï¼ˆä¸Šé¢_the_structï¼‰]ä¹Ÿæ˜¯å®ã€‚æˆ‘ä»ç„¶ä¸çŸ¥é“ä»–ä»¬æ˜¯å¦‚ä½•ä¸åŒçš„ï¼Œä½†å®ƒä»¬ä¼¼ä¹ä¹Ÿä¼šå½±å“ç¼–è¯‘å™¨å¦‚ä½•ä¸ç®±å­ç›¸äº’ä½œç”¨ã€‚ç”±äºä¸€äº›ç‰¹å¾ï¼ˆå¦‚ç”¨äºå¤åˆ¶æˆ–æ‰“å°çš„äººï¼‰ï¼Œå› æ­¤æ ·æ¿æ²‰é‡å’Œå¯é¢„æµ‹ï¼Œæ‚¨å¯ä»¥ä¸ºï¼†ï¼ƒ34è·å¾—ä¸€äº›è¡Œä¸º;å…è´¹ï¼†ï¼ƒ34;å¦‚æœæ‚¨åœ¨å£°æ˜ä¸­æ·»åŠ äº†å³ä¾§ï¼ƒ[æ´¾ç”Ÿï¼ˆ...ï¼‰]ã€‚é‚£ä¸ªï¼†ï¼ƒ39;å®ƒå¦‚ä½•å®é™…ä¸Šå·¥ä½œï¼Œå®ƒç”±äºPartiaLeqè€Œä½œå‡ºçš„ä½œç”¨ã€‚</p><p>    Slap a  &lt;T&gt; in front of your struct and the fields you want it to be generic over. Look up the functions needed for each trait in the documentation. Setup a brief test case. Doesn&#39;t compile? See what  rustc says and try and tack it on some traits; maybe you missed an affine type with  impl&lt;T: Foo&gt; or the  Self::Output - the compiler guides you through patching up your code. If you&#39;re asking for some generic behaviour, the compiler will complain and you&#39;ll have to add another trait implementation so that  it is damn sure you&#39;re allowed to continue.</p><p>    æ‹æ‘„ï¼†lt; tï¼†gt;åœ¨æ‚¨çš„ç»“æ„é¢å‰ä»¥åŠæ‚¨å¸Œæœ›å®ƒæ³›åŒ–çš„å­—æ®µã€‚æŸ¥æ‰¾æ–‡æ¡£ä¸­æ¯ä¸ªç‰¹å¾æ‰€éœ€çš„åŠŸèƒ½ã€‚è®¾ç½®ä¸€ä¸ªç®€çŸ­çš„æµ‹è¯•ç”¨ä¾‹ã€‚ ï¼†ï¼ƒ39; tç¼–è¯‘ï¼Ÿçœ‹çœ‹Rustcè¯´çš„æ˜¯ä»€ä¹ˆï¼Œå¹¶å°è¯•åœ¨ä¸€äº›ç‰¹å¾ä¸Šé’‰èµ·æ¥;ä¹Ÿè®¸ä½ é”™è¿‡äº†ä¸€ç§å¸¦æœ‰iclipï¼†lt; tï¼šfooï¼†gtçš„ä»¿å°„å‹;æˆ–self ::è¾“å‡º - ç¼–è¯‘å™¨é€šè¿‡ä¿®è¡¥ä»£ç æ¥æŒ‡å¯¼æ‚¨ã€‚å¦‚æœä½ ï¼†ï¼ƒ39;é‡æ–°è¦æ±‚ä¸€äº›é€šç”¨è¡Œä¸ºï¼Œç¼–è¯‘å™¨ä¼šæŠ±æ€¨å’Œä½ ï¼†ï¼ƒ39; llå¿…é¡»æ·»åŠ å¦ä¸€ä¸ªç‰¹å¾å®ç°ï¼Œä»¥ä¾¿è¯¥æ­»çš„ç¡®å®šï¼†ï¼ƒ39;é‡æ–°å…è®¸ç»§ç»­ã€‚</p><p>  I also chose a particularly easy example: there&#39;s no associated data (like a string) in my  Point&lt;T&gt;, so I don&#39;t need to prove to the compiler that my data doesn&#39;t outlive its uses - those are  lifetimes, and they can get hairy, fast, but you&#39;ll run into them eventually. I also don&#39;t know how easily you could handle multiple generic types and the compile time penalties associated with them.</p><p>  æˆ‘ä¹Ÿé€‰æ‹©äº†ä¸€ä¸ªç‰¹åˆ«å®¹æ˜“çš„ä¾‹å­ï¼šåœ¨æˆ‘çš„ç‚¹ä¸­æ²¡æœ‰å…³è”çš„æ•°æ®ï¼ˆå¦‚å­—ç¬¦ä¸²ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä¸éœ€è¦å‘ç¼–è¯‘å™¨è¯æ˜æˆ‘çš„æ•°æ®å¹¶åœ¨ï¼†ï¼ƒ39; tæŒç»­å®ƒçš„ç”¨é€” - é‚£äº›æ˜¯å¯¿å‘½ï¼Œä»–ä»¬å¯ä»¥å¿«é€Ÿï¼Œå¿«é€Ÿï¼Œä½†æ˜¯ä½ æœ€ç»ˆè·‘è¿›äº†ä»–ä»¬ã€‚æˆ‘ä¹Ÿæ²¡æœ‰çŸ¥é“æ‚¨å¯ä»¥å¦‚ä½•å®¹æ˜“åœ°å¤„ç†å¤šç§é€šç”¨ç±»å‹å’Œä¸å®ƒä»¬ç›¸å…³è”çš„ç¼–è¯‘æ—¶é—´æƒ©ç½šã€‚</p><p>  There&#39;s more syntax up front compared to Julia, and not just because we&#39;re writing library code here. Pythonistas can pick up Julia within a few hours and be productive. Rust has a lot more surface area to cover in learning the language: references, traits, impls, enums, lifetimes, pattern matching with  match, macros, cargo flags for configuration, ownership and borrowing, Send and Sync...</p><p>  ä¸Juliaç›¸æ¯”ï¼Œåœ¨å‰é¢çš„æ¯”è¾ƒæ–¹é¢çš„è¯­æ³•æ›´å¤šï¼Œè€Œä¸ä»…ä»…æ˜¯å› ä¸ºæˆ‘ä»¬åœ¨è¿™é‡Œç¼–å†™åº“ä»£ç ã€‚ Pythonistaså¯ä»¥åœ¨å‡ ä¸ªå°æ—¶å†…æ‹¿èµ·æœ±è‰å¨…å¹¶å¯Œæœ‰æˆæ•ˆã€‚ Ruståœ¨å­¦ä¹ è¯­è¨€æ—¶æœ‰å¾ˆå¤šè¡¨é¢ç§¯ï¼šå‚è€ƒæ–‡çŒ®ï¼Œç‰¹å¾ï¼Œé”¯ç‰‡ï¼Œæšä¸¾ï¼Œå¯¿å‘½ï¼Œä¸åŒ¹é…ï¼Œå®ï¼Œè´§ç‰©æ ‡å¿—è¿›è¡Œé…ç½®ï¼Œæ‰€æœ‰æƒå’Œå€Ÿç”¨ï¼Œå‘é€å’ŒåŒæ­¥...... </p><p>  Whodathunkit, Garbage Collectors let you worry about other things for a small runtime price. They might not be right for every use case but they&#39;re a solid investment.</p><p>Whodathunkitï¼Œåƒåœ¾æ”¶é›†å™¨è®©æ‚¨æ‹…å¿ƒå…¶ä»–äº‹æƒ…çš„å°å‹è¿è¡Œæ—¶ä»·æ ¼ã€‚å®ƒä»¬å¯èƒ½å¯¹æ¯ç§ç”¨ä¾‹éƒ½ä¸é€‚åˆï¼Œä½†å®ƒä»¬ï¼†ï¼ƒ39;é‡æ–°æŠ•èµ„ã€‚</p><p>      There&#39;s a steep wall to climb when starting out with Rust - however, they&#39;ve nailed the user experience for learning tough stuff. I think it was Esteban Kuber who said something along the lines of &#34;We weren&#39;t missing a sufficiently smart compiler, but a more empathetic one&#34;.</p><p>      å½“ä¸é”ˆç—…å¼€å§‹æ—¶ï¼Œåœ¨é‚£é‡Œçˆ¬ä¸Šé™¡å³­çš„å¢™å£ - ä½†æ˜¯ï¼Œä»–ä»¬å®£å¸ƒäº†å­¦ä¹ è‰°éš¾çš„ä¸œè¥¿çš„ç”¨æˆ·ä½“éªŒã€‚æˆ‘è®¤ä¸ºè¿™æ˜¯æ²¿ç€ï¼†ï¼ƒ34çš„çº¿æ¡çš„Esteban Kuber;æˆ‘ä»¬ä¸å–œæ¬¢ç¼ºå°‘ä¸€ä¸ªè¶³å¤Ÿèªæ˜çš„ç¼–è¯‘å™¨ï¼Œè€Œæ˜¯ä¸€ä¸ªæ›´åŠ å‹å¥½çš„ä¸€ä¸ªï¼†ï¼ƒ34;</p><p>  Alright, so what&#39;s the view from the top look like? Like Julia, Rust is an incumbent in a crowded space, so how has it punched above it&#39;s weight against the established candidates?</p><p>  å¥½å§ï¼Œæ‰€ä»¥ä»€ä¹ˆï¼†ï¼ƒ39;ä»é¡¶éƒ¨çœ‹èµ·æ¥åƒä»€ä¹ˆæ ·çš„è§†å›¾ï¼Ÿåƒæœ±è‰å¨…ä¸€æ ·ï¼ŒRustæ˜¯ä¸€ä¸ªæ‹¥æŒ¤çš„ç©ºé—´çš„ç°ä»»ï¼Œæ‰€ä»¥å®ƒå¦‚ä½•å†²åˆ°å®ƒä¸Šé¢ï¼†ï¼ƒ39;å¯¹æ—¢å®šå€™é€‰äººçš„é‡é‡ï¼Ÿ</p><p>  Here&#39;s a list of all the projects that I&#39;ve found particularly of note to Julians.</p><p>  è¿™é‡Œçš„æ‰€æœ‰é¡¹ç›®çš„åˆ—è¡¨éƒ½æ˜¯æˆ‘ï¼†ï¼ƒ39;åœ¨æœ±è‰å®‰äººçš„ç¬”è®°ä¸­å‘ç°çš„æ‰€æœ‰é¡¹ç›®çš„åˆ—è¡¨ã€‚</p><p>  rayon is the original reason I got interested in Rust. Check their  hello world - the promise is that if you are using iterators, you can swap (mostly)  iter() for  par_iter() and at compile time you can know if your code will run in parallel. That&#39;s just about the friendliest user interface to parallelism besides  Threads.@threads, and with some additional guarantees - a small update loop is easy to keep the invariants in your head, but it really pays when the Rust compiler catches a concurrency bug that spanned multiple files, modules and data structures. Cool tech note: Rayon uses the  same idea for work stealing thread scheduler that Julia&#39;s parallel task run time system uses (inspired by Cilk, get it? &#39;Cuz Rayon is a fake silk? Ha...).</p><p>  äººé€ ä¸æ˜¯æˆ‘å¯¹ç”Ÿé”ˆæ„Ÿå…´è¶£çš„åŸå› ã€‚æ£€æŸ¥ä»–ä»¬çš„Hello World  - æ‰¿è¯ºæ˜¯ï¼Œå¦‚æœæ‚¨ä½¿ç”¨çš„æ˜¯è¿­ä»£å™¨ï¼Œåˆ™å¯ä»¥åœ¨Par_iterï¼ˆï¼‰å’Œç¼–è¯‘æ—¶äº¤æ¢ï¼ˆå¤§å¤šæ•°ï¼‰iterï¼ˆï¼‰ï¼Œæ‚¨å¯ä»¥çŸ¥é“ä»£ç æ˜¯å¦æ­£å¸¸è¿è¡Œã€‚ ï¼†ï¼ƒ39; såªæ˜¯å…³äºçº¿ç¨‹çš„å¹¶è¡Œæ€§çš„æœ€å‹å¥½çš„ç”¨æˆ·ç•Œé¢ã€‚@çº¿ç¨‹ï¼Œä»¥åŠä¸€äº›é¢å¤–çš„ä¿è¯ - ä¸€ä¸ªå°çš„æ›´æ–°å¾ªç¯å¾ˆå®¹æ˜“ä¿ç•™å¤´éƒ¨çš„ä¸å˜æ€§ï¼Œä½†å®ƒçœŸçš„ä»˜å‡ºä»£ä»·ï¼Œä½†æ˜¯å½“Rustç¼–è¯‘å™¨æ•è·å¹¶å‘æ—¶ç¡®å®ä»˜å‡ºä»£ä»·è·¨è¶Šå¤šä¸ªæ–‡ä»¶ï¼Œæ¨¡å—å’Œæ•°æ®ç»“æ„çš„é”™è¯¯ã€‚ Cool Techæ³¨æ„ï¼šRayonä½¿ç”¨åŒæ ·çš„å·¥ä½œçªƒå–çº¿ç¨‹è°ƒåº¦ç¨‹åºï¼Œæœ±è‰å¨…ï¼†ï¼ƒ39; Så¹¶è¡Œä»»åŠ¡è¿è¡Œæ—¶é—´ç³»ç»Ÿä½¿ç”¨ï¼ˆç”±Cilkå¯å‘ï¼Œå¾—åˆ°å®ƒï¼Ÿï¼†ï¼ƒ39; Cuzäººé€ ä¸æ˜¯å‡ä¸ç»¸......ï¼‰ ã€‚</p><p>  tokio deserves a mention as well for its capabilities for asynchronous programming, but I am not familiar enough with it to comment on it. Rust people get excited about it though!</p><p>  Tokioä¹Ÿå€¼å¾—æåŠå…¶å¼‚æ­¥ç¼–ç¨‹çš„èƒ½åŠ›ï¼Œä½†æˆ‘ä¸ç†Ÿæ‚‰å®ƒå¯ä»¥è¯„è®ºå®ƒã€‚ç”Ÿé”ˆäººå¯¹æ­¤æ„Ÿåˆ°å…´å¥‹ï¼</p><p>    egg and related projects like  herbie: A wicked fast egraph matching engine - a great competitor and inspiration for the Symbolics.jl ecosystem.</p><p>    é¸¡è›‹å’Œç›¸å…³é¡¹ç›®å¦‚herbieï¼šä¸€ä¸ªé‚ªæ¶çš„å¿«é€Ÿå¿«é€Ÿå‘ˆç°å¼•æ“ - ä¸€ä¸ªä¼Ÿå¤§çš„ç«äº‰å¯¹æ‰‹å’Œçµæ„Ÿç¬¦å·.jlç”Ÿæ€ç³»ç»Ÿã€‚ </p><p>  MMtk and GCs: Garbage Collectors are a family of algorithms that share behaviour, and different strategies can be built atop of tweakable parameters. The promise for building a configurable, performant and battle-tested back-end for Garbage Collectors is alive with this project by Steve Blackburn and gang. If you haven&#39;t heard of  Immix or  Floorplan, enjoy the rabbithole. If you&#39;re new to GCs,  this is a good starting point for seasoned Julians.</p><p>MMTKå’ŒGCSï¼šåƒåœ¾æ”¶é›†å™¨æ˜¯ä¸€ä¸ªå…±äº«è¡Œä¸ºçš„ä¸€ç³»åˆ—ç®—æ³•ï¼Œå¯ä»¥åœ¨å¯è°ƒå‚æ•°ä¸Šå»ºç«‹ä¸åŒçš„ç­–ç•¥ã€‚åƒåœ¾æ”¶é›†å™¨å»ºç«‹å¯é…ç½®ï¼Œè¡¨æ¼”å’Œæˆ˜æ–—çš„åç«¯çš„æ‰¿è¯ºä¸å²è’‚å¤«å¸ƒæ‹‰åº•å ¡å’Œå›¢ä¼™ä¸€èµ·æ´»ç€è¿™ä¸ªé¡¹ç›®ã€‚å¦‚æœæ‚¨æ²¡æœ‰å¬åˆ°Immixæˆ–Ploorplanï¼Œåˆ™äº«å—rabbitholeã€‚å¦‚æœä½ ï¼†ï¼ƒ39;é‡æ–°åˆ°GCSï¼Œè¿™æ˜¯ç»éªŒä¸°å¯Œçš„æœ±è‰å®‰çš„ä¸€ä¸ªå¾ˆå¥½çš„èµ·ç‚¹ã€‚</p><p>  Rust CLI: Rust people feel comfortable working in the terminal, and they&#39;ve taken that user experience Very Seriously and have a top notch performance and user experience for their command line CLIs. Here&#39;s a few of my favorites - you only need to  cargo install foo and they should be properly installed on your system.</p><p>  Rust Cliï¼šRustäººä»¬è§‰å¾—åœ¨ç»ˆç«¯å·¥ä½œèˆ’é€‚ï¼Œä»–ä»¬ï¼†ï¼ƒ39;ç”¨æˆ·ä½“éªŒéå¸¸é‡è§†ï¼Œå¹¶ä¸ºä»–ä»¬çš„å‘½ä»¤è¡ŒCLISæ‹¥æœ‰é¡¶çº§çš„è¡¨ç°å’Œç”¨æˆ·ä½“éªŒã€‚åœ¨è¿™é‡Œï¼Œæˆ‘çš„ä¸€äº›æœ€çˆ± - ä½ åªéœ€è¦è´§ç‰©å®‰è£…fooï¼Œå®ƒä»¬åº”è¯¥åœ¨ç³»ç»Ÿä¸Šæ­£ç¡®å®‰è£…ã€‚</p><p>  zoxide: directory autojumper. I don&#39;t really do  cd ../.. climbing around anymore I just do  z foo a couple of times and that usually guesses right.</p><p>  å·¦æ’‡å­ï¼šç›®å½•è‡ªåŠ¨jumumperã€‚æˆ‘æ²¡æœ‰çœŸæ­£åšCD .. ......çˆ¬è¡Œï¼Œæˆ‘çˆ¬äº†å‡ æ¬¡ï¼Œè¿™é€šå¸¸çŒœæµ‹ã€‚</p><p>  coz: Invaluable tool for  causal profiling.  Emery Berger&#39;s presentation alone is worth knowing about this project. I reeeeeally want to nerdsnipe someone to port this to Julia.</p><p>  COZï¼šå› æœåˆ†æçš„å®è´µå·¥å…·ã€‚ç‹¬è‡ªå±•ç¤ºçš„emery bergerï¼†ï¼ƒ39æ˜¯å€¼å¾—äº†è§£è¿™ä¸ªé¡¹ç›®ã€‚æˆ‘é‡æ–°æ¬£å–œåœ°å¸Œæœ›æœ‰äººæ¬åˆ°æœ±è‰å¨…ã€‚</p><p>  sled&#39;s approach to benchmarking and databases is top-notch. Also worthy of note is the same author&#39;s  rio crate, which is a Rust interface for the  io_uring linux kernel module, which can significantly speed up asynchronous programming. There&#39;s some WIP PRs for landing this for  libuv, Julia&#39;s thread runtime backend, and that effort  is close to wrapping up.</p><p>  é›ªæ©‡ï¼†ï¼ƒ39;åŸºå‡†æµ‹è¯•å’Œæ•°æ®åº“çš„æ–¹æ³•æ˜¯é¡¶éƒ¨ç¼ºå£ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯åŒæ ·çš„ä½œè€…ï¼†ï¼ƒ39; s rio crateï¼Œè¿™æ˜¯ä¸€ä¸ªç”¨äºio_ing linuxå†…æ ¸æ¨¡å—çš„ç”Ÿé”ˆç•Œé¢ï¼Œè¿™å¯ä»¥æ˜¾ç€åŠ é€Ÿå¼‚æ­¥ç¼–ç¨‹ã€‚åœ¨Libuvï¼ŒJuliaï¼†ï¼ƒ39; STREENè¿è¡Œæ—¶åç«¯çš„ä¸€äº›WIP PRSçš„ä¸€äº›WIP PRSï¼Œå¹¶ä¸”è¯¥åŠªåŠ›å°†æ¥è¿‘åŒ…è£…ã€‚</p><p>  Rust FFT: They beat FFTW in some cases with this one, so it seems worthwhile to take a look ğŸ‘€ .</p><p>  ç”Ÿé”ˆFFTï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä»–ä»¬åœ¨æŸäº›æƒ…å†µä¸‹å‡»è´¥äº†FFTWï¼Œæ‰€ä»¥çœ‹èµ·æ¥å¾ˆå€¼å¾—çœ‹çœ‹â™¥ã€‚</p><p>  Green function evaluation kernels: Newer package, but I&#39;d like to see how special functions pan out in Rust land.</p><p>  ç»¿è‰²å‡½æ•°è¯„ä¼°å†…æ ¸ï¼šè¾ƒæ–°çš„åŒ…ï¼Œä½†æ˜¯æˆ‘å–œæ¬¢çœ‹å¤šåŠŸèƒ½åœ¨é”ˆçš„åœŸåœ°ä¸Šçš„ç‰¹æ®ŠåŠŸèƒ½ã€‚ </p><p>  Polars: A highly tuned dataframes implementation for some use cases. They&#39;ve topped the charts in some of the  H20ai benchmarks, so they&#39;ve definitely got technical chops. (They beat DataFrames.jl because of a sparsification trick which is a bit non-trivial to implement, but there&#39;s not necessarily an impediment to matching their speed.)</p><p>æ³¢æ‹‰ï¼šä¸€äº›ä½¿ç”¨æ¡ˆä¾‹çš„é«˜åº¦è°ƒæ•´çš„Dataframeså®ç°ã€‚ä»–ä»¬ï¼†ï¼ƒ39;åœ¨ä¸€äº›H20AIåŸºå‡†ä¸­ï¼Œå®ƒä»¬é½å…¨åœ°é¥°æ¼”äº†å›¾è¡¨ï¼Œæ‰€ä»¥å®ƒä»¬è‚¯å®šæœ‰æŠ€æœ¯å½•éŸ³ã€‚ ï¼ˆä»–ä»¬å‡»è´¥äº†DataFrames.jlï¼Œå› ä¸ºç¨€ç–æŠ€å·§æœ‰ç‚¹ä¸çç¢ï¼Œä½†æ˜¯åœ¨é‚£é‡Œï¼†ï¼ƒ39; sä¸ä¸€å®šæ˜¯åŒ¹é…å®ƒä»¬çš„é€Ÿåº¦çš„éšœç¢ã€‚ï¼‰</p><p>  Loom: a model checker for atomic primitives, sister project to  tokio. I think Julia is a more natural fit for this approach given the ease of operator overloading and it will be great to try something similar once Jameson&#39;s atomics PR lands.</p><p>  LOOMï¼šç”¨äºåŸå­åŸºå…ƒçš„æ¨¡å‹æ£€æŸ¥å™¨ï¼ŒTokioçš„å§å¦¹é¡¹ç›®ã€‚æˆ‘è®¤ä¸ºæœ±è‰å¨…å¯¹è¿™ç§æ–¹æ³•æ›´åŠ è‡ªç„¶çš„å¥‘åˆé‰´äºæ“ä½œå‘˜è¿‡è½½ï¼Œè¿™å°†æ˜¯ä¸€ä¸ªè©¹å§†æ£®ï¼†ï¼ƒ39;åŸå­å­¦å…¬å…³çš„ç±»ä¼¼ä¸€äº›ç±»ä¼¼çš„ä¸œè¥¿ã€‚</p><p>  Creusot: Add some macros to your Rust code, and have it formally verified by Why3.</p><p>  Creusotï¼šå°†ä¸€äº›å®æ·»åŠ åˆ°ç”Ÿé”ˆä»£ç ä¸­ï¼Œå¹¶é€šè¿‡Whe3æ­£å¼éªŒè¯ã€‚</p><p>  proptest: Configure strategies for exploring type instantiations to fuzz your tests, shrink the cases, and automatically track regressions. Impressive stuff!</p><p>  proptestï¼šé…ç½®æ¢ç´¢å‹å®ä¾‹åŒ–çš„ç­–ç•¥ä»¥ä½¿æ‚¨çš„æµ‹è¯•æ¨¡ç³Šï¼Œç¼©å°æ¡ˆä¾‹ï¼Œå¹¶è‡ªåŠ¨è·Ÿè¸ªå›å½’ã€‚ä»¤äººå°è±¡æ·±åˆ»çš„ä¸œè¥¿ï¼</p><p>  Gleam and  Lumen: Gleam is a Rust backend for an Erlang based language and Lumen is a Rewritten-in-Rust implementation of the ErlangVM, BEAM. Erlang is a concurrency monster, and their actor based model is scalable as hell for certain workloads. I&#39;m glad to see Julia start to step into that domain with  Actors.jl. This seems to be the  right way to abstract for fault tolerance workloads.</p><p>  é—ªé—ªå‘å…‰çš„å’Œè…”ï¼šé—ªå…‰æ˜¯ä¸€ç§ç£¨ç‰™åç«¯ï¼Œæ˜¯åŸºäºerlangçš„è¯­è¨€ï¼Œæµæ˜æ˜¯ä¸€ç§é‡å†™çš„res-in-rus-rust-in-rudvmï¼Œæ¢ã€‚ Erlangæ˜¯ä¸€ä¸ªå¹¶å‘æ€ªç‰©ï¼Œå®ƒä»¬çš„æ¼”å‘˜çš„æ¨¡å‹å¯æ‰©å±•ä¸ºæŸäº›å·¥ä½œè´Ÿè½½ã€‚æˆ‘å¾ˆé«˜å…´çœ‹åˆ°æœ±è‰å¨…å¼€å§‹é€æ­¥å‚åŠ actors.jlã€‚è¿™ä¼¼ä¹æ˜¯æŠ½è±¡å®¹é”™å·¥ä½œè´Ÿè½½çš„æ­£ç¡®æ–¹æ³•ã€‚</p><p>  There&#39;s oodles more. Check out  crates.io or  lib.rs if you want to explore more (this is their community based JuliaHub equivalent).</p><p>  åœ¨é‚£é‡Œæ›´å¤šã€‚å¦‚æœæ‚¨æƒ³æ¢ç´¢æ›´å¤šï¼ˆè¿™æ˜¯ä»–ä»¬çš„ç¤¾åŒºjuliahubç­‰æ•ˆï¼‰ï¼Œè¯·ç­¾å‡ºç®±å­.IOæˆ–lib.rsã€‚</p><p>  I&#39;ll make a special note of  evcxr, a Rust REPL. For now, I don&#39;t think it&#39;s profitable to use Rust with a REPL-like workflow. I&#39;m too used to that in Julia, and that works well there, but I think there&#39;s a risk of digging yourself into a &#34;Everything must be a REPL&#34; mentality and cutting yourself off from learning opportunities. In Rust land, I don&#39;t mind doing as the Rustaceans do and learning to do things around a command line, navigating compiler errors and configuring flags and features for certain behaviours or deployment options. Since that&#39;s the package that I wanted to learn when I bought into Rust, I don&#39;t mind adapting into that mindset. I still wish them all the best and hope they can make the best possible Rust REPL - I&#39;d love to be wrong on this down the road.</p><p>  æˆ‘ï¼†ï¼ƒ39; llæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„evcxrï¼Œä¸€ä¸ªé”ˆçš„reftã€‚ç°åœ¨ï¼Œæˆ‘ä¸è®¤ä¸ºå®ƒï¼†ï¼ƒ39;ï¼†ï¼ƒ39;ä½¿ç”¨Rustçš„å·¥ä½œæµç¨‹ä½¿ç”¨Rustã€‚æˆ‘ä¹Ÿä¹ æƒ¯äº†åœ¨æœ±è‰å¨…ï¼Œåœ¨é‚£é‡Œå·¥ä½œï¼Œä½†æˆ‘è®¤ä¸ºé‚£é‡Œçš„é£é™©å°†è‡ªå·±æŒ–æ˜åˆ°Aï¼†ï¼ƒ34;ä¸€åˆ‡éƒ½å¿…é¡»æ˜¯æ›²æŠ˜ï¼†ï¼ƒ34;å¿ƒç†å’Œå‰Šå‡è‡ªå·±çš„å­¦ä¹ æœºä¼šã€‚åœ¨Rust Landä¸­ï¼Œæˆ‘ä¸ä»‹æ„ä½œä¸ºrustaceansåšå’Œå­¦ä¹ åœ¨å‘½ä»¤è¡Œä¸­åšäº‹ï¼Œå¯¼èˆªç¼–è¯‘å™¨é”™è¯¯å’Œé…ç½®æŸäº›è¡Œä¸ºæˆ–éƒ¨ç½²é€‰é¡¹çš„æ——å¸œå’ŒåŠŸèƒ½ã€‚è‡ªé‚£ä¸ªï¼†ï¼ƒ39;å½“æˆ‘ä¹°è¿›ç”Ÿé”ˆæ—¶æˆ‘æƒ³å­¦ä¹ çš„åŒ…è£¹ï¼Œæˆ‘ä¸ä»‹æ„è°ƒæ•´è¿™ä¸€å¿ƒæ€ã€‚æˆ‘ä»ç„¶å¸Œæœ›ä»–ä»¬ä¸€åˆ‡é¡ºåˆ©ï¼Œå¹¶å¸Œæœ›ä»–ä»¬èƒ½å¤Ÿåˆ¶ä½œæœ€å¥½çš„é”ˆç—… - æˆ‘ï¼†ï¼ƒ39; dåœ¨è¿™æ¡è·¯ä¸Šæœ‰é”™ã€‚ </p><p>      If you want to dive deep into nitty gritty performance fundamentals, these are the best guides I found for explaining the tradeoffs, gotchas, mental model, and engineering for those tasty, tasty flops.</p><p>å¦‚æœæ‚¨æƒ³æ·±å…¥è¿›å…¥Nitty Gittyæ€§èƒ½åŸºç¡€ï¼Œè¿™äº›æ˜¯æˆ‘å‘ç°çš„æœ€ä½³æŒ‡å—ï¼Œå³ç”¨äºè§£é‡Šé‚£äº›ç¾å‘³ï¼Œç¾å‘³çš„ç¬¨è›‹çš„æƒè¡¡ï¼ŒGotchasï¼ŒMental Modelå’Œå·¥ç¨‹ã€‚</p><p>  COST paper: Maybe doesn&#39;t fit here but this is one of my favorite papers and everyone should read it.</p><p>  æˆæœ¬çº¸ï¼šä¹Ÿè®¸ä¸é€‚åˆè¿™é‡Œï¼Œä½†è¿™æ˜¯æˆ‘æœ€å–œæ¬¢çš„è®ºæ–‡ä¹‹ä¸€ï¼Œæ¯ä¸ªäººéƒ½åº”è¯¥é˜…è¯»å®ƒã€‚</p><p>      So Rust is &#34;worth learning&#34;, but these are roadblocks that I faced and would warn others about to save them some grief.</p><p>      æ‰€ä»¥Rustæ˜¯ï¼†ï¼ƒ34;å€¼å¾—å­¦ä¹ ï¼†ï¼ƒ34;ä½†æ˜¯è¿™äº›æ˜¯æˆ‘é¢ä¸´çš„éšœç¢ï¼Œå¹¶ä¼šè­¦å‘Šå…¶ä»–äººå³å°†æ‹¯æ•‘ä»–ä»¬ä¸€äº›æ‚²ä¼¤ã€‚</p><p>  You can learn another hobby waiting for Rust projects to compile. The price for compile-time guarantees/being the designated driver in the codebase is offloading more work to the compiler. They&#39;re working on leveraging concurrency for speeding up the pipeline, and it&#39;s gotten better. Let&#39;s just say they also suffer from TTFP ğŸ˜‰ .</p><p>  æ‚¨å¯ä»¥å­¦ä¹ å…¶ä»–ä¸šä½™çˆ±å¥½ç­‰å¾…é”ˆçš„é¡¹ç›®ç¼–è¯‘ã€‚ç¼–è¯‘æ—¶æ‹…ä¿çš„ä»·æ ¼/æ˜¯ä»£ç åº“ä¸­æŒ‡å®šçš„é©±åŠ¨ç¨‹åºå¯¹ç¼–è¯‘å™¨å¸è½½äº†æ›´å¤šçš„å·¥ä½œã€‚ä»–ä»¬ï¼†ï¼ƒ39;é‡æ–°åŠªåŠ›åˆ©ç”¨å¹¶å‘åŠ é€Ÿç®¡é“ï¼Œå¹¶è¾¾åˆ°æ›´å¥½çš„ï¼†ï¼ƒ39;è®©ï¼†ï¼ƒ39; Såªæ˜¯è¯´ä»–ä»¬ä¹Ÿæ‚£æœ‰TTFPâ™¥ã€‚</p><p>  Learn to run your code with  cargo run --release  and other tricks. This is the equivalent to running your Julia code with globals (or  -O0 flags), and it&#39;s an easy gotcha. This will not change in Rust.</p><p>  å­¦ä¹ ç”¨è´§ç‰©è¿è¡Œçš„ä»£ç  - é‡Šæ”¾å’Œå…¶ä»–æŠ€å·§ã€‚è¿™ç›¸å½“äºä½¿ç”¨å…¨å±€ï¼ˆæˆ–-o0æ ‡å¿—ï¼‰è¿è¡Œæœ±è‰å¨…ä»£ç ï¼Œå®ƒæ˜¯ä¸€ä¸ªç®€å•çš„gotchaï¼†ï¼ƒ39;è¿™ä¸ä¼šæ”¹å˜ç”Ÿé”ˆã€‚</p><p>  Rust people keep saying they have no Garbage Collector, when they have a Region Based Garbage Collector. It&#39;s all fun and games until they have to implement those linked lists...</p><p>  ç”Ÿé”ˆäººä»¬ä¸€ç›´è¯´ä»–ä»¬æ²¡æœ‰åƒåœ¾æ”¶é›†å™¨ï¼Œå½“ä»–ä»¬æœ‰ä¸€ä¸ªåŸºäºåœ°åŒºçš„åƒåœ¾æ”¶é›†å™¨æ—¶ã€‚å®ƒï¼†ï¼ƒ39;æ—¢æœ‰ä¹è¶£å’Œæ¸¸æˆï¼Œç›´åˆ°ä»–ä»¬å¿…é¡»å®æ–½è¿™äº›é“¾æ¥çš„æ¸…å•......</p><p>  Don&#39;t add crates manually! Install  cargo-add, use it to manage crate dependencies. That and some other tricks are great from doing the  AdventOfCode2020 from the article above.</p><p>  Donï¼†ï¼ƒ39; tæ‰‹åŠ¨æ·»åŠ ç®±å­ï¼å®‰è£…Cargo-Addï¼Œä½¿ç”¨å®ƒæ¥ç®¡ç†Crateä¾èµ–é¡¹ã€‚é™¤äº†ä¸Šé¢çš„æ–‡ç« ä¸­ï¼Œè¿™ä¸å…¶ä»–ä¸€äº›è¯€çªå¾ˆå¥½åœ°å®Œæˆäº†adventofcode2020ã€‚ </p><p>  For numerics, install  ndarray and  num_traits. Linear Algebra and numerics where not a primary focus of Rust when starting out as they were with Julia.</p><p>ç”¨äºæ•°å­—ï¼Œå®‰è£…ndArrayå’Œnum_traitsã€‚çº¿æ€§ä»£æ•°å’Œæ•°å­—ï¼Œåœ¨å¼€å§‹æ—¶ä¸æ˜¯æœ±è‰å¨…çš„åŸå§‹é‡ç‚¹ã€‚</p><p>  Setup your  rust-analyzer and  error lens plugins on VSCode or IDE asap, you&#39;ll thank me later. Rust-land expects you to be in constant dialogue with the compiler, and making that iteration cycle as ergonomic as possible will yield dividends in the long run. What we don&#39;t get from accessing help docs in the REPL, Rust people keep a terminal tab handy where they run  cargo watch -c and get continuous feedback from the compiler.</p><p>  åœ¨vscodeæˆ–IDEä¸Šè®¾ç½®ç”Ÿé”ˆåˆ†æä»ªå’Œé”™è¯¯é•œå¤´æ’ä»¶ï¼ŒYouï¼†ï¼ƒ39; LLç¨åè°¢è°¢ã€‚ Rust-Landå¸Œæœ›æ‚¨ä¸ç¼–è¯‘å™¨ä¿æŒä¸å˜çš„å¯¹è¯ï¼Œå¹¶ä½¿è¿­ä»£å‘¨æœŸå°½å¯èƒ½ç¬¦åˆäººä½“å·¥ç¨‹å­¦ï¼Œä»é•¿è¿œæ¥çœ‹ä¼šäº§ç”Ÿçº¢åˆ©ã€‚æˆ‘ä»¬ä¸ä»Replä¸­è®¿é—®Help Docsè®¿é—®ï¼ŒRustäººå‘˜ä¿ç•™ç»ˆç«¯é€‰é¡¹å¡ï¼Œåœ¨é‚£é‡Œè¿è¡ŒCargo Watch -Cå¹¶è·å¾—ç¼–è¯‘å™¨çš„è¿ç»­åé¦ˆã€‚</p><p>  You CAN&#39;T index into a String in Rust with ints!  Instead use slices like  &amp;str[1..] == str[2:end], if I may riff on Rust and Julia syntax in the equality just there.</p><p>  ä½ å¯ä»¥ï¼†ï¼ƒ39; tç´¢å¼•åˆ°ructçš„å­—ç¬¦ä¸²ä¸­ä¸intsï¼è€Œæ˜¯ä½¿ç”¨åƒï¼†ampçš„ç‰‡; str [1 ..] == str [2ï¼šç»“æŸ]ï¼Œå¦‚æœæˆ‘å¯ä»¥åœ¨é‚£é‡Œçš„å¹³ç­‰ä¸­çš„rustå’Œjuliaè¯­æ³•ä¸Šriffã€‚</p><p>  Reading from  stdin is a pain as a newcomer. I wanted to try out some competitive coding exercises and reading from  stdin was waaaay too rough for me at first. Eventually I cobbled this template up  link here so that you don&#39;t struggle if you want to try a couple of CodeForces problems.</p><p>  ä»STDINé˜…è¯»æ˜¯ä¸€ç§ç—›è‹¦ä½œä¸ºæ–°äººã€‚æˆ‘æƒ³å°è¯•ä¸€äº›æœ‰ç«äº‰åŠ›çš„ç¼–ç ç»ƒä¹ ï¼Œå¹¶ä»Stdiné˜…è¯»æ˜¯Waaaayèµ·åˆå¯¹æˆ‘æ¥è¯´å¤ªç²—ç³™äº†ã€‚æœ€ç»ˆæˆ‘æŠŠè¿™ä¸ªæ¨¡æ¿æ—‹è½¬åˆ°è¿™é‡Œè”ç³»åœ¨è¿™é‡Œï¼Œä»¥ä¾¿ä½ ä¸è¦æŒ£æ‰ï¼Œå¦‚æœä½ æƒ³å°è¯•å‡ ä¸ªä»£ç çš„é—®é¢˜ã€‚</p><p>  Not having a generic  rand is just painful. So painful. This is my easiest workaround so far for generating a vector of  n random entries:</p><p>  æ²¡æœ‰ä»¿åˆ¶å…°ç‰¹åªæ˜¯ç—›è‹¦ã€‚å¦‚æ­¤ç—›è‹¦ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¿™æ˜¯æˆ‘æœ€ç®€å•çš„è§£å†³æ–¹æ³•ï¼Œä»¥ç”ŸæˆNä¸ªéšæœºæ¡ç›®çš„å‘é‡ï¼š</p><p>      There is no  @code_native and friends in Rust - your best bet is to use the Rust Playground and click on the  ... to have it emit the total assembly. This only works for the top 100 most popular crates though. You can  cargo run --release -- --emit=llvm-ir/asm and then fish the results out of  target/, but that&#39;s un</p><p>      æ²¡æœ‰@code_nativeå’Œfriendåœ¨forr  - ä½ æœ€å¥½çš„é€‰æ‹©æ˜¯ä½¿ç”¨é“é”ˆæ¸¸ä¹åœºï¼Œç„¶åç‚¹å‡»......è®©å®ƒå‘å‡ºæ€»è£…é…ã€‚è¿™ä»…é€‚ç”¨äºå‰100åæœ€å—æ¬¢è¿çš„ç®±å­ã€‚æ‚¨å¯ä»¥è´§ç‰©è¿è¡Œ -   - é‡Šæ”¾ -   -   -  emit = llvm-Ir / asmï¼Œç„¶åå°†ç»“æœæ•è·å‡ºç›®æ ‡/ï¼Œä½†æ˜¯ï¼†ï¼ƒ39; sè”åˆå›½</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://miguelraz.github.io/blog/juliatorust/">https://miguelraz.github.io/blog/juliatorust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/julia/">#julia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ç”Ÿé”ˆ/">#ç”Ÿé”ˆ</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>