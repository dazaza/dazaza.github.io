<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>æŒ‰ç´ æ•°ç»˜ç”»ï¼ˆ2018ï¼‰ Painting by Prime Number (2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Painting by Prime Number (2018)<br/>æŒ‰ç´ æ•°ç»˜ç”»ï¼ˆ2018ï¼‰ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-23 21:16:07</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/949a1ab28fff50871b248c1525b1618f.png"><img src="http://img2.diglog.com/img/2020/12/949a1ab28fff50871b248c1525b1618f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Two weeks ago I stumbled upon the concept of  prime portraits. In short, prime portraits are pictures in which each color is assigned a number. When we align every pixel, the result should be a prime number. Because I could not find the code used in the article, I decided to recreate these prime portraits in Python â€“ in color! Below is the Jupyter Notebook with the code ( also available on Github) I used to generate the Mona Lisa:</p><p>ä¸¤ä¸ªæ˜ŸæœŸå‰ï¼Œæˆ‘å¶ç„¶å‘ç°äº†ä¸»è¦è‚–åƒçš„æ¦‚å¿µã€‚ç®€è€Œè¨€ä¹‹ï¼ŒåŸå§‹äººåƒæ˜¯ä¸ºæ¯ç§é¢œè‰²åˆ†é…äº†ç¼–å·çš„å›¾ç‰‡ã€‚å½“æˆ‘ä»¬å¯¹é½æ¯ä¸ªåƒç´ æ—¶ï¼Œç»“æœåº”è¯¥æ˜¯è´¨æ•°ã€‚å› ä¸ºæ‰¾ä¸åˆ°æœ¬æ–‡ä¸­ä½¿ç”¨çš„ä»£ç ï¼Œæ‰€ä»¥æˆ‘å†³å®šç”¨Pythoné‡æ–°åˆ›å»ºè¿™äº›ä¸»è¦è‚–åƒ-å½©è‰²ï¼ä»¥ä¸‹æ˜¯Jupyterç¬”è®°æœ¬ï¼Œå…¶ä¸­åŒ…å«æˆ‘ç”¨æ¥ç”Ÿæˆã€Šè’™å¨œä¸½èã€‹çš„ä»£ç ï¼ˆä¹Ÿå¯åœ¨Githubä¸Šæ‰¾åˆ°ï¼‰ï¼š</p><p>   A prime portrait is a prime number formatted as a matrix with X digits per line. When we select a color for each digit, we can generate an image.</p><p>   ç´ æ•°è‚–åƒæ˜¯ç´ æ•°ï¼Œæ ¼å¼ä¸ºçŸ©é˜µï¼Œæ¯è¡ŒXä½æ•°å­—ã€‚å½“æˆ‘ä»¬ä¸ºæ¯ä¸ªæ•°å­—é€‰æ‹©é¢œè‰²æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç”Ÿæˆå›¾åƒã€‚</p><p> Instead of doing this for many prime numbers and color schemes until you find something that resembles a known image, I have turned the process around. I have taken iconic images, such as the Mona Lisa and Starry Night, and converted them to images with only 10 colors. I assigned a digit to each color. Then I generated many similar images with a little bit of â€˜noiseâ€™ added. The noise changed the colors in the images slightly, and thus the digits. If the digits in the image formed a prime number, I found a prime portrait!</p><p> åœ¨æ‰¾åˆ°ä¸å·²çŸ¥å›¾åƒç›¸ä¼¼çš„ä¸œè¥¿ä¹‹å‰ï¼Œæˆ‘æ²¡æœ‰é’ˆå¯¹è®¸å¤šè´¨æ•°å’Œé…è‰²æ–¹æ¡ˆè¿›è¡Œæ­¤æ“ä½œï¼Œè€Œæ˜¯æ”¹è¿‡äº†è¿™ä¸ªè¿‡ç¨‹ã€‚æˆ‘æ‹æ‘„äº†æ ‡å¿—æ€§çš„å›¾åƒï¼Œä¾‹å¦‚ã€Šè’™å¨œä¸½èã€‹å’Œã€Šæ˜Ÿå¤œã€‹ï¼Œå¹¶å°†å®ƒä»¬è½¬æ¢ä¸ºä»…10ç§é¢œè‰²çš„å›¾åƒã€‚æˆ‘ä¸ºæ¯ç§é¢œè‰²åˆ†é…äº†ä¸€ä¸ªæ•°å­—ã€‚ç„¶åï¼Œæˆ‘ç”Ÿæˆäº†è®¸å¤šç±»ä¼¼çš„å›¾åƒï¼Œå¹¶æ·»åŠ äº†ä¸€äº›â€œå™ªéŸ³â€ã€‚å™ªéŸ³ç¨å¾®æ”¹å˜äº†å›¾åƒä¸­çš„é¢œè‰²ï¼Œä»è€Œæ”¹å˜äº†æ•°å­—ã€‚å¦‚æœå›¾åƒä¸­çš„æ•°å­—å½¢æˆè´¨æ•°ï¼Œæˆ‘å‘ç°äº†è´¨æ•°ï¼</p><p> import  matplotlib.pyplot  as  plt % matplotlib  inline import  numpy  as  np import  skimage.transform import  skimage.io from  sklearn.cluster  import  KMeans import  scipy.misc from  PIL  import  Image ,  ImageFont ,  ImageDraw import  numpy  as  np from  multiprocessing  import  Pool import  time import  random import  warnings</p><p> å¯¼å…¥matplotlib.pyplotä½œä¸ºplt ï¼…matplotlibå†…è” å°†numpyå¯¼å…¥ä¸ºnp å¯¼å…¥skimage.transform å¯¼å…¥skimage.io ä»sklearn.clusterå¯¼å…¥KMeans å¯¼å…¥scipy.misc ä»PILå¯¼å…¥Imageï¼ŒImageFontï¼ŒImageDraw å°†numpyå¯¼å…¥ä¸ºnp ä»å¤šå¤„ç†å¯¼å…¥æ±  å¯¼å…¥æ—¶é—´ éšæœºå¯¼å…¥ è¿›å£è­¦å‘Š</p><p> When working with extremely long primes, the naive method of testing each divisor will take way too much time. There are a lot of prime numbers and checking your number for each possible divisor takes too long to test a lot of prime portraits.</p><p> å½“ä½¿ç”¨æé•¿çš„ç´ æ•°å·¥ä½œæ—¶ï¼Œæµ‹è¯•æ¯ä¸ªé™¤æ•°çš„å¹¼ç¨šæ–¹æ³•ä¼šèŠ±è´¹å¤ªå¤šæ—¶é—´ã€‚è´¨æ•°å¾ˆå¤šï¼Œæ£€æŸ¥æ¯ä¸ªå¯èƒ½é™¤æ•°çš„æ•°å­—éœ€è¦å¾ˆé•¿æ—¶é—´æ‰èƒ½æµ‹è¯•è®¸å¤šè´¨æ•°è‚–åƒã€‚</p><p> Instead we take a probabilistic approach to the prime numbers. The  Miller Rabin test uses heuristics to determine if a number is (probably) prime or not. I downloaded the  following code for the Miller-Rabin primality test from Rosetta code to check for primality:</p><p> ç›¸åï¼Œæˆ‘ä»¬å¯¹ç´ æ•°é‡‡å–æ¦‚ç‡æ–¹æ³•ã€‚ Miller Rabinæ£€éªŒä½¿ç”¨å¯å‘å¼æ–¹æ³•ç¡®å®šæ•°å­—æ˜¯å¦ï¼ˆå¯èƒ½ï¼‰æ˜¯è´¨æ•°ã€‚æˆ‘ä»Rosettaä»£ç ä¸‹è½½äº†ä»¥ä¸‹Miller-Rabinç´ æ•°æµ‹è¯•ä»£ç ï¼Œä»¥æ£€æŸ¥ç´ æ•°ï¼š</p><p> def  try_composite ( a ,  d ,  n ,  s ):  # test the base a to see whether it is a witness for the compositeness of n  if  pow ( a ,  d ,  n )  ==  1 :  return  False  for  i  in  range ( s ):  if  pow ( a ,  2 ** i  *  d ,  n )  ==  n - 1 :  return  False  return  True  # n is definitely composite  def  is_probable_prime ( n ,  mrpt_num_trials  =  5 ):  &#34;&#34;&#34;  Miller-Rabin primality test.   A return value of False means n is certainly not prime. A return value of  True means n is very likely a prime.  &#34;&#34;&#34;  assert  n  &gt;=  2  # special case 2  if  n  ==  2 :  return  True  # ensure n is odd  if  n  %  2  ==  0 :  return  False  # write n-1 as 2**s * d  # repeatedly try to divide n-1 by 2  s  =  0  d  =  n - 1  while  True :  quotient ,  remainder  =  divmod ( d ,  2 )  if  remainder  ==  1 :  break  s  +=  1  d  =  quotient  assert ( 2 ** s  *  d  ==  n - 1 )   for  i  in  range ( mrpt_num_trials ):  a  =  random . randrange ( 2 ,  n )  if  try_composite ( a ,  d ,  n ,  s ):  return  False   return  True  # no base tested showed n as composite assert  is_probable_prime ( 2 ) assert  is_probable_prime ( 3 ) assert  not  is_probable_prime ( 4 ) assert  is_probable_prime ( 5 ) assert  not  is_probable_prime ( 123456789 ) primes_under_1000  =  [ i  for  i  in  range ( 2 ,  1000 )  if  is_probable_prime ( i )] assert  len ( primes_under_1000 )  ==  168 assert  primes_under_1000 [ - 10 :]  ==  [ 937 ,  941 ,  947 ,  953 ,  967 ,  971 ,  977 ,  983 ,  991 ,  997 ] assert  is_probable_prime ( 6438080068035544392301298549614926991513861075340134\ 3291807343952413826484237063006136971539473913409092293733259038472039\ 7133335969549256322620979036686633213903952966175107096769180017646161\ 851573147596390153 ) assert  not  is_probable_prime ( 7438080068035544392301298549614926991513861075340134\ 3291807343952413826484237063006136971539473913409092293733259038472039\ 7133335969549256322620979036686633213903952966175107096769180017646161\ 851573147596390153 )</p><p> def try_compositeï¼ˆaï¼Œdï¼Œnï¼Œsï¼‰ï¼š  ï¼ƒæµ‹è¯•åŸºæ•°aä»¥æŸ¥çœ‹å®ƒæ˜¯å¦æ˜¯nçš„å¤åˆæ€§çš„è§è¯  å¦‚æœpowï¼ˆaï¼Œdï¼Œnï¼‰== 1ï¼š  è¿”å›False  å¯¹äºèŒƒå›´ï¼ˆsï¼‰ä¸­çš„iï¼š  å¦‚æœpowï¼ˆaï¼Œ2 ** i * dï¼Œnï¼‰== n-1ï¼š  è¿”å›False  è¿”å›Trueï¼ƒnç»å¯¹æ˜¯å¤åˆçš„  def is_probable_primeï¼ˆnï¼Œmrpt_num_trials = 5ï¼‰ï¼š  ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;  Miller-Rabinç´ æ•°æ£€éªŒã€‚   è¿”å›å€¼ä¸ºFalseæ„å‘³ç€nè‚¯å®šä¸æ˜¯ç´ æ•°ã€‚è¿”å›å€¼ä¸º  Trueè¡¨ç¤ºnå¾ˆå¯èƒ½æ˜¯ç´ æ•°ã€‚  ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;  æ–­è¨€nï¼†gt; = 2  ï¼ƒç‰¹ä¾‹2  å¦‚æœn == 2ï¼š  è¿”å›True  ï¼ƒç¡®ä¿nä¸ºå¥‡æ•°  å¦‚æœnï¼…2 == 0ï¼š  è¿”å›False  ï¼ƒå°†n-1å†™ä¸º2 ** s * d  ï¼ƒåå¤å°è¯•å°†n-1é™¤ä»¥2  s = 0  d = n-1  è€ŒTrueï¼š  å•†ï¼Œä½™æ•°= divmodï¼ˆdï¼Œ2ï¼‰  å¦‚æœä½™æ•°== 1ï¼š  æ‰“ç ´  s + = 1  d =å•†  æ–­è¨€ï¼ˆ2 ** s * d == n-1ï¼‰   å¯¹äºæˆ‘åœ¨èŒƒå›´å†…ï¼ˆmrpt_num_trialsï¼‰ï¼š  a =éšæœºçš„ã€‚ randrangeï¼ˆ2ï¼Œnï¼‰  å¦‚æœtry_compositeï¼ˆaï¼Œdï¼Œnï¼Œsï¼‰ï¼š  è¿”å›False   è¿”å›Trueï¼ƒæ²¡æœ‰æµ‹è¯•çš„åŸºç¡€æ˜¾ç¤ºnä¸ºå¤åˆ æ–­è¨€is_probable_primeï¼ˆ2ï¼‰ æ–­è¨€is_probable_primeï¼ˆ3ï¼‰ æ–­è¨€ä¸æ˜¯is_probable_primeï¼ˆ4ï¼‰ æ–­è¨€is_probable_primeï¼ˆ5ï¼‰ æ–­è¨€ä¸æ˜¯is_probable_primeï¼ˆ123456789ï¼‰ primes_under_1000 = [å¦‚æœis_probable_primeï¼ˆiï¼‰è¡¨ç¤ºiåœ¨èŒƒå›´ï¼ˆ2ï¼Œ1000ï¼‰ä¸­çš„i] æ–­è¨€lenï¼ˆprimes_under_1000ï¼‰== 168 æ–­è¨€primes_under_1000 [-10ï¼š] == [937ï¼Œ941ï¼Œ947ï¼Œ953ï¼Œ967ï¼Œ971ï¼Œ977ï¼Œ983ï¼Œ991ï¼Œ997] æ–­è¨€is_probable_primeï¼ˆ6438080068035535544392301298549614926991513861075340134 \ 3291807343952413826484237063006136971539473913409092293733259059038472039 \ 7133335969549256322620979036686633213903952966175107096769180017646161 \ 851573147596390153ï¼‰ æ–­è¨€ä¸æ˜¯is_probable_primeï¼ˆ7438080068035535592392301298549614926991513861075340134 \ 3291807343952413826484237063006136971539473913409092293733259059038472039 \ 7133335969549256322620979036686633213903952966175107096769180017646161 \ 851573147596390153ï¼‰ </p><p> The basis of the algorithm is generating images with only 10 possible color values. I did not know what a common approach to this is, so I thought applying a  k-means algorithm would work. To do this, I reshaped an input image (so each pixel is a point in 3D space), clustered this, and used the 10 created clusters as color values. Sidenote: when your hammer is machine learning, everything looks like a nailâ€¦</p><p>è¯¥ç®—æ³•çš„åŸºç¡€æ˜¯ç”Ÿæˆä»…å…·æœ‰10ç§å¯èƒ½é¢œè‰²å€¼çš„å›¾åƒã€‚æˆ‘ä¸çŸ¥é“æœ‰ä»€ä¹ˆé€šç”¨æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘è®¤ä¸ºåº”ç”¨k-meansç®—æ³•ä¼šè¡Œå¾—é€šã€‚ä¸ºæ­¤ï¼Œæˆ‘å¯¹è¾“å…¥å›¾åƒè¿›è¡Œäº†æ•´å½¢ï¼ˆå› æ­¤æ¯ä¸ªåƒç´ éƒ½æ˜¯3Dç©ºé—´ä¸­çš„ä¸€ä¸ªç‚¹ï¼‰ï¼Œå¯¹å…¶è¿›è¡Œäº†èšç±»ï¼Œç„¶åå°†åˆ›å»ºçš„10ä¸ªèšç±»ç”¨ä½œé¢œè‰²å€¼ã€‚æ—æ³¨ï¼šå½“æ‚¨çš„é”¤å­æ˜¯æœºå™¨å­¦ä¹ å·¥å…·æ—¶ï¼Œä¸€åˆ‡çœ‹èµ·æ¥éƒ½åƒé’‰å­ä¸€æ ·â€¦â€¦</p><p> Important for the prime generation is that you add a little bit of noise to the original image to create images that look the same, but are slightly different. This means that you created a different number, which is a new chance for us to find a prime number.</p><p> å¯¹äºç´ æ•°ç”Ÿæˆè€Œè¨€ï¼Œé‡è¦çš„æ˜¯è¦å‘åŸå§‹å›¾åƒæ·»åŠ ä¸€ç‚¹å™ªç‚¹ï¼Œä»¥åˆ›å»ºçœ‹èµ·æ¥ç›¸åŒä½†ç•¥æœ‰ä¸åŒçš„å›¾åƒã€‚è¿™æ„å‘³ç€æ‚¨åˆ›å»ºäº†ä¸€ä¸ªä¸åŒçš„æ•°å­—ï¼Œè¿™æ˜¯æˆ‘ä»¬æ‰¾åˆ°è´¨æ•°çš„æ–°æœºä¼šã€‚</p><p> def  get_k_means ( image ):  pointcloud  =  np . reshape ( image ,  ( - 1 ,  3 ))  kmeans  =  KMeans ( n_clusters = 10 ) . fit ( pointcloud )  return  kmeans def  create_numbered_image ( image ,  kmeans ):  &#34;&#34;&#34;  Turns an RGB image into an image with the labels of clusters of the supplied kmeans classifier.   &#34;&#34;&#34;  # apply noise  stdev  =  np . std ( image )  random_noise  =  np . random . random_sample ( size = image . shape ) * ( stdev / 3 )  image  =  image  +  random_noise   orig_shape  =  image . shape  image  =  np . reshape ( image ,  ( - 1 ,  3 ))  numbered_image  =  kmeans . predict ( image )  numbered_image  =  np . reshape ( numbered_image ,  orig_shape [: 2 ])   # make sure the end is uneven  if  numbered_image [ - 1 , - 1 ] % 2 == 0 :  numbered_image [ - 1 , - 1 ]  +=  1  return  numbered_image def  numbered_image_to_normal_image ( numbered_image ,  kmeans ):  &#34;&#34;&#34;  Turns an image with only values between 0 and 9 into a colored image by using the cluster centers   of the supplied kmeans classifier.   &#34;&#34;&#34;  shape  =  ( numbered_image . shape [ 0 ],  numbered_image . shape [ 1 ],  3 )  image  =  np . zeros ( shape )  for  label ,  color  in  zip ( range ( 10 ),  kmeans . cluster_centers_ ):  image [ numbered_image == label ]  =  color  return  image</p><p> def get_k_meansï¼ˆå›¾ç‰‡ï¼‰ï¼š  pointcloud = npã€‚é‡å¡‘ï¼ˆimageï¼Œï¼ˆ-1ï¼Œ3ï¼‰ï¼‰  kmeans = KMeansï¼ˆn_clusters = 10ï¼‰ã€‚é€‚åˆï¼ˆpointcloudï¼‰  è¿”å›kmeans def create_numbered_imageï¼ˆimageï¼Œkmeansï¼‰ï¼š  ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;  å°†RGBå›¾åƒè½¬æ¢ä¸ºå¸¦æœ‰æä¾›çš„kmeansåˆ†ç±»å™¨çš„ç°‡æ ‡ç­¾çš„å›¾åƒã€‚  ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;  ï¼ƒåº”ç”¨å™ªéŸ³  stdev = npã€‚æ ‡å‡†ï¼ˆå›¾ç‰‡ï¼‰  random_noise = npã€‚éšæœºçš„ã€‚ random_sampleï¼ˆå¤§å°=å›¾ç‰‡ã€‚å½¢çŠ¶ï¼‰*ï¼ˆstdev / 3ï¼‰  å›¾ç‰‡=å›¾ç‰‡+ random_noise   orig_shape =å›¾ç‰‡ã€‚å½¢çŠ¶  å›¾ç‰‡= npã€‚é‡å¡‘ï¼ˆimageï¼Œï¼ˆ-1ï¼Œ3ï¼‰ï¼‰  numbered_image = kmeansã€‚é¢„æµ‹ï¼ˆå›¾ç‰‡ï¼‰  numbered_image = npã€‚é‡å¡‘ï¼ˆnumbered_imageï¼Œorig_shape [ï¼š2]ï¼‰   ï¼ƒç¡®ä¿ç»“å°¾ä¸å‡åŒ€  å¦‚æœnumbered_image [-1ï¼Œ-1]ï¼…2 == 0ï¼š  numbered_image [-1ï¼Œ-1] + = 1  è¿”å›numbered_image def numbered_image_to_normal_imageï¼ˆnumbered_imageï¼Œkmeansï¼‰ï¼š  ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;  é€šè¿‡ä½¿ç”¨èšç±»ä¸­å¿ƒå°†åªæœ‰0åˆ°9ä¹‹é—´çš„å€¼çš„å›¾åƒè½¬æ¢ä¸ºå½©è‰²å›¾åƒ  æä¾›çš„kmeansåˆ†ç±»å™¨ã€‚  ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;  shape =ï¼ˆnumbered_imageã€‚shape [0]ï¼Œnumbered_imageã€‚shape [1]ï¼Œ3ï¼‰  å›¾ç‰‡= npã€‚é›¶ï¼ˆå½¢çŠ¶ï¼‰  å¯¹äºæ ‡ç­¾ï¼Œä»¥zipæ ¼å¼æ˜¾ç¤ºçš„é¢œè‰²ï¼ˆèŒƒå›´ï¼ˆ10ï¼‰ï¼Œkmeansã€‚cluster_centers_ï¼‰ï¼š  å›¾ç‰‡[numbered_image ==æ ‡ç­¾] =é¢œè‰²  è¿”å›å›¾ç‰‡</p><p> Here I create a few examples of small numerised images of the Mona Lisa. If you look closely you can see each image is slightly different, but you can still recognise the original picture. This is crucial for us, as this allows us to generate multiple numerised images that we can test for primality.</p><p> åœ¨è¿™é‡Œï¼Œæˆ‘åˆ›å»ºäº†ä¸€äº›è’™å¨œä¸½èå°æ•°å­—å›¾åƒçš„ç¤ºä¾‹ã€‚å¦‚æœä»”ç»†è§‚å¯Ÿï¼Œæ‚¨ä¼šå‘ç°æ¯å¼ å›¾åƒéƒ½ç•¥æœ‰ä¸åŒï¼Œä½†æ˜¯æ‚¨ä»ç„¶å¯ä»¥è¯†åˆ«åŸå§‹å›¾ç‰‡ã€‚è¿™å¯¹æˆ‘ä»¬è‡³å…³é‡è¦ï¼Œå› ä¸ºè¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿç”Ÿæˆå¯ä»¥æµ‹è¯•ç´ æ•°çš„å¤šä¸ªæ•°å­—åŒ–å›¾åƒã€‚</p><p> def  load_and_resize_image ( filename ,  resize_factor = 18 ):  image  =  skimage . io . imread ( filename )  image  =  image . astype ( np . float64 )  image  =  image  /  255.   oldshape  =  image . shape  with  warnings . catch_warnings ():  warnings . simplefilter ( &#34;ignore&#34; )  resized_image  =  skimage . transform . resize ( image ,  ( oldshape [ 0 ] // resize_factor ,  oldshape [ 1 ] // resize_factor ))  return  resized_image resized_image  =  load_and_resize_image ( &#39;input_pictures/monalisa.jpg&#39; ) kmeans  =  get_k_means ( resized_image ) N_IMAGES  =  3 f ,  axarr  =  plt . subplots ( 1 , N_IMAGES ) for  index  in  range ( N_IMAGES ):  n_image  =  create_numbered_image ( resized_image ,  kmeans )  normal_image  =  numbered_image_to_normal_image ( n_image ,  kmeans )  axarr [ index ] . imshow ( normal_image )</p><p> def load_and_resize_imageï¼ˆfilenameï¼Œresize_factor = 18ï¼‰ï¼š  image = skimageã€‚ ioã€‚è¯»ï¼ˆæ–‡ä»¶åï¼‰  å›¾ç‰‡=å›¾ç‰‡ã€‚ astypeï¼ˆnpã€‚float64ï¼‰  å›¾ç‰‡=å›¾ç‰‡/ 255ã€‚   oldshape =å›¾ç‰‡ã€‚å½¢çŠ¶  å¸¦æœ‰è­¦å‘Šã€‚ catch_warningsï¼ˆï¼‰ï¼š  è­¦å‘Šã€‚ simplefilterï¼ˆï¼†ï¼ƒ34; ignoreï¼†ï¼ƒ34;ï¼‰  resized_image = skimageã€‚è½¬å˜ ã€‚è°ƒæ•´å¤§å°ï¼ˆimageï¼Œï¼ˆoldshape [0] // resize_factorï¼Œoldshape [1] // resize_factorï¼‰ï¼‰  è¿”å›resized_image resize_image = load_and_resize_imageï¼ˆï¼†ï¼ƒ39; input_pictures / monalisa.jpgï¼†ï¼ƒ39;ï¼‰ kmeans = get_k_meansï¼ˆresized_imageï¼‰ N_IMAGES = 3 fï¼Œaxarr = pltã€‚å­å›¾ï¼ˆ1ï¼ŒN_IMAGESï¼‰ å¯¹äºèŒƒå›´ï¼ˆN_IMAGESï¼‰ä¸­çš„ç´¢å¼•ï¼š  n_image = create_numbered_imageï¼ˆresize_imageï¼Œkmeansï¼‰  normal_image = numbered_image_to_normal_imageï¼ˆn_imageï¼Œkmeansï¼‰  è½´[ç´¢å¼•]ã€‚ imshowï¼ˆnormal_imageï¼‰</p><p> I had to create some helper functions to return strings, integers, and load and show images.</p><p> æˆ‘å¿…é¡»åˆ›å»ºä¸€äº›è¾…åŠ©å‡½æ•°æ¥è¿”å›å­—ç¬¦ä¸²ï¼Œæ•´æ•°ä»¥åŠåŠ è½½å’Œæ˜¾ç¤ºå›¾åƒã€‚</p><p> def  image_to_number ( numbered_image ):  to_be_number  =  numbered_image . reshape ( - 1 )  as_string  =  &#39;&#39; . join ([ str ( int ( x ))  for  x  in  to_be_number ])  as_int  =  int ( as_string )  return  as_int ,  as_string def  show_and_save_image ( image ,  n_image ,  filename ,  fontsize = 16 ):  oldshape  =  image . shape  resized_image =  scipy . misc . imresize ( image ,( oldshape [ 0 ] * fontsize ,  oldshape [ 1 ] * fontsize ),  interp = &#39;nearest&#39; )  img  =  Image . fromarray ( resized_image ) . convert ( &#34;RGBA&#34; )  txt  =  Image . new ( &#39;RGBA&#39; ,  img . size ,  ( 255 , 255 , 255 , 0 ))  draw  =  ImageDraw . Draw ( txt )  font  =  ImageFont . truetype ( &#34;pirulen rg.ttf&#34; ,  fontsize )  for  y_i ,  totype  in  enumerate ( n_image ):  for  x_i ,  letter  in  enumerate ( totype ):  xpos  =  x_i  *  fontsize  +  1  ypos  =  y_i  *  fontsize  if  letter  ==  1 :  xpos  +=  4  draw . text (( xpos ,  ypos ), str ( letter ),( 255 , 255 , 255 ,  128 ), font = font )  img  =  Image . alpha_composite ( img ,  txt )   img . save ( filename )  plt . figure ( figsize = ( 20 , 20 ))  plt . imshow ( img )  plt . show () def  result_filename ( filename ):  return  filename . split ( &#39;.&#39; )[ 0 ]  +  &#34;-prime.png&#34;</p><p> def image_to_numberï¼ˆnumbered_imageï¼‰ï¼š  to_be_number = numbered_imageã€‚é‡å¡‘ï¼ˆ-1ï¼‰  as_string =ï¼†ï¼ƒ39;ï¼†ï¼ƒ39; ã€‚åŠ å…¥ï¼ˆ[to_be_numberä¸­xçš„[strï¼ˆintï¼ˆxï¼‰ï¼‰]ï¼‰  as_int = intï¼ˆas_stringï¼‰  è¿”å›as_intï¼Œas_string def show_and_save_imageï¼ˆimageï¼Œn_imageï¼Œfilenameï¼Œfontsize = 16ï¼‰ï¼š  oldshape =å›¾ç‰‡ã€‚å½¢çŠ¶  resized_image = scipyã€‚æ‚é¡¹imresizeï¼ˆimageï¼Œï¼ˆoldshape [0] * fontsizeï¼Œoldshape [1] * fontsizeï¼‰ï¼Œinterp =ï¼†ï¼ƒ39; nearestï¼†ï¼ƒ39;ï¼‰  img =å›¾ç‰‡ã€‚ fromarrayï¼ˆresized_imageï¼‰ã€‚è½¬æ¢ï¼ˆï¼†ï¼ƒ34; RGBAï¼†ï¼ƒ34;ï¼‰  txt =å›¾ç‰‡ã€‚æ–°ï¼ˆï¼†ï¼ƒ39; RGBAï¼†ï¼ƒ39;ï¼Œimgã€‚sizeï¼Œï¼ˆ255ï¼Œ255ï¼Œ255ï¼Œ0ï¼‰ï¼‰  ç”»= ImageDrawã€‚ç”»ï¼ˆtxtï¼‰  å­—ä½“= ImageFontã€‚ truetypeï¼ˆï¼†ï¼ƒ34; pirulen rg.ttfï¼†ï¼ƒ34;ï¼Œfontsizeï¼‰  å¯¹äºy_iï¼Œè¾“å…¥æšä¸¾ï¼ˆn_imageï¼‰ï¼š  å¯¹äºx_iï¼Œæšä¸¾ï¼ˆtotypeï¼‰ä¸­çš„å­—æ¯ï¼š  xpos = x_i *å­—ä½“å¤§å°+ 1  ypos = y_i *å­—ä½“å¤§å°  å¦‚æœå­—æ¯== 1ï¼š  xpos + = 4  ç”» ã€‚æ–‡æœ¬ï¼ˆï¼ˆxposï¼Œyposï¼‰ï¼Œstrï¼ˆå­—æ¯ï¼‰ï¼Œï¼ˆ255ï¼Œ255ï¼Œ255ï¼Œ128ï¼‰ï¼Œå­—ä½“=å­—ä½“ï¼‰  img =å›¾ç‰‡ã€‚ alpha_compositeï¼ˆimgï¼Œtxtï¼‰  imgã€‚ä¿å­˜ï¼ˆæ–‡ä»¶åï¼‰  è¯·å›¾ï¼ˆfigsize =ï¼ˆ20ï¼Œ20ï¼‰ï¼‰  è¯·imshowï¼ˆimgï¼‰  è¯·èŠ‚ç›® ï¼ˆï¼‰ def result_filenameï¼ˆfilenameï¼‰ï¼š  è¿”å›æ–‡ä»¶åã€‚åˆ†å‰²ï¼ˆï¼†ï¼ƒ39;ã€‚ï¼†ï¼ƒ39;ï¼‰[0] +ï¼†ï¼ƒ34; -prime.pngï¼†ï¼ƒ34; </p><p> To verify if something is a good prime portrait I made the following helper functions:</p><p>ä¸ºäº†éªŒè¯æŸç‰©æ˜¯å¦æ˜¯å¥½çš„åŸºæœ¬ç”»åƒï¼Œæˆ‘è¿›è¡Œäº†ä»¥ä¸‹è¾…åŠ©åŠŸèƒ½ï¼š</p><p> def  is_good_prime_portrait ( n_image ):  integer ,  string  =  image_to_number ( n_image )  if  is_probable_prime ( integer ):   return  integer ,  string ,  n_image  else :  return  None   def  print_result ( string ,  n_image ):  print ( string )  print ( &#34;-&#34; * 100 )  for  line  in  n_image :  print ( &#39;&#39; . join ([ str ( x )  for  x  in  line ]))</p><p> def is_good_prime_portraitï¼ˆn_imageï¼‰ï¼š  æ•´æ•°ï¼Œå­—ç¬¦ä¸²= image_to_numberï¼ˆn_imageï¼‰  å¦‚æœis_probable_primeï¼ˆintegerï¼‰ï¼š  è¿”å›integerï¼Œstringï¼Œn_image  å…¶ä»–ï¼š  ä¸è¿”å›   def print_resultï¼ˆstringï¼Œn_imageï¼‰ï¼š  æ‰“å°ï¼ˆå­—ç¬¦ä¸²ï¼‰  æ‰“å°ï¼ˆï¼†ï¼ƒ34;-ï¼†ï¼ƒ34; * 100ï¼‰  å¯¹äºn_imageä¸­çš„è¡Œï¼š  æ‰“å°ï¼ˆï¼†ï¼ƒ39;ï¼†ï¼ƒ39;ã€‚joinï¼ˆ[xçš„è¡Œçš„strï¼ˆxï¼‰]ï¼‰ï¼‰</p><p> At first I created a single-threaded solution, which worked. However, my laptop has multiple cores and could work on multiple numbers at the same time, so I rewrote my initial approach in a multi-threaded fashion:</p><p> æœ€åˆï¼Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ªå•çº¿ç¨‹è§£å†³æ–¹æ¡ˆï¼Œè¯¥è§£å†³æ–¹æ¡ˆèµ·ä½œç”¨äº†ã€‚ä½†æ˜¯ï¼Œæˆ‘çš„ç¬”è®°æœ¬ç”µè„‘æœ‰å¤šä¸ªæ ¸å¿ƒï¼Œå¯ä»¥åŒæ—¶å¤„ç†å¤šä¸ªæ•°å­—ï¼Œå› æ­¤æˆ‘ä»¥å¤šçº¿ç¨‹çš„æ–¹å¼é‡å†™äº†æœ€åˆçš„æ–¹æ³•ï¼š</p><p> def  print_result ( string ,  n_image ):  print ( &#34;Found a result: &#34;  +  &#34;-&#34; * 100 )  print ( string )  print ( &#34;Represented as portrait:&#34;  +  &#34;-&#34; * 100 )  for  line  in  n_image :  print ( &#39;&#39; . join ([ str ( x )  for  x  in  line ])) def  multi_threaded_prime_generator ( resized_image ,  kmeans ,  filename ,  threads = 4 ,  log_process = True ):  image_generator  =  ( create_numbered_image ( resized_image ,  kmeans )  for  _  in  range ( 1000000 ))  start  =  time . time ()   with  Pool ( threads )  as  pool :  results  =  pool . imap_unordered ( is_good_prime_portrait ,  image_generator )  total_results  =  0   for  result  in  results :  total_results  +=  1   # Possibly log time spend searching this prime number  if  log_process  and  total_results % 30 == 0 :  elapsed  =  time . time ()  elapsed  =  elapsed  -  start  print ( &#34;Seconds spent in (function name) is  {}  time per result:  {} &#34; . format ( str ( elapsed ),  str ( elapsed / total_results )))   if  result  !=  None :   # Found a prime number, print it and save it!  integer ,  string ,  n_image  =  result  print_result ( string ,  n_image )  normal_image  =  numbered_image_to_normal_image ( n_image ,  kmeans )  plt . imshow ( normal_image )  plt . show ()  show_and_save_image ( normal_image ,  n_image ,  result_filename ( filename ))  break   def  search_prime_portrait ( filename ,  resize_factor = 16 ,  log_process = True ,  threads = 4 ):  resized_image  =  load_and_resize_image ( filename ,  resize_factor = resize_factor )  print ( &#34;Working with size &#34;  +  str ( resized_image . shape ))  kmeans  =  get_k_means ( resized_image )  multi_threaded_prime_generator ( resized_image ,  kmeans ,  filename ,  log_process = log_process ,  threads = threads )</p><p> def print_resultï¼ˆstringï¼Œn_imageï¼‰ï¼š  æ‰“å°ï¼ˆï¼†ï¼ƒ34;æ‰¾åˆ°ç»“æœï¼šï¼†ï¼ƒ34; +ï¼†ï¼ƒ34;-ï¼†ï¼ƒ34; * 100ï¼‰  æ‰“å°ï¼ˆå­—ç¬¦ä¸²ï¼‰  æ‰“å°ï¼ˆï¼†ï¼ƒ34;ä»£è¡¨è‚–åƒï¼šï¼†ï¼ƒ34; +ï¼†ï¼ƒ34;-ï¼†ï¼ƒ34; * 100ï¼‰  å¯¹äºn_imageä¸­çš„è¡Œï¼š  printï¼ˆï¼†ï¼ƒ39;ï¼†ï¼ƒ39;ã€‚joinï¼ˆ[xçš„è¡Œçš„strï¼ˆxï¼‰]ï¼‰ï¼‰ def multi_threaded_prime_generatorï¼ˆresized_imageï¼Œkmeansï¼Œfilenameï¼Œçº¿ç¨‹= 4ï¼Œlog_process = Trueï¼‰ï¼š  image_generator =ï¼ˆèŒƒå›´ï¼ˆ1000000ï¼‰ä¸­çš„_çš„create_numbered_imageï¼ˆresize_imageï¼Œkmeansï¼‰ï¼‰  å¼€å§‹=æ—¶é—´ã€‚æ—¶é—´ ï¼ˆï¼‰  ä¸æ± ï¼ˆçº¿ç¨‹ï¼‰ä½œä¸ºæ± ï¼š  ç»“æœ=æ± ã€‚ imap_unorderedï¼ˆis_good_prime_portraitï¼Œimage_generatorï¼‰  total_results = 0   ä¸ºäº†ç»“æœï¼š  total_results + = 1   ï¼ƒå¯èƒ½ä¼šèŠ±æ—¶é—´æœç´¢æ­¤ç´ æ•°  å¦‚æœlog_processå’Œtotal_resultsï¼…30 == 0ï¼š  ç»è¿‡çš„æ—¶é—´=æ—¶é—´ã€‚æ—¶é—´ ï¼ˆï¼‰  è¿‡å»=è¿‡å»-å¼€å§‹  æ‰“å°ï¼ˆï¼†ï¼ƒ34;åœ¨ï¼ˆå‡½æ•°åï¼‰ä¸­èŠ±è´¹çš„ç§’æ•°æ˜¯{}æ¯ä¸ªç»“æœçš„æ—¶é—´ï¼š{}ï¼†ï¼ƒ34;ã€‚formatï¼ˆstrï¼ˆelapsedï¼‰ï¼Œstrï¼ˆelapsed / total_resultsï¼‰ï¼‰ï¼‰   å¦‚æœç»“æœï¼=æ— ï¼š  ï¼ƒæ‰¾åˆ°ç´ æ•°ï¼Œæ‰“å°å¹¶ä¿å­˜ï¼  æ•´æ•°ï¼Œå­—ç¬¦ä¸²ï¼Œn_image =ç»“æœ  print_resultï¼ˆstringï¼Œn_imageï¼‰  normal_image = numbered_image_to_normal_imageï¼ˆn_imageï¼Œkmeansï¼‰  è¯·imshowï¼ˆnormal_imageï¼‰  è¯·èŠ‚ç›® ï¼ˆï¼‰  show_and_save_imageï¼ˆnormal_imageï¼Œn_imageï¼Œresult_filenameï¼ˆfilenameï¼‰ï¼‰  æ‰“ç ´   def search_prime_portraitï¼ˆfilenameï¼Œresize_factor = 16ï¼Œlog_process = Trueï¼Œçº¿ç¨‹= 4ï¼‰ï¼š  resize_image = load_and_resize_imageï¼ˆfilenameï¼Œresize_factor = resize_factorï¼‰  æ‰“å°ï¼ˆï¼†ï¼ƒ34;ä½¿ç”¨å¤§å°ï¼†ï¼ƒ34; + strï¼ˆresized_imageã€‚shapeï¼‰ï¼‰  kmeans = get_k_meansï¼ˆresized_imageï¼‰  multi_threaded_prime_generatorï¼ˆresize_imageï¼Œkmeansï¼Œæ–‡ä»¶åï¼Œlog_process = log_processï¼Œçº¿ç¨‹=çº¿ç¨‹ï¼‰</p><p> Now that we defined all functionality, itâ€™s finally time to generate the prime portraits! Play around with it and try to feed your own images. Note that you can pass the resize_factor variable to the function â€˜search prime portraitâ€™. The bigger the resize_factor, the faster you can find a prime portrait. See below for more information on the exponential time it takes to generate larger prime portraits.</p><p> ç°åœ¨ï¼Œæˆ‘ä»¬å®šä¹‰äº†æ‰€æœ‰åŠŸèƒ½ï¼Œç»ˆäºå¯ä»¥ç”ŸæˆåŸºæœ¬è‚–åƒäº†ï¼è¯•ä¸€è¯•ï¼Œå°è¯•è¾“å…¥è‡ªå·±çš„å›¾åƒã€‚è¯·æ³¨æ„ï¼Œæ‚¨å¯ä»¥å°†resize_factorå˜é‡ä¼ é€’ç»™å‡½æ•°â€œ search prime portraitâ€ã€‚ resize_factorè¶Šå¤§ï¼Œæ‰¾åˆ°åŸºæœ¬ç”»åƒçš„é€Ÿåº¦å°±è¶Šå¿«ã€‚æœ‰å…³ç”Ÿæˆæ›´å¤§çš„ç´ åƒæ‰€éœ€çš„æŒ‡æ•°æ—¶é—´çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ä¸‹æ–‡ã€‚</p><p> folder  =  &#39;input_pictures/&#39; filenames  =  [  folder  +  &#39;monalisa.jpg&#39; ,  #folder + &#39;sunflowers.jpg&#39;,  #folder + &#39;starrynight.jpg&#39; ] filename  =  filenames [ 0 ] for  filename  in  filenames :  search_prime_portrait ( filename ,  resize_factor = 20 ,  log_process = False ,  threads = 4 )</p><p> æ–‡ä»¶å¤¹=ï¼†ï¼ƒ39; input_pictures /ï¼†ï¼ƒ39; æ–‡ä»¶å= [  æ–‡ä»¶å¤¹+ï¼†ï¼ƒ39monalisa.jpgï¼†ï¼ƒ39; ï¼Œ  #folder +ï¼†ï¼ƒ39; sunflowers.jpgï¼†ï¼ƒ39 ;ï¼Œ  #folder +ï¼†ï¼ƒ39; starrynight.jpgï¼†ï¼ƒ39; ] æ–‡ä»¶å=æ–‡ä»¶å[0] ç”¨äºæ–‡ä»¶åä¸­çš„æ–‡ä»¶åï¼š  search_prime_portraitï¼ˆæ–‡ä»¶åï¼Œresize_factor = 20ï¼Œlog_process = Falseï¼Œçº¿ç¨‹= 4ï¼‰</p><p> Working with size (19, 13, 3)Found a result: ----------------------------------------------------------------------------------------------------6666666666662666626266262222222331222222222395146222066685731062280001758180008000853810000006688771802033388995386733331599578182871883701148387881881131880888181181188883118144141011855514411181111757388411111333881144814118814444114111444444441Represented as portrait:----------------------------------------------------------------------------------------------------6666666666662666626266262222222331222222222395146222066685731062280001758180008000853810000006688771802033388995386733331599578182871883701148387881881131880888181181188883118144141011855514411181111757388411111333881144814118814444114111444444441</p><p> ä½¿ç”¨å°ºå¯¸ï¼ˆ19ã€13ã€3ï¼‰å‘ç°ç»“æœï¼š---------------------------------------------- -------------------------------------------------- ----666666666666266626626222222233122222222239514622206668573106228000175818000800085381000000668877180203338899538673333159957818287188370138838188188188188188818118118888311814414101055555514411181111757388411111333881144814118814114114444ä»£è¡¨è‚–åƒï¼š---------------------------------------------- -------------------------------------------------- ----6666666666662666626266262222222331222222222395146222066685731062280001758180008000853810000006688771802033388995386733331599578182871883701148387881881131880888181181188883118144141011855514411181111757388411111333881144814118814444114111444444441 </p><p> Apparently the  largest known prime number is 22338618 digits long. This would allow us to create a 4726 * 4726 prime portrait, which would be a prime portrait in 4K. I already enjoyed the big images of â€˜Starry Nightâ€™, and I would absolutely love to have a 4K prime portrait of this painting.</p><p>æ˜¾ç„¶ï¼Œæœ€å¤§çš„å·²çŸ¥è´¨æ•°é•¿ä¸º22338618æ•°å­—ã€‚è¿™å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿåˆ›å»º4726 * 4726åŸå§‹å›¾åƒï¼Œè¿™å°†æ˜¯4Kä¸­çš„åŸå§‹å›¾åƒã€‚æˆ‘å·²ç»å¾ˆå–œæ¬¢â€œæ˜Ÿç©ºä¹‹å¤œâ€çš„å¤§å›¾äº†ï¼Œæˆ‘ç»å¯¹å¸Œæœ›æ‹¥æœ‰è¿™å¼ ç”»çš„4Ké»„é‡‘è‚–åƒã€‚</p><p> However: I noticed that finding prime numbers does not really scale. The length of the prime number grows quadratically with the resolution of your images, which causes big problems. Although the probability that you find a prime number only decreases linearly with the length of the prime number, it decreases quadratically when you get larger image resolutions. I plotted it in this image to show the effect up to 300Ã—300:</p><p> ä½†æ˜¯ï¼šæˆ‘æ³¨æ„åˆ°æ‰¾åˆ°è´¨æ•°å¹¶ä¸èƒ½çœŸæ­£æ‰©å±•ã€‚è´¨æ•°çš„é•¿åº¦ä¸å›¾åƒçš„åˆ†è¾¨ç‡æˆå¹³æ–¹å¢é•¿ï¼Œè¿™ä¼šå¼•èµ·å¾ˆå¤§çš„é—®é¢˜ã€‚å°½ç®¡æ‰¾åˆ°è´¨æ•°çš„æ¦‚ç‡ä»…éšè´¨æ•°çš„é•¿åº¦çº¿æ€§é™ä½ï¼Œä½†æ˜¯å½“æ‚¨è·å¾—è¾ƒå¤§çš„å›¾åƒåˆ†è¾¨ç‡æ—¶ï¼Œå…¶æ¦‚ç‡å‘ˆäºŒæ¬¡æ–¹é™ä½ã€‚æˆ‘åœ¨è¿™å¼ å›¾ä¸­ç»˜åˆ¶äº†å®ƒï¼Œä»¥æ˜¾ç¤ºé«˜è¾¾300Ã—300çš„æ•ˆæœï¼š</p><p>  But whatâ€™s even worse is that computing time grows quadratically with the length of the prime number. I also plotted this for my laptop up to an image resolution of 30Ã—30:</p><p>  ä½†æ›´ç³Ÿç³•çš„æ˜¯ï¼Œè®¡ç®—æ—¶é—´éšç€è´¨æ•°çš„é•¿åº¦å‘ˆäºŒæ¬¡æ–¹å¢é•¿ã€‚æˆ‘è¿˜ä¸ºç¬”è®°æœ¬ç”µè„‘ç»˜åˆ¶äº†é«˜è¾¾30Ã—30çš„å›¾åƒåˆ†è¾¨ç‡çš„å›¾åƒï¼š</p><p> def  time_expected_img ( w , h ):  order  =  w * h  start  =  time . time ()   for  _  in  range ( 100 ):  posprim  =  random . randrange ( 10 ** ( order - 1 ),  10 ** order )   a  =  is_probable_prime ( posprim )  end  =  time . time ()  return  end  -  start  test_range  =  range ( 2 , 30 , 4 ) time_needed  =  [ time_expected_img ( x , x )  for  x  in  test_range ] plt . plot ( test_range ,  time_needed ) plt . title ( &#34;Seconds expected to calculate if an XxY image is a prime portrait &#34; ) plt . xlabel ( &#34;Width image&#34; ) plt . ylabel ( &#34;Expected seconds&#34; )</p><p> def time_expected_imgï¼ˆwï¼Œhï¼‰ï¼š  é˜¶æ•°= w * h  å¼€å§‹=æ—¶é—´ã€‚æ—¶é—´ ï¼ˆï¼‰  å¯¹äº_èŒƒå›´ï¼ˆ100ï¼‰ï¼š  posprim =éšæœºçš„ã€‚ randrangeï¼ˆ10 **ï¼ˆè®¢å•-1ï¼‰ï¼Œ10 **è®¢å•ï¼‰  a = is_probable_primeï¼ˆposprimï¼‰  ç»“æŸ=æ—¶é—´ã€‚æ—¶é—´ ï¼ˆï¼‰  è¿”å›ç»“æŸ-å¼€å§‹  test_range =èŒƒå›´ï¼ˆ2ï¼Œ30ï¼Œ4ï¼‰ time_needed = [test_rangeä¸­xçš„time_expected_imgï¼ˆxï¼Œxï¼‰] è¯·æƒ…èŠ‚ï¼ˆtest_rangeï¼Œtime_neededï¼‰ è¯·æ ‡é¢˜ï¼ˆï¼†ï¼ƒ34;é¢„è®¡ç¬¬äºŒæ­¥ï¼Œä»¥è®¡ç®—XxYå›¾åƒæ˜¯å¦æ˜¯åŸºæœ¬è‚–åƒï¼†ï¼ƒ34;ï¼‰ è¯·xlabelï¼ˆï¼†ï¼ƒ34; Width imageï¼†ï¼ƒ34;ï¼‰ è¯·ylabelï¼ˆï¼†ï¼ƒ34; Expected secondsï¼†ï¼ƒ34;ï¼‰</p><p> Combining both linear curves you can easily estimate the expected time you need to find a portrait of a certain size:</p><p> ç»“åˆä¸¤æ¡çº¿æ€§æ›²çº¿ï¼Œæ‚¨å¯ä»¥è½»æ¾ä¼°ç®—æ‰¾åˆ°ä¸€å®šå°ºå¯¸çš„è‚–åƒæ‰€éœ€çš„é¢„æœŸæ—¶é—´ï¼š</p><p> total_needed  =  [ trials_expected_img ( x , x ) * time_expected_img ( x , x )  for  x  in  test_range ] plt . plot ( test_range ,  total_needed ) plt . title ( &#34;Seconds expected to find an XxY prime portrait &#34; ) plt . xlabel ( &#34;Width image&#34; ) plt . ylabel ( &#34;Expected seconds&#34; )</p><p> total_needed = [å¯¹äºtest_rangeä¸­çš„xï¼Œéœ€è¦trials_expected_imgï¼ˆxï¼Œxï¼‰* time_expected_imgï¼ˆxï¼Œxï¼‰] è¯·æƒ…èŠ‚ï¼ˆtest_rangeï¼Œtotal_neededï¼‰ è¯·æ ‡é¢˜ï¼ˆï¼†ï¼ƒ34;é¢„è®¡ç¬¬äºŒæ¬¡ä¼šæ‰¾åˆ°XxYç´ åƒ&& 34;ï¼‰ è¯·xlabelï¼ˆï¼†ï¼ƒ34; Width imageï¼†ï¼ƒ34;ï¼‰ è¯·ylabelï¼ˆï¼†ï¼ƒ34; Expected secondsï¼†ï¼ƒ34;ï¼‰</p><p> If you can find a more efficient Python implementation of a probabilistic prime checker, or implement it in a language more suitable to high demand computation, you can lower the time you need to generate these portraits. Each additional computer core also reduces this time a bit, but for now we can not expect 4K prime portraits anytime soon.</p><p> å¦‚æœæ‚¨å¯ä»¥æ‰¾åˆ°ä¸€ä¸ªæ›´é«˜æ•ˆçš„æ¦‚ç‡ç´ æ•°æ£€æŸ¥å™¨Pythonå®ç°ï¼Œæˆ–è€…ä»¥æ›´é€‚åˆäºé«˜è¦æ±‚è®¡ç®—çš„è¯­è¨€æ¥å®ç°å®ƒï¼Œåˆ™å¯ä»¥å‡å°‘ç”Ÿæˆè¿™äº›è‚–åƒæ‰€éœ€çš„æ—¶é—´ã€‚æ¯ä¸ªé¢å¤–çš„è®¡ç®—æœºå†…æ ¸ä¹Ÿå¯ä»¥å‡å°‘æ­¤æ—¶é—´ï¼Œä½†æ˜¯ç›®å‰æˆ‘ä»¬ä¸èƒ½æœŸæœ›å¾ˆå¿«æœ‰4Kç´ åƒã€‚ </p><p> The last couple of weeks I really enjoyed letting my computer find prime portraits. Here are some of the artworks my computer found:   Sunflowers by Van Gogh   Great wave by Hokusai   Girl with a pearl earring by Vermeer</p><p>åœ¨è¿‡å»çš„å‡ å‘¨é‡Œï¼Œæˆ‘çœŸçš„å¾ˆå–œæ¬¢è®©æˆ‘çš„è®¡ç®—æœºæŸ¥æ‰¾åŸºæœ¬è‚–åƒã€‚è¿™æ˜¯æˆ‘çš„è®¡ç®—æœºä¸Šæ‰¾åˆ°çš„ä¸€äº›è‰ºæœ¯å“ï¼šæ¢µé«˜çš„å‘æ—¥è‘µHokusai Girlçš„ã€Šå¤§æ³¢æµªã€‹å’ŒVermeerçš„çç è€³ç¯</p><p>  Although pictures of existing art often turn our pretty well, it is quite difficult to create good looking prime portraits of people. There is often not enough contrast in the resulting images, which uses only ten colors. I decided to try some portraits for people I like to follow online. Images that turned our well are:</p><p>  å°½ç®¡ç°æœ‰è‰ºæœ¯å“çš„å›¾ç‰‡é€šå¸¸ä¼šä½¿æˆ‘ä»¬æ„Ÿè§‰å¾ˆå¥½ï¼Œä½†æ˜¯è¦åˆ›å»ºç¾è§‚çš„ä¸»è¦äººç‰©è‚–åƒå´ç›¸å½“å›°éš¾ã€‚æœ€ç»ˆçš„å›¾åƒé€šå¸¸å¯¹æ¯”åº¦ä¸è¶³ï¼Œä»…ä½¿ç”¨åç§é¢œè‰²ã€‚æˆ‘å†³å®šä¸ºæˆ‘å–œæ¬¢åœ¨ç½‘ä¸Šå…³æ³¨çš„äººå°è¯•ä¸€äº›è‚–åƒã€‚ä½¿æˆ‘ä»¬æ„Ÿåˆ°æ»¡æ„çš„å›¾åƒæ˜¯ï¼š</p><p>  Writes interesting articles in a Dutch newspaper every Saturday, and got featured a while ago in the Dutch comic called â€œDonald Duckâ€:</p><p>  æ¯ä¸ªæ˜ŸæœŸå…­åœ¨è·å…°æŠ¥çº¸ä¸Šå†™æœ‰è¶£çš„æ–‡ç« ï¼Œä¸ä¹…å‰åœ¨è·å…°æ¼«ç”»ã€Šå”è€é¸­ã€‹ä¸­ç™»è½½ï¼š</p><p>  Makes interesting videos about mathematical concepts on the Numberphile Youtube channel. Also: has a cute dog ğŸ˜‰</p><p>  åœ¨Numberphile Youtubeé¢‘é“ä¸Šåˆ¶ä½œæœ‰å…³æ•°å­¦æ¦‚å¿µçš„æœ‰è¶£è§†é¢‘ã€‚å¦å¤–ï¼šæœ‰ä¸€åªå¯çˆ±çš„ç‹—ğŸ˜‰</p><p>    As I put  the code online you can try to generate some prime portraits for yourself! If you really think I should try a certain artwork, feel free to reach out to me. Also: if you have a good idea what to do with these results, feel free to reach out. I know that I personally am going to hang the prime version of Starry Night on my wall!</p><p>    å½“æˆ‘å°†ä»£ç å‘å¸ƒåˆ°ç½‘ä¸Šæ—¶ï¼Œæ‚¨å¯ä»¥å°è¯•ä¸ºè‡ªå·±ç”Ÿæˆä¸€äº›åŸºæœ¬çš„è‚–åƒï¼å¦‚æœæ‚¨çœŸçš„è®¤ä¸ºæˆ‘åº”è¯¥å°è¯•æŸäº›è‰ºæœ¯å“ï¼Œè¯·éšæ—¶ä¸æˆ‘è”ç³»ã€‚å¦å¤–ï¼šå¦‚æœæ‚¨æœ‰ä¸ªå¥½ä¸»æ„å¦‚ä½•å¤„ç†è¿™äº›ç»“æœï¼Œè¯·éšæ—¶ä¸æˆ‘ä»¬è”ç³»ã€‚æˆ‘çŸ¥é“æˆ‘ä¸ªäººå°†åœ¨å¢™ä¸ŠæŒ‚æ»¡é»„é‡‘æ˜Ÿå¤œï¼ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.pinchofintelligence.com/painting-by-prime-number/">http://www.pinchofintelligence.com/painting-by-prime-number/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ç´ æ•°/">#ç´ æ•°</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/prime/">#prime</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/image/">#image</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>