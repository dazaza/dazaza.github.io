<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>å•ä¸ªEmojiå­—ç¬¦çš„å­—ç¬¦ä¸²é•¿åº¦å‡½æ•°è¯„ä¼°å¤§äº1 String length functions for single emoji characters evaluate to greater than 1</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">String length functions for single emoji characters evaluate to greater than 1<br/>å•ä¸ªEmojiå­—ç¬¦çš„å­—ç¬¦ä¸²é•¿åº¦å‡½æ•°è¯„ä¼°å¤§äº1 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-27 06:38:35</div><div class="page_narrow text-break page_content"><p>Itâ€™s Not Wrong that  &#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;.length == 7</p><p>è¿™ä¸æ˜¯é”™è¯¯çš„é‚£ä¸ªï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34; .length == 7</p><p>  But Itâ€™s Better that  &#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;.len() == 17 and Rather Useless that  len(&#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;) == 5</p><p>  ä½†å®ƒæ›´å¥½çš„æ˜¯é‚£ä¸ªï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34; .lenï¼ˆï¼‰== 17ï¼Œè€Œä¸æ˜¯æ— ç”¨çš„é‚£ä¸ªlenï¼ˆï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34;ï¼‰== 5</p><p> From time to time, someone shows that in JavaScript the  .length of a string containing an emoji results in a number greater than 1 (typically 2) and then proceeds to the conclusion that haha JavaScript is so brokenâ€”and is rewarded with many likes. In this post, I will try to convince you that ridiculing JavaScript for this is less insightful than it first appears and that Swiftâ€™s approach to string length isnâ€™t unambiguously the best one. Python 3â€™s approach is unambiguously the worst one, though.</p><p> ä¸æ—¶åœ°æ˜¾ç¤ºï¼Œåœ¨JavaScriptä¸­ï¼ŒåŒ…å«EMOJIçš„å­—ç¬¦ä¸²çš„é•¿åº¦å¯¼è‡´æ•°é‡å¤§äº1ï¼ˆé€šå¸¸ä¸º2ï¼‰ï¼Œç„¶åè¿›è¡Œå¾—å‡ºçš„ç»“è®ºï¼Œå³å“ˆå“ˆJavaScriptæ˜¯å¦‚æ­¤ç ´ç¢ - è®¸å¤šå–œæ¬¢çš„å¥–åŠ±ã€‚åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä¼šå°è¯•è¯´æœä½ å˜²ç¬‘JavaScriptï¼Œè¿™æ¯”é¦–æ¬¡å‡ºç°çš„æ´å¯ŸåŠ›ä¸é‚£ä¹ˆå¯Œæœ‰æ´å¯ŸåŠ›ï¼Œå¹¶ä¸”Swiftçš„å­—ç¬¦ä¸²é•¿åº¦çš„æ–¹æ³•ä¸æ˜¯æ˜ç¡®çš„æœ€ä½³çŠ¶æ€ã€‚ä½†æ˜¯ï¼ŒPython 3çš„æ–¹æ³•æ˜¯æ˜ç¡®çš„æœ€ç³Ÿç³•çš„æ–¹æ³•ã€‚</p><p>  &#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;.length == 7 evaluates to  true as JavaScript. Letâ€™s try JavaScript console in Firefox:</p><p>  ï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34; .Length == 7ä½œä¸ºJavaScriptè¯„ä¼°ä¸ºTrueã€‚è®©æˆ‘ä»¬åœ¨Firefoxä¸­å°è¯•JavaScriptæ§åˆ¶å°ï¼š</p><p>  Haha, right? Well, youâ€™ve been told that the Python community suffered the Python 2 vs. Python 3 split, among other things, to Get Unicode Right. Letâ€™s try Python 3:</p><p>  å“ˆå“ˆï¼Œå¯¹å—ï¼Ÿå¥½å§ï¼Œä½ è¢«å‘ŠçŸ¥ï¼ŒPythonç¤¾åŒºé­å—äº†Python 2å¯¹é˜µPython 3æ‹†åˆ†ï¼Œä»¥åŠå…¶ä»–äº‹æƒ…æ¥è·å¾—Unicodeå³ã€‚è®©æˆ‘ä»¬è¯•è¯•Python 3ï¼š</p><p> $ python3Python 3.6.8 (default, Jan 14 2019, 11:02:34) [GCC 8.0.1 20180414 (experimental) [trunk revision 259383]] on linuxType &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.&gt;&gt;&gt; len(&#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;) == 5True&gt;&gt;&gt;</p><p> $ python3python 3.6.8ï¼ˆé»˜è®¤å€¼ï¼Œ2019å¹´1æœˆ14æ—¥ï¼Œ11:02:34ï¼‰[GCC 8.0.1 20180414ï¼ˆå®éªŒï¼‰[Trunk Revision 259383]åœ¨Linuxtypeï¼†ï¼ƒ34;å¸®åŠ©ï¼†ï¼ƒ34;ï¼Œï¼†ï¼ƒ34;ç‰ˆæƒï¼†ï¼ƒ 34;ï¼Œï¼†ï¼ƒ34;å­¦åˆ†å’Œï¼ƒ34;æˆ–ï¼†ï¼ƒ34;è®¸å¯è¯ï¼†ï¼ƒ34;æœ‰å…³æ›´å¤šä¿¡æ¯ã€‚ï¼†gt;ï¼†gt;ï¼†gt; Lenï¼ˆï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34;ï¼‰== 5trueï¼†gt;ï¼†gt;ï¼†gt;</p><p> OK, then. Now, Rust has the benefit of learning from languages that came before it. Letâ€™s try Rust:</p><p> å¥½å§ã€‚ç°åœ¨ï¼ŒRustæœ‰åˆ©äºä»ä¹‹å‰çš„è¯­è¨€å­¦ä¹ ã€‚è®©æˆ‘ä»¬å°è¯•ç”Ÿé”ˆï¼š </p><p> $ cargo new -q length$ cd length$ echo &#39;fn main() { println!(&#34;{}&#34;, &#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;.len() == 17); }&#39; &gt; src/main.rs$ cargo run -qtrue</p><p>$ cargo new -q loget $ cdé•¿åº¦$ echoï¼†ï¼ƒ39; fn mainï¼ˆï¼‰{printlnï¼ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34; .lenï¼ˆï¼‰ == 17ï¼‰; }ï¼†ï¼ƒ39; ï¼†gt; src / main.rs $è´§ç‰©è¿è¡Œ-qtrue</p><p>     The string that contains one graphical unit consists of 5 Unicode scalar values. First, thereâ€™s a base character that means a person face palming. By default, the person would have a cartoonish yellow color. The next character is an emoji skintone modifier the changes the color of the personâ€™s skin (and, in practice, also the color of the personâ€™s hair). By default, the gender of the person is undefined, and e.g. Apple defaults to what they consider a male appearance and e.g. Google defaults to what they consider a female appearance. The next two scalar values pick a male-typical appearance specifically regardless of font and vendor. Instead of being an emoji-specific modifier like the skin tone, the gender specification uses an emoji-predating gender symbol (MALE SIGN) explicitly ligated using the ZERO WIDTH JOINER with the (skin-toned) face-palming person. (Whether it is a good or a bad idea that the skin tone and gender specifications use different mechanisms is out of the scope of this post.) Finally, VARIATION SELECTOR-16 makes it explicit that we want a multicolor emoji rendering instead of a monochrome dingbat rendering.</p><p>     åŒ…å«ä¸€ä¸ªå›¾å½¢å•å…ƒçš„å­—ç¬¦ä¸²ç”±5ä¸ªUnicodeæ ‡é‡å€¼ç»„æˆã€‚é¦–å…ˆï¼Œæœ‰ä¸€ä¸ªåŸºæœ¬çš„è§’è‰²ï¼Œè¿™æ„å‘³ç€ä¸€ä¸ªäººçš„é¢å­”æŸã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¯¥äººå°†æœ‰ä¸€ç§å¡é€šé»„è‰²ã€‚ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ä¸€ä¸ªè¡¨æƒ…ç¬¦å·Skintoneä¿®é¥°ç¬¦ï¼Œæ”¹å˜äº†äººçš®è‚¤çš„é¢œè‰²ï¼ˆä»¥åŠåœ¨å®è·µä¸­ï¼Œä¹Ÿæ˜¯äººçš„å¤´å‘çš„é¢œè‰²ï¼‰ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¯¥äººçš„æ€§åˆ«æœªå®šä¹‰ï¼Œä¾‹å¦‚ï¼Œè‹¹æœé»˜è®¤ä¸ºä»–ä»¬è®¤ä¸ºç”·æ€§å¤–è§‚å’Œä¾‹å¦‚ï¼Œ Googleé»˜è®¤ä¸ºä»–ä»¬è®¤ä¸ºå¥³æ€§å¤–è§‚ã€‚æ¥ä¸‹æ¥çš„ä¸¤ä¸ªæ ‡é‡å€¼æ˜ç¡®åœ°é€‰æ‹©äº†ä¸€ä¸ªç”·æ€§å…¸å‹çš„å¤–è§‚ï¼Œæ— è®ºå­—ä½“å’Œä¾›åº”å•†å¦‚ä½•ã€‚æ€§åˆ«è§„èŒƒè€Œä¸æ˜¯åƒè‚¤è‰²ä¸€æ ·çš„è¡¨è¾¾ç‰¹å®šçš„ä¿®é¥°è¯­ï¼Œè€Œæ˜¯ä½¿ç”¨é›¶å®½åº¦æœ¨åŒ ç”¨ï¼ˆçš®è‚¤å®šä½çš„ï¼‰é¢éƒ¨æŸæ ‘äººæ˜ç¡®åœ°è¿æ¥çš„è¡¨æƒ…ç¬¦å·é¢„æµ‹æ€§åˆ«ç¬¦å·ï¼ˆç”·æ€§æ ‡å¿—ï¼‰ã€‚ ï¼ˆæ˜¯å¦æ˜¯ä¸€ç§å¾ˆå¥½çš„æˆ–åçš„æƒ³æ³•ï¼Œå³è‚¤è‰²å’Œæ€§åˆ«è§„èŒƒä½¿ç”¨ä¸åŒçš„æœºåˆ¶æ˜¯ä¸å¯èƒ½çš„ã€‚ï¼‰æœ€åï¼Œå˜ä½“é€‰æ‹©å™¨-16ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ˜ç¡®åˆ°æˆ‘ä»¬æƒ³è¦å¤šè‰²EMOJIæ¸²æŸ“è€Œä¸æ˜¯å•è‰²ã€‚ Dingbatæ¸²æŸ“ã€‚</p><p> Each of the languages above reports the string length as the number of  code units that the string occupies. Python 3 strings store Unicode code points each of which is stored as one code unit by CPython 3, so the string occupies 5 code units. JavaScript (and Java) strings have (potentially-invalid) UTF-16 semantics, so the string occupies 7 code units. Rust strings are (guaranteed-valid) UTF-8, so the string occupies 17 code units. Weâ€™ll come to back to the actual  storage as opposed to  semantics later.</p><p> ä¸Šé¢çš„æ¯ç§è¯­è¨€éƒ½å°†å­—ç¬¦ä¸²é•¿åº¦æŠ¥å‘Šä¸ºå­—ç¬¦ä¸²å ç”¨çš„ä»£ç å•å…ƒæ•°ã€‚ Python 3å­—ç¬¦ä¸²å­˜å‚¨Unicodeä»£ç ç‚¹æ¯ä¸ªç”±cpython 3å­˜å‚¨ä¸ºä¸€ä¸ªä»£ç å•å…ƒï¼Œå› æ­¤å­—ç¬¦ä¸²å ç”¨5ä¸ªä»£ç å•å…ƒã€‚ JavaScriptï¼ˆå’ŒJavaï¼‰å­—ç¬¦ä¸²å…·æœ‰ï¼ˆæ½œåœ¨æ— æ•ˆï¼‰UTF-16è¯­ä¹‰ï¼Œå› æ­¤å­—ç¬¦ä¸²å ç”¨7ä¸ªä»£ç å•å…ƒã€‚ rustå­—ç¬¦ä¸²ï¼ˆä¿è¯æœ‰æ•ˆï¼‰UTF-8ï¼Œå› æ­¤å­—ç¬¦ä¸²å ç”¨17ä¸ªä»£ç å•å…ƒã€‚æˆ‘ä»¬å°†ç¨åå†æ¬¡è¿”å›å®é™…å­˜å‚¨ï¼Œè€Œä¸æ˜¯è¯­ä¹‰ã€‚</p><p> Note about Python 3 added on 2019-09-09: Originally this article claimed that Python 3 guaranteed UTF-32 validity. This was in error. Python 3 guarantees that the units of the string stay within the Unicode code point range but does not guarantee the absence of surrogates. It not only allows unpaired surrogates, which might be explained by wishing to be compatible with the value space of potentially-invalid UTF-16, but Python 3 allows materializing even surrogate pairs, which is a truly bizarre design. The previous conclusions stand with the added conclusion that Python 3 is even more messed up than I thought! With the way the example string was constructed in Python 3, the Python 3 string happens to match the valid UTF-32 representation of the string, so it is still illustrative of UTF-32, but the rest of the article has been slightly edited to avoid claiming that Python 3 used UTF-32.</p><p> å…³äºPython 3åœ¨2019-09-09ä¸­æ·»åŠ äº†å…³äºPython 3ï¼šæœ€åˆæœ¬æ–‡å£°ç§°Python 3ä¿è¯äº†UTF-32æœ‰æ•ˆæ€§ã€‚è¿™æ˜¯é”™è¯¯çš„ã€‚ Python 3ä¿è¯å­—ç¬¦ä¸²çš„å•ä½ä¿æŒåœ¨Unicodeç ç‚¹èŒƒå›´å†…ï¼Œä½†ä¸ä¿è¯ç¼ºå°‘ä»£ç†äººã€‚å®ƒä¸ä»…å…è®¸æœªé…å¯¹ä»£ç†ï¼Œè¿™å¯èƒ½æ˜¯é€šè¿‡å¸Œæœ›ä¸æ½œåœ¨çš„UTF-16çš„ä»·å€¼ç©ºé—´å…¼å®¹æ¥è§£é‡Šï¼Œä½†Python 3å…è®¸å®ç°ç”šè‡³ä»£ç†å¯¹ï¼Œè¿™æ˜¯ä¸€ä¸ªçœŸæ­£çš„å¥‡å¼‚è®¾è®¡ã€‚ä¹‹å‰çš„ç»“è®ºæ˜¯è¾¾åˆ°çš„ç»“è®ºï¼Œå³Python 3æ¯”æˆ‘æƒ³è±¡çš„æ›´æç ¸äº†ï¼éšç€ç¤ºä¾‹å­—ç¬¦ä¸²åœ¨Python 3ä¸­æ„é€ çš„æ–¹å¼ï¼Œçªç„¶å‘ç”ŸPython 3å­—ç¬¦ä¸²ä»¥åŒ¹é…å­—ç¬¦ä¸²çš„æœ‰æ•ˆUTF-32è¡¨ç¤ºï¼Œå› æ­¤å®ƒä»ç„¶æ˜¯UTF-32çš„è¯´æ˜ï¼Œä½†å…¶ä½™çš„æ–‡ç« å·²ç»ç•¥å¾®ç¼–è¾‘é¿å…å£°ç§°Python 3ä½¿ç”¨UTF-32ã€‚</p><p>  Thereâ€™s a language for that. The following used Swift 4.2.3, which was the latest release when I was researching this, on Ubuntu 18.04:</p><p>  æœ‰ä¸€ç§è¯­è¨€ã€‚ä»¥ä¸‹ä½¿ç”¨çš„Swift 4.2.3ï¼Œè¿™æ˜¯æˆ‘åœ¨ubuntu 18.04ä¸Šç ”ç©¶çš„æœ€æ–°ç‰ˆæœ¬ï¼š</p><p> $ mkdir swiftlen$ cd swiftlen/$ swift package init -q --type executable$ swift package init --type executableCreating executable package: swiftlenCreating Package.swiftCreating README.mdCreating .gitignoreCreating Sources/Creating Sources/swiftlen/main.swiftCreating Tests/Creating Tests/LinuxMain.swiftCreating Tests/swiftlenTests/Creating Tests/swiftlenTests/swiftlenTests.swiftCreating Tests/swiftlenTests/XCTestManifests.swift$ echo &#39;print(&#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;.count == 1)&#39; &gt; Sources/swiftlen/main.swift $ swift run swiftlen 2&gt;/dev/nulltrue</p><p> $ mkdir swiftlen $ cd swiftlen / $ swiftåŒ…init-q-typeå¯æ‰§è¡Œæ–‡ä»¶$ swiftåŒ…init  -  type executablecreationå¯æ‰§è¡ŒåŒ…ï¼šswiftlencreating package.swiftcreating Readme.mdcreating .gitignoreCreatingæº/åˆ›å»ºæº/ swiftlen / main.swiftåˆ›å»ºæµ‹è¯•/åˆ›å»ºæµ‹è¯•/ Linuxmain.SwiftCroaringæµ‹è¯•/ SwiftLentests /åˆ›å»ºæµ‹è¯•/ SwiftLentests / SwiftLentests.Swiftåˆ›å»ºæµ‹è¯•/ SwiftLentests / XCTestmanifests.swift $ Echoï¼†ï¼ƒ39;æ‰“å°ï¼ˆï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34; .count == 1ï¼‰ ï¼†ï¼ƒ39; ï¼†gt;æº/ swiftlen / main.swift $ swiftè¿è¡Œswiftlen 2ï¼†gt; / dev / nulltrue</p><p> (Not using the Swift REPL for the example, because it does not appear to accept non-ASCII input on Ubuntu! Swift 5.0.3 prints the same and the REPL is still broken.)</p><p> ï¼ˆä¸ä½¿ç”¨Swift Replä¸ºä¾‹ï¼Œå› ä¸ºå®ƒä¼¼ä¹æ²¡æœ‰æ¥å—Ubuntuä¸Šçš„éASCIIè¾“å…¥ï¼SWIFT 5.0.3æ‰“å°ç›¸åŒï¼ŒREPLä»ç„¶è¢«æ‰“ç ´ã€‚ï¼‰ </p><p> OK, so weâ€™ve found a language that thinks the string contains one countable unit. But what is that countable unit? Itâ€™s an  extended grapheme cluster. (â€œExtendedâ€ to distinguish from the older attempt at defining grapheme clusters now called  legacy grapheme clusters.) The definition is in  Unicode Standard Annex #29 (UAX #29).</p><p>å¥½çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å‘ç°äº†ä¸€ç§è®¤ä¸ºå­—ç¬¦ä¸²åŒ…å«ä¸€ä¸ªå¯æ•°å•å…ƒçš„è¯­è¨€ã€‚ä½†æ˜¯å¯æ•°å•ä½æ˜¯ä»€ä¹ˆï¼Ÿè¿™æ˜¯ä¸€ä¸ªæ‰©å±•çš„å›¾å½¢é›†ç¾¤ã€‚ ï¼ˆâ€œæ‰©å±•â€ä»¥åŒºåˆ†ä»æ—§çš„å°è¯•å®šä¹‰ç°åœ¨ç§°ä¸ºä¼ ç»Ÿå›¾å½¢é›†ç¾¤çš„å›¾å½¢é›†ç¾¤ã€‚ï¼‰å®šä¹‰åœ¨Unicodeæ ‡å‡†é™„ä»¶ï¼ƒ29ä¸­ï¼ˆUAXï¼ƒ29ï¼‰ã€‚</p><p>    Given a valid Unicode string and a version of Unicode, all of the above are well-defined and it holds that each item higher on the list is greater or equal than the items lower on the list.</p><p>    ç»™å®šæœ‰æ•ˆçš„Unicodeå­—ç¬¦ä¸²å’ŒUnicodeçš„ç‰ˆæœ¬ï¼Œæ‰€æœ‰ä¸Šè¿°éƒ½æ˜¯æ˜ç¡®å®šä¹‰çš„ï¼Œå¹¶ä¸”å®ƒä¿å­˜åœ¨åˆ—è¡¨ä¸Šæ›´é«˜çš„æ¯ä¸ªé¡¹ç›®æ¯”åˆ—è¡¨ä¸Šæ›´ä½çš„é¡¹ç›®æ›´å¤§æˆ–ç›¸ç­‰ã€‚</p><p> One of these is not like the others, though: The first three numbers have an unchanging definition for any valid Unicode string whether it contains currently assigned scalar values or whether it is from the future and contains unassigned scalar values as far as software written today is aware. Also, computing the first three lengths does not involve lookups from the Unicode database. However, the last item depends on the Unicode version and involves lookups from the Unicode database. If a string contains scalar values that are unassigned as far as the copy of the Unicode database that the program is using is aware, the program will potentially overcount extended grapheme clusters in the string compared to a program whose copy of the Unicode database is newer and has assignments for those scalar values (and some of those assignments turn out to be combining characters).</p><p> å…¶ä¸­ä¸€ä¸ªå¹¶ä¸åƒå…¶ä»–äººï¼Œä½†æ˜¯ï¼šå‰ä¸‰ä¸ªæ•°å­—å¯¹äºä»»ä½•æœ‰æ•ˆçš„Unicodeå­—ç¬¦ä¸²ï¼Œå®ƒæ˜¯å¦åŒ…å«å½“å‰åˆ†é…çš„æ ‡é‡å€¼æˆ–è€…æ˜¯æ¥è‡ªæœªæ¥çš„ä»»ä½•æœ‰æ•ˆçš„Unicodeå­—ç¬¦ä¸²ï¼Œå¹¶åŒ…å«ç›®å‰å†™çš„è½¯ä»¶çš„æœªåˆ†é…æ ‡é‡å€¼çŸ¥é“çš„ã€‚æ­¤å¤–ï¼Œè®¡ç®—å‰ä¸‰ä¸ªé•¿åº¦ä¸æ¶‰åŠæ¥è‡ªUnicodeæ•°æ®åº“çš„æŸ¥æ‰¾ã€‚ä½†æ˜¯ï¼Œæœ€åä¸€ä¸ªé¡¹ç›®å–å†³äºUnicodeç‰ˆæœ¬ï¼Œæ¶‰åŠä»Unicodeæ•°æ®åº“æŸ¥æ‰¾ã€‚å¦‚æœå­—ç¬¦ä¸²åŒ…å«ç¨‹åºä½¿ç”¨çš„Unicodeæ•°æ®åº“çš„å‰¯æœ¬ï¼Œåˆ™è¯¥å­—ç¬¦ä¸²å€¼æ˜¯æ‰€çŸ¥é“çš„ï¼Œåˆ™è¯¥ç¨‹åºå°†å¯èƒ½ä¼šå æ®å­—ç¬¦ä¸²ä¸­çš„æ‰©å±•å›¾å½¢ç¾¤é›†ï¼Œè€Œä¸Unicodeæ•°æ®åº“çš„å‰¯æœ¬æ›´æ–°çš„ç¨‹åºç›¸æ¯”ï¼Œè¯¥ç¨‹åºç›¸æ¯”æœ‰å…³è¿™äº›æ ‡é‡å€¼çš„åˆ†é…ï¼ˆä»¥åŠå…¶ä¸­ä¸€äº›åˆ†é…ç»“æœæ˜¯ç»„åˆå­—ç¬¦ï¼‰ã€‚</p><p>  It is not the case that a given programming language has to choose only one of the above. If we run this Swift program:</p><p>  ç»™å®šçš„ç¼–ç¨‹è¯­è¨€å¿…é¡»ä»…é€‰æ‹©ä¸Šè¿°ä¸€ä¸ªè¯­è¨€æ˜¯ä¸è¿™æ ·çš„ã€‚å¦‚æœæˆ‘ä»¬è¿è¡Œæ­¤Swiftç¨‹åºï¼š</p><p>     use unicode_segmentation::UnicodeSegmentation;fn main() {	let s = &#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;;	println!(&#34;{}&#34;, s.graphemes(true).count());	println!(&#34;{}&#34;, s.chars().count());	println!(&#34;{}&#34;, s.encode_utf16().count());	println!(&#34;{}&#34;, s.len());}</p><p>     ä½¿ç”¨unicode_segmentation :: Unicodesegation; fn mainï¼ˆï¼‰{let s =ï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34 ;; printlnï¼ï¼ˆï¼†ï¼ƒ34; {}}ï¼†ï¼ƒ34;ï¼Œs.graphemesï¼ˆtrueï¼‰.countï¼ˆï¼‰ï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼Œs.charsï¼ˆï¼‰ã€‚countï¼ˆï¼‰ï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34; {}}ï¼†ï¼ƒ34;ï¼Œs.encode_utf16ï¼ˆï¼‰ã€‚countï¼ˆï¼‰ï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼Œs.lenï¼ˆï¼‰ï¼‰;}</p><p>   Thatâ€™s unexpected! It turns out that  unicode-segmentation does not implement the latest version of the Unicode segmentation rules, so it gives the ZERO WIDTH JOINER generic treatment (break right after ZWJ) instead of the newer refinement in the emoji context.</p><p>   é‚£æ˜¯å‡ºä¹æ„æ–™çš„ï¼äº‹å®è¯æ˜ï¼ŒUnicode-segsationä¸å®ç°Unicodeåˆ†æ®µè§„åˆ™çš„æœ€æ–°ç‰ˆæœ¬ï¼Œå› æ­¤å®ƒç»™å‡ºäº†Zero Widey Joineré€šç”¨å¤„ç†ï¼ˆZWJä¹‹åçš„å³ä¾§ï¼‰è€Œä¸æ˜¯è¡¨æƒ…ç¬¦å·ä¸Šä¸‹æ–‡ä¸­çš„è¾ƒæ–°çš„ç»†åŒ–ã€‚</p><p> Letâ€™s try again, but this time with  unic-segment = &#34;0.9.0&#34; in  Cargo.toml: use unic_segment::Graphemes;fn main() {	let s = &#34;ğŸ¤¦ğŸ¼â€â™‚ï¸&#34;;	println!(&#34;{}&#34;, Graphemes::new(s).count());	println!(&#34;{}&#34;, s.chars().count());	println!(&#34;{}&#34;, s.encode_utf16().count());	println!(&#34;{}&#34;, s.len());}</p><p> è®©æˆ‘ä»¬å†è¯•ä¸€æ¬¡ï¼Œä½†è¿™æ¬¡ä¸Unic-segment =ï¼†ï¼ƒ34; 0.9.0ï¼†ï¼ƒ34;åœ¨Cargo.tomlï¼šä½¿ç”¨Unic_segment :: Graphemes; Fn Mainï¼ˆï¼‰{Let S =ï¼†ï¼ƒ34;ğŸ¤¦ğŸ¼â™‚ï¸ï¼†ï¼ƒ34 ;; Printlnï¼ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼Œgraphemes :: newï¼ˆsï¼‰.countï¼ˆï¼‰ï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼Œs.charsï¼ˆï¼‰ã€‚countï¼ˆï¼‰ï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34; {}}ï¼†ï¼ƒ34;ï¼Œs.encode_utf16ï¼ˆï¼‰ã€‚countï¼ˆï¼‰ï¼‰; printlnï¼ï¼ˆï¼†ï¼ƒ34; {}ï¼†ï¼ƒ34;ï¼Œs.lenï¼ˆï¼‰ï¼‰;} </p><p>  In the Rust case, strings (here mere string slices) know the number of UTF-8 code units they contain. The  len() method call just returns this number that has been stored since the creation of the string (in this case, compile time). In the other cases, what happens is the creation of an iterator and then instead of actually examining the values (string slices correspoding to extended grapheme clusters, Unicode scalar values or UTF-16 code units) that the iterator would yield, the  count() method just consumes the iterator and returns the number of items that were yielded by the iteration. The count isnâ€™t stored anywhere on the string (slice) afterwards. If we wanted to later know the counts again, weâ€™d have to iterate over the string again.</p><p>åœ¨ç”Ÿé”ˆæ¡ˆä¾‹ä¸­ï¼Œå­—ç¬¦ä¸²ï¼ˆè¿™é‡Œåªæœ‰å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼‰çŸ¥é“å®ƒä»¬åŒ…å«çš„UTF-8ä»£ç å•å…ƒçš„æ•°é‡ã€‚ LENï¼ˆï¼‰æ–¹æ³•è°ƒç”¨åªè¿”å›è‡ªåˆ›å»ºå­—ç¬¦ä¸²ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘æ—¶é—´ï¼‰ä»¥æ¥å·²å­˜å‚¨çš„æ­¤æ•°å­—ã€‚åœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæ˜¯åˆ›å»ºè¿­ä»£å™¨ï¼Œè€Œä¸æ˜¯å®é™…æ£€æŸ¥è¿­ä»£å™¨å°†äº§ç”Ÿçš„è¿­ä»£å™¨å°†äº§ç”Ÿçš„å€¼ï¼ˆå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ŒUnicodeç¾¤é›†ï¼ŒUnicodeæ ‡é‡å€¼æˆ–UTF-16ä»£ç å•å…ƒï¼‰æ–¹æ³•åªéœ€æ¶ˆè€—è¿­ä»£å™¨å¹¶è¿”å›ç”±è¿­ä»£æ‰€äº§ç”Ÿçš„é¡¹ç›®æ•°ã€‚ä¹‹åï¼Œè®¡æ•°æœªå­˜å‚¨åœ¨å­—ç¬¦ä¸²ï¼ˆåˆ‡ç‰‡ï¼‰ä¸Šçš„ä»»ä½•ä½ç½®ã€‚å¦‚æœæˆ‘ä»¬æƒ³å†æ¬¡ç¨åçŸ¥é“è®¡æ•°ï¼Œæˆ‘ä»¬å¿…é¡»å†æ¬¡è¿­ä»£å­—ç¬¦ä¸²ã€‚</p><p>  This introduces a notable question in the design space: Should a given type of length quantity be eagerly computed when the string is created? Or should the length be computed when someone asks for it? Or should it be computed when someone asks for it and then automatically stored on the string object so that itâ€™s available immediately if someone asks for it again?</p><p>  è¿™åœ¨è®¾è®¡ç©ºé—´ä¸­å¼•å…¥äº†ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„é—®é¢˜ï¼šå¦‚æœåˆ›å»ºå­—ç¬¦ä¸²æ—¶ä¼šçƒ­åˆ‡åœ°è®¡ç®—ç»™å®šç±»å‹çš„é•¿åº¦æ•°é‡ï¼Ÿæˆ–è€…å¦‚æœæœ‰äººè¦æ±‚å®ƒåº”è¯¥è®¡ç®—é•¿åº¦ï¼Ÿæˆ–è€…å½“æœ‰äººè¦æ±‚å®ƒç„¶åè‡ªåŠ¨å­˜å‚¨åœ¨å­—ç¬¦ä¸²å¯¹è±¡ä¸­æ—¶ï¼Œå®ƒåº”è¯¥è®¡ç®—ï¼Œä»¥ä¾¿å¦‚æœæœ‰äººå†æ¬¡è¦æ±‚å®ƒå¯ä»¥ç«‹å³å¯ç”¨ï¼Ÿ</p><p> The answer Rust has is that the length in the code units of the Unicode Encoding Form of the language is stored upon string creation, and the rest are computed when someone asks for them (and then forgotten and not stored on the string).</p><p> ç­”æ¡ˆRustå…·æœ‰è¯­è¨€çš„Unicodeç¼–ç å½¢å¼çš„ä»£ç å•å…ƒä¸­çš„é•¿åº¦å­˜å‚¨åœ¨å­—ç¬¦ä¸²åˆ›å»ºæ—¶ï¼Œå¹¶ä¸”å½“æœ‰äººè¦æ±‚å®ƒä»¬ï¼ˆç„¶åå¿˜è®°å¹¶ä¸å­˜å‚¨åœ¨å­—ç¬¦ä¸²ä¸Šæ—¶ï¼Œå…¶ä½™çš„</p><p> Swift is a higher-level language and doesnâ€™t document the exact nature of its string internals as part of the API contract. In fact, the internal representation of Swift strings changed substantially between Swift 4.2 and Swift 5.0. Itâ€™s not documented if different views to the string are held onto once created, for example. The documentation does say that strings are copy-on-write, so the first mutation may involve copying the stringâ€™s storage.</p><p> SWIFTæ˜¯ä¸€ç§æ›´é«˜çº§åˆ«çš„è¯­è¨€ï¼Œå¹¶æ²¡æœ‰å°†å…¶å­—ç¬¦ä¸²å†…éƒ¨å†…éƒ¨çš„ç¡®åˆ‡æ€§è´¨ä½œä¸ºAPIåˆåŒçš„ä¸€éƒ¨åˆ†è®°å½•ã€‚äº‹å®ä¸Šï¼ŒSWIFTä¸²çš„å†…éƒ¨è¡¨ç¤ºåœ¨SWIFT 4.2å’ŒSWIFT 5.0ä¹‹é—´å¤§å¤§å˜åŒ–ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå¯¹å­—ç¬¦ä¸²çš„ä¸åŒè§†å›¾ä¿æŒåœ¨åˆ›å»ºæ¬¡æ•°ï¼Œåˆ™ä¸ä¼šè®°å½•ã€‚æ–‡æ¡£ç¡®å®è¯´å­—ç¬¦ä¸²æ˜¯å¤åˆ¶å†™å…¥çš„ï¼Œå› æ­¤ç¬¬ä¸€ä¸ªçªå˜å¯èƒ½æ¶‰åŠå¤åˆ¶å­—ç¬¦ä¸²çš„å­˜å‚¨ã€‚</p><p> Notably, the design space includes not remembering anything. The C programming language is a prominent example of this case. C strings donâ€™t even remember their number of code units. To find out the number of code units, you have to iterate over the string until a sentinel value. In the case of C, the sentinel is the code unit for U+0000, so it excludes one Unicode scalar value from the possible string contents. However, thatâ€™s not a strictly necessary property of a sentinel-based design that doesnâ€™t remember any lengths. 0xFF does not occur as a code unit in any valid UTF-8 string and 0xFFFFFFFF does not occur in any valid UTF-32 string, so they could be used as sentinels for UTF-8 and UTF-32 storage, respectively, without excluding a scalar value from the Unicode value space. There is no 16-bit value that never occurs in a valid UTF-16 string. However, a valid UTF-16 string does not contain unpaired surrogates, so an unpaired low surrogate could, in principle, be used as a sentinel in a design that wanted to use guaranteed-valid UTF-16 strings that donâ€™t remember their code unit length.</p><p> å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè®¾è®¡ç©ºé—´ä¸åŒ…æ‹¬ä»»ä½•å†…å®¹ã€‚ Cç¼–ç¨‹è¯­è¨€æ˜¯è¿™ç§æƒ…å†µçš„ä¸€ä¸ªçªå‡ºç¤ºä¾‹ã€‚ Cå­—ç¬¦ä¸²ç”šè‡³æ²¡æœ‰è®°ä½ä»–ä»¬çš„ä»£ç å•ä½æ•°ã€‚è¦æ‰¾å‡ºä»£ç å•å…ƒçš„æ•°é‡ï¼Œæ‚¨å¿…é¡»åœ¨Sentinelå€¼æ—è¾¹è¿­ä»£å­—ç¬¦ä¸²ã€‚åœ¨Cçš„æƒ…å†µä¸‹ï¼ŒSentinelæ˜¯U + 0000çš„ä»£ç å•å…ƒï¼Œå› æ­¤å®ƒä»å¯èƒ½çš„å­—ç¬¦ä¸²å†…å®¹ä¸­æ’é™¤ä¸€ä¸ªUnicodeæ ‡é‡å€¼ã€‚ä½†æ˜¯ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªåŸºäºSentinelçš„è®¾è®¡çš„ä¸¥æ ¼å¿…è¦çš„å±æ€§ï¼Œè¿™äº›å±æ€§ä¸è®°å¾—ä»»ä½•é•¿åº¦ã€‚ 0xFFä¸ä¼šåœ¨ä»»ä½•æœ‰æ•ˆçš„UTF-8å­—ç¬¦ä¸²ä¸­ä½œä¸ºä»£ç å•å…ƒå‘ç”Ÿï¼Œå¹¶ä¸”åœ¨ä»»ä½•æœ‰æ•ˆçš„UTF-32å­—ç¬¦ä¸²ä¸­éƒ½ä¸ä¼šå‘ç”Ÿ0xFFFFFFFFï¼Œå› æ­¤å®ƒä»¬å¯ä»¥åˆ†åˆ«ç”¨ä½œUTF-8å’ŒUTF-32å­˜å‚¨çš„Sentinelsï¼Œè€Œæ— éœ€æ’é™¤Aæ¥è‡ªUnicodeå€¼ç©ºé—´çš„æ ‡é‡å€¼ã€‚æ²¡æœ‰16ä½å€¼ï¼Œæ°¸è¿œä¸ä¼šå‘ç”Ÿåœ¨æœ‰æ•ˆçš„UTF-16å­—ç¬¦ä¸²ä¸­ã€‚ä½†æ˜¯ï¼Œæœ‰æ•ˆçš„UTF-16å­—ç¬¦ä¸²ä¸åŒ…å«æœªé…å¯¹çš„ä»£ç†ï¼Œå› æ­¤åŸåˆ™ä¸Šï¼Œæœªé…å¯¹çš„ä½ä»£ç†äººå¯ä»¥ç”¨ä½œæƒ³è¦ä½¿ç”¨ä¿è¯æœ‰æ•ˆçš„UTF-16å­—ç¬¦ä¸²çš„è®¾è®¡ä¸­çš„Sentinelï¼Œè¿™äº›rom-16å­—ç¬¦ä¸²ä¸è®°å¾—å…¶ä»£ç å•ä½é•¿åº¦ã€‚</p><p>  The length of the string as counted in code units of its storage-native Unicode Encoding Form (i.e. whichever of UTF-8, UTF-16, and UTF 32 the programming language has chosen for its string semantics) is not like the other lengths. It is the length that the implementation cannot avoid having to know at the time of creating a new string, because it is the length that is required to be known in order to be able to allocate storage for a string. Even C, which promptly forgets about the code unit length in the storage-native Unicode Encoding Form after string has been created, has to know this length when allocating storage for a new string.</p><p>  åœ¨å…¶å­˜å‚¨åŸå§‹Unicodeç¼–ç å½¢å¼çš„ä»£ç å•å…ƒä¸­è®¡æ•°çš„å­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆå³ï¼Œä»¥utf-8ï¼ŒUTF-16å’ŒUTF 32ä¸ºå…¶å­—ç¬¦ä¸²è¯­ä¹‰é€‰æ‹©çš„ç¼–ç¨‹è¯­è¨€ï¼‰ä¸åƒå¦ä¸€ä¸ªé•¿åº¦ã€‚å®ƒçš„é•¿åº¦æ˜¯åœ¨åˆ›å»ºæ–°å­—ç¬¦ä¸²æ—¶å¿…é¡»çŸ¥é“å¿…é¡»çŸ¥é“çš„é•¿åº¦ï¼Œå› ä¸ºå®ƒæ˜¯èƒ½å¤Ÿä¸ºå­—ç¬¦ä¸²åˆ†é…å­˜å‚¨æ‰€éœ€çš„é•¿åº¦ã€‚å¶æ•°Cï¼Œå®ƒè¿…é€Ÿå¿˜è®°åœ¨åˆ›å»ºå­—ç¬¦ä¸²ä¹‹åçš„å­˜å‚¨åŸæœ¬æœºUnicodeç¼–ç è¡¨å•ä¸­çš„ä»£ç å•å…ƒé•¿åº¦ï¼Œå¿…é¡»åœ¨ä¸ºæ–°å­—ç¬¦ä¸²åˆ†é…å­˜å‚¨æ—¶çŸ¥é“æ­¤é•¿åº¦ã€‚</p><p> That is, the design decision is about whether to remember this length. It is not about whether to compute it eagerly. You just have to have it at string creation timeâ€”i.e. eagerly.</p><p> ä¹Ÿå°±æ˜¯è¯´ï¼Œè®¾è®¡å†³å®šæ˜¯å…³äºæ˜¯å¦è¦è®°ä½è¿™ä¸€é•¿åº¦ã€‚å®ƒä¸æ˜¯å…³äºæ˜¯å¦æ€¥åˆ‡åœ°è®¡ç®—å®ƒã€‚ä½ åªéœ€è¦åœ¨Stringåˆ›å»ºæ—¶é—´ - å³ã€‚çƒ­åˆ‡åœ°ã€‚ </p><p> Considering that remembering this quantity makes string concatenation, which is a common operation, substantially faster to implement compared to not remembering this quantity, remembering this quantity is fundamentally reasonable. Also, it means that you donâ€™t need to maintain a sentinel value, which means that a substring operation can yield results that share the buffer with the original string instead of having to copy in order to be able to insert sentinel. (Note that you can easily foil this benefit if you wish to eagerly maintain zero-termination for the sake of C string compatibility.)</p><p>è€ƒè™‘åˆ°è®°ä½æ­¤æ•°é‡ä½¿å¾—å­—ç¬¦ä¸²è¿æ¥æ˜¯ä¸€ä¸ªå¸¸è§çš„æ“ä½œï¼Œä¸ä¸è®°å¾—è¿™ä¸ªæ•°é‡ç›¸æ¯”ï¼Œå®ç°çš„é€Ÿåº¦åŸºæœ¬ä¸Šæ›´å¿«ï¼Œè®°ä½æ­¤æ•°é‡æ˜¯æ ¹æœ¬åˆç†çš„ã€‚æ­¤å¤–ï¼Œè¿™æ„å‘³ç€æ‚¨ä¸éœ€è¦ç»´æŠ¤Sentinelå€¼ï¼Œè¿™æ„å‘³ç€å­å­—ç¬¦ä¸²æ“ä½œå¯ä»¥äº§ç”Ÿä¸åŸå§‹å­—ç¬¦ä¸²å…±äº«ç¼“å†²å™¨çš„ç»“æœï¼Œè€Œä¸æ˜¯å¿…é¡»å¤åˆ¶ä»¥ä¾¿èƒ½å¤Ÿæ’å…¥å“¨å…µã€‚ ï¼ˆè¯·æ³¨æ„ï¼Œå¦‚æœæ‚¨å¸Œæœ›æ€¥åˆ‡åœ°ä¿æŒé›¶ç»ˆæ­¢ï¼Œå› æ­¤å¯ä»¥è½»æ¾åœ°èåˆè¿™ç§ç¦åˆ©ï¼Œä»¥ä¾¿Cå­—ç¬¦ä¸²å…¼å®¹æ€§ã€‚ï¼‰</p><p>  Even if weâ€™ve established that it makes sense for string implementation to remember the storage length of the string in code units all the storage-native Unicode encoding form, it doesnâ€™t answer whether a string implementation should also remember other lengths or which kind of length should be offered in the most ergonomic API. (As we see above, Swift makes the number of extended grapheme clusters more ergonomic to obtain that the code unit or scalar value length.)</p><p>  å³ä½¿æˆ‘ä»¬å·²ç»ç¡®å®šå­—ç¬¦ä¸²å®ç°æ˜¯æœ‰é“ç†çš„ï¼Œä»¥è®°ä½ä»£ç å•å…ƒä¸­çš„å­—ç¬¦ä¸²çš„å­˜å‚¨é•¿åº¦ï¼Œä¹Ÿä¸å›ç­”å­—ç¬¦ä¸²å®ç°æ˜¯å¦åº”è¯¥è®°ä½å…¶ä»–é•¿åº¦æˆ–å“ªç§ç±»å‹åº”åœ¨æœ€ç¬¦åˆäººä½“å·¥ç¨‹å­¦çš„APIä¸­æä¾›é•¿åº¦ã€‚ ï¼ˆæ­£å¦‚æˆ‘ä»¬ä¸Šé¢çš„é‚£æ ·ï¼ŒSWIFTä½¿å¾—æ‰©å±•çš„çŸ³å¢¨ç°‡æ•°é‡æ›´åŠ ç¬¦åˆäººä½“å·¥ç¨‹å­¦ï¼Œä»¥è·å¾—ä»£ç å•å…ƒæˆ–æ ‡é‡å€¼é•¿åº¦ã€‚ï¼‰</p><p> Also, if any other length is to be remembered, there is the question of whether it should be eagerly computed as string creation time or lazily computed the first time someone asks for it. It is easy to see why at least the latter does not make sense for multi-threaded systems-programming language like Rust. If some properties of an object are lazily initialized, in a multi-threaded case you also need to solve synchronization of these computations. Furthermore, you need to allocate space at least for a pointer to auxiliary information if you want to be able to add auxiliary information later or you need to have a hashtable of auxiliary information where the string the information is about is the key, so auxiliary information, even when not present, has storage implications or implications of having to have global state in a run-time system. Finally, for systems programming, it may be more desirable to know the time complexity of a given operation clearly even if it means â€œalways O(n)â€ instead of â€œpossibly O(n) but sometimes O(1)â€. Even if the latter looks strictly better, it is less  predictable.</p><p> æ­¤å¤–ï¼Œå¦‚æœè¦è®°ä½ä»»ä½•å…¶ä»–é•¿åº¦ï¼Œé‚£ä¹ˆæœ‰é—®é¢˜æ˜¯åº”è¯¥è¢«æ€¥åˆ‡åœ°è®¡ç®—ä¸ºå­—ç¬¦ä¸²åˆ›å»ºæ—¶é—´è¿˜æ˜¯æ‡’æ´‹åœ°è®¡ç®—æœ‰äººç¬¬ä¸€æ¬¡è¦æ±‚å®ƒã€‚å¾ˆå®¹æ˜“çœ‹å‡ºä¸ºä»€ä¹ˆè‡³å°‘åè€…æ²¡æœ‰æ„ä¹‰äºåƒç”Ÿé”ˆè¿™æ ·çš„å¤šçº¿ç¨‹ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ã€‚å¦‚æœå¯¹è±¡çš„æŸäº›å±æ€§æ‡’æƒ°åœ°åˆå§‹åŒ–ï¼Œåˆ™åœ¨å¤šçº¿ç¨‹çš„æƒ…å†µä¸‹ï¼Œè¿˜éœ€è¦è§£å†³è¿™äº›è®¡ç®—çš„åŒæ­¥ã€‚æ­¤å¤–ï¼Œå¦‚æœè¦èƒ½å¤Ÿç¨åæ·»åŠ è¾…åŠ©ä¿¡æ¯ï¼Œåˆ™éœ€è¦è‡³å°‘é’ˆå¯¹æŒ‡å‘è¾…åŠ©ä¿¡æ¯çš„æŒ‡é’ˆåˆ†é…ç©ºé—´æˆ–è€…æ‚¨éœ€è¦å…·æœ‰å­—ç¬¦ä¸²ä¿¡æ¯æ‰€åœ¨çš„è¾…åŠ©ä¿¡æ¯çš„å“ˆå¸Œè¡¨æ˜¯å…³é”®ï¼Œå› æ­¤è¾…åŠ©ä¿¡æ¯ï¼Œå³ä½¿åœ¨ä¸å­˜åœ¨æ—¶ï¼Œä¹Ÿå…·æœ‰åœ¨è¿è¡Œæ—¶ç³»ç»Ÿä¸­å…·æœ‰å…¨å±€çŠ¶æ€çš„å­˜å‚¨å½±å“æˆ–å«ä¹‰ã€‚æœ€åï¼Œå¯¹äºç³»ç»Ÿç¼–ç¨‹ï¼Œå³ä½¿å®ƒæ„å‘³ç€â€œå§‹ç»ˆOï¼ˆnï¼‰â€è€Œä¸æ˜¯â€œå¯èƒ½Oï¼ˆnï¼‰ä½†æœ‰æ—¶Oï¼ˆ1ï¼‰â€ï¼Œä¹Ÿå¯èƒ½æ›´å¸Œæœ›æ¸…æ¥šåœ°æ¸…æ¥šåœ°äº†è§£ç»™å®šæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ã€‚å³ä½¿åè€…ä¸¥æ ¼çœ‹èµ·æ¥ï¼Œå®ƒä¹Ÿä¸å¤ªå¯é¢„æµ‹ã€‚</p><p> For a higher-level language, arguments from space requirements or synchronization issues might not be decisive. Itâ€™s more relevant to consider what a given length quantity is  used for. This is often forgotten in Internet debates that revolve around what length is the most â€œcorrectâ€ or â€œlogicalâ€ one. So for the lengths that donâ€™t map to the size of storage allocation, what are they good for?</p><p> å¯¹äºæ›´é«˜çº§åˆ«çš„è¯­è¨€ï¼Œç©ºé—´éœ€æ±‚æˆ–åŒæ­¥é—®é¢˜çš„å‚æ•°å¯èƒ½ä¸ä¼šå¯¼è‡´å†³å®šæ€§ã€‚å®ƒæ›´é‡è¦çš„æ˜¯è€ƒè™‘ä¸€äº›ç»™å®šçš„é•¿åº¦æ•°é‡ã€‚è¿™é€šå¸¸å¿˜è®°å›´ç»•äº’è”ç½‘è¾©è®ºï¼Œè¿™äº›è¾©è®ºå›´ç»•æœ€é•¿åº¦æ˜¯æœ€â€œæ­£ç¡®â€æˆ–â€œé€»è¾‘â€çš„äº‰è®ºã€‚å› æ­¤ï¼Œå¯¹äºä¸æ˜ å°„åˆ°å­˜å‚¨åˆ†é…å¤§å°çš„é•¿åº¦ï¼Œå®ƒä»¬æœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿ</p><p> It turns out that in the Firefox code base there are two places where someone wants to know the number of Unicode scalar values in a string that is not being stored as UTF-32 and attention is not paid to what the scalar values actually are. The IETF specification for Session Traversal Utilities for NAT (STUN) used for WebRTC has the curious property that it places length limits on certain protocol strings such that the limits are expressed as number of Unicode scalar values but the strings are transmitted in UTF-8. Firefox validates these limits. (The limit looks like an arbitrary power-of-two (128 scalar values). The spec has remarks about the possible resulting byte length, which was wrong according to the IETF UTF-8 RFC that was current and already nearly five years old at the time of publication of the STUN RFC. Specifically, the STUN RFC repeatedly says that 128 characters as UTF-8 may be as long as 763 bytes. To arrive at that number, you have to assume that a UTF-8 character can be up to six bytes long, as opposed to up to 4 bytes long as in the prevailing UTF-8 RFC and in the Unicode Standard, and that the last character of the 128 is a zero terminator and, therefore, known to take just one byte.) In this case, the reason for wishing to know a non-storage length is to  impose a limit. The other case is reporting the column number for the source location of JavaScript errors.</p><p> äº‹å®è¯æ˜ï¼Œåœ¨Firefoxä»£ç åº“ä¸­æœ‰ä¸¤ä¸ªåœ°æ–¹æœ‰äººæƒ³è¦çŸ¥é“æœªè¢«å­˜å‚¨ä¸ºUTF-32çš„å­—ç¬¦ä¸²ä¸­çš„Unicodeæ ‡é‡å€¼çš„æ•°é‡ï¼Œå¹¶ä¸”ä¸æ”¯ä»˜ç»™æ ‡é‡å€¼å®é™…çš„æ³¨æ„åŠ›ã€‚ç”¨äºWebRTCçš„NATï¼ˆSTUNï¼‰çš„ä¼šè¯éå†å®ç”¨ç¨‹åºçš„IETFè§„èŒƒå…·æœ‰å¥‡å’Œçš„å±æ€§ï¼Œå…¶åœ¨æŸäº›åè®®å­—ç¬¦ä¸²ä¸Šç½®äºé•¿åº¦é™åˆ¶ï¼Œä½¿å¾—é™åˆ¶è¡¨ç¤ºä¸ºUnicodeæ ‡é‡å€¼çš„æ•°é‡ï¼Œä½†åœ¨UTF-8ä¸­å‘é€å­—ç¬¦ä¸²ã€‚ FirefoxéªŒè¯äº†è¿™äº›é™åˆ¶ã€‚ ï¼ˆé™åˆ¶çœ‹èµ·æ¥åƒä¸€ä¸ªä»»æ„çš„ä¸¤ä¸ªåŠŸç‡ï¼ˆ128ä¸ªæ ‡é‡å€¼ï¼‰ã€‚è§„èŒƒæœ‰å…³äºå¯èƒ½ç»“æœçš„å­—èŠ‚é•¿åº¦çš„å¤‡æ³¨ï¼Œæ ¹æ®IETF UTF-8 RFCï¼Œè¿™æ˜¯è¿‘äº”å¹´çš„IETF UTF-8 RFCé”™è¯¯STUN RFCçš„å‡ºç‰ˆæ—¶é—´ã€‚å…·ä½“æ¥è¯´ï¼Œä»¤äººæƒŠå¹çš„RFCé‡å¤è¯´ï¼ŒUTF-8çš„128ä¸ªå­—ç¬¦å¯ä»¥æ˜¯763å­—èŠ‚ã€‚è¦åˆ°è¾¾è¯¥å·ç ï¼Œæ‚¨å¿…é¡»å‡è®¾UTF-8å­—ç¬¦å¯ä»¥å¯åŠ¨é•¿åº¦ä¸º6ä¸ªå­—èŠ‚ï¼Œè€Œä¸æ˜¯åœ¨æ™®éçš„UTF-8 RFCå’ŒUnicodeæ ‡å‡†ä¸­ç›¸åï¼Œå¹¶ä¸”128çš„æœ€åä¸€ä¸ªå­—ç¬¦æ˜¯é›¶ç»ˆæ­¢è€…ï¼Œå› æ­¤å·²çŸ¥åªéœ€è¦ä¸€ä¸ªå­—èŠ‚ã€‚ ï¼‰åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¸Œæœ›çŸ¥é“éå­˜å‚¨é•¿åº¦çš„åŸå› æ˜¯æ–½åŠ é™åˆ¶ã€‚å¦ä¸€ç§æƒ…å†µæ˜¯æŠ¥å‘ŠJavaScripté”™è¯¯çš„æºä½ç½®çš„åˆ—å·ã€‚</p><p> Length limits, which weâ€™ll come back to, probably arenâ€™t a frequent enough a use case to justify making strings know a particular kind of length as opposed to such length being possible to compute when asked for. Neither are error messages.</p><p> æˆ‘ä»¬å°†è¿”å›çš„é•¿åº¦é™åˆ¶å¯èƒ½ä¸æ˜¯é¢‘ç¹çš„ä½¿ç”¨æƒ…å†µï¼Œä»¥è¯æ˜åˆ¶ä½œå­—ç¬¦ä¸²çŸ¥é“ç‰¹å®šçš„é•¿åº¦ï¼Œè€Œä¸æ˜¯åœ¨è¢«è¦æ±‚æ—¶è®¡ç®—çš„é•¿åº¦ã€‚æ—¢ä¸æ˜¯é”™è¯¯æ¶ˆæ¯ã€‚</p><p> Another use case for asking for a length is iterating by index and using the length as the loop termination condition 1990s Java style. Like this:</p><p> ç”¨äºè¯¢é—®é•¿åº¦çš„å¦ä¸€ä¸ªç”¨ä¾‹æ˜¯é€šè¿‡ç´¢å¼•è¿­ä»£å¹¶ä½¿ç”¨é•¿åº¦ä½œä¸ºå¾ªç¯ç»ˆæ­¢æ¡ä»¶1990s Javaæ ·å¼ã€‚åƒè¿™æ ·ï¼š </p><p> for (int i = 0; i &lt; s.length(); i++) { // Do something with s.charAt(i)}</p><p>forï¼ˆint i = 0; iï¼†lt; s.lengthï¼ˆï¼‰; i ++ï¼‰{//ä¸s.charatï¼ˆiï¼‰åšæŸäº‹}</p><p> In this case, itâ€™s actually important for the length to be precomputed number on the string object. This use case is coupled with the requirement that indexing into the string to find the  nth unit corresponding to the count of units that the â€œlengthâ€ represents should be a fast operation.</p><p> åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒå®é™…ä¸Šå¯¹äºå­—ç¬¦ä¸²å¯¹è±¡ä¸Šçš„æ•°å­—çš„é•¿åº¦å®é™…ä¸Šæ˜¯é‡è¦çš„ã€‚æ­¤ç”¨ä¾‹ä¸ç´¢å¼•åˆ°å­—ç¬¦ä¸²çš„è¦æ±‚ï¼Œä»¥æ‰¾åˆ°ä¸â€œé•¿åº¦â€ä»£è¡¨çš„å•ä½è®¡æ•°å¯¹åº”çš„ç¬¬nä¸ªå•å…ƒåº”è¯¥æ˜¯å¿«é€Ÿæ“ä½œã€‚</p><p> The above pattern is a lot less conclusive in terms of what lengths should be precomputed (and what the indexing unit should be) than it first appears. The above loop doesnâ€™t do random access by index. It sequentially uses every index from zero up to, but not including,  length. Indeed, especially when iterating over a string by Unicode scalar value, typically when you examine the contents of a string, you iterate over the string in order. Programming languages these days provide an  iterator facility for this, and e.g. to iterate over a UTF-8 string by scalar value, the iterator does not need to know the number of scalar values up front. E.g. in Rust, you can do this in O(n) time despite string slices not knowing their number of Unicode scalar values:</p><p> ä»¥ä¸Šæ¨¡å¼çš„ç»“è®ºåœ¨äºåº”è¯¥é¢„å…ˆè®¡ç®—çš„é•¿åº¦ï¼ˆä»¥åŠç´¢å¼•å•å…ƒåº”è¯¥æ˜¯ä»€ä¹ˆï¼‰ï¼Œå®ƒæ˜¯é¦–æ¬¡å‡ºç°çš„ã€‚ä¸Šè¿°å¾ªç¯ä¸æŒ‰ç´¢å¼•éšæœºè®¿é—®ã€‚å®ƒé¡ºåºä½¿ç”¨ä»é›¶åˆ°é›¶çš„æ¯ä¸ªç´¢å¼•ï¼Œä½†ä¸åŒ…æ‹¬é•¿åº¦ã€‚å®é™…ä¸Šï¼Œç‰¹åˆ«æ˜¯å½“é€šè¿‡Unicodeæ ‡é‡å€¼è¿­ä»£å­—ç¬¦ä¸²æ—¶ï¼Œé€šå¸¸åœ¨æ£€æŸ¥å­—ç¬¦ä¸²çš„å†…å®¹æ—¶ï¼Œæ‚¨æŒ‰é¡ºåºè¿­ä»£å­—ç¬¦ä¸²ã€‚è¿™äº›å¤©ç¼–ç¨‹è¯­è¨€ä¸ºæ­¤æä¾›äº†è¿­ä»£å™¨è®¾æ–½ï¼Œè€Œä¾‹å¦‚ï¼Œè¦é€šè¿‡æ ‡é‡å€¼è¿­ä»£UTF-8å­—ç¬¦ä¸²ï¼Œè¿­ä»£å™¨ä¸éœ€è¦äº†è§£å‰é¢çš„æ ‡é‡å€¼çš„æ•°é‡ã€‚ä¾‹å¦‚ã€‚åœ¨Rustä¸­ï¼Œå°½ç®¡å­—ç¬¦ä¸²åˆ‡ç‰‡ä¸çŸ¥é“å®ƒä»¬çš„Unicodeæ ‡é‡å€¼æ•°é‡ï¼Œä½†æ‚¨å¯ä»¥åœ¨Oï¼ˆnï¼‰æ—¶é—´ä¸­æ‰§è¡Œæ­¤æ“ä½œï¼š</p><p>  (Note that  char is an 8-bit code unit (possibly UTF-8 code unit) in C and C++,  char is a UTF-16 code unit in Java,  char is a Unicode scalar value in Rust, and  Character is an extended grapheme cluster in Swift.)</p><p>  ï¼ˆè¯·æ³¨æ„ï¼ŒCHARæ˜¯Cå’ŒC ++ä¸­çš„8ä½ä»£ç å•å…ƒï¼ˆå¯èƒ½çš„UTF-8ä»£ç å•å…ƒï¼‰ï¼ŒCHARæ˜¯Javaä¸­çš„UTF-16ä»£ç å•å…ƒï¼ŒCHARæ˜¯RUREä¸­çš„UNICODEæ ‡é‡å€¼ï¼Œå¹¶ä¸”å­—ç¬¦æ˜¯ä¸€ä¸ªæ‰©å±•çš„çŸ³å¢¨å‰§çƒˆè”“å»¶ã€‚ï¼‰</p><p> A programming language together with its library ecosystem should provide iteration over a string by Unicode scalar value and by extended grapheme cluster, but it does not follow that strings would need to know the scalar value length or the extended grapheme cluster length up front. Unlike the code unit storage length, those quantities arenâ€™t useful for accelerating operations like concatenation that donâ€™t care about the exact content of the string.  The observation that having strings know their code unit length in their storage-native Unicode encoding form is extremely reasonable does not answer how many bits wide the code units should be.</p><p> ä¸å…¶åº“ç”Ÿæ€ç³»ç»Ÿä¸€èµ·çš„ç¼–ç¨‹è¯­è¨€åº”ç”±Unicodeæ ‡é‡å€¼å’Œæ‰©å±•çš„å›¾å½¢ç¾¤é›†æä¾›è¿­ä»£ï¼Œä½†å®ƒä¸éµå¾ªå­—ç¬¦ä¸²éœ€è¦äº†è§£æ ‡é‡å€¼é•¿åº¦æˆ–æ‰©å±•çš„å›¾å½¢ç¾¤é›†é•¿åº¦å‘å‰äº†è§£ã€‚ä¸ä»£ç å•å…ƒå­˜å‚¨é•¿åº¦ä¸åŒï¼Œé‚£äº›æ•°é‡å¯¹äºåŠ é€ŸåŒæ—¶åŠ é€Ÿçš„æ“ä½œä¸é€‚ç”¨äºä¸å…³å¿ƒå­—ç¬¦ä¸²çš„ç¡®åˆ‡å†…å®¹ã€‚å…·æœ‰å­—ç¬¦ä¸²åœ¨å…¶å­˜å‚¨åŸç”ŸUnicodeç¼–ç å½¢å¼ä¸­çŸ¥é“å…¶ä»£ç å•å…ƒé•¿åº¦çš„è§‚å¯Ÿæ˜¯éå¸¸åˆç†çš„ï¼Œä¸åº”å›ç­”ä»£ç å•å…ƒåº”è¯¥æ˜¯å¤šå°‘ä½ã€‚</p><p> The usual way to approach this question is to argue that UTF-32 is the best, because it provides O(1) indexing by â€œcharacterâ€ in the sense of a character meaning a Unicode scalar value, or the argument focuses on whether UTF-8 is unfair to some languages relative to UTF-16. I think these are bad ways to approach this question.</p><p> æ¥è¿‘è¿™ä¸ªé—®é¢˜çš„é€šå¸¸æ–¹æ³•æ˜¯äº‰è¾©è¯´UTF-32æ˜¯æœ€å¥½çš„ï¼Œå› ä¸ºå®ƒåœ¨å­—ç¬¦æ„ä¹‰ä¸Šé€šè¿‡â€œå­—ç¬¦â€æä¾›äº†oï¼ˆ1ï¼‰ç´¢å¼•ï¼Œè¿™æ„å‘³ç€Unicodeæ ‡é‡å€¼ï¼Œæˆ–è€…å‚æ•°ä¾§é‡äºutf- 8å¯¹UTF-16çš„æŸç§è¯­è¨€æ˜¯ä¸å…¬å¹³çš„ã€‚æˆ‘è®¤ä¸ºè¿™äº›æ˜¯è§£å†³è¿™ä¸ªé—®é¢˜çš„ç³Ÿç³•æ–¹å¼ã€‚</p><p> First of all, the argument that the answer should be UTF-32 is bad on two counts. First, it assumes that random access scalar value is important, but in practice it isnâ€™t. Itâ€™s reasonable to want to have a capability to iterate over a string by scalar value, but random access by scalar value is in the YAGNI department. Second, arguments in favor of UTF-32 typically come at a point where the person making the argument has learned about surrogate pairs in UTF-16 but has not yet learned about extended grapheme clusters being even larger things that the user perceives as unit. That is, if you escape the variable-width nature of UTF-16 to UTF-32, you pay by doubling the memory requirements and extended grapheme clusters are  still variable-width.</p><p> é¦–å…ˆï¼Œç­”æ¡ˆåº”è¯¥æ˜¯UTF-32çš„è®ºç‚¹åœ¨ä¸¤ä¸ªè®¡æ•°ä¸Šæ˜¯ç³Ÿç³•çš„ã€‚é¦–å…ˆï¼Œå®ƒå‡è®¾éšæœºè®¿é—®æ ‡é‡å€¼å¾ˆé‡è¦ï¼Œä½†å®é™…ä¸Šå®ƒä¸æ˜¯ã€‚å¸Œæœ›é€šè¿‡æ ‡é‡å€¼è¿­ä»£å­—ç¬¦ä¸²çš„åŠŸèƒ½æ˜¯åˆç†çš„ï¼Œä½†æ ‡é‡å€¼çš„éšæœºè®¿é—®æ˜¯åœ¨YAGNIéƒ¨é—¨ã€‚å…¶æ¬¡ï¼ŒèµæˆUTF-32çš„è®ºæ®é€šå¸¸ä¼šå‡ºç°åœ¨æå‡ºè®ºè¯çš„äººåœ¨UTF-16ä¸­çš„ä»£ç†å¯¹ï¼Œä½†å°šæœªäº†è§£åˆ°ç”¨æˆ·è®¤ä¸ºæ˜¯å•ä½çš„æ›´å¤§çš„ä¸œè¥¿ç”šè‡³æ›´å¤§çš„å›¾å½¢ç¾¤é›†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœé€ƒé¿UTF-16çš„å˜é‡å®½åº¦æ€§è´¨åˆ°UTF-32ï¼Œåˆ™é€šè¿‡åŠ å€å­˜å‚¨å™¨è¦æ±‚ï¼Œæ‰©å±•çš„çŸ³å¢¨ç°‡ä»ç„¶æ˜¯å¯å˜çš„å®½åº¦ã€‚ </p><p> Iâ€™ll come back to the length fairness issue later, but I think a different argument is much more relevant  in practice for the choice of in-memory Unicode encoding form. The more relevant argument is this: Implementations that choose UTF-8 actually accept the UTF-8 storage requirements. When wider-unit semantics are chosen for a language that doesnâ€™t provide raw memory access and, therefore, has the opportunity to tweak string storage, the implementations try to come up with ways to avoid actually paying the cost of the wider units in some situations.</p><p>æˆ‘ç¨åä¼šå›åˆ°é•¿åº¦çš„å…¬å¹³é—®é¢˜ï¼Œä½†æˆ‘è®¤ä¸ºåœ¨å®è·µä¸­ï¼Œå¯ä»¥åœ¨å®è·µä¸­è¿›è¡Œä¸åŒçš„è®ºç‚¹ï¼Œä»¥ä¾¿é€‰æ‹©å†…å­˜çš„Unicodeç¼–ç å½¢å¼ã€‚æ›´ç›¸å…³çš„å‚æ•°æ˜¯ï¼šé€‰æ‹©UTF-8å®é™…ä¸Šæ¥å—UTF-8å­˜å‚¨è¦æ±‚çš„å®ç°ã€‚å½“æ›´å®½å•å…ƒè¯­ä¹‰é€‰æ‹©äº†ä¸æä¾›åŸå§‹å†…å­˜è®¿é—®ï¼Œå› æ­¤è¯­è¨€ï¼Œæœ‰æœºä¼šæ¥è°ƒæ•´å­—ç¬¦ä¸²å­˜å‚¨ï¼Œå®ç°æ–¹å¼è¯•å›¾æƒ³å‡ºçš„åŠæ³•ï¼Œä»¥é¿å…å®é™…æ”¯ä»˜æ›´å¹¿æ³›çš„å•ä½æˆæœ¬åœ¨æŸäº›æƒ…å†µã€‚</p><p> JavaScript and Java strings have the semantics of potentially-invalid UTF-16. SpiderMonkey and V8 implement an optimization for omitting the leading zeros of each code unit in a string, i.e. storing the string as ISO-8859-1 (the actual ISO-8859-1, not the Web notion of â€œISO-8859-1â€ as a label of windows-1252), when all code units in the string have zeros in the most-significant half. The HotSpot JVM also implements this optimization, though enabling it is optional. Swift 4.2 implements a slightly different variant of the same idea, where ASCII-only strings are stored as 8-bit units and everything else is stored as UTF-16. CPython since 3.3 makes the same idea three-level with code point semantics: Strings are stored with 32-bit code units if at least one code point has a non-zero bit above the low 16 bits. Else if a string has a non-zero bits above the low 8 bits for at least one code point, the string is stored as 16-bit units. </p><p> JavaScriptå’ŒJavaå­—ç¬¦ä¸²å…·æœ‰æ½œåœ¨æ— æ•ˆçš„UTF-16çš„è¯­ä¹‰ã€‚ SpiderMoNkeyå’ŒV8å®ç°äº†ä¸€ä¸ªä¼˜åŒ–ï¼Œä»¥çœç•¥å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªä»£ç å•å…ƒçš„å‰å¯¼é›¶ï¼Œå³å°†å­—ç¬¦ä¸²å­˜å‚¨ä¸ºISO-8859-1ï¼ˆå®é™…çš„ISO-8859-1ï¼Œè€Œä¸æ˜¯â€œISO-8859-1â€çš„Webæ¦‚å¿µä½œä¸ºWindows-1252çš„æ ‡ç­¾ï¼‰ï¼Œå½“å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ä»£ç å•ä½éƒ½æœ‰é›¶ï¼Œæœ€é‡è¦çš„ä¸€åŠã€‚ Hotspot JVMè¿˜å®ç°äº†è¿™ç§ä¼˜åŒ–ï¼Œä½†ä½¿å…¶æ˜¯å¯é€‰çš„ã€‚ Swift 4.2å®ç°äº†ç›¸åŒæ€æƒ³çš„ç•¥å¾®ä¸åŒçš„å˜ä½“ï¼Œå…¶ä¸­ä»…å­˜å‚¨ASCIIå­—ç¬¦ä¸²ä½œä¸º8ä½å•å…ƒï¼Œå¹¶ä¸”å…¶ä»–æ‰€æœ‰å†…å®¹å­˜å‚¨ä¸ºUTF-16ã€‚ CPythonè‡ª3.3è‡ª3çº§ä¸ä»£ç ç‚¹è¯­ä¹‰è¿›è¡Œç›¸åŒçš„æ€æƒ³ï¼šå¦‚æœè‡³å°‘ä¸€ä¸ªä»£ç ç‚¹å…·æœ‰é«˜äº16ä½ä¸Šæ–¹çš„éé›¶ä½ï¼Œåˆ™ä¸²ä»¥32ä½ä»£ç å•å…ƒå­˜å‚¨ã€‚å¦åˆ™å¦‚æœå­—ç¬¦ä¸²åœ¨ä½8ä½ä¸Šæ–¹å…·æœ‰è‡³å°‘ä¸€ä¸ªä»£ç ç‚¹çš„éé›¶ä½ï¼Œåˆ™å°†å­—ç¬¦ä¸²å­˜å‚¨ä¸º16ä½å•å…ƒã€‚</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hsivonen.fi/string-length/">https://hsivonen.fi/string-length/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/å­—ç¬¦/">#å­—ç¬¦</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/length/">#length</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/å­—ç¬¦ä¸²/">#å­—ç¬¦ä¸²</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>