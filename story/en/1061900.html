<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Swiftæ¼”å‘˜ï¼šä¸€ä¸ªå®é™…çš„ä¾‹å­ï¼Œç¬¬1éƒ¨åˆ† Swift Actors: A practical example, part 1</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Swift Actors: A practical example, part 1<br/>Swiftæ¼”å‘˜ï¼šä¸€ä¸ªå®é™…çš„ä¾‹å­ï¼Œç¬¬1éƒ¨åˆ† </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-11 16:52:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/e50174eb64b66ff7bd2aab261afb4765.png"><img src="http://img2.diglog.com/img/2021/5/e50174eb64b66ff7bd2aab261afb4765.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Iâ€™ve been re-reading the Swift  structured concurrency roadmap and the Swift  actors proposal and noticed a note on the latter saying:</p><p>æˆ‘ä¸€ç›´åœ¨é‡æ–°é˜…è¯»Swiftç»“æ„åŒ–å¹¶å‘è·¯çº¿å›¾å’ŒSwiftæ¼”å‘˜ææ¡ˆï¼Œå¹¶æ³¨æ„åˆ°åè€…çš„ä¸€ä»½è¯´æ˜ï¼š</p><p>  So, naturally ğŸ¤“, I downloaded the  latest snapshot from Swift.org and took it for a spin to try out some actor code!</p><p>  æ‰€ä»¥ï¼Œè‡ªç„¶ğŸ¤“ï¼Œæˆ‘ä»swift.orgä¸‹è½½äº†æœ€æ–°çš„å¿«ç…§ï¼Œå¹¶å°†å…¶æ—‹è½¬æ—‹è½¬ä»¥å°è¯•ä¸€äº›æ¼”å‘˜ä»£ç ï¼</p><p>  Huge disclaimer: this is all experimental experience using a trunk code not cut into a release.</p><p>  å·¨å¤§çš„å…è´£å£°æ˜ï¼šè¿™æ˜¯ä½¿ç”¨æœªåˆ‡å‰²æˆé‡Šæ”¾çš„ä¸­ç»§ç çš„æ‰€æœ‰å®éªŒç»éªŒã€‚</p><p> I grabbed a May 4th  trunk snapshot of the swift toolchain, installed it on my machine, and activated it in my Xcode 12.5 beta via the Xcode/Toolchainsâ€¦ menu. Now I have Xcode running with Swift 5.5 ğŸ’ªğŸ¼:</p><p> æˆ‘æŠ“ä½äº†Swift Toolchainçš„5æœˆç¬¬4ä¸ªä¸­ç»§å¿«ç…§ï¼Œåœ¨æˆ‘çš„æœºå™¨ä¸Šå®‰è£…å®ƒï¼Œå¹¶é€šè¿‡Xcode / Toolchainsä¸­å°†å…¶æ¿€æ´»åœ¨æˆ‘çš„Xcode 12.5 Betaä¸­...èœå•ã€‚ç°åœ¨æˆ‘æœ‰Xcodeè¿è¡Œï¼Œswift 5.5ğŸ’ªğŸ¼ï¼š</p><p>  Next, I needed a project with enabled experimental concurrency support so I created an app from the command line:</p><p>  æ¥ä¸‹æ¥ï¼Œæˆ‘éœ€è¦ä¸€ä¸ªå…·æœ‰å¯ç”¨çš„å®éªŒå¹¶å‘æ”¯æŒçš„é¡¹ç›®ï¼Œå› æ­¤æˆ‘ä»å‘½ä»¤è¡Œåˆ›å»ºäº†ä¸€ä¸ªåº”ç”¨ç¨‹åºï¼š</p><p>  Then I cleaned up the  Package.swift file and added the swift compiler flag that was mentioned in the actors proposal:</p><p>  ç„¶åæˆ‘æ¸…ç†äº†åŒ…è£¹.swiftæ–‡ä»¶å¹¶æ·»åŠ äº†æ¼”å‘˜æè®®ä¸­æåˆ°çš„Swiftç¼–è¯‘å™¨æ ‡å¿—ï¼š</p><p> // swift-tools-version:5.4 import  PackageDescription let  package = Package( name:  &#34;ActorTest&#34;, platforms: [.macOS(.v11)], targets: [ .executableTarget( name:  &#34;ActorTest&#34;, swiftSettings: [ .unsafeFlags([  &#34;-Xfrontend&#34;,  &#34;-enable-experimental-concurrency&#34; ]) ] ) ])</p><p> // swift-tools-versionï¼š5.4å¯¼å…¥packageedescriptionè®©åŒ…=åŒ…è£¹ï¼ˆåç§°ï¼šï¼†ï¼ƒ34; actortestï¼†ï¼ƒ34;ï¼Œå¹³å°ï¼š[.macosï¼ˆ.v11ï¼‰]ï¼Œtargetsï¼š[.executableTargetï¼ˆåç§°ï¼šï¼†ï¼ƒ34; Scatortestï¼†ï¼ƒ34;ï¼ŒSwiftSettingsï¼š[.Unsafeflagsï¼ˆ[ï¼†ï¼ƒ34; -Xfrontendï¼†ï¼ƒ34;ï¼†ï¼ƒ34; -Enable-Deparical-mancurrencyï¼†ï¼ƒ34;]ï¼‰]ï¼‰]ï¼‰]ï¼‰ï¼‰ </p><p> âŒ˜+B to check if the projects builds fine and thatâ€™s all -  ActorsTest is now an app sporting experimental Swift concurrency with actors!</p><p>âŒ˜+ bæ£€æŸ¥é¡¹ç›®æ˜¯å¦ç½šæ¬¾ï¼Œè¿™ä¸€åˆ‡éƒ½æ˜¯ -  Actorstestç°åœ¨æ˜¯ä¸€ä¸ªåº”ç”¨è¿åŠ¨å®éªŒè¿…é€Ÿå¹¶å‘ä¸æ¼”å‘˜ï¼</p><p>  Iâ€™ve read few times the various Swift concurrency effort proposals and Iâ€™ll try to summarize my understanding of what actors solve (so far).</p><p>  æˆ‘å·²ç»è¯»è¿‡å‡ æ¬¡å„ç§å¿«é€Ÿå¹¶å‘åŠªåŠ›ææ¡ˆï¼Œæˆ‘ä¼šå°½åŠ›æ€»ç»“æˆ‘å¯¹æ¼”å‘˜è§£å†³çš„ç†è§£ï¼ˆåˆ°ç›®å‰ä¸ºæ­¢ï¼‰ã€‚</p><p> Note: I might be wrong about some points or things might change considerably later on.</p><p> æ³¨æ„ï¼šæˆ‘å¯èƒ½æ˜¯é”™è¯¯çš„ä¸€äº›ç‚¹ï¼Œæˆ–è€…åœ¨ä»¥åå¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚</p><p>   Is  Person thread-safe ğŸ¤”? In other words, will your app â€“&gt; ever&lt;â€“ crash inside  Person?</p><p>   äººæ˜¯çº¿ç¨‹å®‰å…¨çš„å—ï¼Ÿæ¢å¥è¯è¯´ï¼Œä½ çš„åº”ç”¨ç¨‹åºä¼š - ï¼†gt;æ°¸è¿œï¼†lt;  - é‡Œé¢çš„å´©æºƒï¼Ÿ</p><p> The answer is: â€œit dependsâ€. It depends how your or others&#39; code uses  Person. If two pieces of code, running concurrently, update  Person.name at the same time - your app will crash. ğŸŒ‹</p><p> ç­”æ¡ˆæ˜¯ï¼šâ€œè¿™å–å†³äºâ€ã€‚è¿™å–å†³äºä½ æˆ–ä»–äººçš„æ–¹å¼å¦‚ä½•ï¼†ï¼ƒ39;ä»£ç ä½¿ç”¨äººå‘˜ã€‚å¦‚æœä¸¤æ¡ä»£ç ï¼ŒåŒæ—¶è¿è¡Œï¼Œè¯·åŒæ—¶æ›´æ–°person.name  - æ‚¨çš„åº”ç”¨ç¨‹åºå°†å´©æºƒã€‚ ğŸŒ‹</p><p> Even if you make  Person.name private, in order to protect it from concurrent reads/writes from outside the class, you can still concurrently read/write from  within the class which is also going to crash your app.</p><p> å³ä½¿æ‚¨åˆ¶ä½œäººç‰©ã€‚ç§äººç§æœ‰ï¼Œä¸ºäº†ä»ç±»å¤–éƒ¨ä¿æŠ¤å®ƒï¼Œæ‚¨ä»ç„¶å¯ä»¥åœ¨ç±»å†…åŒæ—¶è¯»/å†™ï¼Œè¯¥ç±»ä¹Ÿå°†å´©æºƒæ‚¨çš„åº”ç”¨ã€‚</p><p> At present, if you are writing concurrent code, you are probably using Swiftâ€™s thread sanitizer to detect data races like the one Iâ€™m talking about above.</p><p> ç›®å‰ï¼Œå¦‚æœæ‚¨æ­£åœ¨ç¼–å†™å¹¶å‘ä»£ç ï¼Œæ‚¨å¯èƒ½æ­£åœ¨ä½¿ç”¨Swiftçš„çº¿ç¨‹Sunitizeræ¥æ£€æµ‹åƒä¸Šé¢æˆ‘è°ˆè®ºçš„é‚£æ ·çš„æ•°æ®æ¯”èµ›ã€‚ </p><p>  This is extremely useful but the problem is that this way you  still can write unsafe code. Crashes might still happen at runtime. You just hope youâ€™ll discover and fix all the issues by using the Thread sanitizer. (And wonâ€™t introduce new issues later on.)</p><p>è¿™æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œä½†é—®é¢˜æ˜¯è¿™ç§æ–¹å¼ï¼Œæ‚¨ä»ç„¶å¯ä»¥ç¼–å†™ä¸å®‰å…¨çš„ä»£ç ã€‚å´©æºƒå¯èƒ½ä»ç„¶å‘ç”Ÿåœ¨è¿è¡Œæ—¶ã€‚æ‚¨åªå¸Œæœ›ä½¿ç”¨Thread Sacitizerå‘ç°å¹¶ä¿®å¤æ‰€æœ‰é—®é¢˜ã€‚ ï¼ˆå¹¶ä¸”ç¨åä¸ä¼šå¼•å…¥æ–°é—®é¢˜ã€‚ï¼‰</p><p>  Actors offer data isolation within a type in such way that the code you write cannot create data races. In other words, thread-safety is built into the type system. Similarly to how mutability is - you simply cannot compile code that mutates immutable data.</p><p>  Actorsä»¥ä¸€ç§ç±»å‹çš„æ•°æ®éš”ç¦»æä¾›ï¼Œä»¥ä¾¿æ‚¨ç¼–å†™çš„ä»£ç æ— æ³•åˆ›å»ºæ•°æ®æ¯”èµ›ã€‚æ¢å¥è¯è¯´ï¼Œçº¿ç¨‹å®‰å…¨å†…ç½®äºç±»å‹ç³»ç»Ÿä¸­ã€‚ç±»ä¼¼äºå¯å˜æ€§å¦‚ä½• - æ‚¨æ ¹æœ¬æ— æ³•ç¼–è¯‘çªå˜ä¸å¯å˜æ•°æ®çš„ä»£ç ã€‚</p><p> Letâ€™s compare a class versus an actor. The  class below  is not thread safe and whether is crashes or not depends on the way other code uses it:</p><p> è®©æˆ‘ä»¬æ¯”è¾ƒè¯¾ç¨‹ä¸æ¼”å‘˜ã€‚ä¸‹é¢çš„è¯¾ç¨‹ä¸æ˜¯çº¿ç¨‹å®‰å…¨ï¼Œæ˜¯å¦å´©æºƒæˆ–ä¸ä¾èµ–äºå…¶ä»–ä»£ç ä½¿ç”¨å®ƒçš„æ–¹å¼ï¼š</p><p>  In contrast, the following  actor type  is safe to use concurrently. Thanks to the work-in-progress actors feature your code accesses the  name-property memory in a safe way. Itâ€™s guaranteed by the actor type:</p><p>  ç›¸æ¯”ä¹‹ä¸‹ï¼Œä»¥ä¸‹æ¼”å‘˜ç±»å‹å¯ä»¥å®‰å…¨ä½¿ç”¨ã€‚ç”±äºå·¥ä½œä¸­çš„å·¥ä½œæ–¹å¼ï¼Œæ‚¨çš„ä»£ç å¯ä»¥å®‰å…¨åœ°è®¿é—®åç§° - å±æ€§å†…å­˜ã€‚å®ƒç”±æ¼”å‘˜ç±»å‹ä¿è¯ï¼š</p><p>  I havenâ€™t delved into the implementation details but from what Iâ€™ve read so far in the proposal - actors transparently implement the following compile-time rules:</p><p>  æˆ‘è¿˜æ²¡æœ‰ç™»å½•åˆ°å®æ–½ç»†èŠ‚ï¼Œä½†åˆ°ç›®å‰ä¸ºæ­¢æˆ‘åœ¨ææ¡ˆä¸­è¯»åˆ°çš„å†…å®¹ - æ¼”å‘˜é€æ˜åœ°å®æ–½ä»¥ä¸‹ç¼–è¯‘æ—¶é—´è§„åˆ™ï¼š</p><p> Allow only asynchronous access to the actorâ€™s members from any asynchronous context, and</p><p> ä»…å…è®¸å¯¹æ¥è‡ªä»»ä½•å¼‚æ­¥ä¸Šä¸‹æ–‡çš„Actororçš„æˆå‘˜çš„å¼‚æ­¥è®¿é—®ï¼Œ</p><p> This way the actor itself accesses its data synchronously, but any other code from outside is required asynchronous access (with implicit synchronization) to prevent data races.</p><p> è¿™æ ·ï¼Œæ¼”å‘˜æœ¬èº«åŒæ­¥è®¿é—®å…¶æ•°æ®ï¼Œä½†æ˜¯å¤–éƒ¨çš„ä»»ä½•å…¶ä»–ä»£ç éƒ½æ˜¯å¿…éœ€çš„å¼‚æ­¥è®¿é—®ï¼ˆå…·æœ‰éšå¼åŒæ­¥ï¼‰ä»¥é˜²æ­¢æ•°æ®æ¯”èµ›ã€‚ </p><p>    Going back to my  ActorTest app, Iâ€™ll first try some concurrent code that crashes before I add in an actor to solve the crash.</p><p>è¿”å›æˆ‘çš„Actortest Appï¼Œæˆ‘å°†é¦–å…ˆå°è¯•ä¸€äº›å¹¶å‘ä»£ç ï¼Œåœ¨æˆ‘æ·»åŠ æ¼”å‘˜ä»¥è§£å†³å´©æºƒä¹‹å‰å´©æºƒã€‚</p><p> Iâ€™ll start with a cache type that computes SHA512 hashes of numbers (a silly example that requires just few lines of Swift to demonstrate the idea):</p><p> æˆ‘å°†é¦–å…ˆè®¡ç®—Sha512å“ˆå¸Œæ•°çš„ç¼“å­˜ç±»å‹ï¼ˆä¸€ä¸ªåªéœ€è¦å‡ è¡ŒSWIFTçš„æ„šè ¢ç¤ºä¾‹æ¥æ¼”ç¤ºè¿™ä¸ªæƒ³æ³•ï¼‰ï¼š</p><p> import  CryptoKit class  HashCache {  private( set)  var  hashes = [ Int:  String]()  func  addHash( for number:  Int) {  let  string = SHA512.hash(data: Data( String(number).utf8) ).description hashes[number] = string }  func  compute() { DispatchQueue.concurrentPerform(iterations:  15000, execute: addHash( for:)) }}</p><p> å¯¼å…¥cryptokitç±»hashcache {privateï¼ˆsetï¼‰var hasish = [intï¼šstring]ï¼ˆï¼‰func addhashï¼ˆfor numberï¼šintï¼‰{let string = sha512.hashï¼ˆæ•°æ®ï¼šæ•°æ®ï¼ˆå­—ç¬¦ä¸²ï¼ˆå­—ç¬¦ä¸²ï¼‰.utf8ï¼‰ï¼‰.descriptionæ•£åˆ—[number] = string} func computeï¼ˆï¼‰{dissatchqueue.concurrentperformï¼ˆè¿­ä»£ï¼š15000ï¼Œæ‰§è¡Œï¼šAddHashï¼ˆfor :)ï¼‰}}</p><p> addHash(for:) takes a number and adds its text representationâ€™s hash to  hashes, and</p><p> AddHashï¼ˆfor :)é‡‡å–ä¸€ä¸ªæ•°å­—ï¼Œå¹¶å°†å…¶æ–‡æœ¬è¡¨ç¤ºçš„å“ˆå¸Œæ·»åŠ åˆ°å“ˆå¸Œå’Œ</p><p> If youâ€™ve done something along these lines before, you instantly see the issue in this code. When you call  HashCache.compute() youâ€™ll have a crash because multiple threads are calling  addHash(for:) and trying to mutate  hashes at the same time. ğŸ’¥</p><p> å¦‚æœæ‚¨ä¹‹å‰å·²ç»å®Œæˆäº†è¿™äº›è¡Œï¼Œåˆ™ç«‹å³æŸ¥çœ‹æ­¤ä»£ç ä¸­çš„é—®é¢˜ã€‚å½“æ‚¨è°ƒç”¨hashcache.computeï¼ˆï¼‰æ—¶ï¼Œæ‚¨å°†å´©æºƒï¼Œå› ä¸ºå¤šä¸ªçº¿ç¨‹æ­£åœ¨è°ƒç”¨AddHashï¼ˆfor :)å¹¶å°è¯•åŒæ—¶å˜å¼‚å“ˆå¸Œã€‚ ğŸ’¥</p><p>  So again,  hashes and  addHash(for:) arenâ€™t unsafe per sÃ¨ - especially if your app is generally running on the main thread. But as soon as some code calls  addHash(for:) from a non-main thread the app becomes prone to data-race crashes.</p><p>  æ‰€ä»¥å†æ¬¡ï¼Œå“ˆå¸Œå’Œåœ°å€ï¼ˆfor :)å¹¶ä¸æ˜¯æ¯sÃ¨ä¸å®‰å…¨ - ç‰¹åˆ«æ˜¯å¦‚æœæ‚¨çš„åº”ç”¨ç¨‹åºé€šå¸¸åœ¨ä¸»çº¿ç¨‹ä¸Šè¿è¡Œã€‚ä½†æ˜¯ä¸€æ—¦ä¸€äº›ä»£ç è°ƒç”¨AddHashï¼ˆfor :)æ¥è‡ªéä¸»çº¿ç¨‹ï¼Œè¯¥åº”ç”¨ç¨‹åºå˜ä¸ºæ˜“äºæ•°æ®ç«äº‰ã€‚</p><p> At present, to solve this issue, you would add locking around your mutable state or use a serial queue to synchronize data-access but that often requires a lot of boilerplate code. ğŸ™ƒ</p><p> ç›®å‰ï¼Œè¦è§£å†³æ­¤é—®é¢˜ï¼Œæ‚¨å°†åœ¨å¯å˜çŠ¶æ€ä¸‹æ·»åŠ é”å®šæˆ–ä½¿ç”¨ä¸²è¡Œé˜Ÿåˆ—æ¥åŒæ­¥æ•°æ®è®¿é—®ï¼Œä½†é€šå¸¸éœ€è¦å¤§é‡çš„æ ·æ¿ä»£ç ã€‚ ğŸ™ƒ </p><p> Letâ€™s rewrite  HashCache as an  actor and get rid of that crash for good.</p><p>è®©æˆ‘ä»¬å°†Hashcacheé‡å†™ä¸ºæ¼”å‘˜å¹¶æ‘†è„±è¯¥å´©æºƒã€‚</p><p>  So Iâ€™m just going to replace the keyword  class with an  actor and â€¦</p><p>  æ‰€ä»¥æˆ‘åªæ˜¯è¦ç”¨æ¼”å‘˜å’Œ...æ›¿æ¢å…³é”®å­—ç±»ã€‚</p><p> import  CryptoKitactor HashCache {  private( set)  var  hashes = [ Int:  String]()  func  addHash( for number:  Int) {  let  string = SHA512.hash(data: Data( String(number).utf8) ).description hashes[number] = string }  func  compute() { DispatchQueue.concurrentPerform(iterations:  15000, execute: addHash( for:)) }}</p><p> å¯¼å…¥Cryptokitactor Hashcache {privateï¼ˆsetï¼‰var hasish = [intï¼šstring]ï¼ˆï¼‰func addhashï¼ˆfor numberï¼šintï¼‰{let string = sha512.hashï¼ˆæ•°æ®ï¼šæ•°æ®ï¼ˆå­—ç¬¦ä¸²ï¼ˆå­—ç¬¦ä¸²ï¼‰.utf8ï¼‰ï¼‰.description hashes [ number] = string} func computeï¼ˆï¼‰{dissatchqueue.concurrentperformï¼ˆè¿­ä»£ï¼š15000ï¼Œæ‰§è¡Œï¼šAddHashï¼ˆfor :)ï¼‰}}</p><p> It works - the project compiles fine. Running the app though hits the same crash. Donâ€™t forget this feature is work-in-progress. ğŸ¤·ğŸ½â€â™‚ï¸</p><p> å®ƒæœ‰æ•ˆ - é¡¹ç›®ç¼–è¯‘å¾—å¾ˆå¥½ã€‚è¿è¡Œè¯¥åº”ç”¨ç¨‹åºè™½ç„¶åŒæ ·å´©æºƒäº†ã€‚ä¸è¦å¿˜è®°æ­¤åŠŸèƒ½æ˜¯æ­£åœ¨è¿›è¡Œçš„å·¥ä½œã€‚ ğŸ¤·ğŸ½â™‚ï¸</p><p> It looks at the moment the compiler doesnâ€™t quite catch that the  execute parameter of  DispatchQueue.concurrentPerform(...) needs to be synchronized.</p><p> å®ƒä¼¼ä¹æš‚æ—¶ç¼–è¯‘å™¨ä¸å®Œå…¨æ•è·dispatchqueue.concurrentperformï¼ˆ...ï¼‰çš„æ‰§è¡Œå‚æ•°ã€‚</p><p> But the compiler catches data-race code if you provide a closure instead! Changing  compute() to:</p><p> ä½†å¦‚æœæ‚¨æä¾›å…³é—­ï¼Œç¼–è¯‘å™¨ä¼šæ•è·æ•°æ®ç«äº‰ä»£ç ï¼å°†computeï¼ˆï¼‰æ›´æ”¹ä¸ºï¼š</p><p>    The closure in  concurrentPerform(...) is called asynchronously so you are not allowed to synchronously access an actor member because it needs to be synchronized to prevent data races. Awesome!</p><p>    ConcurrentPerformï¼ˆ...ï¼‰ä¸­çš„é—­åˆè¢«å¼‚æ­¥è°ƒç”¨ï¼Œå› æ­¤æ‚¨ä¸å…è®¸åŒæ­¥åœ°è®¿é—®actoræ„ä»¶ï¼Œå› ä¸ºéœ€è¦åŒæ­¥ä»¥é˜²æ­¢æ•°æ®æ¯”èµ›ã€‚æƒŠäººçš„ï¼ </p><p> I wonâ€™t try making the code work with  DispatchQueue because at this point itâ€™d be much more fun to try the new  Task-based (and also work-in-progress) concurrency. Letâ€™s replace the  DispatchQueue code with a task group:</p><p>æˆ‘ä¸ä¼šå°è¯•ä½¿ç”¨DispatchQueueè¿›è¡Œä»£ç å·¥ä½œï¼Œå› ä¸ºæ­¤æ—¶ï¼Œå°è¯•åŸºäºä»»åŠ¡ï¼ˆä»¥åŠæ­£åœ¨è¿›è¡Œçš„å·¥ä½œï¼‰å¹¶å‘ç­‰ç­‰ï¼Œå®ƒä¼šæ›´æœ‰ä¹è¶£ã€‚è®©æˆ‘ä»¬ç”¨ä»»åŠ¡ç»„æ›¿æ¢DispatchQueueä»£ç ï¼š</p><p>  This is more sample code from the actor proposal that I mentioned above but on the surface it looks like it just creates a concurrent group that you can add tasks to. A neat detail is that  withTaskGroup(...) waits until all tasks in the group complete.</p><p>  è¿™æ˜¯æˆ‘åœ¨ä¸Šé¢æåˆ°çš„actorææ¡ˆçš„æ›´å¤šç¤ºä¾‹ä»£ç ï¼Œä½†å®ƒçœ‹èµ·æ¥å®ƒåªæ˜¯åˆ›å»ºäº†ä¸€ä¸ªå¯ä»¥æ·»åŠ ä»»åŠ¡çš„å¹¶å‘ç»„ã€‚ä¸€ä¸ªç®€æ´çš„ç»†èŠ‚æ˜¯ï¼Œä½¿ç”¨æ‰˜æ–¯ç¾¤ï¼ˆ...ï¼‰ç­‰å¾…ï¼Œç›´åˆ°ç»„ä¸­çš„æ‰€æœ‰ä»»åŠ¡å®Œæˆã€‚</p><p> I checked for a way to create tasks that donâ€™t return anything but couldnâ€™t find one, so my tasks in this group will return a  Bool which Iâ€™m gonna discard.</p><p> æˆ‘æ£€æŸ¥äº†ä¸€ç§åˆ›å»ºä¸è¿”å›ä»»ä½•ä¸œè¥¿çš„ä»»åŠ¡ï¼Œä½†æ— æ³•æ‰¾åˆ°ä¸€ä¸ªçš„æ–¹æ³•ï¼Œå› æ­¤æˆ‘åœ¨è¿™ä¸ªå°ç»„ä¸­çš„ä»»åŠ¡å°†è¿”å›ä¸€ä¸ªæˆ‘ä¼šä¸¢å¼ƒçš„BOOLã€‚</p><p>   Since  withTaskGroup(...) needs to wait for all tasks to complete it is, of course, asynchronous. Swift complains that the context in which I call  withTaskGroup(...) is not asynchronous so letâ€™s fix that:</p><p>   ç”±äºå“ˆé¡¿ç¾¤ç»„ï¼ˆ...ï¼‰éœ€è¦ç­‰å¾…æ‰€æœ‰ä»»åŠ¡æ¥å®Œæˆå®ƒï¼Œå½“ç„¶æ˜¯å¼‚æ­¥ã€‚ SwiftæŠ±æ€¨æˆ‘å‘¼å«çš„ä¸Šä¸‹æ–‡ï¼ˆ......ï¼‰ä¸æ˜¯å¼‚æ­¥ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ä¿®å¤ï¼š</p><p>  I made  compute() async and also used  await when calling  withTaskGroup(...). That clears up the previous error message but I get a new one:</p><p>  æˆ‘åˆ¶ä½œäº†computeï¼ˆï¼‰asyncï¼Œå¹¶ä¸”åœ¨è°ƒç”¨withtaskgroupæ—¶ä½¿ç”¨ç­‰å¾…ç­‰å¾…ï¼ˆ...ï¼‰ã€‚æ¸…é™¤ä¹‹å‰çš„é”™è¯¯æ¶ˆæ¯ï¼Œä½†æˆ‘å¾—åˆ°ä¸€ä¸ªæ–°çš„é”™è¯¯ï¼š</p><p>  If you âŒ˜+Click on  withTaskGroup(...) youâ€™ll find that the experimental features have a distant future availability:</p><p>  å¦‚æœæ‚¨âŒ˜+ç‚¹å‡»ä½¿ç”¨æ‰˜æ–¯ç¾¤ï¼ˆ...ï¼‰ï¼Œæ‚¨ä¼šå‘ç°å®éªŒåŠŸèƒ½å…·æœ‰é¥è¿œçš„æœªæ¥å¯ç”¨æ€§ï¼š</p><p>  In any case clicking the third suggested solution makes  HashCache available on macOS 9999 or newer and everything compiles OK.</p><p>  åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œå•å‡»ç¬¬ä¸‰ä¸ªå»ºè®®çš„è§£å†³æ–¹æ¡ˆä½¿HashCacheåœ¨MacOS 9999æˆ–æ›´æ–°ä¸­æä¾›ï¼Œå¹¶ä¸”ä¸€åˆ‡éƒ½å¯ä»¥ç¼–è¯‘ç¡®å®šã€‚ </p><p> Next, I want to create a task for each hash Iâ€™m about to compute. I found this to work and it looks pretty simple (again, I donâ€™t really use the returned boolean).</p><p>æ¥ä¸‹æ¥ï¼Œæˆ‘æƒ³ä¸ºæ¯ä¸ªå³å°†è®¡ç®—çš„å“ˆå¸Œåˆ›å»ºä»»åŠ¡ã€‚æˆ‘å‘ç°è¿™ä¸ªå¯ä»¥å·¥ä½œï¼Œçœ‹èµ·æ¥å¾ˆç®€å•ï¼ˆå†æ¬¡ï¼Œæˆ‘çœŸçš„æ²¡æœ‰ä½¿ç”¨è¿”å›çš„å¸ƒå°”å€¼ï¼‰ã€‚</p><p> func  compute() async { await withTaskGroup(of:  Bool. self) { group  in  for number  in  0 ...  15_000 { group.spawn { await  self.addHash( for: number)  return  true } } }}</p><p> func computeï¼ˆï¼‰async {await withtaskgroupï¼ˆï¼šboolã€‚selfï¼‰{group for number in 0 ... 15_000 {group.spawn {await self.addhashï¼ˆforï¼šnumberï¼‰return true}}}</p><p> Reading up the group API it sounds really great - you can treat it as a lazy sequence and control the tasks execution to batch tasks, cancel one or more tasks, emit progress as tasks complete, and more.</p><p> è¯»å–ç»„APIå¬èµ·æ¥çœŸçš„å¾ˆæ£’ - æ‚¨å¯ä»¥å°†å…¶è§†ä¸ºæ‡’æƒ°çš„åºåˆ—å¹¶æ§åˆ¶ä»»åŠ¡æ‰§è¡Œåˆ°æ‰¹å¤„ç†ä»»åŠ¡ï¼Œå–æ¶ˆä¸€ä¸ªæˆ–å¤šä¸ªä»»åŠ¡ï¼Œä½œä¸ºä»»åŠ¡å®Œæ•´çš„è¿›åº¦å‘å‡ºè¿›åº¦ï¼Œæ›´å¤šã€‚</p><p> But I wonâ€™t go into all that right now as all I want now is to concurrently compute the hashes and be done.</p><p> ä½†æ˜¯ï¼Œæˆ‘ç°åœ¨ä¸ä¼šè¿›å…¥æ‰€æœ‰è¿™äº›ï¼Œå› ä¸ºæˆ‘ç°åœ¨æƒ³è¦çš„åªæ˜¯åŒæ—¶è®¡ç®—å“ˆå¸Œå’Œå®Œæˆã€‚</p><p>  If you scroll waaay up youâ€™ll notice that  addHash(for:) isnâ€™t an  async function at all. But calling  addHash(for:) synchronously from an asynchronous task might cause a data-race and a crash. Thatâ€™s why the compiler requires you to use  await so that it can synchronize your access to the actorâ€™s internals:</p><p>  å¦‚æœæ»šåŠ¨waaayå‘ä¸Šï¼Œæ‚¨ä¼šæ³¨æ„åˆ°AddHashï¼ˆfor :)æ ¹æœ¬ä¸æ˜¯å¼‚æ­¥åŠŸèƒ½ã€‚ä½†æ˜¯ä»å¼‚æ­¥ä»»åŠ¡åŒæ­¥è°ƒç”¨AddHashï¼ˆfor :)å¯èƒ½ä¼šå¯¼è‡´æ•°æ®ç«äº‰å’Œå´©æºƒã€‚è¿™å°±æ˜¯ç¼–è¯‘å™¨è¦æ±‚æ‚¨ä½¿ç”¨ç­‰å¾…çš„åŸå› ï¼Œä»¥ä¾¿å®ƒå¯ä»¥åŒæ­¥æ‚¨å¯¹Actorå†…éƒ¨çš„è®¿é—®ï¼š</p><p>  THIS is what Iâ€™m talking about. The 3 simple rules we spelled out in the beginning are so clever that simply prevent you from writing bad code.</p><p>  è¿™å°±æ˜¯æˆ‘æ‰€è¯´çš„ã€‚æˆ‘ä»¬åœ¨å¼€å§‹æ—¶æ‹¼å†™å‡ºçš„3ä¸ªç®€å•è§„åˆ™æ˜¯å¦‚æ­¤èªæ˜ï¼Œåªéœ€é˜»æ­¢æ‚¨ç¼–å†™ä¸è‰¯ä»£ç ã€‚</p><p>  There is, however, no need to convert  addHash(for:) to an  async function altogether. You still might want to call it synchronously when the context permits it.</p><p>  ä½†æ˜¯ï¼Œæ²¡æœ‰å¿…è¦å°†AddHashï¼ˆfor :)è½¬æ¢ä¸ºAsyncå‡½æ•°ã€‚å½“ä¸Šä¸‹æ–‡å…è®¸æ—¶ï¼Œæ‚¨ä»ç„¶å¯èƒ½å¸Œæœ›åŒæ­¥è°ƒç”¨å®ƒã€‚ </p><p> Now Iâ€™m super curious to try how that works. Letâ€™s add one more hash to the lot that  compute() caches:</p><p>ç°åœ¨ï¼Œæˆ‘éå¸¸å¥½å¥‡ï¼Œå°è¯•å¦‚ä½•è¿ä½œã€‚è®©æˆ‘ä»¬å°†ä¸€ä¸ªå“ˆå¸Œæ·»åŠ åˆ°Computeï¼ˆï¼‰ç¼“å­˜çš„æ‰¹æ¬¡ï¼š</p><p> func  compute() async { addHash( for:  42) await withTaskGroup(of:  Bool. self) { group  in  for number  in  0 ...  15_000 { group.spawn { await  self.addHash( for: number)  return  true } } }}</p><p> func computeï¼ˆï¼‰async {addhashï¼ˆforï¼š42ï¼‰ç­‰å¾…ç”¨æ‰˜æ–¯ç¾¤ï¼ˆä»¥ä¸‹æ˜¯ï¼šboolã€‚selfï¼‰{group in 0 ... 15_000 {group.spawn {await self.addhashï¼ˆforï¼šnumberï¼‰return true}} }}</p><p>  I didnâ€™t read in detail whatâ€™s the annotation that makes the task closure give that actor isolation error but itâ€™s on my todo.</p><p>  æˆ‘æ²¡æœ‰è¯¦ç»†é˜…è¯»ï¼Œè¿™ä½¿å¾—ä»»åŠ¡é—­åˆä½¿æ¼”å‘˜éš”ç¦»é”™è¯¯çš„æ³¨é‡Šæ˜¯ä»€ä¹ˆï¼Œä½†å®ƒåœ¨æˆ‘çš„Todoä¸Šã€‚</p><p>  The last few use-cases to verify have to do with accessing actor members from outside of the actor, regardless whether from an asynchronous context or not.</p><p>  éªŒè¯æ˜¯å¦å¿…é¡»ä½¿ç”¨ä»æ¼”å‘˜çš„å¤–éƒ¨è®¿é—®æ¼”å‘˜æˆå‘˜ï¼Œè€Œæ˜¯æ— è®ºæ˜¯å¦æ¥è‡ªå¼‚æ­¥ä¸Šä¸‹æ–‡ï¼Œéƒ½å¿…é¡»æ‰§è¡Œã€‚</p><p>     addHash() is a â€œvanillaâ€ function but for all purposes itâ€™s treated like an  async when called from outside the actor, and finally</p><p>     AddHashï¼ˆï¼‰æ˜¯ä¸€ä¸ªâ€œé¦™è‰â€åŠŸèƒ½ï¼Œä½†æ˜¯å¯¹äºæ‰€æœ‰ç›®çš„ï¼Œå®ƒåœ¨æ¼”å‘˜å¤–éƒ¨è°ƒç”¨æ—¶ä¼šåƒå¼‚æ­¥ä¸€æ ·å¤„ç†ï¼Œæœ€å</p><p> hashes also needs to be synchronized when accessed outside the actor so you also need to use  await here.</p><p> åœ¨Actorå¤–é¢è®¿é—®æ—¶ï¼Œå“ˆå¸Œä¹Ÿéœ€è¦åŒæ­¥ï¼Œå› æ­¤æ‚¨è¿˜éœ€è¦åœ¨æ­¤å¤„ä½¿ç”¨ç­‰å¾…ã€‚</p><p> The actors implementation design and the experience when writing this code makes me very happy. Having thread-safety checked at compiled time will make Swift apps generally safer, less crash-prone, and hopefully more people will be embracing concurrent programming.</p><p> æ¼”å‘˜å®æ–½è®¾è®¡å’Œå†™ä½œæ­¤ä»£ç çš„ä½“éªŒè®©æˆ‘éå¸¸å¼€å¿ƒã€‚åœ¨ç¼–è¯‘æ—¶é—´æ£€æŸ¥çš„çº¿ç¨‹å®‰å…¨å°†ä½¿SWIFTåº”ç”¨ç¨‹åºä¸€èˆ¬æ›´å®‰å…¨ï¼Œè¶Šæ¥è¶Šå®¹æ˜“å‘ç”Ÿï¼Œå¸Œæœ›æ›´å¤šçš„äººå°†æ‹¥æŠ±å¹¶å‘ç¼–ç¨‹ã€‚ </p><p>   import  Foundation import  CryptoKit@available(macOS  9999, *)@main struct  App {  static  let  cache = HashCache()  static  func  main() async { await cache.addHash( for:  7778) await cache.compute() await print(cache.hashes[ 34]!) }}@available(macOS  9999, *)actor HashCache {  private( set)  var  hashes = [ Int:  String]()  func  addHash( for number:  Int) {  let  string = SHA512.hash(data: Data( String(number).utf8) ).description hashes[number] = string }  func  compute() async { addHash( for:  42) await withTaskGroup(of:  Bool. self) { group  in  for number  in  0 ...  15_000 { group.spawn { await  self.addHash( for: number)  return  true } } } } }</p><p>å¯¼å…¥åŸºç¡€å¯¼å…¥cryptokit @å¯ç”¨ï¼ˆmacos 9999ï¼Œ*ï¼‰@ main struct app {static let cache = hashcacheï¼ˆï¼‰é™æ€func mainï¼ˆï¼‰async {await cache.addhashï¼ˆforï¼š7778ï¼‰ç­‰å¾…cache.computeï¼ˆï¼‰ç­‰å¾…æ‰“å°ï¼ˆç¼“å­˜.hashes [34]ï¼ï¼‰}} @å¯ç”¨ï¼ˆmacos 9999ï¼Œ*ï¼‰æ¼”å‘˜hashcache {privateï¼ˆsetï¼‰var hasish = [intï¼šstring]ï¼ˆï¼‰func addhashï¼ˆfor numberï¼šintï¼‰{let string = sha512.hashï¼ˆæ•°æ®ï¼šæ•°æ®ï¼ˆå­—ç¬¦ä¸²ï¼ˆæ•°å­—ï¼‰.utf8ï¼‰ï¼‰.description hashes [number] = string} func computeï¼ˆï¼‰async {addhashï¼ˆforï¼š42ï¼‰ç­‰å¾…ç”¨æ‰˜æ–¯ç¾¤ï¼ˆä»¥ä¸‹æ˜¯ï¼šselfï¼‰{group in for of no.0ã€‚ ..15_000 {group.spawn {await self.addhashï¼ˆforï¼šnumberï¼‰return true}}}}}</p><p> Final disclaimer: Developed using a Swift toolchain from the Swift.org trunk branch. The concurrency feature is a work-in-progress. This code might not work at a later moment.</p><p> æœ€ç»ˆå…è´£å£°æ˜ï¼šä½¿ç”¨Swift.org Trunk Branchçš„Swift Toolchainå¼€å‘ã€‚å¹¶å‘åŠŸèƒ½æ˜¯ä¸€ä¸ªè¿‡ç¨‹ã€‚æ­¤ä»£ç å¯èƒ½åœ¨ä»¥åçš„æ—¶åˆ»æ— æ³•æ­£å¸¸å·¥ä½œã€‚</p><p>   Update: After wrapping up this post I started thinking about mixing up Swift actors and Combine. Expect a follow-up post coming out in couple of days.</p><p>   æ›´æ–°ï¼šåœ¨åŒ…è£…æ­¤å¸–åï¼Œæˆ‘å¼€å§‹è€ƒè™‘æ··åˆè¿…é€Ÿçš„æ¼”å‘˜å¹¶ç»“åˆã€‚æœŸå¾…å‡ å¤©åå‡ºæ¥çš„åç»­å¸–å­ã€‚</p><p> All of the concurrency features in Swift are still work in progress. You donâ€™t need to be learning them as of right now as syntax or behavior might change, so I hope this post  does not put any unnecessary pressure on you.</p><p> SWIFTä¸­çš„æ‰€æœ‰å¹¶å‘åŠŸèƒ½éƒ½åœ¨è¿›è¡Œä¸­ã€‚æ‚¨ç°åœ¨ä¸éœ€è¦ä¾èµ–äºç°åœ¨ï¼Œå› ä¸ºè¯­æ³•æˆ–è¡Œä¸ºå¯èƒ½ä¼šæ”¹å˜ï¼Œæ‰€ä»¥æˆ‘å¸Œæœ›è¿™ç¯‡æ–‡ç« å¯¹ä½ æ²¡æœ‰ä»»ä½•ä¸å¿…è¦çš„å‹åŠ›ã€‚</p><p> Thatâ€™s also the reason why Iâ€™ve also put so many disclaimers in the post - this write-up is purely exploratory.</p><p> è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæˆ‘åœ¨å¸–å­ä¸­æ”¾ç½®äº†è¿™ä¹ˆå¤šå…è´£å£°æ˜çš„åŸå›  - è¿™ç¯‡æ–‡ç« çº¯ç²¹æ˜¯æ¢ç´¢æ€§çš„ã€‚</p><p> But the next time anyone tells you that concurrent code is bad because it crashes with strange errors and the best way is to only use the main thread, youâ€™ll know thatâ€™s not true if you use the new structured concurrency in Swift :)</p><p> ä½†ä¸‹æ¬¡æœ‰äººå‘Šè¯‰ä½ å¹¶å‘ä»£ç ä¸å¥½ï¼Œå› ä¸ºå®ƒå´©æºƒäº†å¥‡æ€ªçš„é”™è¯¯ï¼Œæœ€å¥½çš„æ–¹æ³•æ˜¯åªä½¿ç”¨ä¸»çº¿ç¨‹ï¼Œå¦‚æœæ‚¨åœ¨SWIFTä¸­ä½¿ç”¨æ–°çš„ç»“æ„åŒ–å¹¶å‘æ—¶ï¼Œæ‚¨å°†çŸ¥é“è¿™ä¸æ˜¯çœŸçš„:)</p><p>   To learn about all Combine check  Combine: Asynchronous programming with Swift - this is where you can see all updates, discuss in the website forums, and more.</p><p>   è¦äº†è§£æ‰€æœ‰ç»„åˆæ£€æŸ¥ç»„åˆï¼šSwiftçš„å¼‚æ­¥ç¼–ç¨‹ - è¿™æ˜¯æ‚¨å¯ä»¥çœ‹åˆ°æ‰€æœ‰æ›´æ–°çš„åœ°æ–¹ï¼Œåœ¨ç½‘ç«™è®ºå›ä¸­è®¨è®ºã€‚ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://trycombine.com/posts/swift-actors/">https://trycombine.com/posts/swift-actors/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/actors/">#actors</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>