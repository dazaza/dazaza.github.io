<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ç”¨shellcodeçš„è¡¬è¡«çš„æ•…äº‹ Story of a Tshirt with a Shellcode</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Story of a Tshirt with a Shellcode<br/>ç”¨shellcodeçš„è¡¬è¡«çš„æ•…äº‹ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-11 04:03:31</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/af475c7cca5ae03114a797d947eb4196.png"><img src="http://img2.diglog.com/img/2021/5/af475c7cca5ae03114a797d947eb4196.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The text printed on it looks very much like the output of  objdump -d shellcode.o command.</p><p>æ‰“å°åœ¨å®ƒä¸Šçš„æ–‡æœ¬çœ‹èµ·æ¥éå¸¸ç±»ä¼¼äºobjdump -d shellcode.oå‘½ä»¤çš„è¾“å‡ºã€‚</p><p>  If you had a chance to write your own shellcode, you will immediately recognize this  jmp,  call,  pop pattern.In pure form it looks like this (NASM syntax):</p><p>  å¦‚æœæ‚¨æœ‰æœºä¼šç¼–å†™è‡ªå·±çš„shellcodeï¼Œæ‚¨å°†ç«‹å³è¯†åˆ«æ­¤JMPï¼Œå‘¼å«ï¼Œæµè¡Œæ¨¡å¼ã€‚çº¯è¡¨å•å¦‚ä¸‹æ‰€ç¤ºï¼ˆNASMè¯­æ³•ï¼‰ï¼š</p><p> jmp  short _end _run:   pop   esi  ; now esi register contains address of data label  ; actual shellcode instructions go here _end:   call  _run  data:   db   &#39;some data&#39;</p><p> JMPçŸ­_END _RUNï¼šPOP ESI;ç°åœ¨ESIå¯„å­˜å™¨åŒ…å«æ•°æ®æ ‡ç­¾çš„åœ°å€;å®é™…çš„ShellcodeæŒ‡ä»¤åœ¨è¿™é‡Œ_endï¼šå‘¼å«_Runæ•°æ®ï¼šDBï¼†ï¼ƒ39;ä¸€äº›æ•°æ®ï¼†ï¼ƒ39;</p><p> When we use shellcode on a real system, we have no idea at which memory address our shellcode will be loaded. Sometimes this information can be very useful e.g. when our shellcode contains not only code but also data.While  jmps and  calls can operate on relative addresses, thus allowing us to write position independent code (PIC), the data access instructions ( movs) need absolute addresses.</p><p> å½“æˆ‘ä»¬åœ¨çœŸå®ç³»ç»Ÿä¸Šä½¿ç”¨shellcodeæ—¶ï¼Œæˆ‘ä»¬ä¸çŸ¥é“æˆ‘ä»¬çš„shellcodeçš„å†…å­˜åœ°å€å°†è¢«åŠ è½½ã€‚æœ‰æ—¶è¿™äº›ä¿¡æ¯å¯ä»¥éå¸¸æœ‰ç”¨ã€‚å½“æˆ‘ä»¬çš„shellcodeä¸ä»…åŒ…å«ä»£ç è€Œä¸”æ•°æ®è€Œä¸”å‘¼å«å¯ä»¥åœ¨ç›¸å¯¹åœ°å€ä¸Šè¿è¡Œï¼Œå› æ­¤å…è®¸æˆ‘ä»¬å†™å…¥ä½ç½®ç‹¬ç«‹ä»£ç ï¼ˆå›¾ç‰‡ï¼‰ï¼Œæ•°æ®è®¿é—®æŒ‡ä»¤ï¼ˆMOVSï¼‰éœ€è¦ç»å¯¹åœ°å€ã€‚</p><p> NOTE: The last sentence is no longer true on x86_64 architecture, as it introduced a new addressing mode called &#34;RIP relative addressing&#34;.</p><p> æ³¨æ„ï¼šæœ€åä¸€å¥åœ¨x86_64æ¶æ„ä¸Šä¸å†æ˜¯çœŸå®çš„ï¼Œå› ä¸ºå®ƒå¼•å…¥äº†ä¸€ä¸ªåä¸ºï¼†ï¼ƒ34; RIPç›¸å¯¹åœ°å€ï¼†ï¼ƒ34çš„æ–°å¯»å€æ¨¡å¼;</p><p> When we use  jmp and  call instructions in relative address mode, we are actually using offsets relative to the  next instruction following  jmp or  call opcode.So a relative jump  jmp short 0 (again NASM syntax), will just jump to the next instruction and  jmp short -2 will create an infinite loop (assuming that the entire  jmp instruction takes two bytes).</p><p> å½“æˆ‘ä»¬åœ¨ç›¸å¯¹åœ°å€æ¨¡å¼ä¸­ä½¿ç”¨JMPå’Œå‘¼å«æŒ‡ä»¤æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šä½¿ç”¨åç§»ç›¸å¯¹äºJMPæˆ–Call opcode.soç›¸å¯¹è·³è½¬JMPçŸ­0ï¼ˆå†æ¬¡NASMè¯­æ³•ï¼‰ï¼Œåªä¼šè·³è½¬åˆ°ä¸‹ä¸€ä¸ªæŒ‡ä»¤å’ŒJMPçŸ­-2å°†åˆ›å»ºä¸€ä¸ªæ— é™å¾ªç¯ï¼ˆå‡è®¾æ•´ä¸ªJMPæŒ‡ä»¤éœ€è¦ä¸¤ä¸ªå­—èŠ‚ï¼‰ã€‚</p><p> call offset instruction is more interesting, as it will not only jump to the offset, but also will push the address of the following instruction on the stack (the so called return address).</p><p> å‘¼å«åç§»æŒ‡ä»¤æ›´æœ‰è¶£ï¼Œå› ä¸ºå®ƒä¸ä»…è·³è½¬åˆ°åç§»é‡ï¼Œè€Œä¸”è¿˜å°†æ¨åŠ¨å †æ ˆä¸Šä»¥ä¸‹æŒ‡ä»¤çš„åœ°å€ï¼ˆæ‰€è°“çš„è¿”å›åœ°å€ï¼‰ã€‚ </p><p> Now we can understand how  jmp,  call,  pop pattern works.First we need to position  call instruction just before the data, of which we want to get address. Then we do a relative jump to the  call. The  call will put the address of the next instruction (in this case our data) on the stack and will again do a relative jump to the specified offset. Now we have the address of our data on the stack, so we may just  pop it into a register of our choice  ğŸ‰</p><p>ç°åœ¨æˆ‘ä»¬å¯ä»¥äº†è§£JMPï¼Œå‘¼å«ï¼Œæµè¡Œæ¨¡å¼Works.Firstæˆ‘ä»¬éœ€è¦åœ¨æ•°æ®ä¹‹å‰å®šä½å‘¼å«æŒ‡ä»¤ï¼Œæˆ‘ä»¬æƒ³è¦è·å¾—åœ°å€ã€‚ç„¶åæˆ‘ä»¬åšä¸€ä¸ªç›¸å¯¹è·³è½¬åˆ°å‘¼å«ã€‚è°ƒç”¨å°†åœ¨å †æ ˆä¸Šæ”¾ç½®ä¸‹ä¸€ä¸ªæŒ‡ä»¤ï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬çš„æ•°æ®ï¼‰çš„åœ°å€ï¼Œå¹¶å°†å†æ¬¡æ‰§è¡Œç›¸å¯¹è·³è½¬åˆ°æŒ‡å®šçš„åç§»é‡ã€‚ç°åœ¨æˆ‘ä»¬æœ‰æˆ‘ä»¬åœ¨å †æ ˆä¸Šçš„æ•°æ®çš„åœ°å€ï¼Œå› æ­¤æˆ‘ä»¬å¯èƒ½åªæ˜¯å°†å…¶æµç¨‹ä¸ºæˆ‘ä»¬é€‰æ‹©çš„æ³¨å†Œ</p><p> When we take a look at the t-shirt again, we may notice that the actual offsets printed there are wrong.  jmp 0x2b should be in fact  jmp 0x2a because the address of  call instruction is  0x2f = 0x05 + 0x2a. The  call instruction on the other hand should jump to the  pop esi instruction, so the offset should be  0x2f (call addr) + 0x05 (length of call instruction) + offset = 0x05, or  -0x2f (using 2&#39;s complement this value can be represented as  0xffffffd1).</p><p> å½“æˆ‘ä»¬å†æ¬¡çœ‹çœ‹Tæ¤æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæ³¨æ„åˆ°å°åˆ·çš„å®é™…åç§»æœ‰é—®é¢˜ã€‚ JMP 0x2Bå®é™…ä¸Šåº”è¯¥æ˜¯JMP 0x2Aï¼Œå› ä¸ºå‘¼å«æŒ‡ä»¤çš„åœ°å€æ˜¯0x2F = 0x05 + 0x2aã€‚å¦ä¸€æ–¹é¢ï¼Œå‘¼å«æŒ‡ä»¤åº”è¯¥è·³è½¬åˆ°POP ESIæŒ‡ä»¤ï¼Œå› æ­¤åç§»é‡åº”ä¸º0x2Fï¼ˆè°ƒç”¨Addrï¼‰+ 0x05ï¼ˆå‘¼å«æŒ‡ä»¤çš„é•¿åº¦ï¼‰+ Offset = 0x05ï¼Œæˆ–-0x2fï¼ˆä½¿ç”¨2ï¼†ï¼ƒ39;è¡¥å……è¿™ä¸ªå€¼å¯ä»¥è¡¨ç¤ºä¸º0xFFFFFFD1ï¼‰ã€‚</p><p>  mov  dword ptr  [ esi + 0x8 ],   esi 	 mov  byte ptr  [ esi + 0x7 ],   0x0 	 mov  dword ptr  [ esi + 0xc ],   0x0</p><p>  MOV DWORD PTR [ESI + 0x8]ï¼ŒESI MOVå­—èŠ‚PTR [ESI + 0x7]ï¼Œ0x0 mov DWORD PTR [ESI + 0xC]ï¼Œ0x0</p><p> We know now that  esi points to the area after our last shellcode instruction.We may illustrate this memory area as:</p><p> æˆ‘ä»¬ç°åœ¨çŸ¥é“ESIåœ¨æˆ‘ä»¬çš„æœ€åä¸€ä¸ªshellcodeæŒ‡ä»¤ä¹‹åæŒ‡å‘è¯¥åŒºåŸŸã€‚æˆ‘ä»¬å¯ä»¥å°†æ­¤å†…å­˜åŒºåŸŸè¯´æ˜ä¸ºï¼š</p><p>  After executing all these move instructions (in intel syntax that we have here, it is always  mov dest, src) our memory area will look like this:</p><p>  æ‰§è¡Œæ‰€æœ‰è¿™äº›ç§»åŠ¨æŒ‡ä»¤ï¼ˆåœ¨æˆ‘ä»¬è¿™é‡Œæ‹¥æœ‰çš„è‹±ç‰¹å°”è¯­æ³•ä¸­ï¼Œå®ƒå§‹ç»ˆæ˜¯mov istï¼Œsrcï¼‰æˆ‘ä»¬çš„å†…å­˜åŒºåŸŸå°†å¦‚ä¸‹æ‰€ç¤ºï¼š</p><p>  Now this is interesting. Looks like we have a seven character string terminated by zero, then a pointer to that string and a  NULL value.</p><p>  ç°åœ¨è¿™å¾ˆæœ‰æ„æ€ã€‚çœ‹èµ·æ¥æˆ‘ä»¬æœ‰ä¸€ä¸ªä¸ƒä¸ªå­—ç¬¦ä¸²ç»ˆæ­¢ä¸ºé›¶ï¼Œç„¶åæŒ‡å‘è¯¥å­—ç¬¦ä¸²çš„æŒ‡é’ˆå’Œç©ºå€¼ã€‚</p><p> ğŸ¤” Seven character string, seven character string... when it is about shellcodes it must be  /bin/sh :D So it looks like the shellcode on the t-shirt is truncated, the last two instruction should look like this:</p><p> ğŸ¤”ä¸ƒå­—ç¬¦ä¸²ï¼Œä¸ƒå­—ç¬¦ä¸²......å½“å®ƒæ˜¯å…³äºshellcodeså®ƒå¿…é¡»æ˜¯/ bin / shï¼šdï¼Œæ‰€ä»¥å®ƒçœ‹èµ·æ¥åƒtæ¤ä¸Šçš„shellcodeè¢«æˆªæ–­ï¼Œæœ€åä¸¤ä¸ªæŒ‡ä»¤åº”è¯¥å¦‚ä¸‹æ‰€ç¤ºï¼š </p><p>    Now that we know what the missing bytes are, we may expect that our shellcode is calling one of the  execve functions.In C  execve is declared in  unistd.h as:</p><p>æ—¢ç„¶æˆ‘ä»¬çŸ¥é“ä¸¢å¤±çš„å­—èŠ‚æ˜¯ä»€ä¹ˆï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›æˆ‘ä»¬çš„shellcodeæ­£åœ¨è°ƒç”¨å…¶ä¸­ä¸€ä¸ªæ‰§è¡Œå‡½æ•°ã€‚åœ¨unistd.hä¸­å£°æ˜äº†cexerme.hæ˜¯ï¼š</p><p>  It takes three arguments that should be know to every C programmer out there.Both  argv and  envp arrays contain pointers to strings and must be terminatedby an entry containing  NULL. Here is how we may use  execve in C:</p><p>  å®ƒéœ€è¦ä¸‰ä¸ªå‚æ•°ï¼Œåº”è¯¥çŸ¥é“æ¯ä¸ªCç¨‹åºå‘˜ã€‚argvå’Œenvpé˜µåˆ—åŒ…å«æŒ‡å‘å­—ç¬¦ä¸²çš„æŒ‡é’ˆï¼Œå¿…é¡»ç»ˆæ­¢åŒ…å«nullçš„æ¡ç›®ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å¦‚ä½•åœ¨Cä¸­ä½¿ç”¨EXECVEï¼š</p><p> int  main( int argc,  char** argv) {	 char* args[] = {   &#34;/bin/sh &#34;,  NULL };	 char* env[] = {  NULL };	 execve(args[ 0], args, env);}</p><p> int mainï¼ˆint argcï¼Œchar ** argvï¼‰{char * args [] = {ï¼†ï¼ƒ34; / bin / shï¼†ï¼ƒ34;ï¼Œnull}; char * env [] = {null};æ‰§è¡Œï¼ˆargs [0]ï¼Œargsï¼ŒEnvï¼‰;}</p><p> Actually when  env is empty we may compress this code a bit (by reusing  NULL already present in  args array):</p><p> å®é™…ä¸Šï¼Œå½“Envä¸ºç©ºæ—¶ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šä¸€ç‚¹å‹ç¼©æ­¤ä»£ç ï¼ˆé€šè¿‡é‡ç”¨å·²åœ¨argsæ•°ç»„ä¸­å­˜åœ¨çš„NULLï¼‰ï¼š</p><p> int  main( int argc,  char** argv) {	 char* args[] = {   &#34;/bin/sh &#34;,  NULL };	 execve(args[ 0], &amp;args[ 0], &amp;args[ 1]);}</p><p> int mainï¼ˆint argcï¼Œchar ** argvï¼‰{char * args [] = {ï¼†ï¼ƒ34; / bin / shï¼†ï¼ƒ34;ï¼Œnull};æ‰§è¡Œï¼ˆargs [0]ï¼Œï¼†amp; args [0]ï¼Œï¼†amp; args [1]ï¼‰;}</p><p>   mov   eax ,   0xb  ; execve(filename, argv, envp) 	 mov   ebx ,   esi   	 lea   ecx ,   [ esi + 0x8 ]   	 lea   edx ,   [ esi + 0xc ] 	 int   0x80</p><p>   mov eaxï¼Œ0xb;æ‰§è¡Œï¼ˆæ–‡ä»¶åï¼Œargvï¼Œenvpï¼‰movebxï¼ŒESI Lea ECXï¼Œ[ESI + 0x8] LEA EDXï¼Œ[ESI + 0xC] INT 0x80</p><p> The  int 0x80 instruction is the standard way to call the Linux kernel from 32-bit code (64-bit code nowadays usually uses  syscall instruction).When we call a system function, we pass the function arguments in ebx,  ecx,  edx,  esi,  edi and  ebp registers in exactly that order. eax register is used to select the function itself. We may see the list of all available functions  here.</p><p> INT 0x80æŒ‡ä»¤æ˜¯è°ƒç”¨ä»32ä½ä»£ç ï¼ˆ64ä½ä»£ç æ—¶ä¸‹é€šå¸¸ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨æŒ‡ä»¤ï¼‰ã€‚å½“æˆ‘ä»¬ç§°ä¸€ä¸ªç³»ç»Ÿå‡½æ•°ï¼Œæˆ‘ä»¬é€šè¿‡åœ¨EBXå‡½æ•°å‚æ•°ï¼ŒECX EDXï¼ŒESI Linuxå†…æ ¸çš„æ ‡å‡†æ–¹æ³•ï¼ŒEDIå’ŒEBPä»¥æ­¤é¡ºåºæ³¨å†Œã€‚ EAXå¯„å­˜å™¨ç”¨äºé€‰æ‹©åŠŸèƒ½æœ¬èº«ã€‚æˆ‘ä»¬å¯èƒ½ä¼šåœ¨æ­¤å¤„æŸ¥çœ‹æ‰€æœ‰å¯ç”¨åŠŸèƒ½çš„åˆ—è¡¨ã€‚ </p><p> For example to call  exit(0), first we need to check the value that system assigned to  exit function ( 0x01) and put it in  eax register. exit(0) takes one argument. We must put that argument value in  ebx register(subsequent arguments would go in  ecx, then  edx and so on).Finally we may call the kernel using  int 0x80 software interrupt:</p><p>ä¾‹å¦‚è¦å‘¼å«é€€å‡ºï¼ˆ0ï¼‰ï¼Œé¦–å…ˆéœ€è¦æ£€æŸ¥åˆ†é…ç»™é€€å‡ºåŠŸèƒ½ï¼ˆ0x01ï¼‰çš„å€¼å¹¶å°†å…¶æ”¾åœ¨EAXå¯„å­˜å™¨ä¸­çš„å€¼ã€‚é€€å‡ºï¼ˆ0ï¼‰é‡‡å–ä¸€ä¸ªäº‰è®ºã€‚æˆ‘ä»¬å¿…é¡»å°†è¯¥å‚æ•°å€¼æ”¾åœ¨EBXå¯„å­˜å™¨ä¸­ï¼ˆåç»­å‚æ•°å°†è¿›å…¥ECXï¼Œç„¶ååœ¨EDXä¸­è¿›å…¥EDXç­‰ï¼‰ã€‚æœ€åæˆ‘ä»¬å¯ä»¥ä½¿ç”¨INT 0x80è½¯ä»¶ä¸­æ–­è°ƒç”¨å†…æ ¸ï¼š</p><p>  execve function is assigned to number  0x0b. And when we look at the t-shirt again, there, after a block of  movs we can see that exactly this function iscalled:</p><p>  EXECVEå‡½æ•°åˆ†é…ç»™0x0Bã€‚å½“æˆ‘ä»¬å†æ¬¡æŸ¥çœ‹Tæ¤æ—¶ï¼Œåœ¨é‚£é‡Œï¼Œåœ¨ä¸€å—MOVä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™å‡½æ•°æ°å¥½è¢«è§†ä¸ºï¼š</p><p> mov   eax ,   0xb  ; execve(filename, argv, envp) 	 mov   ebx ,   esi   	 lea   ecx ,   [ esi + 0x8 ]   	 lea   edx ,   [ esi + 0xc ] 	 int   0x80</p><p> mov eaxï¼Œ0xb;æ‰§è¡Œï¼ˆæ–‡ä»¶åï¼Œargvï¼Œenvpï¼‰movebxï¼ŒESI Lea ECXï¼Œ[ESI + 0x8] LEA EDXï¼Œ[ESI + 0xC] INT 0x80</p><p> lea instruction is used to load the address of the operand to the specified register.But here since we use indirect memory addressing,  lea ecx, [esi+0x8]is equivalent to  ecx = esi + 0x08 in C.</p><p> LeaæŒ‡ä»¤ç”¨äºå°†æ“ä½œæ•°çš„åœ°å€åŠ è½½åˆ°æŒ‡å®šçš„å¯„å­˜å™¨ã€‚ç”±äºæˆ‘ä»¬ä½¿ç”¨é—´æ¥å­˜å‚¨å™¨å¯»å€ï¼Œå› æ­¤lea ECXï¼Œ[ESI + 0x8]ç›¸å½“äºCä¸­çš„ECX = ESI + 0x08ã€‚</p><p> After all these  movs and  leas we have the address of  /bin/sh string in  ebx, the address of  args array (pointer to  /bin/sh followed by  NULL)in  ecx and finally address of  NULL in  edx.In other words our code is equivalent to the C code that we saw earlier:</p><p> åœ¨æ‰€æœ‰è¿™äº›MOVå’Œç§Ÿèµä¹‹åï¼Œæˆ‘ä»¬åœ¨EBXä¸­æ‹¥æœ‰/ bin / shå­—ç¬¦ä¸²çš„åœ°å€ï¼Œargsæ•°ç»„çš„åœ°å€ï¼ˆæŒ‡é’ˆåˆ°/ bin / shï¼Œåè·Ÿnullï¼‰åœ¨ecxä¸­ï¼Œæœ€ååœ¨edxä¸­çš„nullçš„nullçš„åœ°å€ã€‚åœ¨æˆ‘ä»¬çš„ä»£ç ä¸­çš„å…¶ä»–å•è¯ä¸­ç›¸å½“äºæˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„Cä»£ç ï¼š</p><p> int  main( int argc,  char** argv) {	 char* args[] = {   &#34;/bin/sh &#34;,  NULL };	 execve(args[ 0], &amp;args[ 0], &amp;args[ 1]);}</p><p> int mainï¼ˆint argcï¼Œchar ** argvï¼‰{char * args [] = {ï¼†ï¼ƒ34; / bin / shï¼†ï¼ƒ34;ï¼Œnull};æ‰§è¡Œï¼ˆargs [0]ï¼Œï¼†amp; args [0]ï¼Œï¼†amp; args [1]ï¼‰;}</p><p> What follows call to  execve, is a call to  exit(0). This is a standard technique used in shellcode to just exit the program without crashing it. This way we will leave no traces of our code (think no coredumps).</p><p> è·Ÿéšå‘¼å«æ‰§è¡Œï¼Œæ˜¯é€€å‡ºï¼ˆ0ï¼‰çš„å‘¼å«ã€‚è¿™æ˜¯Shellcodeä¸­ä½¿ç”¨çš„æ ‡å‡†æŠ€æœ¯ï¼Œåªéœ€é€€å‡ºç¨‹åºè€Œä¸å´©æºƒã€‚è¿™æ ·æˆ‘ä»¬å°±ä¸ä¼šç•™ä¸‹æˆ‘ä»¬çš„ä»£ç ç—•è¿¹ï¼ˆæ¯«æ— ç–‘é—®ï¼‰ã€‚ </p><p>  jmp  short _sh_last   _sh_start: 	 pop   esi 	 mov  dword  [ esi + 0x8 ],   esi 	 mov  byte  [ esi + 0x7 ],   0x0 	 mov  dword  [ esi + 0xc ],   0x0 	 mov   eax ,   0xb  ; execve(filename, argv, envp) 	 mov   ebx ,   esi   	 lea   ecx ,   [ esi + 0x8 ]   	 lea   edx ,   [ esi + 0xc ] 	 int   0x80 	 mov   eax ,   0x1  ; exit(0) 	 mov   ebx ,   0x0 	 int   0x80 _sh_last: 	 call  _sh_start 	 db   &#39;/bin/sh&#39;</p><p>JMPçŸ­_sh_last _sh_startï¼špop esi mov dword [esi + 0x8]ï¼Œesi mov byte [esi + 0x7]ï¼Œ0x0 mov dword [esi + 0xc]ï¼Œ0x0 mov eaxï¼Œ0xb;æ‰§è¡Œï¼ˆæ–‡ä»¶åï¼ŒARGVï¼ŒENVPï¼‰MOV EBXï¼ŒESI LEA ECXï¼Œ[ESI + 0x8] lea EDXï¼Œ[ESI + 0xC] INT 0x80 MOV EAXï¼Œ0x1;é€€å‡ºï¼ˆ0ï¼‰MOV EBXï¼Œ0x0 int 0x80 _sh_lastï¼šå‘¼å«_sh_start dbï¼†ï¼ƒ39; / bin / shï¼†ï¼ƒ39;</p><p> Now the moral of this story: always put a  working shellcode on t-shirts to avoid further embarrassment by posts like this one ;)</p><p> ç°åœ¨è¿™ä¸ªæ•…äº‹çš„å¯“æ„ï¼šå§‹ç»ˆæŠŠä¸€ä¸ªå·¥ä½œçš„shellcodeæ”¾åœ¨Tæ¤ä¸Šï¼Œä»¥é¿å…åƒè¿™æ ·çš„å¸–å­è¿›ä¸€æ­¥å°´å°¬;ï¼‰</p><p> Bonus: This repo contains a  Makefile that will build the shellcode and also prepare a C header file containing the shellcode bytes. There is also a wrapper program that will demonstrate that the shellcode indeed works. The only thing that you need is a 32-bit Linux.</p><p> å¥–é‡‘ï¼šæ­¤repoåŒ…å«ä¸€ä¸ªMakefileï¼Œå®ƒå°†æ„å»ºshellcodeï¼Œå¹¶å‡†å¤‡åŒ…å«shellcodeå­—èŠ‚çš„Cå¤´æ–‡ä»¶ã€‚è¿˜æœ‰ä¸€ä¸ªåŒ…è£…ç¨‹åºç¨‹åºï¼Œå°†è¯æ˜shellcodeç¡®å®æœ‰æ•ˆã€‚æ‚¨éœ€è¦çš„å”¯ä¸€æ˜¯32ä½Linuxã€‚</p><p>  uname -aLinux 4.15.0-133-generic #137~16.04.1-Ubuntu SMP Fri Jan 15 02:55:05 UTC 2021 i686 i686 i686 GNU/Linux</p><p>  uname -alinux 4.15.0-133-é€šç”¨ï¼ƒ137ã€œ16.04.1-Ubuntu SMP Fri 1æœˆ15æ—¥02:55:05 UTC 2021 I686 I686 I686 GNU / Linux</p><p>  To compile the assembly code you will need  nasm. You can install it using  apt-get.</p><p>  è¦ç¼–è¯‘æ±‡ç¼–ä»£ç ï¼Œæ‚¨å°†éœ€è¦nasmã€‚æ‚¨å¯ä»¥ä½¿ç”¨apt-getå®‰è£…å®ƒã€‚ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/marcin-chwedczuk/shellcode-tshirt">https://github.com/marcin-chwedczuk/shellcode-tshirt</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/è¡¬è¡«/">#è¡¬è¡«</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tshirt/">#tshirt</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shellcode/">#shellcode</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>