<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ä½¿ç”¨Swiftæ¸²æŸ“Moana Rendering Moana with Swift</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rendering Moana with Swift<br/>ä½¿ç”¨Swiftæ¸²æŸ“Moana </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 20:11:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/beee79d8608eda909df459e644e30140.jpg"><img src="http://img2.diglog.com/img/2021/1/beee79d8608eda909df459e644e30140.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>TLDR: Render Disneyâ€™s Moana scene in less than 10.000 lines of Swift code.</p><p>TLDRï¼šåœ¨å°‘äº10.000è¡Œçš„Swiftä»£ç ä¸­æ¸²æŸ“è¿ªå£«å°¼çš„Moanaåœºæ™¯ã€‚</p><p> After Walt Disney Animation Studios released the scene description of the island in Moana some efforts were started to render it besides Disneys Hyperion. I am aware of the following render engines:</p><p> æ²ƒå°”ç‰¹Â·è¿ªæ–¯å°¼åŠ¨ç”»å·¥ä½œå®¤å‘å¸ƒäº†è«é˜¿çº³å²›çš„åœºæ™¯æè¿°åï¼Œé™¤äº†è¿ªæ–¯å°¼çš„Hyperionï¼Œè¿˜å¼€å§‹ç€æ‰‹æ¸²æŸ“ã€‚æˆ‘çŸ¥é“ä»¥ä¸‹æ¸²æŸ“å¼•æ“ï¼š</p><p>  Here I present another one, the  Gonzales renderer, written by  me. It is heavily inspired by PBRT and written in  Swift (with a few lines in C++ to call OpenEXR and Ptex). It is optimized only as far as to be able to render it in a reasonable amount of time on a free Google Cloud instance (8 vCPUS, 64GB RAM). As far as I know this is the only renderer able to render Moana not written in C/C++. I wrote it with vi and command line Swift on Ubuntu Linux and Xcode on macOS so it should be relatively painless to get it compiled on these platforms.</p><p>  åœ¨è¿™é‡Œï¼Œæˆ‘ä»‹ç»ç”±æˆ‘ç¼–å†™çš„å¦ä¸€ä¸ªGonzalesæ¸²æŸ“å™¨ã€‚å®ƒåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå—åˆ°PBRTçš„å¯å‘ï¼Œå¹¶ç”¨Swiftç¼–å†™ï¼ˆåœ¨C ++ä¸­æœ‰å‡ è¡Œè°ƒç”¨OpenEXRå’ŒPtexï¼‰ã€‚å®ƒä»…åœ¨èƒ½å¤Ÿåœ¨åˆç†çš„æ—¶é—´å†…åœ¨å…è´¹çš„Google Cloudå®ä¾‹ï¼ˆ8ä¸ªvCPUSï¼Œ64GB RAMï¼‰ä¸Šå‘ˆç°çš„æƒ…å†µä¸‹è¿›è¡Œäº†ä¼˜åŒ–ã€‚æ®æˆ‘æ‰€çŸ¥ï¼Œè¿™æ˜¯å”¯ä¸€èƒ½å¤Ÿæ¸²æŸ“ä¸æ˜¯ç”¨C / C ++ç¼–å†™çš„Moanaçš„æ¸²æŸ“å™¨ã€‚æˆ‘åœ¨Ubuntu Linuxä¸Šä½¿ç”¨viå’Œå‘½ä»¤è¡ŒSwiftç¼–å†™äº†ä»£ç ï¼Œåœ¨macOSä¸Šä½¿ç”¨Xcodeç¼–å†™äº†ä»£ç ï¼Œå› æ­¤åœ¨è¿™äº›å¹³å°ä¸Šè¿›è¡Œç¼–è¯‘åº”è¯¥ç›¸å¯¹å®¹æ˜“äº›ã€‚</p><p>  I was always uncomfortable with header files and the preprocessor in C and C++. From my point of view something (a variable, a function, â€¦) should be declared and defined  once, not twice. Also, the textual inclusion of header files brings with it many problems like having to add implementation details to header files (templates come to mind) or slow compilation times by repeated inclusion of headers and its combinatorial explosion. When I started C++ modules were not available so I evaluated Python (too slow), Go (too much like C) and some others but in the end only Rust and Swift were serious contenders. I finally chose Swift because of readability (I just donâ€™t like â€fn mainâ€œ of â€impl traitâ€œ). Also, being written by the implementors of LLVM and Clang gave me confidence that it would a) not be abandoned in the future and b) meet my performance goals. In short, I wanted a compiled language, no pointers, modules, concepts, ranges, readable templates, and I wanted it  now. Also, compilers were invented to make the life of programmers easier by making programs more readlabe, and sometimes when looking at templated-based code makes me think we are going backwards in time. I like my stuff readable.</p><p>  å¯¹äºCå’ŒC ++ä¸­çš„å¤´æ–‡ä»¶å’Œé¢„å¤„ç†å™¨ï¼Œæˆ‘æ€»æ˜¯æ„Ÿåˆ°ä¸èˆ’æœã€‚ä»æˆ‘çš„è§’åº¦æ¥çœ‹ï¼Œåº”è¯¥ä¸€æ¬¡å£°æ˜ï¼ˆè€Œä¸æ˜¯ä¸¤æ¬¡ï¼‰å£°æ˜ï¼ˆå®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œä¸€ä¸ªå‡½æ•°ï¼Œâ€¦ï¼‰ã€‚åŒæ ·ï¼Œå¤´æ–‡ä»¶çš„æ–‡æœ¬åŒ…å«ä¹Ÿå¸¦æ¥äº†è®¸å¤šé—®é¢˜ï¼Œä¾‹å¦‚å¿…é¡»å‘å¤´æ–‡ä»¶æ·»åŠ å®ç°ç»†èŠ‚ï¼ˆæƒ³åˆ°çš„æ¨¡æ¿ï¼‰ï¼Œæˆ–è€…ç”±äºé‡å¤åŒ…å«å¤´åŠå…¶ç»„åˆçˆ†ç‚¸è€Œå¯¼è‡´ç¼–è¯‘æ—¶é—´å˜æ…¢ã€‚å½“æˆ‘å¼€å§‹ä½¿ç”¨C ++æ¨¡å—æ—¶ï¼Œæˆ‘æ— æ³•è¯„ä¼°Pythonï¼ˆå¤ªæ…¢ï¼‰ï¼ŒGoï¼ˆå¤ªåƒCï¼‰å’Œå…¶ä»–ä¸€äº›ä¸œè¥¿ï¼Œä½†æœ€ç»ˆåªæœ‰Rustå’ŒSwiftæ˜¯çœŸæ­£çš„ç«äº‰è€…ã€‚ç”±äºå¯è¯»æ€§çš„ç¼˜æ•…ï¼Œæˆ‘æœ€ç»ˆé€‰æ‹©äº†Swiftï¼ˆæˆ‘åªæ˜¯ä¸å–œæ¬¢â€œ impl traitâ€çš„â€œ fn mainâ€ï¼‰ã€‚å¦å¤–ï¼Œç”±LLVMå’ŒClangçš„å®ç°è€…ç¼–å†™çš„æ–‡ä»¶ä½¿æˆ‘å……æ»¡ä¿¡å¿ƒï¼Œå®ƒaï¼‰å°†æ¥ä¸ä¼šè¢«æ”¾å¼ƒï¼Œå¹¶ä¸”bï¼‰è¾¾åˆ°æˆ‘çš„æ€§èƒ½ç›®æ ‡ã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘æƒ³è¦ä¸€ç§ç¼–è¯‘è¯­è¨€ï¼Œæ²¡æœ‰æŒ‡é’ˆï¼Œæ¨¡å—ï¼Œæ¦‚å¿µï¼ŒèŒƒå›´ï¼Œå¯è¯»æ¨¡æ¿ï¼Œç°åœ¨æˆ‘æƒ³è¦å®ƒã€‚åŒæ ·ï¼Œå‘æ˜äº†ç¼–è¯‘å™¨æ˜¯é€šè¿‡ä½¿ç¨‹åºæ›´å…·å¯è¯»æ€§æ¥ä½¿ç¨‹åºå‘˜çš„ç”Ÿæ´»æ›´è½»æ¾ï¼Œå¹¶ä¸”æœ‰æ—¶åœ¨æŸ¥çœ‹åŸºäºæ¨¡æ¿çš„ä»£ç æ—¶ï¼Œæˆ‘è®¤ä¸ºæˆ‘ä»¬ä¼šå€’é€€ã€‚æˆ‘å–œæ¬¢æˆ‘çš„ä¸œè¥¿å¯è¯»ã€‚</p><p>  Parsing went through a few incarnations. First it was a simple  String(file.availableData, encoding: .utf8) but that is simply to big to fit in memory. Data was not used for similar reasons. Also Scanner from Foundation was evicted at a time. In the end I settled on a InputStream read into an UnsafeMutablePointer&lt;UInt8&gt; array of 64kB.</p><p>  è§£æç»å†äº†ä¸€äº›å˜åŒ–ã€‚é¦–å…ˆï¼Œå®ƒæ˜¯ä¸€ä¸ªç®€å•çš„Stringï¼ˆfile.availableDataï¼Œç¼–ç ï¼š.utf8ï¼‰ï¼Œä½†å®ƒå¤ªå¤§äº†ä»¥é€‚åˆå†…å­˜ã€‚å‡ºäºç±»ä¼¼åŸå› æœªä½¿ç”¨æ•°æ®ã€‚åŸºé‡‘ä¼šçš„æ‰«æä»ªä¹Ÿè¢«é€å‡ºäº†ä¸€æ¬¡ã€‚æœ€åï¼Œæˆ‘å†³å®šå°†InputStreamè¯»å…¥UnsafeMutablePointerï¼†lt; UInt8ï¼†gt;ã€‚æ•°ç»„64kBã€‚</p><p> The Array dead end; in short, donâ€™t ever use Array in a hot path. That is to say, do not ever  generate one. This should have been clear from the beginning since it is heap allocated but the lesson was learned quickly since it always turned up at the top of an analysis done with perf. For fixed-size arrays this can be overcome with tuples or Swiftâ€™s internal  FixedArray. Even if the Array is only used subscript getters tend to show up at the top of perf runs.</p><p> æ•°ç»„æ­»è§’ï¼›ç®€è€Œè¨€ä¹‹ï¼Œæ°¸è¿œä¸è¦åœ¨çƒ­é€”ä¸­ä½¿ç”¨Arrayã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ°¸è¿œä¸è¦ç”Ÿæˆä¸€ä¸ªã€‚ä»ä¸€å¼€å§‹å°±åº”è¯¥æ¸…æ¥šè¿™ä¸€ç‚¹ï¼Œå› ä¸ºå®ƒæ˜¯å †åˆ†é…çš„ï¼Œä½†æ˜¯ç”±äºå®ƒæ€»æ˜¯å‡ºç°åœ¨ç”¨perfè¿›è¡Œçš„åˆ†æçš„é¡¶éƒ¨ï¼Œæ‰€ä»¥å¾ˆå¿«å°±å­¦åˆ°äº†è¿™ä¸€è¯¾ã€‚å¯¹äºå›ºå®šå¤§å°çš„æ•°ç»„ï¼Œå¯ä»¥ä½¿ç”¨å…ƒç»„æˆ–Swiftçš„å†…éƒ¨FixedArrayæ¥å…‹æœã€‚å³ä½¿ä»…ä½¿ç”¨æ•°ç»„ï¼Œä¸‹æ ‡getterä¹Ÿä¼šæ˜¾ç¤ºåœ¨æ€§èƒ½è¿è¡Œçš„é¡¶éƒ¨ã€‚</p><p> In general, I found it quite practical to develop on Linus and macOS in parallel since the available tools to check for performance and memory nicely complement each other. I used mainly four tools:</p><p> æ€»çš„æ¥è¯´ï¼Œæˆ‘å‘ç°å¹¶è¡Œå¼€å‘Linuså’ŒmacOSç›¸å½“å®ç”¨ï¼Œå› ä¸ºå¯ç”¨çš„ç”¨äºæ£€æŸ¥æ€§èƒ½å’Œå†…å­˜çš„å·¥å…·å¯ä»¥å¾ˆå¥½åœ°äº’è¡¥ã€‚æˆ‘ä¸»è¦ä½¿ç”¨äº†å››ä¸ªå·¥å…·ï¼š </p><p> Perf: This Linux kernel tool gives valuable information where time is spent. Just fire it up, look at the function showing up at the top and wonder where time is wasted. Hint; it is usually not where you think it is. In my case it was always swift_retain or release which tells you over and over again to not allocate objects on the heap.</p><p>æ€§èƒ½ï¼šæ­¤Linuxå†…æ ¸å·¥å…·æä¾›äº†å®è´µçš„æ—¶é—´ä¿¡æ¯ã€‚åªéœ€å°†å…¶å¯åŠ¨ï¼ŒæŸ¥çœ‹é¡¶éƒ¨æ˜¾ç¤ºçš„åŠŸèƒ½ï¼Œå¹¶æƒ³çŸ¥é“æ—¶é—´æµªè´¹åœ¨å“ªé‡Œã€‚æš—ç¤º;å®ƒé€šå¸¸ä¸åœ¨æ‚¨è®¤ä¸ºçš„ä½ç½®ã€‚åœ¨æˆ‘çš„æƒ…å†µä¸‹ï¼Œæ€»æ˜¯swift_retainæˆ–releaseä¸€æ¬¡åˆä¸€æ¬¡å‘Šè¯‰æ‚¨ä¸è¦åœ¨å †ä¸Šåˆ†é…å¯¹è±¡ã€‚</p><p> Valgrind Memcheck: This shows where the memory is gone. For example, an analysis with this tool is the reason why the acceleration structure is separated from the acceleration structure builder; the memory spent in building a bounding hierarchy was simply never released. It is nice to have no pointers in Swift, no malloc or new, or even shared_pointers, but it is still necessary to  think about how memory is used.</p><p> Valgrind Memcheckï¼šè¿™æ˜¾ç¤ºå†…å­˜å·²è€—å°½ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨æ­¤å·¥å…·è¿›è¡Œåˆ†ææ˜¯å°†åŠ é€Ÿç»“æ„ä¸åŠ é€Ÿç»“æ„ç”Ÿæˆå™¨åˆ†ç¦»çš„åŸå› ï¼›èŠ±åœ¨å»ºç«‹è¾¹ç•Œå±‚æ¬¡ç»“æ„ä¸Šçš„å†…å­˜ä»æœªè¢«é‡Šæ”¾è¿‡ã€‚åœ¨Swiftä¸­æ²¡æœ‰æŒ‡é’ˆï¼Œæ²¡æœ‰mallocæˆ–newç”šè‡³æ²¡æœ‰shared_pointerséƒ½å¾ˆå¥½ï¼Œä½†æ˜¯ä»ç„¶æœ‰å¿…è¦è€ƒè™‘ä¸€ä¸‹å¦‚ä½•ä½¿ç”¨å†…å­˜ã€‚</p><p> Xcode profiling: I mostly used Time Profiler, Leaks and Allocations which gives you roughly the same information as Perf and Valgrind but from a different viewpoint. Sometimes it is very helpful to look at the same thing from two different views. Which reminds me of the old times when we used to feed our software to three different compilers (Visual Studio, GCC and the one from IRIX, what was its name again? MIPSPro?).</p><p> Xcodeæ¦‚è¦åˆ†æï¼šæˆ‘ä¸»è¦ä½¿ç”¨Time Profilerï¼ŒLeakså’ŒAllocationsï¼Œå®ƒä»¬ä¸ºæ‚¨æä¾›ä¸Perfå’ŒValgrindå¤§è‡´ç›¸åŒçš„ä¿¡æ¯ï¼Œä½†æ˜¯ä»ä¸åŒçš„è§’åº¦æ¥çœ‹ã€‚æœ‰æ—¶ä»ä¸¤ä¸ªä¸åŒçš„è§’åº¦çœ‹åŒä¸€ä»¶äº‹å¾ˆæœ‰å¸®åŠ©ã€‚è¿™è®©æˆ‘æƒ³èµ·äº†è¿‡å»ï¼Œæˆ‘ä»¬æ›¾ç»å°†è½¯ä»¶æä¾›ç»™ä¸‰ç§ä¸åŒçš„ç¼–è¯‘å™¨ï¼ˆVisual Studioï¼ŒGCCå’ŒIRIXçš„ä¸€ç§ï¼‰ï¼Œå®ƒçš„åå­—åˆå«MIPSProï¼Ÿ</p><p> Talking about memory, while Swift makes it very easy to write readable and compact code, you still have to think about low-level operations like memory allocations and the like. I frequently switched between structs and classes just to see how memory and performance are affected. The nice thing about not having pointers, new and shared_pointers is that I was able most of the time to just switch between the two without changing anything else in the system.</p><p> è°ˆåˆ°å†…å­˜ï¼Œå°½ç®¡Swiftä½¿å¾—ç¼–å†™å¯è¯»æ€§å’Œç´§å‡‘ä»£ç éå¸¸å®¹æ˜“ï¼Œä½†æ˜¯æ‚¨ä»ç„¶å¿…é¡»è€ƒè™‘ä½çº§æ“ä½œï¼Œä¾‹å¦‚å†…å­˜åˆ†é…ç­‰ã€‚æˆ‘ç»å¸¸åœ¨ç»“æ„å’Œç±»ä¹‹é—´åˆ‡æ¢ï¼Œåªæ˜¯ä¸ºäº†äº†è§£å†…å­˜å’Œæ€§èƒ½å¦‚ä½•å—åˆ°å½±å“ã€‚æ²¡æœ‰æŒ‡é’ˆï¼Œnewå’Œshared_pointersçš„å¥½å¤„æ˜¯ï¼Œæˆ‘å¤§éƒ¨åˆ†æ—¶é—´éƒ½å¯ä»¥åœ¨ä¸¤è€…ä¹‹é—´åˆ‡æ¢è€Œæ— éœ€æ›´æ”¹ç³»ç»Ÿä¸­çš„ä»»ä½•å…¶ä»–å†…å®¹ã€‚</p><p>  About protocol-based programming: Grepping through todaysâ€˜ Gonzales shows 23 protocols, 57 structs, 47 final classes and 2 non-final classes. Inheritance is almost never used. The two remaining non-final classes are TrowbridgeReitzDistribution and Texture, both of which Iâ€™m not happy about and think about redesigning them in the future. All in all, protocol-based programming turns out to result in nice code, for example I used to have a Primitive class like PBRT but soon changed it to a protocol inheriting from protocols like Boundable, Intersectable, Emitting (gone now) and others. Now it is gone too, the BoundingHierarchyBuild just depends on a Boundable existential type and returns a hierarchy of Intersectables that is used by BoundingHierarchy. All primitives are now stored as an array of existential types consisting of a composition of protocols of Boundable and Intersectable ( var primitives = [Boundable &amp; Intersectable]()).</p><p>  å…³äºåŸºäºåè®®çš„ç¼–ç¨‹ï¼šç¿»é˜…å½“ä»Šçš„Gonzalesï¼Œå¯ä»¥çœ‹åˆ°23ç§åè®®ï¼Œ57ä¸ªç»“æ„ï¼Œ47ä¸ªæœ€ç»ˆç±»å’Œ2ä¸ªéæœ€ç»ˆç±»ã€‚ç»§æ‰¿å‡ ä¹ä»æœªä½¿ç”¨è¿‡ã€‚å‰©ä¸‹çš„ä¸¤ä¸ªéæœ€ç»ˆç±»æ˜¯TrowbridgeReitzDistributionå’ŒTextureï¼Œæˆ‘éƒ½ä¸æ»¡æ„ï¼Œå¹¶ä¸”è€ƒè™‘åœ¨å°†æ¥é‡æ–°è®¾è®¡å®ƒä»¬ã€‚æ€»è€Œè¨€ä¹‹ï¼ŒåŸºäºåè®®çš„ç¼–ç¨‹æœ€ç»ˆä¼šäº§ç”Ÿæ¼‚äº®çš„ä»£ç ï¼Œä¾‹å¦‚ï¼Œæˆ‘æ›¾ç»æ‹¥æœ‰PBRTä¹‹ç±»çš„Primitiveç±»ï¼Œä½†å¾ˆå¿«å°†å…¶æ›´æ”¹ä¸ºç»§æ‰¿è‡ªBoundableï¼ŒIntersectableï¼ŒEmittingï¼ˆç°å·²æ¶ˆå¤±ï¼‰ç­‰åè®®çš„åè®®ã€‚ç°åœ¨å®ƒä¹Ÿæ¶ˆå¤±äº†ï¼ŒBoundingHierarchyBuildä»…ä¾èµ–äºBoundableå­˜åœ¨ç±»å‹ï¼Œå¹¶è¿”å›ç”±BoundingHierarchyä½¿ç”¨çš„Intersectableså±‚æ¬¡ç»“æ„ã€‚ç°åœ¨ï¼Œæ‰€æœ‰åŸè¯­éƒ½å­˜å‚¨ä¸ºå­˜åœ¨ç±»å‹çš„æ•°ç»„ï¼Œè¯¥æ•°ç»„ç”±å¯ç»‘å®šå’Œå¯äº¤å‰çš„åè®®ç»„æˆï¼ˆvaråŸè¯­= [Boundableï¼†Intersectable]ï¼ˆï¼‰ï¼‰ã€‚</p><p> The primitives in a BoundingHierarchy on the other hand are stored as a [AnyObject &amp; Intersectable]. This has two reasons: 1. Only intersection is needed. 2. AnyObject forces the stored objects to be reference types (or classes) which saves memory since the layout of protocols for both structs and classes ( OpaqueExistentialContainer) uses 40 bytes since Swift tries to store structs inline, whereas class-only protocols ( ClassExistentialContainer) use only 16 bytes as only a pointer has to be stored as can be seen in  Swiftâ€™s documentation or verified in the  source. I emphasize that this is not only an academic discussion but I came across this since it showed up at the top of a memcheck run.</p><p> å¦ä¸€æ–¹é¢ï¼ŒBoundingHierarchyä¸­çš„åŸºå…ƒå­˜å‚¨ä¸º[AnyObjectï¼†amp;ç›¸äº¤]ã€‚è¿™æœ‰ä¸¤ä¸ªåŸå› ï¼š1.ä»…éœ€è¦äº¤å‰ç‚¹ã€‚ 2. AnyObjectå¼ºåˆ¶å­˜å‚¨çš„å¯¹è±¡ä¸ºå¼•ç”¨ç±»å‹ï¼ˆæˆ–ç±»ï¼‰ï¼Œè¿™èŠ‚çœäº†å†…å­˜ï¼Œå› ä¸ºç»“æ„å’Œç±»çš„åè®®å¸ƒå±€ï¼ˆOpaqueExistentialContainerï¼‰éƒ½ä½¿ç”¨40å­—èŠ‚ï¼Œå› ä¸ºSwiftè¯•å›¾ä»¥å†…è”æ–¹å¼å­˜å‚¨ç»“æ„ï¼Œè€Œçº¯ç±»åè®®ï¼ˆClassExistentialContainerï¼‰ä»…ä½¿ç”¨16ä¸ªå­—èŠ‚ï¼Œå› ä¸ºåªéœ€è¦å­˜å‚¨ä¸€ä¸ªæŒ‡é’ˆå³å¯ï¼Œå¦‚Swiftçš„æ–‡æ¡£ä¸­æ‰€ç¤ºæˆ–åœ¨æºä»£ç ä¸­è¿›è¡Œäº†éªŒè¯ã€‚æˆ‘å¼ºè°ƒï¼Œè¿™ä¸ä»…æ˜¯å­¦æœ¯è®¨è®ºï¼Œè€Œä¸”ç”±äºå®ƒå‡ºç°åœ¨memcheckè¿è¡Œçš„é¡¶éƒ¨ï¼Œæ‰€ä»¥æˆ‘ç¢°åˆ°äº†è¿™ä¸€ç‚¹ã€‚</p><p> One of the reasons you can render Moana in less than 10.000 lines is the ability to write compact code in Swift. One extreme example is parameter lists. In PBRT you can attach arbitrary parameters to objects which results in around 1000 lines of code in paramset.[h|cpp]. In Swift you can achieve the same in about three lines:</p><p> æ‚¨å¯ä»¥åœ¨å°‘äº10.000è¡Œä¸­å‘ˆç°Moanaçš„åŸå› ä¹‹ä¸€æ˜¯èƒ½å¤Ÿåœ¨Swiftä¸­ç¼–å†™ç´§å‡‘çš„ä»£ç ã€‚ä¸€ä¸ªæç«¯çš„ä¾‹å­æ˜¯å‚æ•°åˆ—è¡¨ã€‚åœ¨PBRTä¸­ï¼Œæ‚¨å¯ä»¥å°†ä»»æ„å‚æ•°é™„åŠ åˆ°å¯¹è±¡ï¼Œä»è€Œåœ¨å‚æ•°é›†[h | cpp]ä¸­äº§ç”Ÿå¤§çº¦1000è¡Œä»£ç ã€‚åœ¨Swiftä¸­ï¼Œæ‚¨å¯ä»¥é€šè¿‡ä¸‰è¡Œä»£ç å®ç°ç›¸åŒçš„ç›®çš„ï¼š </p><p>  Actually, Iâ€™m cheating a little bit here but you get the point. (Also, I think this has changed in PBRT-v4.)</p><p>å®é™…ä¸Šï¼Œæˆ‘åœ¨è¿™é‡Œæœ‰ç‚¹ä½œå¼Šï¼Œä½†æ˜¯æ‚¨æ˜ç™½äº†ã€‚ ï¼ˆæ­¤å¤–ï¼Œæˆ‘è®¤ä¸ºè¿™åœ¨PBRT-v4ä¸­å·²ç»æ”¹å˜ã€‚ï¼‰</p><p> About interfacing C++ for Ptex and OpenEXR support: Interoperability with C++ is  on the way for Swift but wasnâ€™t available when I started/as of now. Since Iâ€™m using OpenEXR and Ptex only for reading textures and writing images I resorted to  extern &#34;C&#34;. One modulemap and a few lines of C++ code later (100 for Ptex, 82 for OpenEXR) I had support for reading and writing OpenEXR images and Ptex textures.</p><p> å…³äºå°†C ++ç”¨äºPtexå’ŒOpenEXRçš„æ¥å£æ”¯æŒï¼šä¸C ++çš„äº’æ“ä½œæ€§æ­£åœ¨Swiftä¸­å‘å±•ï¼Œä½†åœ¨æˆ‘å¼€å§‹æ—¶ï¼ˆæˆ–ç›®å‰ï¼‰è¿˜ä¸å¯ç”¨ã€‚ç”±äºæˆ‘ä»…å°†OpenEXRå’ŒPtexç”¨äºè¯»å–çº¹ç†å’Œå†™å…¥å›¾åƒï¼Œæ‰€ä»¥æˆ‘æ±‚åŠ©äºexternï¼†ï¼ƒ34; Cï¼†ï¼ƒ34;ã€‚åæ¥æœ‰ä¸€ä¸ªmodulemapå’Œå‡ è¡ŒC ++ä»£ç ï¼ˆPtexä¸º100ï¼ŒOpenEXRä¸º82ï¼‰æˆ‘æ”¯æŒè¯»å†™OpenEXRå›¾åƒå’ŒPtexçº¹ç†ã€‚</p><p> I am releasing the code now as I am able to render Moana on a Google Compute Engine with 8 vCPUs and 64GB memory which is free for three months, so please download the code, get an account at fire it up. ğŸ™‚ That said, there is a lot to do as I optimized it only as far as to be able to get one image rendered. The following is a big todo list roughly sorted from easily implemented to big projects which I might or might not tackle in the future.</p><p> æˆ‘ç°åœ¨è¦å‘å¸ƒä»£ç ï¼Œå› ä¸ºæˆ‘å¯ä»¥åœ¨å…·æœ‰8ä¸ªvCPUå’Œ64GBå†…å­˜çš„Google Compute Engineä¸Šæ¸²æŸ“Moanaï¼Œè¿™ä¸‰ä¸ªæœˆéƒ½æ˜¯å…è´¹çš„ï¼Œå› æ­¤è¯·ä¸‹è½½ä»£ç ï¼Œå¹¶å¯åŠ¨ä¸€ä¸ªå¸æˆ·ã€‚ ğŸ™‚å°±æ˜¯è¯´ï¼Œè¦åšå¾ˆå¤šäº‹æƒ…ï¼Œå› ä¸ºæˆ‘åªå¯¹å…¶è¿›è¡Œäº†ä¼˜åŒ–ï¼Œä»¥ä¾¿èƒ½å¤Ÿæ¸²æŸ“ä¸€å¼ å›¾åƒã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¤§å‹å¾…åŠäº‹é¡¹æ¸…å•ï¼Œä»å®¹æ˜“å®æ–½çš„é¡¹ç›®åˆ°æˆ‘å°†æ¥å¯èƒ½ä¼šè§£å†³æˆ–å¯èƒ½ä¸ä¼šè§£å†³çš„å¤§å‹é¡¹ç›®è¿›è¡Œåˆ†ç±»ã€‚</p><p>  Ray differentials for direct rays. This should be relatively easy; have a look at how PBRT-v3 does it, implement differential generation in the camera, pump it through the system and use it in the call to Ptex. There it is handled automatically.</p><p>  ç›´æ¥å…‰çº¿çš„å…‰çº¿å·®å¼‚ã€‚è¿™åº”è¯¥ç›¸å¯¹å®¹æ˜“äº›ã€‚çœ‹çœ‹PBRT-v3æ˜¯å¦‚ä½•åšåˆ°çš„ï¼Œå¦‚ä½•åœ¨æ‘„åƒæœºä¸­å®ç°å·®åˆ†ç”Ÿæˆï¼Œå°†å…¶æ³µé€åˆ°ç³»ç»Ÿä¸­ï¼Œå¹¶åœ¨å¯¹Ptexçš„è°ƒç”¨ä¸­ä½¿ç”¨ã€‚åœ¨é‚£é‡Œå®ƒæ˜¯è‡ªåŠ¨å¤„ç†çš„ã€‚</p><p> Better hierarchies: I only implemented the simplest bounding hierarchy which is nice since it is only 177 lines of code but is also results in suboptimal rendering times. SAH optimized hierarchies should be much better in this regard. They also should not be to difficult to implement since I followed very much PBRTâ€™s implementation.</p><p> æ›´å¥½çš„å±‚æ¬¡ç»“æ„ï¼šæˆ‘ä»…å®ç°äº†æœ€ç®€å•çš„è¾¹ç•Œå±‚æ¬¡ç»“æ„ï¼Œè¿™å¾ˆä¸é”™ï¼Œå› ä¸ºå®ƒåªæœ‰177è¡Œä»£ç ï¼Œä½†æ¸²æŸ“æ—¶é—´ä¹Ÿä¸ç†æƒ³ã€‚åœ¨è¿™æ–¹é¢ï¼ŒSAHä¼˜åŒ–çš„å±‚æ¬¡ç»“æ„åº”è¯¥æ›´å¥½ã€‚ç”±äºæˆ‘éå¸¸å…³æ³¨PBRTçš„å®æ–½ï¼Œå› æ­¤å®æ–½èµ·æ¥ä¹Ÿä¸éš¾ã€‚</p><p> Faster parsing: Integrate Ingo Waldâ€™s  fast pbrt parser which parses Moana in seconds instead of half an hour. Or even better: Write a parser for the pbf format in Swift.</p><p> æ›´å¿«çš„è§£æé€Ÿåº¦ï¼šé›†æˆIngo Waldçš„å¿«é€Ÿpbrtè§£æå™¨ï¼Œè¯¥è§£æå™¨å¯ä»¥åœ¨å‡ ç§’é’Ÿå†…è€Œä¸æ˜¯åŠå°æ—¶å†…è§£æMoanaã€‚ç”šè‡³æ›´å¥½ï¼šåœ¨Swiftä¸­ä¸ºpbfæ ¼å¼ç¼–å†™ä¸€ä¸ªè§£æå™¨ã€‚</p><p>  An idea about faster parsing, hierarchy generation and scene formats:  LLVM has  three different bitcode formats; in-memory, machine readable (binary) and human readable and it can losslessly convert between the three. Can we have the same? Like PBRT (human readable), PBF or USD (machine readable) and BHF (binary hierarchy format) where bounding hierarchies are already generated and can simply be mapped to memory.</p><p>  å…³äºæ›´å¿«çš„è§£æï¼Œå±‚æ¬¡ç»“æ„ç”Ÿæˆå’Œåœºæ™¯æ ¼å¼çš„æƒ³æ³•ï¼šLLVMå…·æœ‰ä¸‰ç§ä¸åŒçš„ä½ç æ ¼å¼ã€‚å†…å­˜ï¼Œæœºå™¨å¯è¯»ï¼ˆäºŒè¿›åˆ¶ï¼‰å’Œäººç±»å¯è¯»çš„ï¼Œå®ƒå¯ä»¥åœ¨è¿™ä¸‰ç§ä¹‹é—´è¿›è¡Œæ— æŸè½¬æ¢ã€‚æˆ‘ä»¬å¯ä»¥ä¸€æ ·å—ï¼ŸåƒPBRTï¼ˆäººç±»å¯è¯»ï¼‰ï¼ŒPBFæˆ–USDï¼ˆæœºå™¨å¯è¯»ï¼‰å’ŒBHFï¼ˆäºŒè¿›åˆ¶å±‚æ¬¡ç»“æ„æ ¼å¼ï¼‰ä¸€æ ·ï¼Œå®ƒä»¬çš„è¾¹ç•Œå±‚æ¬¡ç»“æ„å·²ç»ç”Ÿæˆï¼Œå¯ä»¥ç®€å•åœ°æ˜ å°„åˆ°å†…å­˜ä¸­ã€‚ </p><p> Beginner tasks: I only tried to get Moana to render but it should be fairly easy to enhance Gonzales to be able to render other scenes by adding features or fixing bugs. There are lots of  scenes  to  try. Also there  are  many  exporters for PBRT which should work for Gonzales too.</p><p>å…¥é—¨ä»»åŠ¡ï¼šæˆ‘åªæ˜¯æƒ³è®©Moanaè¿›è¡Œæ¸²æŸ“ï¼Œä½†æ˜¯å¢å¼ºGonzalesä½¿å…¶èƒ½å¤Ÿé€šè¿‡æ·»åŠ åŠŸèƒ½æˆ–ä¿®å¤é”™è¯¯æ¥æ¸²æŸ“å…¶ä»–åœºæ™¯åº”è¯¥ç›¸å½“å®¹æ˜“ã€‚æœ‰å¾ˆå¤šåœºæ™¯å¯ä»¥å°è¯•ã€‚ä¹Ÿæœ‰è®¸å¤šPBRTå‡ºå£å•†ä¹Ÿåº”ä¸ºå†ˆè¨é›·æ–¯æœåŠ¡ã€‚</p><p>   Memory: Lots of memory is used for pixel samples as the image is only written when rendering is finished. Change that to write tiles as they are rendered and discard samples early. This interferes with pixel filtering but since we are denoising anyway maybe this is not needed anymore?</p><p>   å†…å­˜ï¼šç”±äºä»…åœ¨æ¸²æŸ“å®Œæˆæ—¶æ‰å†™å…¥å›¾åƒï¼Œå› æ­¤è®¸å¤šå†…å­˜ç”¨äºåƒç´ æ ·æœ¬ã€‚å°†å…¶æ›´æ”¹ä¸ºåœ¨æ¸²æŸ“æ—¶å†™å…¥å›¾å—ï¼Œå¹¶å°½æ—©ä¸¢å¼ƒæ ·æœ¬ã€‚è¿™ä¼šå¹²æ‰°åƒç´ è¿‡æ»¤ï¼Œä½†ç”±äºæˆ‘ä»¬æ— è®ºå¦‚ä½•éƒ½è¦è¿›è¡Œå»å™ªï¼Œä¹Ÿè®¸ä¸å†éœ€è¦äº†å—ï¼Ÿ</p><p> Smaller Transforms: As of now Transforms store two matrices, a 4Ã—4 matrix storing the transformation and its inverse. This is a little wasteful since you can always compute one from the other but inversion is slow but after careful thinking when which transform is needed it should be possible to get rid of one. Right now both are used when intersecting a triangle but is it possible to store triangle (and other objects like curves) in world space to get rid of the transformation of the ray into object space and similarly the transformation to world space for surface interactions? And how does this interact with transformed primitives and object instances?</p><p> è¾ƒå°çš„å˜æ¢ï¼šåˆ°ç›®å‰ä¸ºæ­¢ï¼Œå˜æ¢å­˜å‚¨ä¸¤ä¸ªçŸ©é˜µï¼Œä¸€ä¸ª4Ã—4çŸ©é˜µå­˜å‚¨å˜æ¢åŠå…¶é€†çŸ©é˜µã€‚è¿™æœ‰ç‚¹æµªè´¹ï¼Œå› ä¸ºæ‚¨æ€»æ˜¯å¯ä»¥å½¼æ­¤è®¡ç®—ï¼Œä½†æ˜¯æ±‚é€†å¾ˆæ…¢ï¼Œä½†æ˜¯åœ¨ä»”ç»†è€ƒè™‘ä½•æ—¶éœ€è¦å“ªç§è½¬æ¢ä¹‹åï¼Œåº”è¯¥å¯ä»¥æ‘†è„±å…¶ä¸­ä¸€ç§ã€‚ç°åœ¨åœ¨ç›¸äº¤ä¸‰è§’å½¢æ—¶éƒ½ä½¿ç”¨äº†ä¸¤è€…ï¼Œä½†æ˜¯æ˜¯å¦å¯ä»¥åœ¨ä¸–ç•Œç©ºé—´ä¸­å­˜å‚¨ä¸‰è§’å½¢ï¼ˆä»¥åŠå…¶ä»–å¯¹è±¡ï¼Œä¾‹å¦‚æ›²çº¿ï¼‰ä»¥æ‘†è„±å°„çº¿åˆ°å¯¹è±¡ç©ºé—´çš„è½¬æ¢ä»¥åŠç±»ä¼¼åœ°åˆ°è¡¨é¢ç›¸äº’ä½œç”¨çš„åˆ°ä¸–ç•Œç©ºé—´çš„è½¬æ¢ï¼Ÿä»¥åŠå¦‚ä½•ä¸è½¬æ¢åçš„åŸè¯­å’Œå¯¹è±¡å®ä¾‹è¿›è¡Œäº¤äº’ï¼Ÿ</p><p> Denoising: I am using OpenImageDenoise for the time being but of course an integrated denoiser in Swift would be nice to have. Also, the beauty, albedo and normal image are written separately, this should be rearchitected.</p><p> é™å™ªï¼šæˆ‘æš‚æ—¶æ­£åœ¨ä½¿ç”¨OpenImageDenoiseï¼Œä½†æ˜¯åœ¨Swiftä¸­ä½¿ç”¨é›†æˆçš„å»å™ªå™¨å½“ç„¶æ˜¯ä¸é”™çš„é€‰æ‹©ã€‚æ­¤å¤–ï¼Œåº”å°†ç¾å¥³ï¼Œåç…§ç‡å’Œæ­£å¸¸å½¢è±¡åˆ†åˆ«å†™å…¥ï¼Œè¿™åº”è¯¥é‡æ–°æ„é€ ã€‚</p><p>   Beyond path tracing: Look at  PxrUnified and implement  Guided Path Tracing (I had a look at it but it looksâ€¦ confusing) and  Manifold Next Event Estimation. I think I saw an implementation somewhere but I forgot. (And if only Weta followed Disneyâ€™s lead and published the Gandalf head from that paper, sigh!)</p><p>   è¶…è¶Šè·¯å¾„è·Ÿè¸ªï¼šæŸ¥çœ‹PxrUnifiedå¹¶å®ç°â€œå¼•å¯¼è·¯å¾„è·Ÿè¸ªâ€ï¼ˆæˆ‘çœ‹è¿‡å®ƒï¼Œä½†çœ‹èµ·æ¥â€¦â€¦ä»¤äººè¿·æƒ‘ï¼‰å’Œæµå½¢ä¸‹ä¸€ä¸ªäº‹ä»¶ä¼°è®¡ã€‚æˆ‘æƒ³æˆ‘åœ¨æŸå¤„çœ‹åˆ°äº†ä¸€ä¸ªå®ç°ï¼Œä½†æˆ‘å¿˜äº†ã€‚ ï¼ˆå¦‚æœåªæœ‰Wetaè·Ÿéšè¿ªæ–¯å°¼çš„é¢†å¯¼ï¼Œå¹¶ä»é‚£ç¯‡è®ºæ–‡ä¸­å‘è¡¨äº†ç”˜é“å¤«çš„å¤´åƒï¼Œé‚£å°±å¹æ°”ï¼ï¼‰</p><p>  Faster rendering: Embree has a  path tracer. Look at it hard and try to make Gonzales faster.</p><p>  æ¸²æŸ“é€Ÿåº¦æ›´å¿«ï¼šEmbreeå…·æœ‰è·¯å¾„è·Ÿè¸ªå™¨ã€‚åŠªåŠ›çœ‹å¾…å®ƒï¼Œå¹¶å°è¯•ä½¿å†ˆè¨é›·æ–¯æ›´å¿«ã€‚</p><p> GPU rendering: This should be a big one, PBRT-v4 obviously does this as some of the mentioned renderers above. It should be very well possible to follow them and use Optix to render on a graphics card but I would much prefer a solution not involving closed source. Which would mean that you have to implement your own Optix.   But looking at how CPUs and GPUs are evolving it might be possible in a distant future to use the same (Swift) code on both of them; you can have instances with 448 CPUs in the cloud and the latest GPUs have a few thousand micro-cpus, they look more and more the same. I wonder whether it will be needed to program for AVX in the future as it seems less needed as you can just throw more cores at the problem. At the same time memory is getting more and more NUMA-like so having your data next to the ALU is getting more important. Maybe one day we have render nodes in the cloud each responsible for one part of the scene, each node partitioning the scene geometrically and sending only portions to the CPUS. Then the returned intersections could simply sorted by the  t value of the ray which reminds me of sort-first/middle/last architectures like  Chromium.</p><p> GPUæ¸²æŸ“ï¼šè¿™åº”è¯¥æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ¸²æŸ“ï¼Œæ˜¾ç„¶ï¼ŒPBRT-v4ä¼šåƒä¸Šé¢æåˆ°çš„æŸäº›æ¸²æŸ“å™¨ä¸€æ ·åšåˆ°è¿™ä¸€ç‚¹ã€‚è·Ÿéšå®ƒä»¬å¹¶ä½¿ç”¨Optixåœ¨å›¾å½¢å¡ä¸Šè¿›è¡Œæ¸²æŸ“åº”è¯¥æ˜¯éå¸¸æœ‰å¯èƒ½çš„ï¼Œä½†æ˜¯æˆ‘æ›´å–œæ¬¢ä¸æ¶‰åŠå°é—­æºä»£ç çš„è§£å†³æ–¹æ¡ˆã€‚è¿™æ„å‘³ç€æ‚¨å¿…é¡»å®æ–½è‡ªå·±çš„Optixã€‚ä½†æ˜¯ï¼Œçœ‹çœ‹CPUå’ŒGPUçš„å‘å±•æƒ…å†µï¼Œå¾ˆå¯èƒ½åœ¨é¥è¿œçš„å°†æ¥åœ¨ä¸¤è€…ä¸Šä½¿ç”¨ç›¸åŒçš„ï¼ˆSwiftï¼‰ä»£ç ã€‚æ‚¨å¯ä»¥åœ¨äº‘ç«¯æ‹¥æœ‰448ä¸ªCPUçš„å®ä¾‹ï¼Œè€Œæœ€æ–°çš„GPUå…·æœ‰æ•°åƒä¸ªå¾®CPUï¼Œå®ƒä»¬çœ‹èµ·æ¥è¶Šæ¥è¶Šç›¸ä¼¼ã€‚æˆ‘æƒ³çŸ¥é“å°†æ¥æ˜¯å¦éœ€è¦å¯¹AVXè¿›è¡Œç¼–ç¨‹ï¼Œå› ä¸ºå®ƒä¼¼ä¹ä¸éœ€è¦äº†ï¼Œå› ä¸ºæ‚¨å¯ä»¥åœ¨é—®é¢˜ä¸ŠæŠ•å…¥æ›´å¤šçš„å†…æ ¸ã€‚åŒæ—¶ï¼Œå†…å­˜å˜å¾—è¶Šæ¥è¶ŠåƒNUMAï¼Œå› æ­¤å°†æ•°æ®æ”¾åœ¨ALUæ—è¾¹å˜å¾—è¶Šæ¥è¶Šé‡è¦ã€‚ä¹Ÿè®¸æœ‰ä¸€å¤©ï¼Œæˆ‘ä»¬åœ¨äº‘ä¸­æœ‰æ¸²æŸ“èŠ‚ç‚¹ï¼Œæ¯ä¸ªæ¸²æŸ“èŠ‚ç‚¹è´Ÿè´£åœºæ™¯çš„ä¸€éƒ¨åˆ†ï¼Œæ¯ä¸ªèŠ‚ç‚¹å°†åœºæ™¯è¿›è¡Œå‡ ä½•åˆ’åˆ†ï¼Œå¹¶ä¸”ä»…å°†éƒ¨åˆ†å†…å®¹å‘é€ç»™CPUSã€‚ç„¶åï¼Œè¿”å›çš„äº¤å‰ç‚¹å¯ä»¥ç®€å•åœ°æŒ‰å°„çº¿çš„tå€¼æ’åºï¼Œè¿™è®©æˆ‘æƒ³èµ·äº†Chromiumç­‰æ’åºä¼˜å…ˆ/ä¸­é—´/æœ€åçš„ä½“ç³»ç»“æ„ã€‚ </p><p> Thatâ€™s it for now. I would be extremely happy to receive comments what could be done better or implemented more elegantly, bug reports or even pull requests. ğŸ˜‰ Also thanks to Matt Pharr and PBRT, the most valuable resource in the known universe (at least when it involves rendering).</p><p>ç°åœ¨å°±è¿™æ ·ã€‚ æˆ‘éå¸¸é«˜å…´æ”¶åˆ°è¯„è®ºï¼Œè¿™äº›è¯„è®ºå¯ä»¥åšå¾—æ›´å¥½æˆ–æ›´ä¼˜é›…åœ°æ‰§è¡Œï¼Œè¿˜å¯ä»¥æŠ¥å‘Šé”™è¯¯ï¼Œç”šè‡³å¯ä»¥æå‡ºè¯·æ±‚ã€‚ ğŸ˜‰åŒæ—¶è¿˜è¦æ„Ÿè°¢Matt Pharrå’ŒPBRTï¼Œè¿™æ˜¯å·²çŸ¥å®‡å®™ä¸­æœ€æœ‰ä»·å€¼çš„èµ„æºï¼ˆè‡³å°‘åœ¨æ¶‰åŠæ¸²æŸ“æ—¶ï¼‰ã€‚ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://gonsoloblog.wordpress.com/2021/01/14/rendering-moana-with-swift/">https://gonsoloblog.wordpress.com/2021/01/14/rendering-moana-with-swift/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/moana/">#moana</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>