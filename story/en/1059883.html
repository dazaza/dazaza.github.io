<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>åˆ›é€ æ€§ç¼–ç ä¸­çš„å™ªéŸ³ Noise in Creative Coding</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Noise in Creative Coding<br/>åˆ›é€ æ€§ç¼–ç ä¸­çš„å™ªéŸ³ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-23 06:14:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/feb2fa238e92c8d5dd2de5eb116b60a6.gif"><img src="http://img2.diglog.com/img/2021/4/feb2fa238e92c8d5dd2de5eb116b60a6.gif" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Noise is an indispensable tool for creative coding. We use it to generate all kinds of organic effects like clouds, landscapes and contours. Or to move and distort objects with a more lifelike behaviour.</p><p>å™ªå£°æ˜¯åˆ›æ„ç¼–ç çš„ä¸å¯æˆ–ç¼ºçš„å·¥å…·ã€‚æˆ‘ä»¬ç”¨å®ƒæ¥äº§ç”Ÿäº‘ï¼Œæ™¯è§‚å’Œè½®å»“ç­‰å„ç§æœ‰æœºæ•ˆæœã€‚æˆ–è€…ä»¥æ›´é€¼çœŸçš„è¡Œä¸ºç§»åŠ¨å’Œæ‰­æ›²å¯¹è±¡ã€‚</p><p> On the surface, noise appears to be simple to use but, there are so many layers to it. This post takes a deep dive into what noise is, its variants, how to use it on the web and its applications. And lotâ€™s of examples. So many examples!</p><p> åœ¨è¡¨é¢ä¸Šï¼Œå™ªéŸ³ä¼¼ä¹å¾ˆç®€å•ï¼Œä½†æ˜¯ï¼Œå®ƒæœ‰è¿™ä¹ˆå¤šçš„å±‚ã€‚è¿™ç¯‡æ–‡ç« æ·±å…¥æ½œå…¥å™ªéŸ³æ˜¯å®ƒçš„å˜ä½“ï¼Œå¦‚ä½•åœ¨Webä¸Šä½¿ç”¨å®ƒåŠå…¶åº”ç”¨ã€‚å’Œå¾ˆå¤šä¾‹å­ã€‚è¿™ä¹ˆå¤šä¾‹å­ï¼</p><p>  Imagine you want to move an object around the screen. Animators will use keyframes and tweens to describe the exact motion. Generative artists instead rely on algorithms.</p><p>  æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æƒ³åœ¨å±å¹•å‘¨å›´ç§»åŠ¨ä¸€ä¸ªç‰©ä½“ã€‚åŠ¨ç”»å¸ˆå°†ä½¿ç”¨å…³é”®å¸§å’ŒTWEENSæ¥æè¿°ç¡®åˆ‡çš„è¿åŠ¨ã€‚ç”Ÿæˆè‰ºæœ¯å®¶ä¾èµ–äºç®—æ³•ã€‚</p><p>  Not exactly. Randomness is just too unnatural. Look at that pink ball, bouncing all over the place. Itâ€™s nauseating ğŸ¥´</p><p>  ä¸å®Œå…¨æ˜¯ã€‚éšæœºæ€§å¤ªä¸è‡ªç„¶ã€‚çœ‹çœ‹é‚£ä¸ªç²‰çº¢è‰²çš„çƒï¼Œåœ¨è¿™ä¸ªåœ°æ–¹å¼¹è·³ã€‚è¿™æ˜¯ä»¤äººç”Ÿæ„çš„â™¥</p><p> What we need is a smoother, moreÂ  organic randomness. That is what the noise function generates (the yellow ball). Much more aesthetically pleasing!</p><p> æˆ‘ä»¬éœ€è¦çš„æ˜¯æ›´å¹³æ»‘çš„ï¼Œæ›´æœ‰æœºçš„éšæœºæ€§ã€‚è¿™å°±æ˜¯å™ªå£°åŠŸèƒ½äº§ç”Ÿçš„ï¼ˆé»„çƒï¼‰ã€‚æ›´ç¾è§‚åœ°æ„‰æ‚¦ï¼</p><p>  This idea ofÂ  organic randomnessÂ appears again and again in creative coding. For example, when generating textures, moving objects or distorting them. We often reach for the noise function.</p><p>  åœ¨åˆ›æ„ç¼–ç ä¸­ï¼Œè¿™ç§æœ‰æœºéšæœºæ€§çš„æƒ³æ³•å†æ¬¡å‡ºç°ã€‚ä¾‹å¦‚ï¼Œåœ¨ç”Ÿæˆçº¹ç†æ—¶ï¼Œç§»åŠ¨ç‰©ä½“æˆ–æ‰­æ›²å®ƒä»¬ã€‚æˆ‘ä»¬ç»å¸¸è¾¾åˆ°å™ªå£°åŠŸèƒ½ã€‚</p><p>   Ken Perlin developed the first while working on Tron in the early 1980s and won an  Oscar ğŸ† for those special effects. He then improved on it with Simplex noise and made it a bit faster. Iâ€™ll focus on the latter and use the  simplex-noise library for my examples.</p><p>   Ken Perlinåœ¨20ä¸–çºª80å¹´ä»£åˆåœ¨Tronå¼€å‘çš„åŒæ—¶å¼€å‘äº†ç¬¬ä¸€ï¼Œå¹¶è·å¾—äº†é‚£äº›ç‰¹æ•ˆçš„å¥¥æ–¯å¡ğŸ†ã€‚ç„¶åä»–ç”¨å•çº¯å…‹å™ªéŸ³æ”¹å–„äº†å®ƒï¼Œå¹¶ä½¿å®ƒæ›´å¿«ã€‚æˆ‘å°†ä¸“æ³¨äºåè€…å¹¶ä¸ºæˆ‘çš„ç¤ºä¾‹ä½¿ç”¨å•çº¯å…‹å™ªå£°åº“ã€‚ </p><p> The noise function takes in a couple of inputs (which  drive the output) and returns a value between -1 and 1. The output is a mix of  Math.sin() and  Math.random(). A random wave is how I would describe it.</p><p>å™ªå£°åŠŸèƒ½å æ®äº†å‡ ä¸ªè¾“å…¥ï¼ˆé©±åŠ¨è¾“å‡ºï¼‰å¹¶è¿”å›-1å’Œ1ä¹‹é—´çš„å€¼ã€‚è¾“å‡ºæ˜¯math.sinï¼ˆï¼‰å’Œmath.randomï¼ˆï¼‰çš„æ··åˆã€‚éšæœºæ³¢æ˜¯æˆ‘å¦‚ä½•å½¢å®¹çš„ã€‚</p><p> import SimplexNoise  from  &#39;simplex-noise&#39; ; const simplex  =  new   ( ) ; const y  = simplex . noise2D (x  * frequency ,  0 )  * amplitude ;</p><p> ä»ï¼†ï¼ƒ39å¯¼å…¥simplexnoise; simplexå™ªå£°ï¼†ï¼ƒ39; ; const simplex = newï¼ˆï¼‰; const y = simplexã€‚ Coke2dï¼ˆx *é¢‘ç‡ï¼Œ0ï¼‰*å¹…åº¦;</p><p> The underlying mechanics are similar to how waves work. You can control how quickly or how much it oscillates by adjusting frequency and amplitude.</p><p> æ½œåœ¨çš„åŠ›å­¦ç±»ä¼¼äºæ³¢æµªçš„å·¥ä½œã€‚æ‚¨å¯ä»¥é€šè¿‡è°ƒæ•´é¢‘ç‡å’Œå¹…åº¦æ¥æ§åˆ¶å¦‚ä½•å¿«é€Ÿæˆ–æŒ¯è¡æŒ¯è¡ã€‚</p><p>    The noise algorithm can be implemented for multiple dimensions. Think of these as the number of inputs into the noise generatorâ€”two for 2D, three for 3D and so on.</p><p>    å¯ä»¥ä¸ºå¤šä¸ªç»´åº¦å®ç°å™ªå£°ç®—æ³•ã€‚å°†è¿™äº›è§†ä¸ºå™ªå£°å‘ç”Ÿå™¨çš„è¾“å…¥æ•°é‡ - ä¸¤ä¸ªç”¨äº2Dï¼Œ3ä¸ªç”¨äº3Dçš„è¾“å…¥ã€‚</p><p> Which dimension you pick depends on what variables you want to drive the generator with. Letâ€™s look at a few examples.</p><p> æ‚¨é€‰æ‹©çš„ç»´åº¦å–å†³äºæ‚¨æƒ³è¦ä½¿ç”¨çš„å˜é‡ã€‚è®©æˆ‘ä»¬æ¥çœ‹çœ‹ä¸€äº›ä¾‹å­ã€‚</p><p> ğŸ’¡ Starting here, each example is embedded in a source card. With links to the actual source code and, in some cases, variables you can tweak.</p><p> ğŸ’¡ä»è¿™é‡Œå¼€å§‹ï¼Œæ¯ä¸ªç¤ºä¾‹éƒ½åµŒå…¥åœ¨æºå¡ä¸­ã€‚é€šè¿‡é“¾æ¥åˆ°å®é™…æºä»£ç ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨å¯ä»¥è°ƒæ•´çš„å˜é‡ã€‚</p><p>  Technically there is no noise1D. You can get 1D noise by passing in zero as the second argument to simplex.noise2D. Letâ€™s say you want to move a ball with an organic-looking oscillating motion. Increment its x coordinate and use it to generate the y value.</p><p>  ä»æŠ€æœ¯ä¸Šè®²ï¼Œæ²¡æœ‰å™ªéŸ³ã€‚æ‚¨å¯ä»¥é€šè¿‡å°†é›¶ä½œä¸ºSimplex.Noise2dçš„ç¬¬äºŒä¸ªå‚æ•°ä¼ é€’é›¶æ¥è·å¾—1Då™ªå£°ã€‚è®©æˆ‘ä»¬è¯´ä½ æƒ³ç”¨æœ‰æœºæŒ¯è¡è¿åŠ¨ç§»åŠ¨ä¸€ä¸ªçƒã€‚é€’å¢å…¶xåæ ‡å¹¶ä½¿ç”¨å®ƒæ¥ç”Ÿæˆyå€¼ã€‚ </p><p>    We can turn a flat 2D plane into hilly terrain by moving its vertices in the z-direction. Use the  x and  y coordinates to generate the  z location.</p><p>é€šè¿‡åœ¨zæ–¹å‘ä¸Šç§»åŠ¨å…¶é¡¶ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥å°†å¹³æ¿2Då¹³é¢å˜æˆä¸˜é™µåœ°å½¢ã€‚ä½¿ç”¨xå’Œyåæ ‡ç”Ÿæˆzä½ç½®ã€‚</p><p>     Youâ€™ve probably seen these  distorted spheres in the wild. They are created by displacing the vertices of a sphere. Use the vertex coordinate  (x, y, z) to generate the distortion amount. Then displace the vertex by it radially.</p><p>     ä½ å¯èƒ½å·²ç»çœ‹åˆ°è¿™äº›æ‰­æ›²çš„çƒä½“åœ¨é‡å¤–ã€‚å®ƒä»¬æ˜¯é€šè¿‡ç§»ä½çƒä½“çš„é¡¶ç‚¹è€Œåˆ›å»ºçš„ã€‚ä½¿ç”¨é¡¶ç‚¹åæ ‡ï¼ˆxï¼Œyï¼Œzï¼‰ç”Ÿæˆå¤±çœŸé‡ã€‚ç„¶åå¾„å‘ä½¿é¡¶ç‚¹å–ä»£é¡¶ç‚¹ã€‚</p><p> const distortion  = simplex . noise3D (x  * frequency , y  * frequency , z  * frequency )  * amplitude ;newPosition  = position . normalize ( ) . multiplyScalar (distortion ) ;</p><p> const distå˜å½¢= simplexã€‚ Coke3dï¼ˆx *é¢‘ç‡ï¼Œy *é¢‘ç‡ï¼Œz *é¢‘ç‡ï¼‰*å¹…åº¦; repposition =ä½ç½®ã€‚æ­£å¸¸åŒ–ï¼ˆï¼‰ã€‚å¤šé¢…è£‚ï¼ˆå˜å½¢ï¼‰;</p><p>   We can animate the distorted sphere by using 4D noise. The inputs will be the vertex coordinate  (x, y, z) and  time. This technique is used to create  fireballs, amongst other things.</p><p>   æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨4Då™ªå£°ä¸ºå¤±çœŸçš„çƒä½“è¿›è¡ŒåŠ¨ç”»ã€‚è¾“å…¥å°†æ˜¯é¡¶ç‚¹åæ ‡ï¼ˆxï¼Œyï¼Œzï¼‰å’Œæ—¶é—´ã€‚è¿™ç§æŠ€æœ¯ç”¨äºåœ¨å…¶ä»–æ–¹é¢åˆ›é€ ç«çƒã€‚</p><p> const distortion  = simplex . noise4D ( x  * frequency , y  * frequency , z  * frequency , time  * frequency  )  * amplitude ;newPosition  = position . normalize ( ) . multiplyScalar (distortion ) ;</p><p> const distå˜å½¢= simplexã€‚ Coke4dï¼ˆx *é¢‘ç‡ï¼Œy *é¢‘ç‡ï¼Œz *é¢‘ç‡ï¼Œæ—¶é—´*é¢‘ç‡ï¼‰*å¹…åº¦; repposition =ä½ç½®ã€‚æ­£å¸¸åŒ–ï¼ˆï¼‰ã€‚å¤šé¢…è£‚ï¼ˆå˜å½¢ï¼‰;</p><p>  Notice our use of amplitude in the above examples. Itâ€™s a handy way to scale the noise output to your application. You could also use  interpolation to map the noise output to a specified range of your choice.</p><p>  æ³¨æ„æˆ‘ä»¬åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ä½¿ç”¨å¹…åº¦ã€‚è¿™æ˜¯ä¸€ç§ä½¿å™ªå£°è¾“å‡ºæ‰©å±•åˆ°åº”ç”¨ç¨‹åºçš„æ–¹ä¾¿æ–¹å¼ã€‚æ‚¨è¿˜å¯ä»¥ä½¿ç”¨æ’å€¼æ¥å°†å™ªå£°è¾“å‡ºæ˜ å°„åˆ°æ‚¨é€‰æ‹©çš„æŒ‡å®šèŒƒå›´å†…ã€‚</p><p>  Now that we have the basics down letâ€™s look at a few more applications of noise.</p><p>  ç°åœ¨æˆ‘ä»¬æœ‰åŸºç¡€çŸ¥è¯†è®©æˆ‘ä»¬æ¥çœ‹çœ‹æ›´å¤šçš„å™ªéŸ³åº”ç”¨ã€‚ </p><p>     for  ( let y  =  0 ; y  &lt; gridSize [ 1 ] ; y ++ )  {  for  ( let x  =  0 ; x  &lt; gridSize [ 0 ] ; x ++ )  {  const n  = simplex . noise2D ( x  /  (gridSize [ 0 ]  *  0.75 ) , y  /  (gridSize [ 1 ]  *  0.75 )  ) ;  } }</p><p>forï¼ˆè®©y = 0; y <yï¼†lt; gridsize [1]; y ++ï¼‰{forï¼ˆè®¾å®šx = 0; xï¼†lt; gridsize [0]; x ++ï¼‰{const n = simplexã€‚å™ªS2Dï¼ˆx /ï¼ˆgridsize [0] * 0.75ï¼‰ï¼Œy /ï¼ˆgridsize [1] * 0.75ï¼‰ï¼‰; }}</p><p>  We can use the  Marching Squares algorithm to turn that 2D noise data into contours. Using Canavas, SVG, WebGL or whatever else you prefer. I recently used this technique with SVG to create generative profile cards. For a full tutorial on that, check out  creating a generative image service ğŸ“¸</p><p>  æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¸¸è¡Œæ–¹å—ç®—æ³•å°†2Då™ªå£°æ•°æ®è½¬æ¢ä¸ºè½®å»“ã€‚ä½¿ç”¨Canavasï¼ŒSVGï¼ŒWebGLæˆ–æ‚¨æ›´å–œæ¬¢çš„å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚æˆ‘æœ€è¿‘ä½¿ç”¨è¿™ç§æŠ€æœ¯ä½¿ç”¨SVGæ¥åˆ›å»ºç”Ÿæˆé…ç½®æ–‡ä»¶å¡ã€‚æœ‰å…³è¿™ä¸€æ•™ç¨‹çš„å®Œæ•´æ•™ç¨‹ï¼Œè¯·æŸ¥çœ‹åˆ›å»ºç”Ÿæˆå›¾åƒæœåŠ¡ğŸ“¸</p><p>  The cool thing about noise is that you can go up one dimension, layer in time and animate your image.</p><p>  å…³äºå™ªå£°çš„å¾ˆé…·çš„äº‹æƒ…æ˜¯æ‚¨å¯ä»¥åœ¨æ—¶é—´ä¸Šå‡èµ·ä¸€å±‚ï¼Œå¹¶ä¸ºå›¾åƒè®¾ç½®åŠ¨ç”»ã€‚</p><p>    Honestly, this 2D grid of noise data is super utilitarian. Itâ€™s my go-to for all kinds of stuff. One of which is noise fieldsâ€”a particular favourite of mine.</p><p>    è€å®è¯´ï¼Œè¿™æ¬¾å™ªå£°æ•°æ®çš„è¿™æ¬¾2Dç”µç½‘æ˜¯è¶…çº§åŠŸåˆ©ä¸»ä¹‰ã€‚è¿™æ˜¯æˆ‘å¯¹å„ç§ä¸œè¥¿çš„è½¬ç§»ã€‚å…¶ä¸­ä¸€ä¸ªæ˜¯å™ªéŸ³å­—æ®µ - æˆ‘çš„ç‰¹å®šæœ€çˆ±ã€‚</p><p> Letâ€™s go back to that initial grayscale output. Map that to a more interesting colour scale, and you get plasma ğŸ¤©</p><p> è®©æˆ‘ä»¬å›åˆ°åˆå§‹ç°åº¦è¾“å‡ºã€‚å°†å…¶æ˜ å°„åˆ°æ›´æœ‰è¶£çš„é¢œè‰²åˆ»åº¦ï¼Œè€Œä¸”ä½ å¾—åˆ°äº†ç­‰ç¦»å­ä½“â™¥</p><p>  Or, start with a grid of rectangles. Then turn it into a vector field by using noise to control the colour and angle of rotation.</p><p>  æˆ–è€…ï¼Œä»çŸ©å½¢çš„ç½‘æ ¼å¼€å§‹ã€‚ç„¶åä½¿ç”¨å™ªå£°å°†å…¶è½¬æ¢ä¸ºçŸ¢é‡å­—æ®µï¼Œä»¥æ§åˆ¶é¢œè‰²å’Œæ—‹è½¬è§’åº¦ã€‚</p><p>   Vector fields are cool, but  flow fields are an even more exciting visualization. Hereâ€™s a plot I made last year.</p><p>   çŸ¢é‡å­—æ®µå¾ˆé…·ï¼Œä½†æµåœºæ˜¯ä¸€ä¸ªæ›´ä»¤äººå…´å¥‹çš„å¯è§†åŒ–ã€‚è¿™æ˜¯æˆ‘å»å¹´åˆ¶ä½œçš„æƒ…èŠ‚ã€‚ </p><p>  Notice the path that the pen traces. Each one of those strokes is generated by dropping a particle onto the vector field. And then tracing its path. ğŸ’«</p><p>æ³¨æ„ç¬”è¿¹çº¿çš„è·¯å¾„ã€‚é€šè¿‡å°†ç²’å­ä¸¢å¼ƒåˆ°çŸ¢é‡åœºä¸Šæ¥äº§ç”Ÿè¿™äº›ç¬”åˆ’ä¸­çš„æ¯ä¸€ä¸ªã€‚ç„¶åè·Ÿè¸ªå®ƒçš„è·¯å¾„ã€‚ ğŸ’«</p><p>   Step 1, create a vector field. Same as before. But this time, weâ€™re  not going to animate the vector field.</p><p>   æ­¥éª¤1ï¼Œåˆ›å»ºçŸ¢é‡å­—æ®µã€‚å’Œä¹‹å‰ä¸€æ ·ã€‚ä½†è¿™ä¸€æ¬¡ï¼Œæˆ‘ä»¬ä¸ä¼šåŠ¨ç”»çŸ¢é‡å­—æ®µã€‚</p><p> Step 2, drop a bunch of particles onto the canvas. Their direction of movement is based on the underlying vector field. Take a step forward, get the new direction and repeat.</p><p> æ­¥éª¤2ï¼Œå°†ä¸€å †é¢—ç²’æ»´åœ¨å¸†å¸ƒä¸Šã€‚ä»–ä»¬çš„è¿åŠ¨æ–¹å‘æ˜¯åŸºäºåº•å±‚çš„çŸ¢é‡é¢†åŸŸã€‚å‰è¿›ï¼Œè·å¾—æ–°çš„æ–¹å‘å¹¶é‡å¤ã€‚</p><p>  function  moveParticle ( particle )  {  // Calculate direction from noise  const angle  = simplex . noise2D (particle .x  *  FREQUENCY , particle .y  *  FREQUENCY )  *  AMPLITUDE ;  // Update the velocity of the particle  // based on the direction particle .vx  += Math . cos (angle )  *  STEP ; particle .vy  += Math . sin (angle )  *  STEP ;  // Move the particle particle .x  += particle .vx ; particle .y  += particle .vy ;  // Use damping to slow down the particle (think friction) particle .vx  *=  DAMPING ; particle .vy  *=  DAMPING ; particle .line . push ( [particle .x , particle .y ] ) ; }</p><p>  åŠŸèƒ½moveparticleï¼ˆç²’å­ï¼‰{//ä»å™ªå£°constè§’åº¦= simplexè®¡ç®—æ–¹å‘ã€‚å™ªå£°2Dï¼ˆç²’å­.x *é¢‘ç‡ï¼Œç²’å­.Y *é¢‘ç‡ï¼‰*å¹…åº¦; //åŸºäºæ–¹å‘ç²’å­.vx + =æ•°å­¦æ›´æ–°ç²’å­//çš„é€Ÿåº¦ã€‚ cosï¼ˆè§’ï¼‰*æ­¥;ç²’å­.vy + =æ•°å­¦ã€‚ç½ªï¼ˆè§’åº¦ï¼‰*æ­¥; //ç§»åŠ¨ç²’å­ç²’å­.x + =ç²’å­.vx;ç²’å­.Y + =ç²’å­.vy; //ä½¿ç”¨é˜»å°¼å‡æ…¢ç²’å­ï¼ˆæ€ç»´æ‘©æ“¦ï¼‰ç²’å­.vx * =é˜»å°¼;ç²’å­.vy * =é˜»å°¼;é¢—ç²’.lineã€‚æ¨ï¼ˆ[ç²’å­.xï¼Œç²’å­.y]ï¼‰; }</p><p>      Speaking of particles, noise shows up in particle systems too. For effects like rain, snow or confetti, youâ€™re looking to simulate a natural-looking motion. Imagine a confetti particle floating down to earth. The particles donâ€™t move in straight lines. They float and wiggle due to air resistance. Noise is a really great tool for adding in that organic variability.</p><p>      è°ˆåˆ°é¢—ç²’ï¼Œå™ªéŸ³ä¹Ÿæ˜¾ç¤ºåœ¨ç²’å­ç³»ç»Ÿä¸­ã€‚å¯¹äºåƒé›¨ï¼Œé›ªæˆ–äº”å½©çº¸å±‘è¿™æ ·çš„æ•ˆæœï¼Œæ‚¨æ­£åœ¨å¯»æ±‚æ¨¡æ‹Ÿè‡ªç„¶è¿åŠ¨ã€‚æƒ³è±¡ä¸€ä¸‹æ¼‚æµ®åœ¨åœ°çƒä¸Šçš„äº”å½©çº¸å±‘é¢—ç²’ã€‚é¢—ç²’ä¸ä¼šç›´çº¿ç§»åŠ¨ã€‚å®ƒä»¬ç”±äºç©ºæ°”é˜»åŠ›è€Œæµ®åŠ¨å’Œè •åŠ¨ã€‚å™ªéŸ³æ˜¯æ·»åŠ è¯¥æœ‰æœºå˜å¼‚æ€§çš„ä¸€ä¸ªéå¸¸å¥½çš„å·¥å…·ã€‚</p><p> const wiggle  =  { x : simplex . noise2D (particle .x  * frequency , time )  * amplitude , y : simplex . noise2D (particle .y  * frequency , time )  * amplitude , } ;particle .x  += wiggle .x ;particle .y  += wiggle .y ;</p><p> const wiggle = {xï¼šsimplexã€‚ Coke2Dï¼ˆç²’å­.x *é¢‘ç‡ï¼Œæ—¶é—´ï¼‰*å¹…åº¦ï¼ŒYï¼šå•é¢ã€‚ Coke2Dï¼ˆç²’å­.Y *é¢‘ç‡ï¼Œæ—¶é—´ï¼‰*å¹…åº¦ï¼Œ};ç²’å­.x + =è •è™«.x;ç²’å­.Y + =è •è™«.Y;</p><p>    Letâ€™s circle all the way back to those animated blobs. Manipulating and animating 3D geometries is a lot more efficient with shaders. But shaders are a whole different world unto themselves. For starters, there is a special WebGL version of noise,  glsl-noise. Weâ€™ll need to import that into our shader using  glslify.</p><p>    è®©æˆ‘ä»¬ä¸€ç›´åœˆå›é‚£äº›åŠ¨ç”»çš„æ–‘ç‚¹ã€‚æ“çºµå’ŒåŠ¨ç”»3Då‡ ä½•å½¢çŠ¶ä¸ç€è‰²å™¨æ›´æœ‰æ•ˆã€‚ä½†ç€è‰²å™¨æ˜¯ä¸€ä¸ªå®Œæ•´çš„ä¸–ç•Œã€‚å¯¹äºåˆå­¦è€…ï¼Œæœ‰ä¸€ä¸ªç‰¹æ®Šçš„WebGLç‰ˆæœ¬çš„å™ªå£°ï¼ŒGLSLå™ªå£°ã€‚æˆ‘ä»¬éœ€è¦ä½¿ç”¨glslifyå°†å…¶å¯¼å…¥åˆ°æˆ‘ä»¬çš„ç€è‰²å™¨ä¸­ã€‚ </p><p>   The animation above is quite similar to the contours we looked at earlier. Itâ€™s implemented as a fragment shader. Which means we run the same program for each pixel of the canvas.</p><p>ä¸Šé¢çš„åŠ¨ç”»ä¸æˆ‘ä»¬æ—©å…ˆçœ‹çš„è½®å»“éå¸¸ç›¸ä¼¼ã€‚å®ƒå®ç°ä¸ºç‰‡æ®µç€è‰²å™¨ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬ä¸ºç”»å¸ƒçš„æ¯ä¸ªåƒç´ è¿è¡Œç›¸åŒçš„ç¨‹åºã€‚</p><p> Notice the  pragma line? Thatâ€™s us importing webgl-noise. Then use it to generate noise data for each pixel position  vUv.</p><p> æ³¨æ„Pragmaç³»åˆ—ï¼Ÿè¿™æ˜¯æˆ‘ä»¬å¯¼å…¥WebGLå™ªå£°ã€‚ç„¶åä½¿ç”¨å®ƒæ¥ä¸ºæ¯ä¸ªåƒç´ ä½ç½®Vuvç”Ÿæˆå™ªå£°æ•°æ®ã€‚</p><p>   precision  highp  float ; uniform  float time ; uniform  float density ; varying  vec2 vUv ;  # define     3.141592653589793  # pragma  glslify : noise  =  require (glsl -noise /simplex / 3d ) ; float  patternZebra ( float v ) {  float d  =  1.0  / density ;  float s  =  - cos (v  / d  * PI  *  2. ) ;  return  smoothstep ( .0 ,  .1  * d ,  .1  * s  /  fwidth (s ) ) ; } void  main ( )  {   // Generate noise data   float amplitude  =  1.0 ;   float frequency  =  1.5 ;   float noiseValue  =  noise ( vec3 (vUv  * frequency , time ) )  * amplitude ;  // Convert noise data to rings  float t  =  patternZebra (noiseValue ) ;  vec3 color  =  mix ( vec3 ( 1. , 0.4 , 0.369 ) ,  vec3 ( 0.824 , 0.318 , 0.369 ) , t ) ;  // Clip the rings to a circle  float dist  =  length (vUv  -  vec2 ( 0.5 ,  0.5 ) ) ;  float alpha  =  smoothstep ( 0.250 ,  0.2482 , dist ) ; gl_FragColor  =  vec4 (color , alpha ) ; }</p><p>   ç²¾å¯†é«˜æ•ˆæµ®å­;æ¼‚æµ®æ—¶é—´å‡åŒ€;å‡åŒ€çš„æµ®å­å¯†åº¦;æ”¹å˜Vec2 VUV; ï¼ƒå®šä¹‰3.141592653589793 #pragma glslifyï¼šå™ªå£°=éœ€è¦ï¼ˆglsl -noise / simplex / 3dï¼‰;æµ®åŠ¨å›¾æ¡ˆåŒ–ï¼ˆFloat Vï¼‰{float d = 1.0 /å¯†åº¦; float s =  -  cosï¼ˆv / d * pi * 2.ï¼‰;è¿”å›SmotsceStepï¼ˆ.0ï¼Œ.1 * Dï¼Œ.1 * S / FWIDTHï¼ˆSï¼‰ï¼‰; void mainï¼ˆï¼‰{//ç”Ÿæˆå™ªå£°æ•°æ®æµ®åŠ¨å¹…åº¦= 1.0;æµ®åŠ¨é¢‘ç‡= 1.5; Float Noisevalue =å™ªå£°ï¼ˆVEC3ï¼ˆVUV *é¢‘ç‡ï¼Œæ—¶é—´ï¼‰ï¼‰*å¹…åº¦; //å°†å™ªå£°æ•°æ®è½¬æ¢ä¸ºç¯Float T = Patternzebraï¼ˆNoisevalueï¼‰; vec3é¢œè‰²=æ··åˆï¼ˆvec3ï¼ˆ1.ï¼Œ0.4,0.369ï¼‰ï¼Œvec3ï¼ˆ0.824,0.318,0.369ï¼‰ï¼Œtï¼‰; //å°†ç¯å¤¹åˆ°åœ†æµ®å­Dist =é•¿åº¦ï¼ˆVuv  -  Vec2ï¼ˆ0.5,0.5ï¼‰ï¼‰; Float Alpha = SmootchStepï¼ˆ0.250,0.2482ï¼ŒDistï¼‰; gl_fragcolor = vec4ï¼ˆé¢œè‰²ï¼Œalphaï¼‰; }</p><p> Fragment shaders have this concept of  distance functions used for drawing shapes.  patternZebra is one such example that converts noise data into rings. Essentially it returns either  0 or  1. Which we then use to pick a colour using  mix. And finally, use another distance function to clip a circular boundary.</p><p> ç‰‡æ®µç€è‰²å™¨å…·æœ‰ç”¨äºç»˜åˆ¶å½¢çŠ¶çš„è·ç¦»å‡½æ•°çš„è¿™ç§æ¦‚å¿µã€‚å›¾æ¡ˆåŒ–BRAæ˜¯å°†å™ªå£°æ•°æ®è½¬æ¢ä¸ºç¯çš„è¿™æ ·çš„ç¤ºä¾‹ã€‚åŸºæœ¬ä¸Šå®ƒè¿”å›0æˆ–1.ç„¶åæˆ‘ä»¬ç”¨æ¥ä½¿ç”¨æ··åˆæ¥é€‰æ‹©é¢œè‰²ã€‚æœ€åï¼Œä½¿ç”¨å¦ä¸€ä¸ªè·ç¦»åŠŸèƒ½æ¥å‰ªè¾‘åœ†å½¢è¾¹ç•Œã€‚</p><p>  Well, the amazing thing about shaders is that you can turn them into a material and apply it to more complex geometry.</p><p>  å—¯ï¼Œå…³äºç€è‰²å™¨çš„æƒŠäººçš„äº‹æƒ…æ˜¯æ‚¨å¯ä»¥å°†å®ƒä»¬è½¬æ¢ä¸ºææ–™å¹¶å°†å…¶åº”ç”¨äºæ›´å¤æ‚çš„å‡ ä½•å½¢çŠ¶ã€‚</p><p>  We can take the same 2D mars shader from above. Convert it into a ThreeJS  shader material. Then use the vertex position  vPosition to generate noise instead of  vUv.</p><p>  æˆ‘ä»¬å¯ä»¥ä»ä¸Šé¢é‡‡å–ç›¸åŒçš„2Dç«æ˜Ÿç€è‰²å™¨ã€‚å°†å…¶è½¬æ¢ä¸ºThreeJSç€è‰²å™¨ææ–™ã€‚ç„¶åä½¿ç”¨é¡¶ç‚¹ä½ç½®VPORIONæ¥ç”Ÿæˆå™ªå£°è€Œä¸æ˜¯VUVã€‚</p><p>  const material  =  new   ( { extensions :  { derivatives :  true ,  } , uniforms :  { time :  { value :  0  } , density :  { value :  1.0  } ,  } , vertexShader :  /*glsl*/   `  varying vec3 vPosition; void main () { vPosition = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }  ` , fragmentShader :  glslify ( /* glsl */   `  precision highp float; varying vec3 vPosition; uniform float time; uniform float density; #pragma glslify: noise = require(glsl-noise/simplex/4d); #define PI 3.141592653589793 float patternZebra(float v){ float d = 1.0 / density; float s = -cos(v / d * PI * 2.); return smoothstep(.0, .1 * d, .1 * s / fwidth(s)); } void main () { float frequency = .6; float amplitude = 1.5; float v = noise(vec4(vPosition * frequency, sin(PI * time))) * amplitude; float t = patternZebra(v); vec3 fragColor = mix(vec3(1.,0.4,0.369), vec3(0.824,0.318,0.369), t); gl_FragColor = vec4(fragColor, 1.); }  ` ) , } ) ;</p><p>  const material = newï¼ˆ{æ‰©å±•ï¼š{arivationï¼štrueï¼Œ}ï¼Œç»Ÿä¸€ï¼š{timeï¼š{valueï¼š0}ï¼Œå¯†åº¦ï¼š{valueï¼š1.0}ï¼Œvertexshaderï¼š/ * glsl * /`ä¸åŒçš„vec3 vposition; void main ï¼ˆï¼‰{vposition = position; gl_position = proigntmatrix * modelviewmatrix * vec4ï¼ˆä½ç½®ï¼Œ1.0ï¼‰;}`ï¼Œfragmentshaderï¼šglslifyï¼ˆ/ * glsl * /`precision highp float;æ”¹å˜vec3 vposition;å‡åŒ€çš„æµ®åŠ¨æ—¶é—´;ï¼ƒ pragma glslifyï¼šå™ªå£°=éœ€è¦ï¼ˆglsl-noise / simplex / 4dï¼‰; #define pi 3.141592653589793æµ®åŠ¨å›¾æ¡ˆåŒ–ï¼ˆfloat vï¼‰{float d = 1.0 /å¯†åº¦; float s = -cosï¼ˆv / d * pi * 2.ï¼‰;è¿”å›SmoothStepï¼ˆ.0ï¼Œ.1 * Dï¼Œ.1 * S / FWIDTHï¼ˆSï¼‰ï¼‰; void mainï¼ˆï¼‰{æµ®åŠ¨é¢‘ç‡= .6;æµ®åŠ¨å¹…åº¦= 1.5; float v =å™ªå£°ï¼ˆvec4ï¼ˆvposition *é¢‘ç‡ï¼Œ SINï¼ˆPI *æ—¶é—´ï¼‰ï¼‰ï¼‰*å¹…åº¦; float t = patternzebraï¼ˆvï¼‰; vec3 fragcolor = mixï¼ˆvec3ï¼ˆ1.ï¼Œ0.4,0.369ï¼‰ï¼Œvec3ï¼ˆ0.824,0.318,0.369ï¼‰ï¼Œtï¼‰; gl_fragcolor = vec4ï¼ˆ Fragcolorï¼Œ1.ï¼‰;}`ï¼‰ï¼Œ}ï¼‰; </p><p>  This is honestly just a start. Shaders open up so many possibilities. Like the example below ğŸ‘»</p><p>è¿™æ˜¯è¯šå®çš„åªæ˜¯ä¸€ä¸ªå¼€å§‹ã€‚ç€è‰²å™¨æ‰“å¼€äº†è®¸å¤šå¯èƒ½æ€§ã€‚å°±åƒä¸‹é¢çš„ä¾‹å­ä¸€æ ·</p><p>    The idea behind vertex displacement is quite similar. Instead of a fragment shader, we write a vertex shader that transforms each vertex of the sphere. Again, applied using a  shader material.</p><p>    é¡¶ç‚¹ä½ç§»èƒŒåçš„æƒ³æ³•éå¸¸ç›¸ä¼¼ã€‚è€Œä¸æ˜¯ç‰‡æ®µç€è‰²å™¨ï¼Œæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªè½¬æ¢çƒä½“çš„æ¯ä¸ªé¡¶ç‚¹çš„é¡¶ç‚¹ç€è‰²å™¨ã€‚å†æ¬¡ä½¿ç”¨ç€è‰²å™¨ææ–™æ–½åŠ ã€‚</p><p>  precision  highp  float ; varying  vec3 vNormal ;  # pragma  glslify : snoise4  =  require (glsl -noise /simplex / 4d ) uniform  float u_time ; uniform  float u_amplitude ; uniform  float u_frequency ; void  main  ( )  {  vNormal  = normalMatrix  *  normalize (normal ) ;    float distortion  =  snoise4 ( vec4 (normal  * u_frequency , u_time ) )  * u_amplitude ;   vec3 newPosition  = position  +  (normal  * distortion ) ; gl_Position  = projectionMatrix  * modelViewMatrix  *  vec4 (newPosition ,  1.0 ) ; }</p><p>  ç²¾å¯†é«˜æ•ˆæµ®å­;ä¸åŒçš„vec3 vnormal; ï¼ƒpragma glslifyï¼šsnoise4 =è¦æ±‚ï¼ˆglsl -noise / simplex / 4dï¼‰å‡åŒ€æµ®åŠ¨u_time;å‡åŒ€æµ®åŠ¨u_amplitude;å‡åŒ€æµ®åŠ¨U_FREQUENCY; void mainï¼ˆï¼‰{vnormal = normalmatrix *æ­£å¸¸åŒ–ï¼ˆæ­£å¸¸ï¼‰; float distå˜å½¢= snoise4ï¼ˆvec4ï¼ˆæ­£å¸¸* u_frequencyï¼Œu_timeï¼‰ï¼‰* u_amplitude; vec3 newposition =ä½ç½®+ï¼ˆæ­£å¸¸*å¤±çœŸï¼‰; gl_position = proigntmatrix * modelviewmatrix * vec4ï¼ˆnewPositionï¼Œ1.0ï¼‰; }</p><p> Oh, and throw on some  matcap, and youâ€™ve got some glossy animated blobs.</p><p> å“¦ï¼Œæ‰”ä¸€äº›matcapï¼Œä½ æœ‰ä¸€äº›å…‰æ³½çš„åŠ¨ç”»æ–‘ç‚¹ã€‚</p><p>   That was quite a journey. Motion, textures, fields, particle systems and displacementâ€”noise can do it all. It truly is the workhorse of the creative coding world.</p><p>   è¿™æ˜¯ä¸€ä¸ªå¾ˆå¤šæ—…ç¨‹ã€‚è¿åŠ¨ï¼Œçº¹ç†ï¼Œå­—æ®µï¼Œç²’å­ç³»ç»Ÿå’Œä½ç§»å™ªå£°å¯ä»¥å…¨éƒ¨å®Œæˆã€‚å®ƒçœŸçš„æ˜¯åˆ›æ„ç¼–ç ä¸–ç•Œçš„ä¸»æ•™ã€‚</p><p>  Iâ€™ve put together a little starter CodePen for you. It spins up a grid of noise and maps it to an array of glyphs. Just start by modifying the array and see how far you can take it.</p><p>  æˆ‘æŠŠä¸€ä»½å°å‹å…¥é—¨ä»£ç æ”¾åœ¨ä¸€èµ·ã€‚å®ƒæ—‹è½¬å™ªéŸ³ç½‘æ ¼ï¼Œå¹¶å°†å…¶æ˜ å°„åˆ°ä¸€ç³»åˆ—å­—å½¢ã€‚åˆšåˆšé¦–å…ˆä¿®æ”¹æ•°ç»„å¹¶æŸ¥çœ‹æ‚¨å¯ä»¥æ¥å—çš„ç¨‹åº¦ã€‚</p><p> const glyphs  =  [ &#39;Â¤&#39; ,  &#39;âœ³&#39; ,  &#39;â—&#39; ,  &#39;â—”&#39; ,  &#39;â—‹&#39; ,  &#39;â—•&#39; ,  &#39;â—&#39; ,  &#39;â—‘&#39; ,  &#39;â—’&#39; ] ;</p><p> const glyphs = [ï¼†ï¼ƒ39;Â¤ï¼†ï¼ƒ39; ï¼Œï¼†ï¼ƒ39;âœ³ï¼†ï¼ƒ39; ï¼Œï¼†ï¼ƒ39;â—ï¼†ï¼ƒ39; ï¼Œï¼†ï¼ƒ39;â—”ï¼†ï¼ƒ39; ï¼Œï¼†ï¼ƒ39;â—‹ï¼†ï¼ƒ39; ï¼Œï¼†ï¼ƒ39;â—•ï¼†ï¼ƒ39; ï¼Œï¼†ï¼ƒ39;â—ï¼†ï¼ƒ39; ï¼Œï¼†ï¼ƒ39;â—‘ï¼†ï¼ƒ39; ï¼Œï¼†ï¼ƒ39;â—’ï¼†ï¼ƒ39; ]; </p><p> Or if youâ€™re looking for something more advanced, check out  noisedeck.app. Itâ€™s like a synthesizer but for visuals.</p><p>æˆ–è€…å¦‚æœæ‚¨æ­£åœ¨å¯»æ‰¾æ›´é«˜çº§çš„ä¸œè¥¿ï¼Œè¯·æŸ¥çœ‹Noisedeck.appã€‚ å®ƒå°±åƒä¸€ä¸ªåˆæˆå™¨ï¼Œä½†é€‚åˆè§†è§‰æ•ˆæœã€‚ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://varun.ca/noise/">https://varun.ca/noise/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/åˆ›é€ æ€§/">#åˆ›é€ æ€§</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/creative/">#creative</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/å™ªå£°/">#å™ªå£°</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>