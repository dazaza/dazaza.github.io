<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ç½‘ç»œæµè§ˆå™¨ä¸­IPFSè¿æ¥æŒ‡å—A guide to IPFS connectivity in web browsers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A guide to IPFS connectivity in web browsers<br/>ç½‘ç»œæµè§ˆå™¨ä¸­IPFSè¿æ¥æŒ‡å—</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 19:02:02</div><div class="page_narrow text-break page_content"><p>We see a lot of questions about how to get started with using  js-ipfs in the browser. This post demonstrates a minimal chat example in  js-ipfs entirely in the browser. It uses WebRTC to achieve browser-to-browser connectivity where possible, and a circuit relay to connect browser nodes where not. Message passing is done with libp2p&#39;s pubsub.</p><p>æˆ‘ä»¬çœ‹åˆ°äº†å¾ˆå¤šå…³äºå¦‚ä½•å¼€å§‹åœ¨æµè§ˆå™¨ä¸­ä½¿ç”¨js ipfsçš„é—®é¢˜ã€‚æœ¬æ–‡æ¼”ç¤ºäº†ä¸€ä¸ªå®Œå…¨åœ¨æµè§ˆå™¨ä¸­ä½¿ç”¨js ipfsçš„èŠå¤©ç¤ºä¾‹ã€‚å®ƒä½¿ç”¨WebRTCåœ¨å¯èƒ½çš„æƒ…å†µä¸‹å®ç°æµè§ˆå™¨åˆ°æµè§ˆå™¨çš„è¿æ¥ï¼Œå¹¶ä½¿ç”¨ç”µè·¯ä¸­ç»§åœ¨ä¸å¯èƒ½çš„æƒ…å†µä¸‹è¿æ¥æµè§ˆå™¨èŠ‚ç‚¹ã€‚æ¶ˆæ¯ä¼ é€’æ˜¯é€šè¿‡libp2på’Œ#39å®Œæˆçš„ï¼›é…’å§ã€‚</p><p>    You can see the live demo  here       (opens new window). If you&#39;d like a local copy you can edit yourself, you can download the whole directory using IPFS:</p><p>ä½ å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°å®æ—¶æ¼”ç¤ºï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ã€‚å¦‚æœä½ &#39ï¼›æˆ‘æƒ³è¦ä¸€ä»½æœ¬åœ°å‰¯æœ¬ï¼Œä½ å¯ä»¥è‡ªå·±ç¼–è¾‘ï¼Œä½ å¯ä»¥ä½¿ç”¨IPFSä¸‹è½½æ•´ä¸ªç›®å½•ï¼š</p><p>   Then simply open  index.html in your web browser and you&#39;ll immediately begin automatically connecting to nodes and looking for peers!</p><p>ç„¶åç®€å•åœ°æ‰“å¼€ç´¢å¼•ã€‚ç½‘é¡µæµè§ˆå™¨ä¸­çš„htmlå’Œä½ &#39ï¼›æˆ‘ä»¬å°†ç«‹å³å¼€å§‹è‡ªåŠ¨è¿æ¥åˆ°èŠ‚ç‚¹å¹¶å¯»æ‰¾å¯¹ç­‰èŠ‚ç‚¹ï¼</p><p>  You can also fork  TheDiscordian/browser-ipfs-chat       (opens new window) on GitHub, and it&#39;ll be ready to test right away! If you want to deploy your own version, simply edit  index.html and follow the setup information below.</p><p>ä½ ä¹Ÿå¯ä»¥åœ¨GitHubä¸Šæ‰“å¼€Discordian/browser ipfsèŠå¤©ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ï¼Œå®ƒ&#39ï¼›Iâ€™æˆ‘é©¬ä¸Šå°±å‡†å¤‡å¥½æµ‹è¯•ï¼å¦‚æœæ‚¨æƒ³éƒ¨ç½²è‡ªå·±çš„ç‰ˆæœ¬ï¼Œåªéœ€ç¼–è¾‘ç´¢å¼•å³å¯ã€‚å¹¶æŒ‰ç…§ä¸‹é¢çš„è®¾ç½®ä¿¡æ¯è¿›è¡Œæ“ä½œã€‚</p><p>  The libraries used in this example are   js-ipfs       (opens new window) and Bootstrap (just their minified CSS). If you want a newer version of  js-ipfs, feel free to download  this one here       (opens new window) to use the latest version available ğŸ˜ƒ.</p><p>æœ¬ä¾‹ä¸­ä½¿ç”¨çš„åº“æ˜¯js ipfsï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰å’ŒBootstrapï¼ˆåªæ˜¯å®ƒä»¬çš„ç¼©å°CSSï¼‰ã€‚å¦‚æœä½ æƒ³è¦æ›´æ–°ç‰ˆæœ¬çš„js ipfsï¼Œå¯ä»¥åœ¨è¿™é‡Œä¸‹è½½ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ä»¥ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬ğŸ˜ƒ.</p><p>          In a browser, discovering and connecting to peers can be very hard, as we can&#39;t listen for new peers and we don&#39;t have access to the DHT. In order to have the best experience working in a browser, it&#39;s important to understand how to both find peers and stay connected with them.</p><p>åœ¨æµè§ˆå™¨ä¸­ï¼Œå‘ç°å’Œè¿æ¥åŒé¾„äººå¯èƒ½éå¸¸å›°éš¾ï¼Œå°±åƒæˆ‘ä»¬ä¸€æ ·&#39ï¼›ä¸è¦å€¾å¬æ–°åŒäº‹çš„å£°éŸ³ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼š&#39ï¼›æˆ‘æ— æ³•ä½¿ç”¨DHTã€‚ä¸ºäº†è·å¾—åœ¨æµè§ˆå™¨ä¸­å·¥ä½œçš„æœ€ä½³ä½“éªŒï¼Œå®ƒ&#39ï¼›äº†è§£å¦‚ä½•æ‰¾åˆ°åŒé¾„äººå¹¶ä¸ä»–ä»¬ä¿æŒè”ç³»å¾ˆé‡è¦ã€‚</p><p>  The chat example achieves this in two ways. Using WebRTC-Star, we achieve direct browser-to-browser communication, and with a circuit relay, we have a relay in the middle. The chat application also has a status indicator in the top left to let you know what kind of connection you have. Green means you&#39;re connected to the relay, even if it&#39;s via another peer; yellow means you&#39;re only seeing direct peers; and red means you have no peers (at least none using the chat application).</p><p>èŠå¤©ç¤ºä¾‹é€šè¿‡ä¸¤ç§æ–¹å¼å®ç°è¿™ä¸€ç‚¹ã€‚ä½¿ç”¨WebRTCæ˜Ÿï¼Œå®ç°äº†æµè§ˆå™¨ä¸æµè§ˆå™¨çš„ç›´æ¥é€šä¿¡ï¼Œå¹¶é€šè¿‡ç”µè·¯ç»§ç”µå™¨ï¼Œåœ¨ä¸­é—´æœ‰ä¸€ä¸ªç»§ç”µå™¨ã€‚èŠå¤©åº”ç”¨ç¨‹åºåœ¨å·¦ä¸Šè§’è¿˜æœ‰ä¸€ä¸ªçŠ¶æ€æŒ‡ç¤ºå™¨ï¼Œå¯ä»¥è®©ä½ çŸ¥é“ä½ çš„è¿æ¥ç±»å‹ã€‚ç»¿è‰²æ„å‘³ç€ä½ &#39ï¼›é‡æ–°è¿æ¥åˆ°ç»§ç”µå™¨ï¼Œå³ä½¿å®ƒ&#39ï¼›é€šè¿‡å¦ä¸€ä¸ªåŒé¾„äººï¼›é»„è‰²è¡¨ç¤ºä½ &#39ï¼›æˆ‘ä»¬åªçœ‹åˆ°ç›´æ¥çš„åŒé¾„äººï¼›çº¢è‰²è¡¨ç¤ºä½ æ²¡æœ‰åŒä¼´ï¼ˆè‡³å°‘æ²¡æœ‰ä½¿ç”¨èŠå¤©åº”ç”¨ç¨‹åºçš„åŒä¼´ï¼‰ã€‚</p><p>    ğŸŒŸ The diagram above demonstrates what a three-user network can look like. It&#39;s worth noting that the browser nodes can communicate with  go-ipfs as well, so BrowserC doesn&#39;t have to be a browser at all, but instead could be a  go-ipfs node!</p><p>ğŸŒŸ ä¸Šå›¾å±•ç¤ºäº†ä¸‰ç”¨æˆ·ç½‘ç»œçš„æ ·å­ã€‚å®ƒ&#39ï¼›å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæµè§ˆå™¨èŠ‚ç‚¹ä¹Ÿå¯ä»¥ä¸go IPFé€šä¿¡ï¼Œå› æ­¤BrowserCä¸&#39ï¼›ä¸å¿…æ˜¯æµè§ˆå™¨ï¼Œä½†å¯ä»¥æ˜¯go ipfsèŠ‚ç‚¹ï¼</p><p>      After this section we&#39;ll go over what WebRTC-Star and circuit relay do, and how to set them up. However, if you&#39;d like to quickly roll your own kit using Docker, I&#39;ve prepared an image you can use. It might not be the best long-term solution, but it should be great if you want to quickly get rolling and experiment.</p><p>åœ¨æœ¬èŠ‚ä¹‹åï¼Œæˆ‘ä»¬&#39ï¼›æˆ‘å°†ä»‹ç»WebRTC Starå’Œç”µè·¯ç»§ç”µå™¨çš„åŠŸèƒ½ï¼Œä»¥åŠå¦‚ä½•è®¾ç½®å®ƒä»¬ã€‚ç„¶è€Œï¼Œå¦‚æœä½ &#39ï¼›æˆ‘æƒ³ç”¨Dockerï¼ŒI&#39ï¼›æˆ‘å‡†å¤‡äº†ä¸€å¼ ä½ å¯ä»¥ä½¿ç”¨çš„å›¾ç‰‡ã€‚è¿™å¯èƒ½ä¸æ˜¯æœ€å¥½çš„é•¿æœŸè§£å†³æ–¹æ¡ˆï¼Œä½†å¦‚æœä½ æƒ³å¿«é€Ÿå¼€å§‹å¹¶è¿›è¡Œå®éªŒï¼Œè¿™åº”è¯¥æ˜¯å¾ˆå¥½çš„ã€‚</p><p>         You need a domain and SSL to use this kit with browser nodes. There are two options below: One will run certbot and automatically grab a certificate for the provided domain name. The other option won&#39;t handle SSL for you, and instead you&#39;ll have to reverse proxy port 9091 to 9090 (SSL), and port 4011 to 4430 (SSL).</p><p>æ‚¨éœ€è¦ä¸€ä¸ªåŸŸå’ŒSSLæ‰èƒ½å°†æ­¤å·¥å…·åŒ…ä¸æµè§ˆå™¨èŠ‚ç‚¹ä¸€èµ·ä½¿ç”¨ã€‚ä¸‹é¢æœ‰ä¸¤ä¸ªé€‰é¡¹ï¼šä¸€ä¸ªå°†è¿è¡Œcertbotå¹¶è‡ªåŠ¨è·å–æ‰€æä¾›åŸŸåçš„è¯ä¹¦ã€‚å¦ä¸€ä¸ªé€‰é¡¹èµ¢äº†&#39ï¼›æˆ‘ä¸èƒ½ä¸ºä½ å¤„ç†SSLï¼Œç›¸åï¼Œä½ &#39ï¼›æˆ‘ä»¬å¿…é¡»å°†ä»£ç†ç«¯å£9091åè½¬ä¸º9090ï¼ˆSSLï¼‰ï¼Œå°†ç«¯å£4011åè½¬ä¸º4430ï¼ˆSSLï¼‰ã€‚</p><p>  When you execute either commands, your IPFS node will also be set up for the first time giving you information such as its  PeerID and circuit relay addresses. Take note of these â€” you&#39;ll want to edit them into the chat client so you can use your own node (see  WebRTC-Star Usage and  p2p-circuit Usage for usage examples, or edit  index.html and change my node&#39;s multiaddresses out for your own).</p><p>å½“æ‚¨æ‰§è¡Œä»»ä¸€å‘½ä»¤æ—¶ï¼Œæ‚¨çš„IPFSèŠ‚ç‚¹ä¹Ÿå°†ç¬¬ä¸€æ¬¡è¢«è®¾ç½®ï¼Œä¸ºæ‚¨æä¾›å…¶å¯¹ç­‰åœ°å€å’Œç”µè·¯ä¸­ç»§åœ°å€ç­‰ä¿¡æ¯ã€‚æ³¨æ„è¿™äº›â€”â€”ä½ &#39ï¼›Iâ€™æˆ‘æƒ³å°†å®ƒä»¬ç¼–è¾‘åˆ°èŠå¤©å®¢æˆ·ç«¯ï¼Œè¿™æ ·ä½ å°±å¯ä»¥ä½¿ç”¨è‡ªå·±çš„èŠ‚ç‚¹ï¼ˆå‚è§WebRTC Star Usageå’Œp2p circuit Usageäº†è§£ç”¨æ³•ç¤ºä¾‹ï¼Œæˆ–è€…ç¼–è¾‘index.htmlå¹¶å°†my node&#39ï¼›s multiaddressesæ›´æ”¹ä¸ºä½ è‡ªå·±çš„ï¼‰ã€‚</p><p>    Ensure port 80 isn&#39;t being used, follow the checklist below, and then run the following command:</p><p>ç¡®ä¿ç«¯å£80ä¸º&#39ï¼›å¦‚æœæ­£åœ¨ä½¿ç”¨ï¼Œè¯·éµå¾ªä¸‹é¢çš„æ£€æŸ¥è¡¨ï¼Œç„¶åè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š</p><p>  docker run --mount  source =ipfs_bundle,destination =/root -p  9091:9091 -p  4011:4011 -p  9090:9090 -p  4430:4430 -p  80:80 -it trdiscordian/ipfsbundle certbot DOMAIN.COM</p><p>docker runâ€”â€”mount source=ipfs_bundleï¼Œdestination=/root-p9091:9091-p4011:4011-p9090:9090-p4430:4430-p80:80-it trdiscordian/ipfsbundle certbotåŸŸã€‚ç»„ä»¶å¯¹è±¡æ¨¡å‹</p><p>   If you do this option, the container won&#39;t handle SSL at all, and you&#39;ll have to reverse proxy port 9091 to 9090 (SSL), and port 4011 to 4430 (SSL).</p><p>å¦‚æœæ‚¨é€‰æ‹©æ­¤é€‰é¡¹ï¼Œåˆ™å®¹å™¨å°†èµ¢å¾—&#39ï¼›æ ¹æœ¬æ— æ³•å¤„ç†SSLï¼Œè€Œæ‚¨&#39ï¼›æˆ‘ä»¬å¿…é¡»å°†ä»£ç†ç«¯å£9091åè½¬ä¸º9090ï¼ˆSSLï¼‰ï¼Œå°†ç«¯å£4011åè½¬ä¸º4430ï¼ˆSSLï¼‰ã€‚</p><p>     Ensure the domain is correctly pointing to the machine you&#39;re running the container on (subdomains work fine too)</p><p>ç¡®ä¿åŸŸæ­£ç¡®åœ°æŒ‡å‘æ‚¨çš„æœºå™¨&#39ï¼›åœ¨ä¸Šé‡æ–°è¿è¡Œå®¹å™¨ï¼ˆå­åŸŸä¹Ÿå¯ä»¥æ­£å¸¸å·¥ä½œï¼‰</p><p>    Once you&#39;re configured, running the container is simple. Ensure that, at minimum, ports 4430 and 9090 are forwarded.</p><p>ä¸€æ—¦ä½ &#39ï¼›é‡æ–°é…ç½®åï¼Œè¿è¡Œå®¹å™¨å¾ˆç®€å•ã€‚ç¡®ä¿è‡³å°‘è½¬å‘ç«¯å£4430å’Œ9090ã€‚</p><p>   ğŸ‰ You should now be able to use this machine as both a WebRTC-Star node and a p2p-circuit node.</p><p>ğŸ‰ ç°åœ¨ï¼Œæ‚¨åº”è¯¥å¯ä»¥å°†è¯¥æœºå™¨ç”¨ä½œWebRTCæ˜Ÿå½¢èŠ‚ç‚¹å’Œp2pç”µè·¯èŠ‚ç‚¹ã€‚</p><p>    We can use  WebRTC-Star       (opens new window) nodes to help discover other peers we can connect with directly browser-to-browser. I find it easy to think of this as similar to  STUN       (opens new window), if you&#39;re already familiar with that concept. Effectively, each connecting node will be given a WebRTC-Star  multiaddress       (opens new window) that other nodes can use to discover and connect to your browser directly. This means that if you peer with someone using the star node, and the star node goes offline, you remain connected!</p><p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨WebRTC Starï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰èŠ‚ç‚¹æ¥å¸®åŠ©å‘ç°æˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡æµè§ˆå™¨åˆ°æµè§ˆå™¨è¿æ¥çš„å…¶ä»–èŠ‚ç‚¹ã€‚æˆ‘å‘ç°å¾ˆå®¹æ˜“å°†å…¶è§†ä¸ºç±»ä¼¼äºSTUNï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ï¼Œå¦‚æœä½ &#39ï¼›æˆ‘ä»¬å·²ç»ç†Ÿæ‚‰è¿™ä¸ªæ¦‚å¿µäº†ã€‚å®é™…ä¸Šï¼Œæ¯ä¸ªè¿æ¥èŠ‚ç‚¹éƒ½å°†è·å¾—ä¸€ä¸ªWebRTCæ˜Ÿå½¢å¤šåœ°å€ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ï¼Œå…¶ä»–èŠ‚ç‚¹å¯ä»¥ä½¿ç”¨è¯¥åœ°å€ç›´æ¥å‘ç°å¹¶è¿æ¥åˆ°æµè§ˆå™¨ã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æœä½ ä¸ä½¿ç”¨æ˜Ÿå‹èŠ‚ç‚¹çš„äººè¿›è¡Œå¯¹ç­‰ï¼Œè€Œæ˜Ÿå‹èŠ‚ç‚¹ç¦»çº¿ï¼Œä½ å°†ä¿æŒè¿æ¥ï¼</p><p>      ipfs  =  await Ipfs . create ( { repo :  &#39;ok&#39;  + Math . random ( ) ,  // random so we get a new peerid every time, useful for testing config :  { Addresses :  { Swarm :  [  &#39;/dns4/star.thedisco.zone/tcp/9090/wss/p2p-webrtc-star&#39; ,  &#39;/dns6/star.thedisco.zone/tcp/9090/wss/p2p-webrtc-star&#39;  ]  } , } } ) ;</p><p>ipfs=ç­‰å¾…ipfsã€‚åˆ›å»ºï¼ˆ{repo:&#39ï¼›ok&#39ï¼›+Math.randomï¼ˆï¼‰ï¼Œ//randomï¼Œè¿™æ ·æˆ‘ä»¬æ¯æ¬¡éƒ½ä¼šå¾—åˆ°ä¸€ä¸ªæ–°çš„peeridï¼Œç”¨äºæµ‹è¯•é…ç½®ï¼š{Addresses:{Swarm:[&#39ï¼›/dns4/star.thedisco.zone/tcp/9090/wss/p2p webrtc star#39ï¼›&#39ï¼›/dns6/star thedisco.zone/tcp/9090/wss/p2p webrtc star 39ï¼›}ï¼Œ}ï¼‰ï¼›</p><p>   Please note that this example uses my own star nodes â€” however, those won&#39;t necessarily always be accessible there. Currently it&#39;s important to either find a reliable star node or host your own. You can host your own quite simply by following the instructions  here       (opens new window) for a native setup and  here       (opens new window) for a Docker container which includes Nginx (for SSL). If you opt for the native setup, we cover the Nginx reverse proxy process and SSL cert retrieval later in this post.</p><p>è¯·æ³¨æ„ï¼Œè¿™ä¸ªä¾‹å­ä½¿ç”¨äº†æˆ‘è‡ªå·±çš„æ˜Ÿå‹èŠ‚ç‚¹â€”â€”ç„¶è€Œï¼Œè¿™äº›èŠ‚ç‚¹èµ¢äº†&#39ï¼›åœ¨é‚£é‡Œä¸ä¸€å®šæ€»èƒ½æ‰¾åˆ°ã€‚ç›®å‰ä¸º&#39ï¼›é‡è¦çš„æ˜¯æ‰¾åˆ°ä¸€ä¸ªå¯é çš„æ˜Ÿå‹èŠ‚ç‚¹æˆ–è‡ªå·±çš„ä¸»æœºã€‚æ‚¨åªéœ€æŒ‰ç…§æ­¤å¤„çš„è¯´æ˜ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰è¿›è¡Œæœ¬æœºè®¾ç½®ï¼Œå¹¶æŒ‰ç…§æ­¤å¤„çš„è¯´æ˜ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰è¿›è¡ŒDockerå®¹å™¨çš„æ‰˜ç®¡ï¼Œè¯¥å®¹å™¨åŒ…å«Nginxï¼ˆç”¨äºSSLï¼‰ã€‚å¦‚æœæ‚¨é€‰æ‹©æœ¬æœºè®¾ç½®ï¼Œæˆ‘ä»¬å°†åœ¨æœ¬æ–‡åé¢ä»‹ç»Nginxåå‘ä»£ç†è¿‡ç¨‹å’ŒSSLè¯ä¹¦æ£€ç´¢ã€‚</p><p>  ğŸš€ This is a very clean and effective method of P2P communications; however, sometimes NATs get in the way. We use   p2p-circuit       (opens new window) to get around that.</p><p>ğŸš€ è¿™æ˜¯ä¸€ç§éå¸¸å¹²å‡€æœ‰æ•ˆçš„P2Pé€šä¿¡æ–¹æ³•ï¼›ç„¶è€Œï¼Œæœ‰æ—¶NATä¼šç¢äº‹ã€‚æˆ‘ä»¬ä½¿ç”¨p2pç”µè·¯ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p><p>    Using  p2p-circuit is really helpful for peers behind tricky NATs (or a VPN, or anything really). I find the relaying of  p2p-circuit to be similar to  TURN       (opens new window), so it&#39;s easy to think of it that way if you&#39;re already familiar with it.</p><p>ä½¿ç”¨p2p circuitå¯¹å¤æ‚çš„NATï¼ˆæˆ–VPNï¼Œæˆ–å…¶ä»–ä»»ä½•ä¸œè¥¿ï¼‰èƒŒåçš„å¯¹ç­‰æ–¹æ¥è¯´çœŸçš„å¾ˆæœ‰å¸®åŠ©ã€‚æˆ‘å‘ç°p2pç”µè·¯çš„ä¸­ç»§ç±»ä¼¼äºTURNï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ï¼Œæ‰€ä»¥å®ƒ&#39ï¼›å¦‚æœä½ &#39ï¼›æˆ‘ä»¬å·²ç»å¾ˆç†Ÿæ‚‰äº†ã€‚</p><p>    Once all the services for  p2p-circuit are put together, connecting to the node can be achieved in a few different ways. First, to connect on startup to  only our node(s):</p><p>ä¸€æ—¦p2pç”µè·¯çš„æ‰€æœ‰æœåŠ¡éƒ½æ”¾åœ¨ä¸€èµ·ï¼Œå°±å¯ä»¥é€šè¿‡å‡ ç§ä¸åŒçš„æ–¹å¼è¿æ¥åˆ°èŠ‚ç‚¹ã€‚é¦–å…ˆï¼Œè¦åœ¨å¯åŠ¨æ—¶ä»…è¿æ¥åˆ°æˆ‘ä»¬çš„èŠ‚ç‚¹ï¼š</p><p>      If you&#39;re looking to do your own client without copying the example, ensure you&#39;re also communicating with the announce channel, which is described under  Advertising. The relevant code in the chat demo is this (simplified):</p><p>å¦‚æœä½ &#39ï¼›å¦‚æœä½ å¸Œæœ›åœ¨ä¸å¤åˆ¶ç¤ºä¾‹çš„æƒ…å†µä¸‹å¼€å‘è‡ªå·±çš„å®¢æˆ·ï¼Œè¯·ç¡®ä¿&#39ï¼›é‡æ–°ä¸å…¬å‘Šé¢‘é“è¿›è¡Œæ²Ÿé€šï¼Œè¯¦è§å¹¿å‘Šéƒ¨åˆ†ã€‚èŠå¤©æ¼”ç¤ºä¸­çš„ç›¸å…³ä»£ç å¦‚ä¸‹ï¼ˆç®€åŒ–ï¼‰ï¼š</p><p>  var ipfs ;  // store the IPFS node you&#39;re using in this variable // processes a circuit-relay announce over pubsub async  function  processAnnounce ( addr )  {  // get our peerid me  =  await ipfs . id ( ) ; me  = me .id ;  // not really an announcement if it&#39;s from us  if  (addr .from  == me )  {  return ;  }  // if we got a keep-alive, nothing to do  if  (addr  ==  &#34;keep-alive&#34; )  { console . log (addr ) ;  return ;  } peer  = addr . split ( &#34;/&#34; ) [ 9 ] ; console . log ( &#34;Peer: &#34;  + peer ) ; console . log ( &#34;Me: &#34;  + me ) ;  if  (peer  == me )  {  // return if the peer being announced is us  return ;  }  // get a list of peers peers  =  await ipfs .swarm . peers ( ) ;  for  (i  in peers )  {  // if we&#39;re already connected to the peer, don&#39;t bother doing a  // circuit connection  if  (peers [i ] .peer  == peer )  {  return ;  }  }  // log the address to console as we&#39;re about to attempt a connection console . log (addr ) ;  // connection almost always fails the first time, but almost always  // succeeds the second time, so we do this:  try  {  await ipfs .swarm . connect (addr ) ;  }  catch (err )  { console . log (err ) ;  await ipfs .swarm . connect (addr ) ;  } } // process announcements over the relay network, and publish our own // keep-alives to keep the channel alive await ipfs .pubsub . subscribe ( &#34;announce-circuit&#34; , processAnnounce ) ; setInterval ( function ( ) {ipfs .pubsub . publish ( &#34;announce-circuit&#34; ,  &#34;peer-alive&#34; ) ; } ,  15000 ) ;</p><p>var ipfsï¼›//å­˜å‚¨æ‚¨éœ€è¦çš„IPFSèŠ‚ç‚¹&#39ï¼›åœ¨è¿™ä¸ªå˜é‡ä¸­é‡æ–°ä½¿ç”¨//é€šè¿‡pubsubå¼‚æ­¥å‡½æ•°processannoundï¼ˆaddrï¼‰{//get our peerid me=await ipfs.idï¼ˆï¼‰ï¼›me=me.idï¼›//å¦‚æœå®ƒæ˜¯ä»æˆ‘ä»¬è¿™é‡Œå‘å‡ºçš„ï¼Œé‚£ä¹ˆå®ƒå°±ä¸æ˜¯çœŸæ­£çš„é€šå‘Šï¼Œå¦‚æœï¼ˆaddr.from==meï¼‰{returnï¼›}å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªkeep aliveï¼Œå¦‚æœï¼ˆaddr==&#34ï¼›keep alive&#34ï¼›ï¼‰å°±æ²¡ä»€ä¹ˆå¯åšçš„äº†{console.logï¼ˆaddrï¼‰ï¼›returnï¼›}peer=addrã€‚æ‹†åˆ†ï¼ˆ&#34ï¼›/&#34ï¼›ï¼‰[ 9 ] ; å®‰æ…°æ—¥å¿—ï¼ˆ&#34ï¼›å¯¹ç­‰ï¼š&#34ï¼›+å¯¹ç­‰ï¼‰ï¼›å®‰æ…°æ—¥å¿—ï¼ˆ&#34ï¼›Me:&#34ï¼›+Meï¼‰ï¼›ifï¼ˆpeer==meï¼‰{//returnå¦‚æœæ‰€å®£å¸ƒçš„peeræ˜¯us returnï¼›}//è·å–å¯¹ç­‰ç‚¹åˆ—è¡¨=ç­‰å¾…IPFã€‚ä¸€å¤§ç¾¤åŒé¾„äººï¼ˆï¼‰ï¼›å¯¹äºï¼ˆå¯¹ç­‰ä½“ä¸­çš„iï¼‰{//å¦‚æœæˆ‘ä»¬å·²ç»è¿æ¥åˆ°å¯¹ç­‰ä½“ï¼Œé‚£ä¹ˆä¸è¦è´¹å¿ƒåš//ç”µè·¯è¿æ¥ï¼Œå¦‚æœï¼ˆå¯¹ç­‰ä½“[i].peer==peerï¼‰{returnï¼›}//åœ¨æˆ‘ä»¬&#39ï¼›æˆ‘ä»¬å°†å°è¯•è¿æ¥æ§åˆ¶å°ã€‚æ—¥å¿—ï¼ˆåœ°å€ï¼‰ï¼›//è¿æ¥å‡ ä¹æ€»æ˜¯ç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œä½†å‡ ä¹æ€»æ˜¯//ç¬¬äºŒæ¬¡æˆåŠŸï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™æ ·åšï¼šå°è¯•{wait ipfs.swarm.connectï¼ˆaddrï¼‰ï¼›}catchï¼ˆerrï¼‰{console.logï¼ˆerrï¼‰ï¼›wait ipfs.swarm.connectï¼ˆaddrï¼‰ï¼›}}//é€šè¿‡ä¸­ç»§ç½‘ç»œå¤„ç†å…¬å‘Šï¼Œå¹¶å‘å¸ƒæˆ‘ä»¬è‡ªå·±çš„//keep alivesä»¥ä¿æŒé¢‘é“çš„æ´»åŠ›ï¼Œç­‰å¾…IPFã€‚pubsubã€‚è®¢é˜…ï¼ˆ&#34ï¼›å…¬å‘Šç”µè·¯&#34ï¼›ï¼Œæµç¨‹å…¬å‘Šï¼‰ï¼›setIntervalï¼ˆå‡½æ•°ï¼ˆï¼‰{ipfs.pubsub.publishï¼ˆ&#34ï¼›å…¬å‘Šç”µè·¯&#34ï¼›ï¼Œ&#34ï¼›å¯¹ç­‰æ´»åŠ¨&#34ï¼›ï¼‰ï¼›ï¼‰ï¼Œ15000 ) ;</p><p>   Like the star nodes, it&#39;ll be important to host your own things as the ones in this post could go offline at any moment.</p><p>ä¸æ˜Ÿå½¢èŠ‚ç‚¹ä¸€æ ·ï¼Œå®ƒ&#39ï¼›Weâ€™é‡è¦çš„æ˜¯ï¼Œä½ å¯ä»¥è‡ªå·±ç®¡ç†è‡ªå·±çš„ä¸œè¥¿ï¼Œå› ä¸ºè¿™ç¯‡æ–‡ç« ä¸­çš„ä¸œè¥¿éšæ—¶éƒ½å¯èƒ½ç¦»çº¿ã€‚</p><p>  For the purposes of this example, you&#39;ll need to do a few things on a server hosting your own  go-ipfs       (opens new window) node. You&#39;ll also need a working Nginx install setup, which will be used for SSL, which is a requirement for browsers.</p><p>åœ¨æœ¬ä¾‹ä¸­ï¼Œæ‚¨&#39ï¼›æˆ‘éœ€è¦åœ¨æ‰˜ç®¡è‡ªå·±çš„go ipfsï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰èŠ‚ç‚¹çš„æœåŠ¡å™¨ä¸Šæ‰§è¡Œä¸€äº›æ“ä½œã€‚ä½ &#39ï¼›æˆ‘è¿˜éœ€è¦ä¸€ä¸ªæ­£å¸¸å·¥ä½œçš„Nginxå®‰è£…ç¨‹åºï¼Œå®ƒå°†ç”¨äºSSLï¼Œè¿™æ˜¯æµè§ˆå™¨çš„ä¸€ä¸ªè¦æ±‚ã€‚</p><p>  First configure the Go node, enabling  WebSocket       (opens new window) support, and designate it as a relay so we can communicate with it from a browser by editing  ~/.ipfs/config to add the following settings:</p><p>é¦–å…ˆé…ç½®GoèŠ‚ç‚¹ï¼Œå¯ç”¨WebSocketï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰æ”¯æŒï¼Œå¹¶å°†å…¶æŒ‡å®šä¸ºä¸­ç»§ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¼–è¾‘~/ä»æµè§ˆå™¨ä¸å®ƒé€šä¿¡ã€‚ipfs/configä»¥æ·»åŠ ä»¥ä¸‹è®¾ç½®ï¼š</p><p>  {  &#34;Addresses&#34; :  {  &#34;Swarm&#34;  :  [  &#34;/ip4/0.0.0.0/tcp/4011/ws&#34; ,  &#34;/ip6/::/tcp/4011/ws&#34;  ]  } ,  &#34;Swarm&#34; :  {  &#34;EnableRelayHop&#34; :  true  } }</p><p>{&#34ï¼›åœ°å€&#34ï¼›ï¼š{&#34ï¼›Swarm&#34ï¼›ï¼š[&#34ï¼›/ip4/0.0.0/tcp/4011/ws&#34ï¼›ï¼Œ&#34ï¼›/ip6/ï¼šï¼š/tcp/4011/ws&#34ï¼›]&#34;Swarm&#34ï¼›ï¼š{&#34ï¼›EnableRelayHop&#34ï¼›ï¼štrue}</p><p> Restart your  go-ipfs node however you normally do (possibly  systemctl --user restart ipfs), and we&#39;re mostly set up! We&#39;ve enabled regular WebSockets with relaying support, however we need secure WebSockets (outlined in the SSL section below) â€” otherwise browsers won&#39;t be able to connect to us.</p><p>ä»¥æ­£å¸¸æ–¹å¼é‡æ–°å¯åŠ¨go ipfsèŠ‚ç‚¹ï¼ˆå¯èƒ½æ˜¯systemctlâ€”â€”ç”¨æˆ·é‡æ–°å¯åŠ¨ipfsï¼‰ï¼Œæˆ‘ä»¬&#39ï¼›æˆ‘ä»¬å·²ç»å‡†å¤‡å¥½äº†ï¼æˆ‘ä»¬&#39ï¼›æˆ‘ä»¬å·²ç»å¯ç”¨äº†å…·æœ‰ä¸­ç»§æ”¯æŒçš„å¸¸è§„WebSocketï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦å®‰å…¨çš„WebSocketï¼ˆåœ¨ä¸‹é¢çš„SSLéƒ¨åˆ†ä¸­æ¦‚è¿°ï¼‰â€”â€”å¦åˆ™æµè§ˆå™¨å°†èµ¢å¾—&#39ï¼›æˆ‘æ— æ³•ä¸æˆ‘ä»¬è”ç³»ã€‚</p><p>    Using  p2p-circuit can be a bit tricky. Once we connect to the relay from a browser, we&#39;re not advertising that we&#39;re able to be reached through it! For this purpose, I&#39;ve created a Python script that runs alongside  go-ipfs and advertises the browser  js-ipfs peers it encounters over  PubSub       (opens new window) with a  p2p-circuit  multiaddress       (opens new window).</p><p>ä½¿ç”¨p2pç”µè·¯å¯èƒ½æœ‰ç‚¹æ£˜æ‰‹ã€‚ä¸€æ—¦æˆ‘ä»¬ä»æµè§ˆå™¨è¿æ¥åˆ°ä¸­ç»§ï¼Œæˆ‘ä»¬&#39ï¼›æˆ‘ä»¬ä¸æ˜¯åœ¨å®£ä¼ æˆ‘ä»¬&#39ï¼›æˆ‘ä»¬å¯ä»¥é€šè¿‡å®ƒè”ç³»åˆ°ä½ ï¼ä¸ºæ­¤ï¼Œæˆ‘&#39ï¼›æˆ‘åˆ›å»ºäº†ä¸€ä¸ªPythonè„šæœ¬ï¼Œå®ƒä¸go ipfsä¸€èµ·è¿è¡Œï¼Œå¹¶ç”¨ä¸€ä¸ªp2på›è·¯å¤šåœ°å€ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰åœ¨PubSubï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ä¸Šå…¬å¸ƒå®ƒé‡åˆ°çš„æµè§ˆå™¨js ipfså¯¹ç­‰ç‚¹ã€‚</p><p>  You can find the Python script  here       (opens new window). It can be run with a simple  python ipfs_peeradvertiser.py. However, ensure you first edit  CIRCUIT with your own node&#39;s information, or you won&#39;t announce the peers correctly, and they won&#39;t know how to use your relay to connect to other peers.</p><p>æ‚¨å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°Pythonè„šæœ¬ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ã€‚å®ƒå¯ä»¥ç”¨ä¸€ä¸ªç®€å•çš„python ipfs_peeradvertiserè¿è¡Œã€‚çš®è€¶ã€‚ä½†æ˜¯ï¼Œè¯·ç¡®ä¿é¦–å…ˆä½¿ç”¨è‡ªå·±çš„èŠ‚ç‚¹ç¼–è¾‘å›è·¯&#39ï¼›è¿™æ˜¯ä½ çš„ä¿¡æ¯ï¼Œå¦åˆ™ä½ èµ¢äº†&#39ï¼›æ²¡æœ‰æ­£ç¡®åœ°å®£å¸ƒåŒé¾„äººï¼Œä»–ä»¬èµ¢äº†&#39ï¼›æˆ‘ä¸çŸ¥é“å¦‚ä½•ä½¿ç”¨ä¸­ç»§è¿æ¥åˆ°å…¶ä»–åŒé¾„äººã€‚</p><p>  You can retrieve your own circuit info quite easily. Simply run  ipfs id on your  go-ipfs node to get your PeerID, then form the circuit URL like so:</p><p>ä½ å¯ä»¥å¾ˆå®¹æ˜“åœ°æ£€ç´¢è‡ªå·±çš„ç”µè·¯ä¿¡æ¯ã€‚åªéœ€åœ¨go ipfsèŠ‚ç‚¹ä¸Šè¿è¡Œipfs idå³å¯è·å¾—PeerIDï¼Œç„¶åæŒ‰å¦‚ä¸‹æ–¹å¼å½¢æˆå›è·¯URLï¼š</p><p>   You should see here where you simply fill out your domain name you got the SSL cert for, as well as your node&#39;s PeerID. For the script, the leading and trailing slash are required, too.</p><p>ä½ åº”è¯¥åœ¨è¿™é‡Œçœ‹åˆ°ï¼Œä½ åªéœ€å¡«å†™ä½ è·å¾—SSLè¯ä¹¦çš„åŸŸåï¼Œä»¥åŠä½ çš„èŠ‚ç‚¹&#39ï¼›è¿™æ˜¯çš®åˆ©å¾·ã€‚å¯¹äºè„šæœ¬ï¼Œå‰å¯¼æ–œæ å’Œå°¾éšæ–œæ ä¹Ÿæ˜¯å¿…éœ€çš„ã€‚</p><p>    Ensure you specify DNS6 or DNS4, depending on if you&#39;re forming an IPv6 or IPv4 address.  It&#39;s important to ensure you use DNS, otherwise browser nodes likely won&#39;t be able to connect. Also note the port 4430; if you used a different one, you&#39;ll need to specify that.</p><p>ç¡®ä¿æŒ‡å®šDNS6æˆ–DNS4ï¼Œå…·ä½“å–å†³äº&#39ï¼›æ­£åœ¨é‡æ–°å½¢æˆIPv6æˆ–IPv4åœ°å€ã€‚å®ƒ&#39ï¼›ç¡®ä¿ä½¿ç”¨DNSå¾ˆé‡è¦ï¼Œå¦åˆ™æµè§ˆå™¨èŠ‚ç‚¹å¯èƒ½ä¼šèµ¢#39ï¼›æˆ‘æ— æ³•è¿æ¥ã€‚è¿˜è¦æ³¨æ„ç«¯å£4430ï¼›å¦‚æœä½ ç”¨äº†å¦ä¸€ä¸ªï¼Œä½ &#39ï¼›æˆ‘éœ€è¦å…·ä½“è¯´æ˜ä¸€ä¸‹ã€‚</p><p>    So far we&#39;ve setup WebRTC-Star and  p2p-circuit without SSL (unless you used the WebRTC-Star docker setup). If you want to use your nodes over the Internet, with a browser, they need to support SSL. If you&#39;re using the defaults currently WebRTC-Star should be running on port 9090 (no-SSL) and p2p-circuit will be on port 4011 (no-SSL). We&#39;re going to put those on port 9091 (SSL) and port 4430 (SSL), respectively.</p><p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬&#39ï¼›veè®¾ç½®ä¸å¸¦SSLçš„WebRTC Starå’Œp2pç”µè·¯ï¼ˆé™¤éä½¿ç”¨WebRTC Star dockerè®¾ç½®ï¼‰ã€‚å¦‚æœä½ æƒ³åœ¨äº’è”ç½‘ä¸Šé€šè¿‡æµè§ˆå™¨ä½¿ç”¨ä½ çš„èŠ‚ç‚¹ï¼Œå®ƒä»¬éœ€è¦æ”¯æŒSSLã€‚å¦‚æœä½ &#39ï¼›é‡æ–°ä½¿ç”¨é»˜è®¤è®¾ç½®å½“å‰WebRTC Staråº”åœ¨ç«¯å£9090ï¼ˆæ— SSLï¼‰ä¸Šè¿è¡Œï¼Œp2pç”µè·¯å°†åœ¨ç«¯å£4011ï¼ˆæ— SSLï¼‰ä¸Šè¿è¡Œã€‚æˆ‘ä»¬&#39ï¼›æˆ‘ä»¬å°†æŠŠå®ƒä»¬åˆ†åˆ«æ”¾åœ¨ç«¯å£9091ï¼ˆSSLï¼‰å’Œç«¯å£4430ï¼ˆSSLï¼‰ä¸Šã€‚</p><p>    We&#39;re going to create two files from templates below. Ensure you&#39;re editing entries like  YOURDOMAIN.COM with the full domain (including subdomain) you plan to use for your services.</p><p>æˆ‘ä»¬&#39ï¼›æˆ‘ä»¬å°†ä»ä¸‹é¢çš„æ¨¡æ¿åˆ›å»ºä¸¤ä¸ªæ–‡ä»¶ã€‚ç¡®ä¿ä½ &#39ï¼›é‡æ–°ç¼–è¾‘åƒYOURDOMAINè¿™æ ·çš„æ¡ç›®ã€‚COMä¸æ‚¨è®¡åˆ’ç”¨äºæœåŠ¡çš„å®Œæ•´åŸŸï¼ˆåŒ…æ‹¬å­åŸŸï¼‰è¿›è¡Œé€šä¿¡ã€‚</p><p>    map  $http_upgrade  $connection_upgrade  {	default upgrade ;	 &#39;&#39; close ; } upstream ipfs  {	 server  127.0 .0 .1 : 4011 ; } server  {	 server_name YOURDOMAIN .COM ;	 listen  4430  ssl ;	 ssl_certificate  /etc /letsencrypt /live /YOURDOMAIN .COM /fullchain .pem ;	 ssl_certificate_key  /etc /letsencrypt /live /YOURDOMAIN .COM /privkey .pem ;	 location  /  {		 proxy_set_header X -Forwarded -For  $proxy_add_x_forwarded_for ;		 proxy_pass  http : / /ipfs ;		 proxy_http_version  1.1 ;		 proxy_set_header Upgrade  $http_upgrade ;		 proxy_set_header Connection  $connection_upgrade ;		 proxy_set_header Host  $host ;	 } }</p><p>map$http#u upgrade$connection#u upgrade{default upgradeï¼›&#39ï¼›&#39ï¼›closeï¼›}ä¸Šæ¸¸ipfs{server127.0.0.1:4011ï¼›}æœåŠ¡å™¨{server_name YOURDOMAIN.COMï¼›listen 4430 sslï¼›ssl_certificate/etc/letsencrypt/live/YOURDOMAIN.COM/fullchain.pemï¼›ssl_certificate_key/etc/letsencrypt/live/YOURDOMAIN.COM/privkey.pemï¼›ä½ç½®/{proxy_set_header X-Forwarded-For$proxy_add_X_Forwarded_Forï¼›proxy_pass http://ipfsï¼›proxy_http_version 1.1ï¼›proxy_set_header Upgrade$http_Upgradeï¼›proxy_set_header Connection$Connection_Upgradeï¼›proxy_set_header Host$Hostï¼›}</p><p>     map  $http_upgrade  $connection_upgrade  {	default upgrade ;	 &#39;&#39; close ; } upstream star  {	 server  127.0 .0 .1 : 9090 ; } server  {	 server_name YOURDOMAIN .COM ;	 listen  9091  ssl ;	 ssl_certificate  /etc /letsencrypt /live /YOURDOMAIN .COM /fullchain .pem ;	 ssl_certificate_key  /etc /letsencrypt /live /YOURDOMAIN .COM /privkey .pem ;	 location  /  {		 proxy_set_header X -Forwarded -For  $proxy_add_x_forwarded_for ;		 proxy_pass  http : / /star ;		 proxy_http_version  1.1 ;		 proxy_set_header Upgrade  $http_upgrade ;		 proxy_set_header Connection  $connection_upgrade ;		 proxy_set_header Host  $host ;	 } }</p><p>map$http#u upgrade$connection#u upgrade{default upgradeï¼›&#39ï¼›&#39ï¼›closeï¼›}ä¸Šæ¸¸æ˜Ÿå‹{Server127.0.0.1:9090ï¼›}æœåŠ¡å™¨{server_name YOURDOMAIN.COMï¼›listen 9091 sslï¼›ssl_certificate/etc/letsencrypt/live/YOURDOMAIN.COM/fullchain.pemï¼›ssl_certificate_key/etc/letsencrypt/live/YOURDOMAIN.COM/privkey.pemï¼›ä½ç½®/{proxy_set_header X-Forwarded-For$proxy_add_X_Forwarded_Forï¼›proxy_pass http://starï¼›proxy_http_version 1.1ï¼›proxy_set_header Upgrade$http_Upgradeï¼›proxy_set_header Connection$Connection_Upgradeï¼›proxy_set_header Host$Hostï¼›}</p><p> So in this example you can see we&#39;re accepting SSL on port 4430 â€” this is our &#34;wss port&#34; (WebSocket Secure) â€” and then passing it to the unsecured port locally on 4011 â€” this is our &#34;ws port&#34;. So if we want to connect to this node from a browser, we&#39;d use port 4430.</p><p>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ å¯ä»¥çœ‹åˆ°æˆ‘ä»¬&#39ï¼›é‡æ–°æ¥å—ç«¯å£4430ä¸Šçš„SSL-è¿™æ˜¯æˆ‘ä»¬çš„&#34ï¼›wssç«¯å£&#34ï¼›ï¼ˆWebSocketå®‰å…¨ï¼‰-ç„¶ååœ¨4011æœ¬åœ°å°†å…¶ä¼ é€’åˆ°ä¸å®‰å…¨çš„ç«¯å£-è¿™æ˜¯æˆ‘ä»¬çš„&#34ï¼›ws-port&#34ï¼›ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬æƒ³ä»æµè§ˆå™¨è¿æ¥åˆ°è¿™ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬&#39ï¼›dä½¿ç”¨ç«¯å£4430ã€‚</p><p>    sudo systemctl stop nginx sudo certbot -d YOURDOMAIN.COM --standalone  # Edit YOURDOMAIN.COM to the domain you want a cert for, if you need multiple, fill in multiple or run the command multiple times sudo  ln -s /etc/nginx/sites-available/ipfs /etc/nginx/sites-enabled/ipfs sudo  ln -s /etc/nginx/sites-available/star /etc/nginx/sites-enabled/star sudo systemctl start nginx</p><p>sudo systemctl stop nginx sudo certbot-d YOURDOMAINã€‚COM--ç‹¬ç«‹#ç¼–è¾‘ä½ çš„åŸŸåã€‚COMåˆ°æ‚¨æƒ³è¦è¯ä¹¦çš„åŸŸï¼Œå¦‚æœéœ€è¦å¤šä¸ªï¼Œè¯·å¡«å†™å¤šä¸ªæˆ–å¤šæ¬¡è¿è¡Œå‘½ä»¤sudo ln-s/etc/nginx/sites available/ipfs/etc/nginx/sites enabled/ipfs sudo ln-s/etc/nginx/sites available/star/etc/nginx/sites enabled/star sudo systemctl start nginx</p><p>     Whew! Since you made it this far, you might be wondering &#34;what is communication like?&#34; Luckily the answer is that it&#39;s  very easy in comparison to finding the peers, with only minor pitfalls. We&#39;re going to simply cover how we&#39;re using  PubSub       (opens new window) in the chat example, and exactly what pitfalls were found while it was developed.</p><p>å”·ï¼æ—¢ç„¶ä½ èµ°äº†è¿™ä¹ˆè¿œï¼Œä½ å¯èƒ½ä¼šæƒ³&#34ï¼›æ²Ÿé€šæ˜¯ä»€ä¹ˆæ ·çš„&#34; å¹¸è¿çš„æ˜¯ï¼Œç­”æ¡ˆæ˜¯&#39ï¼›ä¸å¯»æ‰¾åŒé¾„äººç›¸æ¯”ï¼Œè¿™å¾ˆå®¹æ˜“ï¼Œåªæœ‰ä¸€äº›å°ç¼ºé™·ã€‚æˆ‘ä»¬&#39ï¼›æˆ‘ä»¬å°†ç®€å•ä»‹ç»ä¸€ä¸‹æˆ‘ä»¬&#39ï¼›åœ¨èŠå¤©ç¤ºä¾‹ä¸­é‡æ–°ä½¿ç”¨PubSubï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰ï¼Œä»¥åŠåœ¨å¼€å‘è¿‡ç¨‹ä¸­å‘ç°äº†å“ªäº›é™·é˜±ã€‚</p><p>    Using PubSub, we&#39;re able to subscribe to topics and retrieve any messages posted to those topics. In  js-ipfs, we can set a callback function, which gets called whenever a message is received:</p><p>ä½¿ç”¨PubSubï¼Œæˆ‘ä»¬&#39ï¼›æˆ‘ä»¬å¯ä»¥è®¢é˜…ä¸»é¢˜å¹¶æ£€ç´¢å‘å¸ƒåˆ°è¿™äº›ä¸»é¢˜çš„ä»»ä½•æ¶ˆæ¯ã€‚åœ¨js ipfsä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œåœ¨æ”¶åˆ°æ¶ˆæ¯æ—¶è°ƒç”¨è¯¥å‡½æ•°ï¼š</p><p>      This is effectively what the chat demo is doing. It&#39;s subscribing to a global topic (named &#34;discochat-global&#34;), and simply relaying the messages people type around over PubSub.</p><p>è¿™å®é™…ä¸Šå°±æ˜¯èŠå¤©æ¼”ç¤ºæ‰€åšçš„ã€‚å®ƒ&#39ï¼›sè®¢é˜…ä¸€ä¸ªå…¨çƒä¸»é¢˜ï¼ˆåä¸º&#34ï¼›discochat global&#34ï¼›ï¼‰ï¼Œç®€å•åœ°ä¼ é€’äººä»¬åœ¨PubSubä¸Šé”®å…¥çš„ä¿¡æ¯ã€‚</p><p>    So let&#39;s say you&#39;ve done everything correctly. You&#39;re able to find peers using WebRTC-Star and  p2p-circuit â€” awesome! However, you might find your connections expire, and you&#39;re unable to restore them. I&#39;m not completely sure what causes this behaviour (probably some browser policy); however, we can do our best to mitigate these issues!</p><p>æ‰€ä»¥è®©æˆ‘ä»¬&#39ï¼›æ¯”å¦‚è¯´ä½ &#39ï¼›æˆ‘ä¸€åˆ‡éƒ½åšå¯¹äº†ã€‚ä½ &#39ï¼›æˆ‘ä»¬å¯ä»¥ä½¿ç”¨WebRTC Starå’Œp2p circuitæ‰¾åˆ°åŒé¾„äººâ€”â€”å¤ªæ£’äº†ï¼ç„¶è€Œï¼Œä½ å¯èƒ½ä¼šå‘ç°ä½ çš„è¿æ¥è¿‡æœŸäº†ï¼Œä½ &#39ï¼›æˆ‘ä»¬æ— æ³•æ¢å¤å®ƒä»¬ã€‚æˆ‘&#39ï¼›æˆ‘ä¸å®Œå…¨ç¡®å®šæ˜¯ä»€ä¹ˆå¯¼è‡´äº†è¿™ç§è¡Œä¸ºï¼ˆå¯èƒ½æ˜¯ä¸€äº›æµè§ˆå™¨ç­–ç•¥ï¼‰ï¼›ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥å°½æœ€å¤§åŠªåŠ›ç¼“è§£è¿™äº›é—®é¢˜ï¼</p><p>    We stay connected to peers in a couple of ways. The first way is more direct: by subscribing to and sending a &#34;keepalive&#34; announcement over  discochat-keepalive every 4 seconds:</p><p>æˆ‘ä»¬é€šè¿‡å‡ ç§æ–¹å¼ä¸åŒé¾„äººä¿æŒè”ç³»ã€‚ç¬¬ä¸€ç§æ–¹å¼æ›´ç›´æ¥ï¼šè®¢é˜…å¹¶å‘é€&#34ï¼›ä¿æŒæ´»åŠ›&#34ï¼›æ¯4ç§’é€šè¿‡discochat keepaliveå‘å¸ƒä¸€æ¬¡å…¬å‘Šï¼š</p><p>   This should help ensure we give peers looking to chat a high priority. Additionally, we report over  announce-circuit every 15 seconds to make sure we keep a connection to the circuit relay so we can connect to peers stuck behind a NAT. That&#39;s accomplished like so:</p><p>è¿™å°†æœ‰åŠ©äºç¡®ä¿æˆ‘ä»¬ä¼˜å…ˆè€ƒè™‘å¸Œæœ›èŠå¤©çš„åŒé¾„äººã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬æ¯15ç§’æŠ¥å‘Šä¸€æ¬¡ç”µè·¯ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬ä¸ç”µè·¯ç»§ç”µå™¨ä¿æŒè¿æ¥ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥è¿æ¥åˆ°NATåé¢çš„å¯¹ç­‰æ–¹ã€‚é‚£&#39ï¼›ä»–æ˜¯è¿™æ ·å®Œæˆçš„ï¼š</p><p>  // process announcements over the relay network, and publish our own keep-alives to keep the channel alive await ipfs .pubsub . subscribe ( &#34;announce-circuit&#34; , processAnnounce ) ; setInterval ( function ( ) {ipfs .pubsub . publish ( &#34;announce-circuit&#34; ,  &#34;peer-alive&#34; ) ; } ,  15000 ) ;</p><p>//é€šè¿‡ä¸­ç»§ç½‘ç»œå¤„ç†å…¬å‘Šï¼Œå¹¶å‘å¸ƒæˆ‘ä»¬è‡ªå·±çš„keep alivesï¼Œä»¥ä¿æŒé¢‘é“çš„æ´»åŠ›ï¼Œç­‰å¾…IPFã€‚pubsubã€‚è®¢é˜…ï¼ˆ&#34ï¼›å…¬å‘Šç”µè·¯&#34ï¼›ï¼Œæµç¨‹å…¬å‘Šï¼‰ï¼›setIntervalï¼ˆå‡½æ•°ï¼ˆï¼‰{ipfs.pubsub.publishï¼ˆ&#34ï¼›å…¬å‘Šç”µè·¯&#34ï¼›ï¼Œ&#34ï¼›å¯¹ç­‰æ´»åŠ¨&#34ï¼›ï¼‰ï¼›ï¼‰ï¼Œ15000 ) ;</p><p>   The Python script on the circuit relay will report a keepalive every 4 seconds. You may have noticed we&#39;re reporting &#34;peer-alive&#34; instead of &#34;keep-alive&#34;; this is to separate peer requests from relay requests, making it easier to tell when we no longer see a relay.</p><p>ç”µè·¯ç»§ç”µå™¨ä¸Šçš„Pythonè„šæœ¬å°†æ¯4ç§’æŠ¥å‘Šä¸€æ¬¡keepaliveã€‚ä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°æˆ‘ä»¬&#39ï¼›é‡æ–°æŠ¥å‘Š&#34ï¼›æ´»ç€çš„åŒä¼´&#34ï¼›è€Œä¸æ˜¯&#34ï¼›ä¿æŒæ´»åŠ›&#34ï¼›ï¼›è¿™æ˜¯ä¸ºäº†å°†å¯¹ç­‰è¯·æ±‚ä¸ä¸­ç»§è¯·æ±‚åˆ†å¼€ï¼Œä»¥ä¾¿åœ¨æˆ‘ä»¬ä¸å†çœ‹åˆ°ä¸­ç»§æ—¶æ›´å®¹æ˜“åˆ¤æ–­ã€‚</p><p>    Outside of the simplified version of  processAnnounce, in the real version there are a few variables used for tracking keep-alive and peer-alive. These are  lastAlive and  lastPeer, respectively. We even track the last time we bootstrapped via  lastBootstrap. Using all this, we can display the yellow status when we&#39;re only connected to peers (tracked via  lastPeer), and if we don&#39;t see a keep-alive for 35 seconds (and we haven&#39;t attempted a bootstrap in 60 seconds), we can attempt to re-connect to the bootstrap relay (and display a red status). This is accomplished like so:</p><p>é™¤äº†ProcessAnnoundçš„ç®€åŒ–ç‰ˆæœ¬å¤–ï¼Œåœ¨çœŸå®ç‰ˆæœ¬ä¸­ï¼Œè¿˜æœ‰ä¸€äº›ç”¨äºè·Ÿè¸ªkeep aliveå’Œpeer aliveçš„å˜é‡ã€‚å®ƒä»¬åˆ†åˆ«æ˜¯lastAliveå’ŒlastPeerã€‚æˆ‘ä»¬ç”šè‡³é€šè¿‡lastBootstrapè·Ÿè¸ªä¸Šæ¬¡å¼•å¯¼çš„æ—¶é—´ã€‚ä½¿ç”¨æ‰€æœ‰è¿™äº›ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨&#39ï¼›æˆ‘ä»¬åªè¿æ¥åˆ°å¯¹ç­‰ç‚¹ï¼ˆé€šè¿‡lastPeerè·Ÿè¸ªï¼‰ï¼Œå¦‚æœæˆ‘ä»¬ä¸è¿æ¥&#39ï¼›åœ¨35ç§’å†…æ²¡æœ‰çœ‹åˆ°ä¿æŒæ´»åŠ¨çŠ¶æ€ï¼ˆæˆ‘ä»¬åœ¨60ç§’å†…æ²¡æœ‰å°è¯•è¿‡å¼•å¯¼ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•é‡æ–°è¿æ¥å¼•å¯¼ç»§ç”µå™¨ï¼ˆå¹¶æ˜¾ç¤ºçº¢è‰²çŠ¶æ€ï¼‰ã€‚è¿™æ˜¯è¿™æ ·å®Œæˆçš„ï¼š</p><p>  const bootstraps  =  [  &#39;/dns6/ipfs.thedisco.zone/tcp/4430/wss/p2p/12D3KooWChhhfGdB9GJy1GbhghAAKCUR99oCymMEVS4eUcEy67nt&#39; ,  &#39;/dns4/ipfs.thedisco.zone/tcp/4430/wss/p2p/12D3KooWChhhfGdB9GJy1GbhghAAKCUR99oCymMEVS4eUcEy67nt&#39; ] ; var lastAlive  =  0 ;	 // last keep-alive we saw from a relay var lastPeer  =  0 ; 	 // last keep-alive we saw from another peer var lastBootstrap  =  0 ;  // used for tracking when we last attempted to bootstrap (likely to reconnect to a relay) // if reconnect is true, it&#39;ll first attempt to disconnect from the bootstrap nodes async  function  dobootstrap ( reconnect )  { now  =  new   ( ) . getTime ( ) ;  if  (now -lastBootstrap  &lt;  60000 )  {  // don&#39;t try to bootstrap again if we just tried within the last 60 seconds  return ;  } lastBootstrap  = now ;  for  (i  in bootstraps )  {  if  (reconnect )  {  try  {  await ipfs .swarm . disconnect (bootstraps [i ] ) ;  }  catch  (e )  { console . log (e ) ;  }  }  else  {  await ipfs .bootstrap . add (bootstraps [i ] ) ;  }  await ipfs .swarm . connect (bootstraps [i ] ) ;  } } // check if we&#39;re still connected to the circuit relay function  checkalive ( )  { now  =  new   ( ) . getTime ( ) ;  if  (now -lastAlive  &gt;=  35000 )  {  if  (now -lastPeer  &gt;=  35000 )  { document . getElementById ( &#34;status-ball&#34; ) .style .color  =  &#34;red&#34; ;  }  else  { document . getElementById ( &#34;status-ball&#34; ) .style .color  =  &#34;yellow&#34; ;  }  dobootstrap ( true ) ;  // let&#39;s try to reconnect  }  else  { document . getElementById ( &#34;status-ball&#34; ) .style .color  =  &#34;lime&#34; ;  } } setInterval (checkalive ,  1000 ) ;</p><p>const bootstraps=[&#39ï¼›/dns6/ipfs.thedisco.zone/tcp/4430/wss/p2p/12d3koowchhfgdb9gj1gbhghakcur99ocymmevs4eucey67nt&#39ï¼›&#39ï¼›/dns4/ipfs.thedisco.zone/tcp/4430/wss/p2p/12d3koowchhfgdb9gy1gbhghakcur99ocymmevs4eucey67nt&#39ï¼›]ï¼›var lastAlive=0ï¼›//æˆ‘ä»¬ä»ç»§ç”µå™¨var lastPeer=0çœ‹åˆ°çš„æœ€åä¸€ä¸ªä¿æŒæ´»åŠ¨çŠ¶æ€ï¼›//ä¸Šæ¬¡æˆ‘ä»¬ä»å¦ä¸€ä¸ªå¯¹ç­‰æœåŠ¡å™¨ä¸Šçœ‹åˆ°çš„ä¿æŒæ´»åŠ¨var lastBootstrap=0ï¼›//ç”¨äºè·Ÿè¸ªä¸Šæ¬¡å°è¯•å¼•å¯¼æ—¶ï¼ˆå¯èƒ½é‡æ–°è¿æ¥åˆ°ç»§ç”µå™¨ï¼‰//å¦‚æœé‡æ–°è¿æ¥ä¸ºçœŸï¼Œåˆ™ä¸º&#39ï¼›llé¦–å…ˆå°è¯•æ–­å¼€ä¸å¼•å¯¼èŠ‚ç‚¹å¼‚æ­¥å‡½æ•°dobootstrapï¼ˆreconnectï¼‰{now=newï¼ˆï¼‰.getTimeï¼ˆï¼‰ï¼›ifï¼ˆnow-lastBootstrap&ltï¼›60000ï¼‰{//don&#39ï¼›å¦‚æœæˆ‘ä»¬åœ¨æœ€å60ç§’å†…å°è¯•ï¼Œè¯·ä¸è¦å†æ¬¡å°è¯•å¼•å¯¼è¿”å›ï¼›}lastBootstrap=nowï¼›å¯¹äºï¼ˆå¼•å¯¼ä¸­çš„iï¼‰{ifï¼ˆé‡æ–°è¿æ¥ï¼‰{try{wait ipfs.swarm.disconnectï¼ˆå¼•å¯¼[i]ï¼‰ï¼›}catchï¼ˆeï¼‰{console.logï¼ˆeï¼‰ï¼›}else{wait ipfs.bootstrap.addï¼ˆbootstraps[i]ï¼‰ï¼›}ç­‰å¾…ipfsã€‚ä¸€å¤§ç¾¤è¿æ¥ï¼ˆå¼•å¯¼[i]ï¼‰ï¼›}}//æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦&#39ï¼›reä»ç„¶è¿æ¥åˆ°ç”µè·¯ä¸­ç»§å‡½æ•°checkaliveï¼ˆï¼‰{now=newï¼ˆï¼‰.getTimeï¼ˆï¼‰ï¼›ifï¼ˆnow-lastAlive&gtï¼›=35000ï¼‰{ifï¼ˆnow-lastPeer&gtï¼›=35000ï¼‰{document.getElementByIdï¼ˆ&#34ï¼›çŠ¶æ€çƒ&#34ï¼›ï¼‰ã€‚é£æ ¼é¢œè‰²=&#34ï¼›çº¢è‰²&#34ï¼›ï¼›}else{document.getElementByIdï¼ˆ&#34ï¼›çŠ¶æ€çƒ&#34ï¼›ï¼‰ã€‚é£æ ¼é¢œè‰²=&#34ï¼›é»„è‰²&#34ï¼›ï¼›}dobootstrapï¼ˆæ­£ç¡®ï¼‰ï¼›//è®©&#39ï¼›è®©æˆ‘ä»¬å°è¯•é‡æ–°è¿æ¥}else{document.getElementByIdï¼ˆ&#34ï¼›çŠ¶æ€çƒ&#34ï¼›ï¼‰ã€‚é£æ ¼é¢œè‰²=&#34ï¼›é…¸æ©™è®¾ç½®é—´éš”ï¼ˆcheckaliveï¼Œ1000ï¼‰ï¼›</p><p> ğŸŒŸ The above should be used with the full version of  processAnnounce, as it relies on  lastAlive and  lastPeer, which aren&#39;t updated in the simplified version.</p><p>ğŸŒŸ ä»¥ä¸Šå†…å®¹åº”ä¸å®Œæ•´ç‰ˆæœ¬çš„ProcessAnnoundä¸€èµ·ä½¿ç”¨ï¼Œå› ä¸ºå®ƒä¾èµ–äºlastAliveå’ŒlastPeerï¼Œè¿™ä¸¤ä¸ªç‰ˆæœ¬ä¸æ˜¯&#39ï¼›tåœ¨ç®€åŒ–ç‰ˆæœ¬ä¸­æ›´æ–°ã€‚</p><p>    I hope this was informative enough to get rolling. If you were successful in following this entire guide, you now have the ability to deploy powerful IPFS apps that run entirely in the browser, and leverage decentralized p2p whenever you can! I&#39;ve selected some helpful resources and shared them below for further reading:</p><p>æˆ‘å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½æä¾›è¶³å¤Ÿçš„ä¿¡æ¯ï¼Œè®©æˆ‘ä»¬å¼€å§‹è¡ŒåŠ¨ã€‚å¦‚æœä½ æˆåŠŸåœ°éµå¾ªäº†æ•´ä¸ªæŒ‡å—ï¼Œä½ ç°åœ¨å°±å¯ä»¥éƒ¨ç½²å®Œå…¨åœ¨æµè§ˆå™¨ä¸­è¿è¡Œçš„å¼ºå¤§IPFSåº”ç”¨ç¨‹åºï¼Œå¹¶å°½å¯èƒ½åˆ©ç”¨åˆ†æ•£çš„p2pï¼æˆ‘&#39ï¼›æˆ‘é€‰æ‹©äº†ä¸€äº›æœ‰ç”¨çš„èµ„æºï¼Œå¹¶åœ¨ä¸‹é¢åˆ†äº«å®ƒä»¬ï¼Œä»¥ä¾›è¿›ä¸€æ­¥é˜…è¯»ï¼š</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/æµè§ˆå™¨/">#æµè§ˆå™¨</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ipfs/">#ipfs</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>