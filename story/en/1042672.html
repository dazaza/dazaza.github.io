<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>æ¶ˆæ¯é˜Ÿåˆ—å¤§æŒ‡å— The Big Little Guide to Message Queues</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Big Little Guide to Message Queues<br/>æ¶ˆæ¯é˜Ÿåˆ—å¤§æŒ‡å— </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-01 08:09:14</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/fee825295c8896de286edf32d534cdc2.jpeg"><img src="http://img2.diglog.com/img/2021/1/fee825295c8896de286edf32d534cdc2.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Message Queues are now fairly prevalentâ€”there are so many of them showing up so fast you&#39;d think they were  rabbits with an unlimited supply of  celery, resulting in an  kafkaesque situation where making a decision is like trying to catch a  stream in your hands. If only there were fewer  simple  services that could help with  publishing and subscribing, it would be so much easier to make a  zero-effort choice ğŸ˜•</p><p>æ¶ˆæ¯é˜Ÿåˆ—ç°åœ¨ç›¸å½“æ™®é-å‡ºç°çš„æ¶ˆæ¯é˜Ÿåˆ—æ˜¯å¦‚æ­¤ä¹‹å¿«ï¼Œä»¥è‡³äºæ‚¨è®¤ä¸ºå®ƒä»¬æ˜¯èŠ¹èœä¾›åº”é‡æ— é™çš„å…”å­ï¼Œä»è€Œå¯¼è‡´å¡å¤«å¡å¼é£æ ¼çš„æƒ…å†µï¼Œåšå‡ºå†³å®šå°±åƒè¯•å›¾æŠ“ä½ä¸€æ¡å°æºªä½ çš„åŒæ‰‹ã€‚å¦‚æœåªæœ‰å¾ˆå°‘çš„ç®€å•æœåŠ¡å¯ä»¥å¸®åŠ©å‘å¸ƒå’Œè®¢é˜…ï¼Œé‚£ä¹ˆåšå‡ºé›¶åŠªåŠ›çš„é€‰æ‹©å°±ä¼šå®¹æ˜“å¾—å¤šğŸ˜•</p><p> Whether we use them by themselves as-is to move data between parts of our application, or as an integral part of the architecture (like event driven systems), message queues are here to stay. In a way, they&#39;ve been here all alongâ€”just without as many names. But what are they? Why are they useful? And how do we use them effectively? Which implementation do we pick? Does it even matter which one we use? And do we need to learn each of them individually, or are there more general concepts that apply to all message queues?</p><p> æ— è®ºæˆ‘ä»¬æ˜¯æŒ‰åŸæ ·ä½¿ç”¨å®ƒä»¬æ¥åœ¨åº”ç”¨ç¨‹åºçš„å„ä¸ªéƒ¨åˆ†ä¹‹é—´ç§»åŠ¨æ•°æ®ï¼Œè¿˜æ˜¯ä½œä¸ºä½“ç³»ç»“æ„çš„ç»„æˆéƒ¨åˆ†ï¼ˆå¦‚äº‹ä»¶é©±åŠ¨çš„ç³»ç»Ÿï¼‰ï¼Œæ¶ˆæ¯é˜Ÿåˆ—éƒ½å°†ä¿ç•™ä¸‹æ¥ã€‚ä»æŸç§æ„ä¹‰ä¸Šè¯´ï¼Œä»–ä»¬ä¸€ç›´åœ¨è¿™é‡Œ-åªæ˜¯åå­—ä¸å¤šã€‚ä½†æ˜¯ä»–ä»¬æ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆæœ‰ç”¨ï¼Ÿä»¥åŠæˆ‘ä»¬å¦‚ä½•æœ‰æ•ˆåœ°ä½¿ç”¨å®ƒä»¬ï¼Ÿæˆ‘ä»¬é€‰æ‹©å“ªç§å®ç°ï¼Ÿæˆ‘ä»¬ä½¿ç”¨å“ªä¸€ä¸ªéƒ½ä¸é‡è¦ï¼Ÿæˆ‘ä»¬æ˜¯å¦éœ€è¦åˆ†åˆ«å­¦ä¹ å®ƒä»¬ï¼Œè¿˜æ˜¯æœ‰é€‚ç”¨äºæ‰€æœ‰æ¶ˆæ¯é˜Ÿåˆ—çš„æ›´ä¸€èˆ¬çš„æ¦‚å¿µï¼Ÿ</p><p>  Patterns for fan-out and fan-in: delivering one message to many systems or messages from many systems into one.</p><p>  æ‰‡å‡ºå’Œæ‰‡å…¥çš„æ¨¡å¼ï¼šå°†ä¸€æ¡æ¶ˆæ¯ä¼ é€’åˆ°å¤šä¸ªç³»ç»Ÿï¼Œæˆ–å°†æ¶ˆæ¯ä»è®¸å¤šç³»ç»Ÿç»„åˆæˆä¸€ä¸ªã€‚</p><p>  Message Queues are a way to transfer information between two systems. This informationâ€”a messageâ€”can be data, metadata, signals, or a combination of all three. The systems that are sending and receiving messages could be processes on the same computer, modules of the same application, services that might but running on different computers or technology stacks, or entirely different kinds of systems altogetherâ€”like transferring information from your software into an email or an SMS on the cellphone network.</p><p>  æ¶ˆæ¯é˜Ÿåˆ—æ˜¯åœ¨ä¸¤ä¸ªç³»ç»Ÿä¹‹é—´ä¼ è¾“ä¿¡æ¯çš„ä¸€ç§æ–¹å¼ã€‚æ­¤ä¿¡æ¯ï¼ˆä¸€æ¡æ¶ˆæ¯ï¼‰å¯ä»¥æ˜¯æ•°æ®ï¼Œå…ƒæ•°æ®ï¼Œä¿¡å·æˆ–è¿™ä¸‰è€…çš„ç»„åˆã€‚å‘é€å’Œæ¥æ”¶æ¶ˆæ¯çš„ç³»ç»Ÿå¯ä»¥æ˜¯åŒä¸€å°è®¡ç®—æœºä¸Šçš„è¿›ç¨‹ï¼ŒåŒä¸€åº”ç”¨ç¨‹åºçš„æ¨¡å—ï¼Œå¯èƒ½åœ¨ä¸åŒè®¡ç®—æœºæˆ–æŠ€æœ¯å †æ ˆä¸Šè¿è¡Œä½†å¯èƒ½å®Œå…¨ä¸åŒç§ç±»çš„ç³»ç»Ÿä¸Šè¿è¡Œçš„æœåŠ¡ï¼Œä¾‹å¦‚å°†ä¿¡æ¯ä»è½¯ä»¶ä¼ è¾“åˆ°ç”µå­é‚®ä»¶æˆ–æ‰‹æœºç½‘ç»œä¸Šçš„SMSã€‚</p><p> The idea of a messaging system has been around a very long time, from the message boxes used for moving information between people or office departments (literally where the words  inbox and  outbox come from), to telegrams, to your local postal or courier service. The messaging systems in the physical world that come closest to what we have in computing are probably the  pnuematic  tubes that moved messages through buildings and cities using compressed air until a few decades ago (and are still used in some places today).</p><p> æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿçš„æƒ³æ³•å·²ç»å­˜åœ¨äº†å¾ˆé•¿çš„æ—¶é—´ï¼Œä»ç”¨äºåœ¨äººå‘˜æˆ–åŠå…¬å®¤éƒ¨é—¨ä¹‹é—´ç§»åŠ¨ä¿¡æ¯çš„æ¶ˆæ¯æ¡†ï¼ˆå®é™…ä¸Šæ˜¯æ”¶ä»¶ç®±å’Œå‘ä»¶ç®±çš„å­—çœ¼æ¥è‡ªå“ªé‡Œï¼‰ï¼Œç”µæŠ¥åˆ°æ‚¨å½“åœ°çš„é‚®æ”¿æˆ–å¿«é€’æœåŠ¡ã€‚ç‰©ç†ä¸–ç•Œä¸­æœ€æ¥è¿‘æˆ‘ä»¬è®¡ç®—èƒ½åŠ›çš„æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿå¯èƒ½æ˜¯æ°”åŠ¨ç®¡é“ï¼Œè¿™äº›ç®¡é“åˆ©ç”¨å‹ç¼©ç©ºæ°”å°†æ¶ˆæ¯ä¼ é€’é€šè¿‡å»ºç­‘ç‰©å’ŒåŸå¸‚ï¼Œç›´åˆ°å‡ åå¹´å‰ï¼ˆå¦‚ä»Šä»åœ¨æŸäº›åœ°æ–¹ä½¿ç”¨ï¼‰ã€‚</p><p> The kinds of messages we transfer today might be a note that something technical happened, like CPU usage exceeding a limit; or a business event of interest, like a customer placing an order; or a signal, like a command that tells another service to do something. The contents of each message will be driven entirely by the architecture of your application and its purposesâ€”so for the rest of this guide, we don&#39;t need to be concerned about what&#39;s inside a messageâ€”we&#39;re more concerned with how the message gets from the system where it originates (the  producer,  source, publisher or  sender) to the system where&#39;s it&#39;s supposed to go (the  consumer,  subscriber,  destination or  receiver).</p><p> æˆ‘ä»¬ä»Šå¤©ä¼ è¾“çš„æ¶ˆæ¯ç±»å‹å¯èƒ½è¡¨æ˜å‘ç”Ÿäº†æŸäº›æŠ€æœ¯é—®é¢˜ï¼Œä¾‹å¦‚CPUä½¿ç”¨ç‡è¶…å‡ºé™åˆ¶ï¼›æˆ–æ„Ÿå…´è¶£çš„å•†ä¸šäº‹ä»¶ï¼Œä¾‹å¦‚å®¢æˆ·ä¸‹è®¢å•ï¼›æˆ–ä¿¡å·ï¼Œä¾‹å¦‚å‘Šè¯‰å…¶ä»–æœåŠ¡æ‰§è¡ŒæŸé¡¹æ“ä½œçš„å‘½ä»¤ã€‚æ¯æ¡æ¶ˆæ¯çš„å†…å®¹å°†å®Œå…¨ç”±æ‚¨çš„åº”ç”¨ç¨‹åºçš„ä½“ç³»ç»“æ„åŠå…¶ç”¨é€”æ¥å†³å®š-å› æ­¤ï¼Œåœ¨æœ¬æŒ‡å—çš„å…¶ä½™éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬ä¸å¿…æ‹…å¿ƒæ¶ˆæ¯ä¸­çš„å†…å®¹-æˆ‘ä»¬ï¼›æ›´å…³æ³¨æ¶ˆæ¯å¦‚ä½•ä»æ¶ˆæ¯èµ·æºçš„ç³»ç»Ÿï¼ˆç”Ÿäº§è€…ï¼Œæºï¼Œå‘å¸ƒè€…æˆ–å‘é€è€…ï¼‰åˆ°è¾¾åº”è¯¥å‘é€åˆ°çš„ç³»ç»Ÿï¼ˆæ¶ˆè´¹è€…ï¼Œè®¢æˆ·ï¼Œç›®çš„åœ°æˆ–æ¥æ”¶è€…ï¼‰ ï¼‰ã€‚</p><p>  We need message queues because no system exists or works in isolationâ€”all systems need to communicate with other systems in structured ways that they both can understand, and at a controlled speed that they both can handle. Any non-trivial process needs a way to move information between each stage of the process; any workflow needs a way to move the intermediate product between the stages of that workflow. Message queues are a great way to handle this movement. There are plenty of ways of getting these messages around using API calls, file systems, or many other abuses of the natural order of things; but all of these are ad-hoc implementations of the message queue that we sometimes refuse to acknowledge we need.</p><p>  æˆ‘ä»¬éœ€è¦æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå› ä¸ºæ²¡æœ‰ç³»ç»Ÿå­˜åœ¨æˆ–æ— æ³•å­¤ç«‹åœ°å·¥ä½œ-æ‰€æœ‰ç³»ç»Ÿéƒ½éœ€è¦ä»¥å®ƒä»¬éƒ½å¯ä»¥ç†è§£çš„ç»“æ„åŒ–æ–¹å¼å¹¶ä»¥å®ƒä»¬éƒ½å¯ä»¥å¤„ç†çš„å—æ§é€Ÿåº¦ä¸å…¶ä»–ç³»ç»Ÿé€šä¿¡ã€‚ä»»ä½•éå¹³å‡¡çš„æµç¨‹éƒ½éœ€è¦ä¸€ç§åœ¨æµç¨‹çš„å„ä¸ªé˜¶æ®µä¹‹é—´ç§»åŠ¨ä¿¡æ¯çš„æ–¹æ³•ã€‚ä»»ä½•å·¥ä½œæµç¨‹éƒ½éœ€è¦ä¸€ç§åœ¨è¯¥å·¥ä½œæµç¨‹çš„å„ä¸ªé˜¶æ®µä¹‹é—´ç§»åŠ¨ä¸­é—´äº§å“çš„æ–¹æ³•ã€‚æ¶ˆæ¯é˜Ÿåˆ—æ˜¯å¤„ç†æ­¤ç§»åŠ¨çš„å¥½æ–¹æ³•ã€‚æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥ä½¿ç”¨APIâ€‹â€‹è°ƒç”¨ï¼Œæ–‡ä»¶ç³»ç»Ÿæˆ–è®¸å¤šå…¶ä»–å¯¹äº‹ç‰©è‡ªç„¶é¡ºåºçš„æ»¥ç”¨æ¥è·å–è¿™äº›æ¶ˆæ¯ã€‚ä½†æ˜¯æ‰€æœ‰è¿™äº›éƒ½æ˜¯æ¶ˆæ¯é˜Ÿåˆ—çš„ä¸´æ—¶å®ç°ï¼Œæœ‰æ—¶æˆ‘ä»¬æ‹’ç»æ‰¿è®¤æˆ‘ä»¬éœ€è¦è¿™äº›å®ç°ã€‚ </p><p> The simplest mental model for a message queue is a very long tube that you can roll a ball into. You write your message on a ball, roll it into the tube, and someone or something else receives it at the other end. There are a lot of interesting benefits with this model, some of which are:</p><p>æ¶ˆæ¯é˜Ÿåˆ—çš„æœ€ç®€å•æ€ç»´æ¨¡å‹æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„ç®¡ï¼Œæ‚¨å¯ä»¥å°†å®ƒæ‰”è¿›å»ã€‚æ‚¨å°†æ‚¨çš„æ¶ˆæ¯å†™åœ¨ä¸€ä¸ªçƒä¸Šï¼Œå°†å…¶æ»šåŠ¨åˆ°ç®¡å­ä¸­ï¼Œå¦ä¸€ç«¯æ”¶åˆ°æŸäººæˆ–å…¶ä»–ä¸œè¥¿ã€‚è¯¥æ¨¡å‹æœ‰å¾ˆå¤šæœ‰è¶£çš„å¥½å¤„ï¼Œå…¶ä¸­åŒ…æ‹¬ï¼š</p><p> We don&#39;t need to worry about  who or what is going to receive the message â€“ that&#39;s one less responsibility for the sender to be concerned about.</p><p> æˆ‘ä»¬ä¸å¿…æ‹…å¿ƒæ¥æ”¶æ¶ˆæ¯çš„æ˜¯è°æˆ–ä»€ä¹ˆï¼Œè¿™ä½¿å‘ä»¶äººä¸å¿…æ‹…å¿ƒã€‚</p><p> We don&#39;t need to worry about  when the receiver is going to pick up the message.</p><p> æˆ‘ä»¬ä¸å¿…æ‹…å¿ƒæ¥æ”¶æ–¹ä½•æ—¶æ¥æ”¶æ¶ˆæ¯ã€‚</p><p> We can put  as many messages as we want into the tube (let&#39;s assume we have a infinitely long tube) at whatever  speed is comfortable to us.</p><p> æˆ‘ä»¬å¯ä»¥æŒ‰ç…§è‡ªå·±å–œæ¬¢çš„é€Ÿåº¦å°†ä»»æ„æ•°é‡çš„æ¶ˆæ¯æ”¾å…¥ç®¡é“ä¸­ï¼ˆå‡è®¾æˆ‘ä»¬æœ‰æ— é™é•¿çš„ç®¡é“ï¼‰ã€‚</p><p> The receiver will  never be impacted by our actionsâ€”they will pull out as many messages as they want at whatever rate is comfortable to them.</p><p> æ¥æ”¶è€…æ°¸è¿œä¸ä¼šå—åˆ°æˆ‘ä»¬è¡ŒåŠ¨çš„å½±å“-ä»–ä»¬å°†ä»¥ä»–ä»¬å¸Œæœ›çš„ä»»ä½•é€Ÿç‡æ‹‰å‡ºä»»æ„æ•°é‡çš„æ¶ˆæ¯ã€‚</p><p>  Neither the sender nor the receiver are concerned with the  capacity or load of the other.</p><p>  å‘é€æ–¹å’Œæ¥æ”¶æ–¹éƒ½ä¸å…³å¿ƒå¯¹æ–¹çš„å®¹é‡æˆ–è´Ÿè½½ã€‚</p><p> Neither system is concerned with  where the other one is â€“ they may or many not reside on the same computer, network, continent or even the same planet.</p><p> ä¸¤ä¸ªç³»ç»Ÿéƒ½ä¸å…³å¿ƒå¦ä¸€ä¸ªç³»ç»Ÿçš„ä½ç½®â€“å®ƒä»¬å¯èƒ½ä½äºæˆ–ä¸åœ¨åŒä¸€å°è®¡ç®—æœºï¼Œç½‘ç»œï¼Œå¤§é™†æˆ–åŒä¸€æ˜Ÿçƒä¸Šã€‚ </p><p> Each of these advantages (and this isn&#39;t even an exhaustive list) has very important benefits in software developmentâ€”what they all have in common is  decoupling. One system is decoupled from the other in terms of responsibility, time, bandwidth, internal workings, load and geography. And decoupling is a very desirable part of any distributed or complex systemâ€”the more decoupled the parts of the system are, the easier it is to independently build, test, run, maintain and scale them.</p><p>æ‰€æœ‰è¿™äº›ä¼˜ç‚¹ï¼ˆç”šè‡³ä¸æ˜¯è¯¦å°½çš„æ¸…å•ï¼‰åœ¨è½¯ä»¶å¼€å‘ä¸­éƒ½å…·æœ‰éå¸¸é‡è¦çš„å¥½å¤„-å®ƒä»¬çš„å…±åŒç‚¹æ˜¯å»è€¦ã€‚ä¸€ä¸ªç³»ç»Ÿåœ¨èŒè´£ï¼Œæ—¶é—´ï¼Œå¸¦å®½ï¼Œå†…éƒ¨å·¥ä½œæ–¹å¼ï¼Œè´Ÿè½½å’Œåœ°ç†ä½ç½®æ–¹é¢ä¸å¦ä¸€ä¸ªç³»ç»Ÿæ˜¯åˆ†ç¦»çš„ã€‚è§£è€¦æ˜¯ä»»ä½•åˆ†å¸ƒå¼æˆ–å¤æ‚ç³»ç»Ÿä¸­éå¸¸éœ€è¦çš„éƒ¨åˆ†-ç³»ç»Ÿå„éƒ¨åˆ†ä¹‹é—´çš„è§£è€¦è¶Šå¤šï¼Œç‹¬ç«‹æ„å»ºï¼Œæµ‹è¯•ï¼Œè¿è¡Œï¼Œç»´æŠ¤å’Œæ‰©å±•å®ƒä»¬å°±è¶Šå®¹æ˜“ã€‚</p><p> Most systems interact with other outside or third-party systems as wellâ€”if we build a shopping site we might interact with a payment processor, and letâ€™s say we attempt to directly communicate with the payment processor on each user click. If our system is under heavy load, we&#39;re also subjecting the other system to the same load. And vice versaâ€”if our payment provider needs to send us millions of pieces of information about our past payment statues, our system better be ready. The two systems are now  coupled. The decisions and actions made by one system have a significant impact on the other, so the needs of both need to be taken into account while making every decision. Add enough other systems into the mix, like logistics or delivery systems, and we quickly have a paralysing mess that makes it difficult to decide anything at all. If one system goes down, the other systems have effectively gone down as well, for no fault of their own.</p><p> å¤§å¤šæ•°ç³»ç»Ÿä¹Ÿå¯ä»¥ä¸å…¶ä»–å¤–éƒ¨æˆ–ç¬¬ä¸‰æ–¹ç³»ç»Ÿè¿›è¡Œäº¤äº’-å¦‚æœæˆ‘ä»¬å»ºç«‹è´­ç‰©ç½‘ç«™ï¼Œåˆ™å¯èƒ½ä¼šä¸æ”¯ä»˜å¤„ç†å™¨è¿›è¡Œäº¤äº’ï¼Œå¹¶ä¸”å‡è®¾æˆ‘ä»¬å°è¯•åœ¨æ¯æ¬¡ç”¨æˆ·ç‚¹å‡»æ—¶ç›´æ¥ä¸æ”¯ä»˜å¤„ç†å™¨è¿›è¡Œé€šä¿¡ã€‚å¦‚æœæˆ‘ä»¬çš„ç³»ç»Ÿè´Ÿè½½è¿‡é‡ï¼Œæˆ‘ä»¬è¿˜ä¼šä½¿å¦ä¸€ä¸ªç³»ç»Ÿæ‰¿å—ç›¸åŒçš„è´Ÿè½½ã€‚åä¹‹äº¦ç„¶-å¦‚æœæˆ‘ä»¬çš„ä»˜æ¬¾æä¾›å•†éœ€è¦å‘æˆ‘ä»¬å‘é€æ•°ç™¾ä¸‡æ¡æœ‰å…³è¿‡å»ä»˜æ¬¾æ–¹å¼çš„ä¿¡æ¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ç³»ç»Ÿå°±æ›´å¥½äº†ã€‚è¿™ä¸¤ä¸ªç³»ç»Ÿç°åœ¨å·²è€¦åˆã€‚ä¸€ä¸ªç³»ç»Ÿåšå‡ºçš„å†³å®šå’ŒåŠ¨ä½œä¼šå¯¹å¦ä¸€ä¸ªç³»ç»Ÿäº§ç”Ÿé‡å¤§å½±å“ï¼Œå› æ­¤åœ¨åšå‡ºæ¯ä¸ªå†³å®šæ—¶éƒ½å¿…é¡»è€ƒè™‘åˆ°ä¸¤è€…çš„éœ€æ±‚ã€‚å°†è¶³å¤Ÿå¤šçš„å…¶ä»–ç³»ç»Ÿï¼ˆä¾‹å¦‚ç‰©æµæˆ–äº¤ä»˜ç³»ç»Ÿï¼‰æ·»åŠ åˆ°ç»„åˆä¸­ï¼Œæˆ‘ä»¬å¾ˆå¿«å°±ä¼šé™·å…¥ç˜«ç—ªçŠ¶æ€ï¼Œè¿™ä½¿å¾—æ ¹æœ¬æ— æ³•å†³å®šä»»ä½•äº‹æƒ…ã€‚å¦‚æœä¸€ä¸ªç³»ç»Ÿå‘ç”Ÿæ•…éšœï¼Œåˆ™å…¶ä»–ç³»ç»Ÿä¹Ÿæœ‰æ•ˆåœ°å‘ç”Ÿæ•…éšœï¼Œè€Œå®ƒä»¬æœ¬èº«æ²¡æœ‰æ•…éšœã€‚</p><p> Weâ€™re also in trouble if we want to switch out any one of these systems for another one, like a new payment processor or delivery system. Weâ€™d have to make deep changes in multiple places in our application, and itâ€™s even more difficult to build code to split our messages between multiple providersâ€”we may want to use a ratio to load balance them or split them by geography; or dynamically switch between them based on each providerâ€™s availability or cost.</p><p> å¦‚æœæˆ‘ä»¬æƒ³å°†è¿™äº›ç³»ç»Ÿä¸­çš„ä»»ä½•ä¸€ä¸ªåˆ‡æ¢ä¸ºå¦ä¸€ä¸ªç³»ç»Ÿï¼Œä¾‹å¦‚æ–°çš„ä»˜æ¬¾å¤„ç†å™¨æˆ–äº¤ä»˜ç³»ç»Ÿï¼Œä¹Ÿä¼šé‡åˆ°éº»çƒ¦ã€‚æˆ‘ä»¬å¿…é¡»åœ¨åº”ç”¨ç¨‹åºçš„å¤šä¸ªä½ç½®è¿›è¡Œæ·±åˆ»çš„æ›´æ”¹ï¼Œæ„å»ºä»£ç ä»¥åœ¨å¤šä¸ªæä¾›å•†ä¹‹é—´æ‹†åˆ†æ¶ˆæ¯ç”šè‡³æ›´åŠ å›°éš¾ã€‚æˆ‘ä»¬å¯èƒ½éœ€è¦ä½¿ç”¨æ¯”ç‡æ¥è´Ÿè½½å‡è¡¡å®ƒä»¬æˆ–æŒ‰åœ°ç†ä½ç½®æ‹†åˆ†å®ƒä»¬ï¼›æˆ–æ ¹æ®æ¯ä¸ªæä¾›å•†çš„å¯ç”¨æ€§æˆ–æˆæœ¬åœ¨å®ƒä»¬ä¹‹é—´åŠ¨æ€åˆ‡æ¢ã€‚</p><p> Message queues offer the decoupling that solves a lot of these problems. If we set up a queue between two systems that need to communicate with each other, they can now go about their work without having to worry about each other at allâ€”we put our messages aimed at any system into a queue, and we expect information from the other system to come to us through another queue as well. We now have clear points at which we can add rules or make the changes we require, without either system knowing or caring about what&#39;s different.</p><p> æ¶ˆæ¯é˜Ÿåˆ—æä¾›äº†è§£å†³è®¸å¤šè¿™äº›é—®é¢˜çš„è§£è€¦åŠŸèƒ½ã€‚å¦‚æœæˆ‘ä»¬åœ¨ä¸¤ä¸ªéœ€è¦ç›¸äº’é€šä¿¡çš„ç³»ç»Ÿä¹‹é—´å»ºç«‹ä¸€ä¸ªé˜Ÿåˆ—ï¼Œé‚£ä¹ˆä»–ä»¬ç°åœ¨å°±å¯ä»¥ç»§ç»­å·¥ä½œè€Œä¸å¿…æ‹…å¿ƒå½¼æ­¤â€”æˆ‘ä»¬å°†é’ˆå¯¹ä»»ä½•ç³»ç»Ÿçš„æ¶ˆæ¯æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œæˆ‘ä»¬æœŸæœ›è·å¾—ä¿¡æ¯ä¹Ÿå¯ä»¥é€šè¿‡å¦ä¸€ä¸ªé˜Ÿåˆ—æ¥è®¿é—®æˆ‘ä»¬ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æœ‰äº†æ˜ç¡®çš„è¦ç‚¹ï¼Œå¯ä»¥åœ¨å…¶ä¸­æ·»åŠ è§„åˆ™æˆ–è¿›è¡Œæ‰€éœ€çš„æ›´æ”¹ï¼Œè€Œæ— éœ€ç³»ç»Ÿäº†è§£æˆ–å…³å¿ƒä¸åŒä¹‹å¤„ã€‚</p><p>  Are message queues the holy grail of computing, though? Do they solve all the world&#39;s problems? No, of course not. There are plenty of situations where we might not want to use them. And we certainly don&#39;t want to use a queue just because we have one easily available and think it might be fun. There are some systems that are really simple that just don&#39;t require itâ€”a message queue is a way to reduce to complexity of communicating systems, but two communicating systems will always be more complex than one system that doesn&#39;t have to communicate. If you have a system thatâ€™s simple enough to not require communication with any others, there simply isn&#39;t any reason to reach for a queue.</p><p>  æ¶ˆæ¯é˜Ÿåˆ—æ˜¯è®¡ç®—çš„åœ£æ¯å—ï¼Ÿä»–ä»¬æ˜¯å¦è§£å†³äº†ä¸–ç•Œä¸Šæ‰€æœ‰çš„é—®é¢˜ï¼Ÿä¸ï¼Œå½“ç„¶ä¸ã€‚åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½ä¸æƒ³ä½¿ç”¨å®ƒä»¬ã€‚è€Œä¸”æˆ‘ä»¬å½“ç„¶ä¸å¸Œæœ›ä»…ä»…å› ä¸ºæˆ‘ä»¬æœ‰ä¸€ä¸ªå®¹æ˜“ä½¿ç”¨çš„é˜Ÿåˆ—è€Œè®¤ä¸ºä½¿ç”¨é˜Ÿåˆ—å¾ˆæœ‰è¶£ã€‚æœ‰äº›ç³»ç»ŸçœŸçš„å¾ˆç®€å•ï¼Œåªæ˜¯ä¸éœ€è¦å®ƒâ€”æ¶ˆæ¯é˜Ÿåˆ—æ˜¯ä¸€ç§é™ä½é€šä¿¡ç³»ç»Ÿå¤æ‚æ€§çš„æ–¹æ³•ï¼Œä½†æ˜¯ä¸¤ä¸ªé€šä¿¡ç³»ç»Ÿæ€»æ˜¯æ¯”ä¸€ä¸ªä¸éœ€è¦é€šä¿¡ç³»ç»Ÿæ›´å¤æ‚ã€‚å¿…é¡»æ²Ÿé€šã€‚å¦‚æœæ‚¨çš„ç³»ç»Ÿéå¸¸ç®€å•ï¼Œä¸éœ€è¦ä¸å…¶ä»–ä»»ä½•äººè¿›è¡Œé€šä¿¡ï¼Œé‚£ä¹ˆæ ¹æœ¬å°±æ²¡æœ‰ä»»ä½•ç†ç”±æ’é˜Ÿã€‚</p><p> There are also systems that communicate with each other, but where the complexity added by that communication added is insignificant and not worth worrying about. Or more often the systems are already coupled, in the sense that they all need to work together to function. A really common example is an application server and a data service (in an  OLTP system). There&#39;s not much point in decoupling them with a queue, because neither can do anything useful without the direct involvement of the other.</p><p> ä¹Ÿæœ‰ä¸€äº›ç³»ç»Ÿå¯ä»¥äº’ç›¸é€šä¿¡ï¼Œä½†æ˜¯è¿™äº›é€šä¿¡æ‰€å¢åŠ çš„å¤æ‚æ€§å¾®ä¸è¶³é“ï¼Œå› æ­¤ä¸å¿…æ‹…å¿ƒã€‚ä»æŸç§æ„ä¹‰ä¸Šè¯´ï¼Œå®ƒä»¬éƒ½éœ€è¦ååŒå·¥ä½œæ‰èƒ½æ­£å¸¸è¿è¡Œï¼Œæˆ–è€…æ›´ç»å¸¸åœ°ï¼Œç³»ç»Ÿå·²ç»è€¦åˆã€‚ä¸€ä¸ªçœŸæ­£å¸¸è§çš„ç¤ºä¾‹æ˜¯åº”ç”¨æœåŠ¡å™¨å’Œæ•°æ®æœåŠ¡ï¼ˆåœ¨OLTPç³»ç»Ÿä¸­ï¼‰ã€‚å°†å®ƒä»¬ä¸é˜Ÿåˆ—è§£è€¦æ²¡æœ‰å¤šå¤§æ„ä¹‰ï¼Œå› ä¸ºå¦‚æœæ²¡æœ‰å¦ä¸€ä¸ªçš„ç›´æ¥å‚ä¸ï¼Œè¿™ä¸¤ä¸ªéƒ½æ— æ³•åšä»»ä½•æœ‰ç”¨çš„äº‹æƒ…ã€‚</p><p> Then there&#39;s performance to consider as wellâ€”the whole point of decoupling two systems with regards to time and load is so that they can each process information at their own paceâ€”but we certainly would  not want this to happen in performance sensitive applications or real-time systems. A queue might help us process more work at the same time (the receiver might have many processes working in parallel on the messages you send) but will remove any guarantees we need about the exact time taken for each piece of work. If predictability is more important than throughput, we&#39;re better off without a queue.</p><p> ç„¶åï¼Œè¿˜è¦è€ƒè™‘æ€§èƒ½-å°†ä¸¤ä¸ªç³»ç»Ÿåœ¨æ—¶é—´å’Œè´Ÿè½½æ–¹é¢è§£è€¦çš„é‡ç‚¹æ˜¯ï¼Œä»¥ä¾¿å®ƒä»¬å¯ä»¥æŒ‰ç…§è‡ªå·±çš„è¿›åº¦å¤„ç†ä¿¡æ¯-ä½†æˆ‘ä»¬å½“ç„¶ä¸å¸Œæœ›è¿™ç§æƒ…å†µåœ¨æ€§èƒ½æ•æ„Ÿçš„æƒ…å†µä¸‹å‘ç”Ÿåº”ç”¨ç¨‹åºæˆ–å®æ—¶ç³»ç»Ÿã€‚é˜Ÿåˆ—å¯ä»¥å¸®åŠ©æˆ‘ä»¬åŒæ—¶å¤„ç†æ›´å¤šçš„å·¥ä½œï¼ˆæ¥æ”¶è€…å¯èƒ½æœ‰è®¸å¤šå¹¶è¡Œå¤„ç†æ‚¨å‘é€çš„æ¶ˆæ¯çš„å·¥ä½œï¼‰ï¼Œä½†ä¼šæ¶ˆé™¤æˆ‘ä»¬å¯¹æ¯é¡¹å·¥ä½œæ‰€éœ€çš„ç¡®åˆ‡æ—¶é—´çš„ä¿è¯ã€‚å¦‚æœå¯é¢„æµ‹æ€§æ¯”ååé‡æ›´é‡è¦ï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ€å¥½ä¸è¦æ’é˜Ÿã€‚ </p><p> Using a queue might increase the time taken to process each  individual message, but will allow you process many more messages at the same time across different computersâ€”so your total number of messages processed per minute or hour, or  throughput, will increase.</p><p>ä½¿ç”¨é˜Ÿåˆ—å¯èƒ½ä¼šå¢åŠ å¤„ç†æ¯æ¡å•ä¸ªæ¶ˆæ¯æ‰€èŠ±è´¹çš„æ—¶é—´ï¼Œä½†æ˜¯å°†å…è®¸æ‚¨åœ¨ä¸åŒçš„è®¡ç®—æœºä¸ŠåŒæ—¶å¤„ç†æ›´å¤šçš„æ¶ˆæ¯-å› æ­¤ï¼Œæ¯åˆ†é’Ÿæˆ–æ¯å°æ—¶å¤„ç†çš„æ¶ˆæ¯æ€»æ•°æˆ–ååé‡å°†å¢åŠ ã€‚</p><p> If we do have multiple systems that need to communicate, and that communication needs to be  durable (if weâ€™ve put a message into a queue, we want to be sure that the messaging system isnâ€™t going to â€˜forgetâ€™ about it) and decoupled, a message queue is indispensable.</p><p> å¦‚æœç¡®å®æœ‰å¤šä¸ªéœ€è¦é€šä¿¡çš„ç³»ç»Ÿï¼Œå¹¶ä¸”é€šä¿¡éœ€è¦æŒä¹…ï¼ˆå¦‚æœå°†æ¶ˆæ¯æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œæˆ‘ä»¬è¦ç¡®ä¿æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿä¸ä¼šâ€œå¿˜è®°â€å®ƒï¼‰å¹¶ä¸”è§£è€¦åï¼Œæ¶ˆæ¯é˜Ÿåˆ—å¿…ä¸å¯å°‘ã€‚</p><p>  There&#39;s simply no way to learn about message queues without reading and/or arguing about delivery guarantees and semantics, so we might as well get to that quickly. People who build message queues will claim that their system offers one of three delivery guaranteesâ€”that each message you put into the queue will be delivered:</p><p>  åœ¨æ²¡æœ‰é˜…è¯»å’Œ/æˆ–äº‰è®ºä¼ é€’ä¿è¯å’Œè¯­ä¹‰çš„æƒ…å†µä¸‹ï¼Œæ ¹æœ¬æ— æ³•äº†è§£æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå› æ­¤æˆ‘ä»¬ä¹Ÿå¯ä»¥å¾ˆå¿«åœ°äº†è§£å®ƒã€‚å»ºç«‹æ¶ˆæ¯é˜Ÿåˆ—çš„äººå°†å£°ç§°ä»–ä»¬çš„ç³»ç»Ÿæä¾›äº†ä¸‰ç§ä¼ é€’ä¿è¯ä¹‹ä¸€ï¼Œå³æ‚¨æ”¾å…¥é˜Ÿåˆ—ä¸­çš„æ¯æ¡æ¶ˆæ¯éƒ½å°†è¢«ä¼ é€’ï¼š</p><p>  Which guarantees we&#39;re using will have a massive impact on the design and working of our system, so let&#39;s unpack each of them one by one.</p><p>  è¿™ä¿è¯äº†æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨è¯¥è½¯ä»¶å°†å¯¹æˆ‘ä»¬ç³»ç»Ÿçš„è®¾è®¡å’Œå·¥ä½œäº§ç”Ÿå·¨å¤§å½±å“ï¼Œå› æ­¤è®©æˆ‘ä»¬å°†å®ƒä»¬ä¸­çš„æ¯ä¸€ä¸ªéƒ½æ‹†åŒ…ã€‚</p><p>  This is the most common delivery mechanism, and it&#39;s the simplest to reason about and implement. If I have a message for you, I will read it to you, and keep doing so again and again until you acknowledge it. That&#39;s it. In a system which works on an at-least-once basis, this means that when you receive a message from the queue and don&#39;t delete/acknowledge it, you will receive it again in the future, and will keep receiving it until you explicitly delete/acknowledge it.</p><p>  è¿™æ˜¯æœ€å¸¸è§çš„äº¤ä»˜æœºåˆ¶ï¼Œä¹Ÿæ˜¯æœ€ç®€å•çš„æ¨ç†å’Œå®æ–½æœºåˆ¶ã€‚å¦‚æœæˆ‘æœ‰ä¸€æ¡è¦ç»™æ‚¨çš„æ¶ˆæ¯ï¼Œæˆ‘ä¼šç»™æ‚¨æœ—è¯»ï¼Œå¹¶ä¸æ–­åå¤ï¼Œç›´åˆ°æ‚¨ç¡®è®¤ä¸ºæ­¢ã€‚å°±æ˜¯è¿™æ ·ã€‚åœ¨è‡³å°‘ä¸€æ¬¡è¿è¡Œçš„ç³»ç»Ÿä¸­ï¼Œè¿™æ„å‘³ç€å½“æ‚¨ä»é˜Ÿåˆ—ä¸­æ”¶åˆ°ä¸€æ¡æ¶ˆæ¯å¹¶ä¸”ä¸åˆ é™¤/ç¡®è®¤è¯¥æ¶ˆæ¯æ—¶ï¼Œæ‚¨å°†æ¥ä¼šå†æ¬¡æ”¶åˆ°å®ƒï¼Œå¹¶å°†ç»§ç»­æ¥æ”¶å®ƒç›´åˆ°æ‚¨æ˜ç¡®åˆ é™¤/ç¡®è®¤å®ƒä¸ºæ­¢ã€‚</p><p> The reason this is the most common guarantee is that it&#39;s simple and gets the job done 100% of the timeâ€”there&#39;s no edge case in which the message gets lost. Even if the receiver crashes before acknowledging the message, it will simply receive the same message again. The flip side is that you as the receiver need to plan on receiving the same message multiple timesâ€”even if you haven&#39;t necessarily experienced a crash. This is because offering at-least-once is the simplest way to protect the queueing service from missing out messages as wellâ€”if your acknowledgement doesn&#39;t reach the queueing system over the network, the message will be sent again. If there&#39;s a problem persisting your acknowledgement, the message will be sent again. If the queuing system restarts before it can properly keep track of what&#39;s been sent to you, the message will be sent again. This simple remedy of sending the message again in case of any problem on any side is what makes this guarantee so reliable.</p><p> è¿™æ˜¯æœ€å¸¸è§çš„ä¿è¯ï¼Œæ˜¯å› ä¸ºå®ƒå¾ˆç®€å•å¹¶ä¸”å¯ä»¥100ï¼…åœ°å®Œæˆå·¥ä½œ-ä¸ä¼šå‡ºç°æ¶ˆæ¯ä¸¢å¤±çš„æƒ…å†µã€‚å³ä½¿æ¥æ”¶å™¨åœ¨ç¡®è®¤æ¶ˆæ¯ä¹‹å‰å´©æºƒäº†ï¼Œå®ƒä¹Ÿåªä¼šå†æ¬¡æ¥æ”¶ç›¸åŒçš„æ¶ˆæ¯ã€‚ä¸åˆ©çš„ä¸€é¢æ˜¯ï¼Œä½œä¸ºæ¥æ”¶æ–¹çš„æ‚¨éœ€è¦è®¡åˆ’å¤šæ¬¡æ¥æ”¶åŒä¸€æ¡æ¶ˆæ¯ï¼Œå³ä½¿æ‚¨ä¸ä¸€å®šé‡åˆ°å´©æºƒä¹Ÿæ˜¯å¦‚æ­¤ã€‚è¿™æ˜¯å› ä¸ºè‡³å°‘æä¾›ä¸€æ¬¡æ˜¯ä¿æŠ¤æ’é˜ŸæœåŠ¡ä¹Ÿä¸ä¼šä¸¢å¤±æ¶ˆæ¯çš„æœ€ç®€å•æ–¹æ³•-å¦‚æœæ‚¨çš„ç¡®è®¤æ²¡æœ‰é€šè¿‡ç½‘ç»œåˆ°è¾¾æ’é˜Ÿç³»ç»Ÿï¼Œåˆ™æ¶ˆæ¯å°†å†æ¬¡å‘é€ã€‚å¦‚æœä»ç„¶å­˜åœ¨æ‚¨çš„ç¡®è®¤é—®é¢˜ï¼Œè¯¥æ¶ˆæ¯å°†å†æ¬¡å‘é€ã€‚å¦‚æœæ’é˜Ÿç³»ç»Ÿåœ¨é‡æ–°å¯åŠ¨ä¹‹å‰å¯ä»¥æ­£ç¡®è·Ÿè¸ªå·²å‘é€ç»™æ‚¨çš„å†…å®¹ï¼Œåˆ™è¯¥æ¶ˆæ¯å°†å†æ¬¡å‘é€ã€‚åœ¨ä»»ä½•æ–¹é¢å‡ºç°ä»»ä½•é—®é¢˜çš„æƒ…å†µä¸‹ï¼Œå†æ¬¡å‘é€æ¶ˆæ¯çš„ç®€å•è¡¥æ•‘æªæ–½å°±æ˜¯ä½¿æ­¤ä¿è¯å¦‚æ­¤å¯é ã€‚</p><p> But is message duplication/repetition a problem? That&#39;s really up to you and your application or use-case. If the message is a timestamp and a measurement, for example, there&#39;s no problem with receiving a million duplicates. But if you&#39;re moving money based on the messages, it definitely is a problem. In these cases you&#39;ll need to have a transactional (ACID) database at the receiving end, and maybe record the message ID in a unique index so that it can&#39;t be repeated. This is called using an  idempotency token or  tombstoneâ€”when you act on a message you store a unique permanent marker to keep track of your actions, often in the same database transaction as taking the action itself. The prevents you from repeating that action again even if the message is duplicated.</p><p> ä½†æ˜¯æ¶ˆæ¯é‡å¤/é‡å¤æ˜¯ä¸€ä¸ªé—®é¢˜å—ï¼Ÿè¿™å®é™…ä¸Šå–å†³äºæ‚¨å’Œæ‚¨çš„åº”ç”¨ç¨‹åºæˆ–ç”¨ä¾‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè¯¥æ¶ˆæ¯æ˜¯æ—¶é—´æˆ³å’Œåº¦é‡ï¼Œåˆ™æ¥æ”¶ä¸€ç™¾ä¸‡ä¸ªå‰¯æœ¬æ²¡æœ‰é—®é¢˜ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨æ ¹æ®æ¶ˆæ¯è½¬ç§»èµ„é‡‘ï¼Œé‚£è‚¯å®šæ˜¯ä¸€ä¸ªé—®é¢˜ã€‚åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œæ‚¨å°†éœ€è¦åœ¨æ¥æ”¶ç«¯å»ºç«‹ä¸€ä¸ªäº‹åŠ¡ï¼ˆACIDï¼‰æ•°æ®åº“ï¼Œå¹¶å¯èƒ½å°†æ¶ˆæ¯IDè®°å½•åœ¨å”¯ä¸€çš„ç´¢å¼•ä¸­ï¼Œä»¥ä½¿å…¶æ— æ³•é‡å¤ã€‚è¿™ç§°ä¸ºä½¿ç”¨å¹‚ç­‰æ ‡è®°æˆ–é€»è¾‘åˆ é™¤-å½“æ‚¨å¯¹æ¶ˆæ¯è¿›è¡Œæ“ä½œæ—¶ï¼Œæ‚¨é€šå¸¸ä¼šåœ¨ä¸æ‰§è¡Œæ“ä½œæœ¬èº«ç›¸åŒçš„æ•°æ®åº“äº‹åŠ¡ä¸­å­˜å‚¨å”¯ä¸€çš„æ°¸ä¹…æ ‡è®°æ¥è·Ÿè¸ªæ‚¨çš„æ“ä½œã€‚å³ä½¿é‚®ä»¶é‡å¤ï¼Œä¹Ÿä¼šé˜»æ­¢æ‚¨å†æ¬¡é‡å¤è¯¥æ“ä½œã€‚ </p><p> If you handle duplication, or if your messages are naturally resistant to duplication, your systems are said to be  idempotent. This means you can safely handle receiving the same message multiple times, without corrupting your work. It also often means you can tolerate the sender sending the same message multiple timesâ€”remember that senders will usually operate on the at-least-once principle when sending messages as well. If senders are unable to record the fact that they&#39;ve sent a particular message, they&#39;ll simply send it again. The senders are then responsible for making sure that they use the same tombstone or idempotency token if and when they re-send messages.</p><p>å¦‚æœæ‚¨å¤„ç†é‡å¤ï¼Œæˆ–è€…æ‚¨çš„æ¶ˆæ¯å¤©ç”Ÿå°±å¯ä»¥æŠµæŠ—é‡å¤ï¼Œåˆ™å¯ä»¥è¯´æ‚¨çš„ç³»ç»Ÿæ˜¯å¹‚ç­‰çš„ã€‚è¿™æ„å‘³ç€æ‚¨å¯ä»¥å®‰å…¨åœ°å¤„ç†å¤šæ¬¡æ”¶åˆ°ç›¸åŒçš„æ¶ˆæ¯ï¼Œè€Œä¸ä¼šç ´åæ‚¨çš„å·¥ä½œã€‚è¿™é€šå¸¸ä¹Ÿæ„å‘³ç€æ‚¨å¯ä»¥å®¹å¿å‘ä»¶äººå¤šæ¬¡å‘é€ç›¸åŒçš„æ¶ˆæ¯-è¯·è®°ä½ï¼Œå‘ä»¶äººåœ¨å‘é€æ¶ˆæ¯æ—¶é€šå¸¸ä¹Ÿå°†è‡³å°‘ä¸€æ¬¡æ‰§è¡Œä¸€æ¬¡æ“ä½œã€‚å¦‚æœå‘ä»¶äººæ— æ³•è®°å½•ä»–ä»¬å·²å‘é€ç‰¹å®šæ¶ˆæ¯çš„äº‹å®ï¼Œåˆ™åªéœ€å†æ¬¡å‘é€å³å¯ã€‚ç„¶åï¼Œå‘ä»¶äººæœ‰è´£ä»»ç¡®ä¿åœ¨é‡æ–°å‘é€é‚®ä»¶æ—¶ä½¿ç”¨ç›¸åŒçš„å¢“ç¢‘æˆ–å¹‚ç­‰ä»¤ç‰Œã€‚</p><p>  This is a pretty rare semantic, used for messages where duplication is so horribly explosive (or the message so utterly unimportant) that we&#39;d prefer not to send the message at all, rather than send it twice. At-most-once once implies that the queuing system will attempt to deliver the message to you once, but that&#39;s it. If you receive and acknowledge the message all is well, but if you don&#39;t, or anything goes wrong, that message will be lost foreverâ€”either because the queuing system has taken great pains to record the delivery to you before attempting to send it (in case the message is horribly explosive), or has not even bothered to record the message at all, and is just passing it on like a router passes on a UDP packet.</p><p>  è¿™æ˜¯ä¸€ç§éå¸¸å°‘è§çš„è¯­ä¹‰ï¼Œç”¨äºé‡å¤éå¸¸å¯æ€•çš„æ¶ˆæ¯ï¼ˆæˆ–è€…æ¶ˆæ¯æ ¹æœ¬ä¸é‡è¦ï¼‰ï¼Œä»¥è‡³äºæˆ‘ä»¬ä¸å¸Œæœ›æ ¹æœ¬ä¸å‘é€æ¶ˆæ¯ï¼Œè€Œä¸æ˜¯å‘é€ä¸¤æ¬¡ã€‚æœ€å¤šä¸€æ¬¡è¡¨ç¤ºæ’é˜Ÿç³»ç»Ÿå°†å°è¯•ä¸€æ¬¡å°†æ¶ˆæ¯ä¼ é€’ç»™æ‚¨ï¼Œä½†ä»…æ­¤è€Œå·²ã€‚å¦‚æœæ‚¨æ”¶åˆ°å¹¶ç¡®è®¤è¯¥æ¶ˆæ¯ä¸€åˆ‡éƒ½å¾ˆå¥½ï¼Œä½†æ˜¯å¦‚æœæ‚¨ä¸è¿™æ ·åšæˆ–æœ‰ä»»ä½•é”™è¯¯ï¼Œåˆ™è¯¥æ¶ˆæ¯å°†æ°¸è¿œä¸¢å¤±-è¦ä¹ˆæ˜¯å› ä¸ºæ’é˜Ÿç³»ç»Ÿè´¹äº†å¾ˆå¤§çš„åŠ²æ‰èƒ½åœ¨å°è¯•å‘é€ä¹‹å‰è®°å½•ä¸‹å‘æ‚¨çš„ä¼ é€’å‘é€å®ƒï¼ˆä»¥é˜²è¯¥æ¶ˆæ¯å…·æœ‰æƒŠäººçš„çˆ†ç‚¸æ€§ï¼‰ï¼Œæˆ–è€…æ ¹æœ¬ä¸ç”¨å»è®°å½•è¯¥æ¶ˆæ¯ï¼Œå°±åƒè·¯ç”±å™¨åœ¨UDPæ•°æ®åŒ…ä¸Šä¼ é€’ä¸€æ ·ï¼Œåªæ˜¯åœ¨ä¼ é€’å®ƒã€‚</p><p> This semantic usually comes into play for messaging systems that are either acting as stateless information routers; or in those cases where a repeat message is so destructive that an investigation or reconciliation is necessary in case there&#39;s any failure.</p><p> è¿™ç§è¯­ä¹‰é€šå¸¸åœ¨å……å½“æ— çŠ¶æ€ä¿¡æ¯è·¯ç”±å™¨çš„æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿä¸­èµ·ä½œç”¨ã€‚æˆ–è€…åœ¨é‡å¤æ¶ˆæ¯å…·æœ‰ç ´åæ€§çš„æƒ…å†µä¸‹ï¼Œä»¥é˜²ä¸‡ä¸€å‘ç”Ÿä»»ä½•æ•…éšœæ—¶å¿…é¡»è¿›è¡Œè°ƒæŸ¥æˆ–å¯¹å¸ã€‚</p><p>  This is the holy grail of messaging, and also the fountain of a lot of snake-oil. It implies that every message is guaranteed to be delivered and processed exactly once, no more and no less. Everyone who builds or uses distributed systems has a point in their lives where they think â€œhow hard can this be?â€, and then they either (1) learn why it&#39;s impossible, figure out idempotency, and use at-least-once, or (2) they try to build a half-assed â€œexactly-onceâ€ system and sell it for lots of money to those who haven&#39;t figured out (1) yet.</p><p>  è¿™æ˜¯æ¶ˆæ¯ä¼ é€’çš„åœ£æ¯ï¼Œä¹Ÿæ˜¯è®¸å¤šè›‡æ²¹çš„æºæ³‰ã€‚è¿™æ„å‘³ç€ä¿è¯æ¯æ¡æ¶ˆæ¯éƒ½åªå‘é€ä¸€æ¬¡ï¼Œå¤„ç†ä¸€æ¬¡ï¼Œæœ€å¤šä¹Ÿä¸ä¼šå‡å°‘ã€‚æ„å»ºæˆ–ä½¿ç”¨åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ¯ä¸ªäººåœ¨ç”Ÿæ´»ä¸­éƒ½æœ‰ä¸€ä¸ªè§‚ç‚¹ï¼Œä»–ä»¬è®¤ä¸ºâ€œè¿™æœ‰å¤šéš¾ï¼Ÿâ€ï¼Œç„¶åä»–ä»¬è¦ä¹ˆï¼ˆ1ï¼‰äº†è§£ä¸ºä»€ä¹ˆè¿™æ˜¯ä¸å¯èƒ½çš„ï¼Œæ‰¾å‡ºå¹‚ç­‰æ€§ï¼Œç„¶åè‡³å°‘ä½¿ç”¨-ä¸€æ¬¡ï¼Œæˆ–ï¼ˆ2ï¼‰ä»–ä»¬å°è¯•å»ºç«‹ä¸€ä¸ªåŠç¡®å®šçš„â€œå®Œå…¨ä¸€æ¬¡â€ç³»ç»Ÿï¼Œå¹¶ä»¥é«˜ä»·å°†å…¶å‡ºå”®ç»™å°šæœªå¼„æ¸…ï¼ˆ1ï¼‰çš„é‚£äº›äººã€‚</p><p>   If you think about the problem deeply, there are a lot of things that can go wrong:</p><p>   å¦‚æœæ‚¨æ·±å…¥æ€è€ƒé—®é¢˜ï¼Œé‚£ä¹ˆå¾ˆå¤šäº‹æƒ…éƒ½ä¼šå‡ºé”™ï¼š</p><p> the acknowledgement that the messaging system has recorded the message might not reach the sender over the network</p><p> é‚®ä»¶ç³»ç»Ÿå·²è®°å½•é‚®ä»¶çš„ç¡®è®¤å¯èƒ½æ— æ³•é€šè¿‡ç½‘ç»œåˆ°è¾¾å‘ä»¶äºº</p><p> the sender might not be able to record the acknowledgement that the messaging system has received the message</p><p> å‘ä»¶äººå¯èƒ½æ— æ³•è®°å½•æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿå·²æ”¶åˆ°æ¶ˆæ¯çš„ç¡®è®¤ </p><p> Let&#39;s say all goes well while sending the messageâ€”when the messaging system tries to deliver the message to the receiver:</p><p>å‡è®¾å‘é€æ¶ˆæ¯æ—¶ä¸€åˆ‡é¡ºåˆ©-å½“æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿå°è¯•å°†æ¶ˆæ¯ä¼ é€’ç»™æ¥æ”¶è€…æ—¶ï¼š</p><p> the messaging systemâ€™s database might not be able to record that the message has been delivered</p><p> é‚®ä»¶ç³»ç»Ÿçš„æ•°æ®åº“å¯èƒ½æ— æ³•è®°å½•é‚®ä»¶å·²ä¼ é€’</p><p> Given all the things that can go wrong, it&#39;s impossible for any messaging system to guarantee exactly-once delivery. Even if the messaging system is godlike in its perfection, most of the things that can go wrong are outside of it or in the interconnecting networks. Some systems do attempt to use the phrase â€œexactly onceâ€ anyway, usually because they claim their implementation will never have any of the messaging system problems mentioned aboveâ€”but that doesn&#39;t mean the whole system is magically blessed with exactly-once semantics, even if the claims are actually true. It usually means that the queuing system has some form of ordering, locking, hashing, timers and idempotency tokens that will ensure it never re-delivers a messsage that&#39;s already been deleted/acknowledgedâ€”but this doesn&#39;t mean that the whole system including publisher + queue + subscriber has gained full exactly-once guarantees.</p><p> è€ƒè™‘åˆ°æ‰€æœ‰å¯èƒ½å‡ºé”™çš„åœ°æ–¹ï¼Œä»»ä½•æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿéƒ½ä¸å¯èƒ½ä¿è¯ä¸€æ¬¡å‘é€ã€‚å³ä½¿æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿå®Œç¾æ— ç‘•ï¼Œå¤§å¤šæ•°å¯èƒ½å‡ºé—®é¢˜çš„åœ°æ–¹è¿˜æ˜¯åœ¨æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿä¹‹å¤–æˆ–åœ¨äº’è¿ç½‘ç»œä¸­ã€‚æŸäº›ç³»ç»Ÿç¡®å®å°è¯•ä½¿ç”¨â€œä»…ä¸€æ¬¡â€ä¸€è¯ï¼Œé€šå¸¸æ˜¯å› ä¸ºå®ƒä»¬å£°ç§°å…¶å®ç°ç»ä¸ä¼šé‡åˆ°ä¸Šè¿°ä»»ä½•æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿé—®é¢˜-ä½†è¿™å¹¶ä¸æ„å‘³ç€æ•´ä¸ªç³»ç»Ÿç¥å¥‡åœ°æ‹¥æœ‰ä¸€æ¬¡è¯­ä¹‰ï¼Œå³ä½¿å£°æ˜å®é™…ä¸Šæ˜¯æ­£ç¡®çš„ã€‚è¿™é€šå¸¸æ„å‘³ç€æ’é˜Ÿç³»ç»Ÿå…·æœ‰æŸç§å½¢å¼çš„æ’åºï¼Œé”å®šï¼Œå“ˆå¸Œï¼Œè®¡æ—¶å™¨å’Œå¹‚ç­‰æ€§ä»¤ç‰Œï¼Œè¿™å°†ç¡®ä¿å®ƒæ°¸è¿œä¸ä¼šé‡æ–°ä¼ é€’å·²ç»è¢«åˆ é™¤/ç¡®è®¤çš„æ¶ˆæ¯ï¼Œä½†è¿™å¹¶ä¸æ„å‘³ç€åŒ…æ‹¬å‘å¸ƒè€…+é˜Ÿåˆ—+è®¢é˜…è€…åœ¨å†…çš„æ•´ä¸ªç³»ç»Ÿå·²ç»è·å¾—äº†å®Œå…¨ç²¾ç¡®çš„ä¸€æ¬¡ä¿è¯ã€‚</p><p> Most good messaging system engineers understand this and will  explain to their users why this semantic is unworkable. The simpler and more reliable way to handle messages is go back to the basics and embrace at-least-once with idempotency measures at every point on the sending, receiving and queuing process: if at first you don&#39;t succeed, retry, retry, retry...</p><p> å¤§å¤šæ•°ä¼˜ç§€çš„é‚®ä»¶ç³»ç»Ÿå·¥ç¨‹å¸ˆéƒ½ç†è§£è¿™ä¸€ç‚¹ï¼Œå¹¶å°†å‘ç”¨æˆ·è§£é‡Šä¸ºä»€ä¹ˆè¿™ç§è¯­ä¹‰ä¸å¯è¡Œã€‚å¤„ç†æ¶ˆæ¯çš„æ›´ç®€å•ï¼Œæ›´å¯é çš„æ–¹æ³•æ˜¯å›åˆ°åŸºç¡€çŸ¥è¯†ï¼Œå¹¶åœ¨å‘é€ï¼Œæ¥æ”¶å’Œæ’é˜Ÿè¿‡ç¨‹çš„æ¯ä¸ªç‚¹ä¸Šè‡³å°‘ä¸€æ¬¡é‡‡ç”¨å¹‚ç­‰åº¦é‡ï¼šå¦‚æœä¸€å¼€å§‹æ‚¨ä¸æˆåŠŸï¼Œè¯·é‡è¯•ï¼Œé‡è¯•ï¼Œé‡è¯•...</p><p>  After delivery semantics, another common question on peoplesâ€™ minds is â€œwhy canâ€™t we just process messages in parallel while also making sure we process them in order?â€. Unfortunately this is another tradeoff imposed on us by the tyranny of logic. Doing work in a sequence and doing multiple pieces of work at the same time are always at conflict with each other. Most message queue systems will ask you to pick oneâ€”AWS SQS started by prioritising parallelism over strict ordering; but recently introduced a separate FIFO (first in, first out) queuing system as well, which maintains strict sequential ordering. Before making a choice between the two, letâ€™s go over what the difference is and why there needs to be a difference at all.</p><p>  åœ¨ä¼ é€’è¯­ä¹‰ä¹‹åï¼Œäººä»¬å¿ƒä¸­çš„å¦ä¸€ä¸ªå¸¸è§é—®é¢˜æ˜¯â€œä¸ºä»€ä¹ˆæˆ‘ä»¬æ—¢ä¸èƒ½å¹¶è¡Œå¤„ç†æ¶ˆæ¯ï¼Œåˆè¦ç¡®ä¿æŒ‰é¡ºåºå¤„ç†æ¶ˆæ¯ï¼Ÿâ€ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™æ˜¯é€»è¾‘ä¸“åˆ¶å¼ºåŠ ç»™æˆ‘ä»¬çš„å¦ä¸€ä¸ªæƒè¡¡ã€‚ä¾æ¬¡è¿›è¡Œå·¥ä½œå’ŒåŒæ—¶è¿›è¡Œå¤šé¡¹å·¥ä½œæ€»æ˜¯ç›¸äº’å†²çªçš„ã€‚å¤§å¤šæ•°æ¶ˆæ¯é˜Ÿåˆ—ç³»ç»Ÿéƒ½ä¼šè¦æ±‚æ‚¨é€‰æ‹©ä¸€ä¸ª-AWS SQSæ˜¯é€šè¿‡å°†å¹¶è¡Œæ€§æ”¾åœ¨ä¼˜å…ˆé¡ºåºä¹‹ä¸Šæ¥å¼€å§‹çš„ï¼›ä½†æœ€è¿‘åˆå¼•å…¥äº†ä¸€ä¸ªå•ç‹¬çš„FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰æ’é˜Ÿç³»ç»Ÿï¼Œè¯¥ç³»ç»Ÿä¿æŒä¸¥æ ¼çš„é¡ºåºæ’åºã€‚åœ¨ä¸¤è€…ä¹‹é—´åšå‡ºé€‰æ‹©ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆæ¢è®¨ä¸€ä¸‹ä¸¤è€…ä¹‹é—´çš„åŒºåˆ«ä»¥åŠä¸ºä»€ä¹ˆéœ€è¦å®Œå…¨æœ‰æ‰€åŒºåˆ«ã€‚</p><p> Returning to our earlier metaphor for a queueâ€”a long tube into which we roll messages written on a ballâ€”we probably imagined the tube to be just a little wider than a single ball. There&#39;s really no way the balls could overtake or pass each other inside the tube, so the only way a receiver could get these messages out is one-by-one, in the order they were put in. This guarantees strict ordering, but places strong limitations on our receiver. There can  only be one  agent on the receiver side that&#39;s processing each messageâ€”if there was more than one, there would be no guarantee that the messages were processed in order. Because each new agent could processes each message independently, they could each finish and start on the next message at any time. If the are two agents, A &amp; B, and Agent A receives the first message and Agent B the second; Agent B could finish processing the second message and start on the third message even before Agent A is finished processing the first message. Though the messages were  received from the queue strictly in the order that they were put in, if there are multiple receiving agents thereâ€™s no way to say the messages will  be processed in that order.</p><p> å›åˆ°æˆ‘ä»¬è¾ƒæ—©çš„éšå–»é˜Ÿåˆ—ï¼ˆé•¿çš„ç®¡å­ï¼Œæˆ‘ä»¬å°†å†™åœ¨çƒä¸Šçš„æ¶ˆæ¯æ»šåŠ¨åˆ°å…¶ä¸­ï¼‰ï¼Œæˆ‘ä»¬å¯èƒ½æƒ³è±¡ç®¡å­æ¯”å•ä¸ªçƒè¦å®½ä¸€ç‚¹ã€‚å®é™…ä¸Šï¼Œçƒä¸å¯èƒ½åœ¨ç®¡å†…ç›¸äº’è¶…è¶Šæˆ–é€šè¿‡ï¼Œå› æ­¤æ¥æ”¶è€…å‘å‡ºè¿™äº›æ¶ˆæ¯çš„å”¯ä¸€æ–¹æ³•æ˜¯æŒ‰ç…§æ”¾å…¥çš„é¡ºåºä¸€ä¸ªæ¥ä¸€ä¸ªåœ°å‘é€æ¶ˆæ¯ã€‚è¿™ç¡®ä¿äº†ä¸¥æ ¼çš„æ’åºï¼Œä½†å¯¹æˆ‘ä»¬çš„æ¥æ”¶å™¨æœ‰ä¸¥æ ¼çš„é™åˆ¶ã€‚æ¥æ”¶æ–¹åªèƒ½æœ‰ä¸€ä¸ªå¤„ç†æ¯ä¸ªæ¶ˆæ¯çš„ä»£ç†ï¼Œå¦‚æœæœ‰ä¸€ä¸ªä»¥ä¸Šï¼Œåˆ™ä¸èƒ½ä¿è¯æ¶ˆæ¯æ˜¯æŒ‰é¡ºåºå¤„ç†çš„ã€‚å› ä¸ºæ¯ä¸ªæ–°ä»£ç†éƒ½å¯ä»¥ç‹¬ç«‹å¤„ç†æ¯ä¸ªæ¶ˆæ¯ï¼Œæ‰€ä»¥å®ƒä»¬å¯ä»¥éšæ—¶å®Œæˆå¹¶ä»ä¸‹ä¸€æ¡æ¶ˆæ¯å¼€å§‹ã€‚å¦‚æœæ˜¯ä¸¤ä¸ªä»£ç†ï¼Œåˆ™Aï¼†amp;Aã€‚ Bï¼Œå¹¶ä¸”ä»£ç†Aæ¥æ”¶ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼Œä»£ç†Bæ¥æ”¶ç¬¬äºŒæ¡æ¶ˆæ¯ï¼›ç”šè‡³åœ¨ä»£ç†Aå®Œæˆå¤„ç†ç¬¬ä¸€æ¡æ¶ˆæ¯ä¹‹å‰ï¼Œä»£ç†Bå³å¯å®Œæˆç¬¬äºŒæ¡æ¶ˆæ¯çš„å¤„ç†å¹¶ä»ç¬¬ä¸‰æ¡æ¶ˆæ¯å¼€å§‹ã€‚å°½ç®¡ä¸¥æ ¼æŒ‰ç…§å‘é€é¡ºåºä»é˜Ÿåˆ—ä¸­æ¥æ”¶æ¶ˆæ¯ï¼Œä½†æ˜¯å¦‚æœæœ‰å¤šä¸ªæ¥æ”¶ä»£ç†ï¼Œåˆ™æ— æ³•è¯´å‡ºæ¶ˆæ¯å°†æŒ‰ç…§è¯¥é¡ºåºè¿›è¡Œå¤„ç†ã€‚</p><p> The agents could use a  distributed  lock of some kind to co-ordinate with each other, but this is basically the same as having only one agentâ€”the lock would only allow one agent to work at any given time. This also means that one agent crashing would result in a  deadlock with no work being done.</p><p> ä»£ç†å¯ä»¥ä½¿ç”¨æŸç§åˆ†å¸ƒå¼é”ç›¸äº’åè°ƒï¼Œä½†è¿™åŸºæœ¬ä¸Šä¸åªæœ‰ä¸€ä¸ªä»£ç†ç›¸åŒ-è¯¥é”å°†åªå…è®¸ä¸€ä¸ªä»£ç†åœ¨ä»»ä½•ç»™å®šæ—¶é—´å·¥ä½œã€‚è¿™ä¹Ÿæ„å‘³ç€ä¸€ä¸ªä»£ç†å´©æºƒå°†å¯¼è‡´æ­»é”ï¼Œè€Œæ— éœ€å®Œæˆä»»ä½•å·¥ä½œã€‚ </p><p> One way for the messaging system to guarantee order would be for the tube to refuse to give out the next ball until and unless the last ball that was received has been destroyed (the last message has been deleted/acknowledged). This is what FIFO queues in general will doâ€”they&#39;ll provide the next message only after the last one has been acknowledged or deletedâ€”but this means that only one agent can possibly be working at a time, even if there are  N agents waiting to receive messages from the queue.</p><p>æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿä¿è¯å‘½ä»¤çš„ä¸€ç§æ–¹å¼æ˜¯ï¼Œè¯•ç®¡æ‹’ç»å‘å‡ºä¸‹ä¸€ä¸ªçƒï¼Œç›´åˆ°å¹¶ä¸”é™¤éæ¥æ”¶åˆ°çš„æœ€åä¸€ä¸ªçƒè¢«ç ´åï¼ˆæœ€åä¸€æ¡æ¶ˆæ¯å·²è¢«åˆ é™¤/ç¡®è®¤ï¼‰ä¸ºæ­¢ã€‚è¿™é€šå¸¸æ˜¯FIFOé˜Ÿåˆ—ä¼šåšçš„-åªæœ‰åœ¨ç¡®è®¤æˆ–åˆ é™¤äº†æœ€åä¸€ä¸ªæ¶ˆæ¯åï¼Œå®ƒä»¬æ‰ä¼šæä¾›ä¸‹ä¸€æ¡æ¶ˆæ¯-ä½†è¿™æ„å‘³ç€å³ä½¿åªæœ‰Nä¸ªä»£ç†ï¼Œä¸€æ¬¡ä¹Ÿå¯èƒ½åªèƒ½å·¥ä½œã€‚ä»£ç†ç­‰å¾…ä»é˜Ÿåˆ—ä¸­æ¥æ”¶æ¶ˆæ¯ã€‚</p><p> Sometimes, this is exactly what we want. Some operations are easier to control effectively when we only have to deal with a single agent, like enforcing rules on financial transactions; respecting  rate limits; or generally processing messages whose formats have been designed assuming they would always be processed in order. But a lot of these â€œbenefitsâ€ are not really coming from the decision to use FIFO orderingâ€”any scenario where we have  N receivers that must somehow co-ordinate their work with each other will benefit from the special case of  N = 1. The key takeaway is that requiring a guaranteed order means we have to processes messages sequentially on only one receiver at a time.</p><p> æœ‰æ—¶ï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚å½“æˆ‘ä»¬åªéœ€è¦ä¸å•ä¸ªä»£ç†äººæ‰“äº¤é“æ—¶ï¼ŒæŸäº›æ“ä½œå°±æ›´æ˜“äºæœ‰æ•ˆæ§åˆ¶ï¼Œä¾‹å¦‚å¯¹é‡‘èäº¤æ˜“æ‰§è¡Œè§„åˆ™ï¼›éµå®ˆé€Ÿç‡é™åˆ¶ï¼›æˆ–é€šå¸¸å‡è®¾å°†å§‹ç»ˆæŒ‰é¡ºåºå¤„ç†å…¶æ ¼å¼å·²è®¾è®¡å¥½çš„æ¶ˆæ¯ã€‚ä½†æ˜¯ï¼Œè¿™äº›â€œå¥½å¤„â€ä¸­çš„è®¸å¤šå¹¶éçœŸæ­£æ¥è‡ªå†³å®šä½¿ç”¨FIFOæ’åºçš„æƒ…å†µ-åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œå¦‚æœæˆ‘ä»¬æœ‰Nä¸ªæ¥æ”¶å™¨ï¼Œå®ƒä»¬å¿…é¡»ä»¥æŸç§æ–¹å¼å½¼æ­¤åè°ƒå·¥ä½œï¼Œåˆ™å°†å—ç›ŠäºN = 1çš„ç‰¹æ®Šæƒ…å†µã€‚å…³é”®çš„ä¸€ç‚¹æ˜¯ï¼Œè¦æ±‚æœ‰ä¿è¯çš„é¡ºåºæ„å‘³ç€æˆ‘ä»¬å¿…é¡»ä¸€æ¬¡åªåœ¨ä¸€ä¸ªæ¥æ”¶å™¨ä¸Šé¡ºåºå¤„ç†æ¶ˆæ¯ã€‚</p><p> This restriction also places severe pressure on the queuing system, so you&#39;ll find that FIFO queues are often more expensive and have less capacity than their parallel counterparts. This is because the same logical limits apply to the internal implementa</p><p> è¿™ç§é™åˆ¶ä¹Ÿç»™æ’é˜Ÿç³»ç»Ÿå¸¦æ¥äº†å·¨å¤§å‹åŠ›ï¼Œå› æ­¤æ‚¨ä¼šå‘ç°FIFOé˜Ÿåˆ—é€šå¸¸æ¯”å¹¶è¡Œé˜Ÿåˆ—æ›´æ˜‚è´µä¸”å®¹é‡æ›´å°‘ã€‚è¿™æ˜¯å› ä¸ºç›¸åŒçš„é€»è¾‘é™åˆ¶é€‚ç”¨äºå†…éƒ¨å®ç°</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sudhir.io/the-big-little-guide-to-message-queues/">https://sudhir.io/the-big-little-guide-to-message-queues/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/æ¶ˆæ¯/">#æ¶ˆæ¯</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/guide/">#guide</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ç³»ç»Ÿ/">#ç³»ç»Ÿ</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>