<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>æ ¸å¿ƒæ•°æ®å®šå¾‹ The Laws of Core Data</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Laws of Core Data<br/>æ ¸å¿ƒæ•°æ®å®šå¾‹ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-22 13:43:48</div><div class="page_narrow text-break page_content"><p>In my conversations with developers, Iâ€™ve heard a pretty common theme from them that â€œCore Data is hardâ€ or â€œCore Data is buggyâ€ or â€œI could never get it to work right and gave up on itâ€.</p><p>åœ¨ä¸å¼€å‘äººå‘˜çš„å¯¹è¯ä¸­ï¼Œæˆ‘å¬åˆ°äº†ä¸€ä¸ªéå¸¸æ™®éçš„ä¸»é¢˜ï¼Œå³â€œæ ¸å¿ƒæ•°æ®å¾ˆéš¾â€æˆ–â€œæ ¸å¿ƒæ•°æ®æœ‰é”™è¯¯â€æˆ–â€œæˆ‘æ°¸è¿œæ— æ³•ä½¿å®ƒæ­£å¸¸å·¥ä½œå¹¶æ”¾å¼ƒâ€ã€‚</p><p> Iâ€™ve spent a lot of time using Core Data and thought Iâ€™d share my â€œLaws of Core Dataâ€. These are a set of rules Iâ€™ve developed over time on how to use Core Data in such a way that it is almost  entirely painless. When I follow these rules, I almost  never have any problems using it.</p><p> æˆ‘èŠ±äº†å¾ˆå¤šæ—¶é—´ä½¿ç”¨Core Dataï¼Œå¹¶ä»¥ä¸ºæˆ‘ä¼šåˆ†äº«â€œ Laws of Core Dataâ€ã€‚è¿™äº›æ˜¯æˆ‘éšç€æ—¶é—´çš„æµé€è€Œåˆ¶å®šçš„ä¸€å¥—è§„åˆ™ï¼Œè¿™äº›è§„åˆ™å‡ ä¹å®Œå…¨ä¸è´¹åŠ›åœ°ä½¿ç”¨Core Dataã€‚å½“æˆ‘éµå¾ªè¿™äº›è§„åˆ™æ—¶ï¼Œä½¿ç”¨å®ƒå‡ ä¹æ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚</p><p>  Itâ€™s common to hear developers talk about and treat Core Data as if it were a database. They see that itâ€™s powered by  SQLite, and think itâ€™s functionally equivalent.</p><p>  ç»å¸¸å¬åˆ°å¼€å‘äººå‘˜è°ˆè®ºæ ¸å¿ƒæ•°æ®å¹¶å°†å…¶è§†ä¸ºæ•°æ®åº“çš„æƒ…å†µã€‚ä»–ä»¬çœ‹åˆ°å®ƒç”±SQLiteæä¾›æ”¯æŒï¼Œå¹¶è®¤ä¸ºå®ƒåœ¨åŠŸèƒ½ä¸Šç­‰æ•ˆã€‚</p><p>    Core Data is an â€œobject graph and persistence frameworkâ€, which is basically like a fancy kind of  object-relational mapping. That means it is a whole bunch of code to help you maintain a graph (ie, a â€œnetworkâ€ of related pieces of data with a defined organization) of objects and then persist them in some fashion.</p><p>    æ ¸å¿ƒæ•°æ®æ˜¯ä¸€ä¸ªâ€œå¯¹è±¡å›¾å’ŒæŒä¹…æ€§æ¡†æ¶â€ï¼ŒåŸºæœ¬ä¸Šå°±åƒæ˜¯ä¸€ç§å¥‡ç‰¹çš„å¯¹è±¡å…³ç³»æ˜ å°„ã€‚è¿™å°±æ˜¯ä¸€å †å®Œæ•´çš„ä»£ç ï¼Œå¯ä»¥å¸®åŠ©æ‚¨ç»´æŠ¤å¯¹è±¡çš„å›¾å½¢ï¼ˆå³å…·æœ‰å®šä¹‰çš„ç»„ç»‡çš„ç›¸å…³æ•°æ®çš„â€œç½‘ç»œâ€ï¼‰ï¼Œç„¶åä»¥æŸç§æ–¹å¼æŒä¹…åŒ–å®ƒä»¬ã€‚</p><p>  It does not necessarily mean you have tables with rows of data. It does not necessarily mean that you have the ability to join across data types. It does not necessarily mean that itâ€™s even stored as a file on your disk.</p><p>  è¿™å¹¶ä¸ä¸€å®šæ„å‘³ç€æ‚¨å…·æœ‰åŒ…å«æ•°æ®è¡Œçš„è¡¨ã€‚è¿™å¹¶ä¸ä¸€å®šæ„å‘³ç€æ‚¨å…·æœ‰è·¨æ•°æ®ç±»å‹è¿›è¡Œè”æ¥çš„èƒ½åŠ›ã€‚è¿™ä¸ä¸€å®šæ„å‘³ç€å®ƒç”šè‡³å·²ä½œä¸ºæ–‡ä»¶å­˜å‚¨åœ¨ç£ç›˜ä¸Šã€‚</p><p>      Having these abilities means you can have Core Data take care of a lot more logic for you than if you were using a traditional database.</p><p>      æ‹¥æœ‰è¿™äº›åŠŸèƒ½æ„å‘³ç€ä¸ä½¿ç”¨ä¼ ç»Ÿæ•°æ®åº“ç›¸æ¯”ï¼Œæ‚¨å¯ä»¥è®©Core Dataä¸ºæ‚¨å¤„ç†æ›´å¤šçš„é€»è¾‘ã€‚</p><p>  This is very much related to the first law, but is a bit more specific, and it has to do with  how Core Data persists data. It is exceptionally rare to find a Core Data implementation that does not use SQLite as the persistence layer,  but it does happen.</p><p>  è¿™ä¸ç¬¬ä¸€å®šå¾‹æœ‰å¾ˆå¤§å…³ç³»ï¼Œä½†æ˜¯æ›´å…·ä½“ä¸€äº›ï¼Œå®ƒä¸Core DataæŒä¹…åŒ–æ•°æ®çš„æ–¹å¼æœ‰å…³ã€‚å¾ˆå°‘ä¼šå‘ç°æ²¡æœ‰ä½¿ç”¨SQLiteä½œä¸ºæŒä¹…å±‚çš„Core Dataå®ç°ï¼Œä½†æ˜¯ç¡®å®å‘ç”Ÿäº†ã€‚ </p><p>      In addition to these, Core Data also allows you to create your own persistence mechanism, by subclassing either   NSAtomicStore or   NSIncrementalStore. So, if you wanted, you could make Core Data save things to a  git repository, or to  CloudKit, or to  MySQL or  PostgreSQL, or to your own custom backendâ€¦ Several years ago I created a framework to access the  stackoverflow.com API, and networking was done via a custom Core Data store that translated Core Data requests in to API calls. It was weird, but it worked.</p><p>é™¤äº†è¿™äº›ï¼ŒCore Dataè¿˜å…è®¸æ‚¨é€šè¿‡å­ç±»åŒ–NSAtomicStoreæˆ–NSIncrementalStoreæ¥åˆ›å»ºè‡ªå·±çš„æŒä¹…æ€§æœºåˆ¶ã€‚å› æ­¤ï¼Œå¦‚æœæ‚¨æ„¿æ„ï¼Œå¯ä»¥ä½¿Core Dataå°†å†…å®¹ä¿å­˜åˆ°gitå­˜å‚¨åº“ï¼ŒCloudKitï¼ŒMySQLæˆ–PostgreSQLæˆ–æ‚¨è‡ªå·±çš„è‡ªå®šä¹‰åç«¯ä¸­ã€‚...å‡ å¹´å‰ï¼Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ªæ¡†æ¶æ¥è®¿é—®stackoverflow.com APIï¼Œè”ç½‘æ˜¯é€šè¿‡è‡ªå®šä¹‰æ ¸å¿ƒæ•°æ®å­˜å‚¨å®Œæˆçš„ï¼Œè¯¥å­˜å‚¨å°†æ ¸å¿ƒæ•°æ®è¯·æ±‚è½¬æ¢ä¸ºAPIè°ƒç”¨ã€‚è¿™å¾ˆå¥‡æ€ªï¼Œä½†æ˜¯æœ‰æ•ˆã€‚</p><p>  Core Data does not have to be just SQLite. In fact, modeling your schema as if it were SQLite (or some other RDBMS variant) is a sure sign youâ€™re â€œdoing it wrongâ€. Setting up custom things like artificial foreign keys or join tables are almost never necessary and are almost always wrong.</p><p>  æ ¸å¿ƒæ•°æ®å¹¶ä¸ä»…é™äºSQLiteã€‚å®é™…ä¸Šï¼Œå¯¹æ¶æ„è¿›è¡Œå»ºæ¨¡å°±å¥½åƒå®ƒæ˜¯SQLiteï¼ˆæˆ–å…¶ä»–RDBMSå˜ä½“ï¼‰ä¸€æ ·ï¼Œè¿™æ— ç–‘æ˜¯æ‚¨â€œåšé”™äº†â€çš„æ ‡å¿—ã€‚å‡ ä¹ä¸éœ€è¦è®¾ç½®è¯¸å¦‚äººé€ å¤–é”®æˆ–è”æ¥è¡¨ä¹‹ç±»çš„è‡ªå®šä¹‰å†…å®¹ï¼Œå¹¶ä¸”å‡ ä¹æ€»æ˜¯é”™è¯¯çš„ã€‚</p><p>  Typically one of the first things that developers do when creating a Core Data stack is to create a â€œDataStackâ€ object that encapsulates loading up the model, creating the store coordinator, and then creating the main   NSManagedObjectContext. That â€œstackâ€ object then gets passed around as your â€œCore Data managerâ€ object by which you get the context you need. iOS 10.0 and macOS 10.12 added the concept of an   NSPersistentContainer, which does a lot of this for you.</p><p>  é€šå¸¸ï¼Œå¼€å‘äººå‘˜åœ¨åˆ›å»ºCore Dataå †æ ˆæ—¶è¦åšçš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯åˆ›å»ºä¸€ä¸ªâ€œ DataStackâ€å¯¹è±¡ï¼Œè¯¥å¯¹è±¡å°è£…äº†åŠ è½½æ¨¡å‹ï¼Œåˆ›å»ºå­˜å‚¨åè°ƒå™¨ï¼Œç„¶ååˆ›å»ºä¸»NSManagedObjectContextçš„è¿‡ç¨‹ã€‚ç„¶åï¼Œè¯¥â€œå †æ ˆâ€å¯¹è±¡å°†ä½œä¸ºâ€œæ ¸å¿ƒæ•°æ®ç®¡ç†å™¨â€å¯¹è±¡ä¼ é€’ï¼Œé€šè¿‡å®ƒå¯ä»¥è·å–æ‰€éœ€çš„ä¸Šä¸‹æ–‡ã€‚ iOS 10.0å’ŒmacOS 10.12æ·»åŠ äº†NSPersistentContainerçš„æ¦‚å¿µï¼Œå®ƒå¯ä»¥ä¸ºæ‚¨å®Œæˆå¾ˆå¤šå·¥ä½œã€‚</p><p>  Having a single object to load up your model and everything is great. But you  donâ€™t need to pass it around.</p><p>  æ‹¥æœ‰ä¸€ä¸ªå¯¹è±¡å³å¯åŠ è½½æ¨¡å‹ï¼Œä¸€åˆ‡éƒ½å¾ˆå¥½ã€‚ä½†æ˜¯æ‚¨ä¸éœ€è¦ä¼ é€’å®ƒã€‚</p><p>  Itâ€™s usually passed around in order to have easy access to making a new context or accessing the model. That is all unnecessary. If you do decide to pass Core Data objects around your app, then all you need is the  NSManagedObjectContext (â€œMOCâ€).</p><p>  ä¸ºäº†æ–¹ä¾¿è®¿é—®æ–°çš„ä¸Šä¸‹æ–‡æˆ–è®¿é—®æ¨¡å‹ï¼Œé€šå¸¸å°†å…¶ä¼ é€’å‡ºå»ã€‚é‚£éƒ½æ˜¯ä¸å¿…è¦çš„ã€‚å¦‚æœæ‚¨ç¡®å®å†³å®šåœ¨åº”ç”¨ç¨‹åºä¸­ä¼ é€’Core Dataå¯¹è±¡ï¼Œé‚£ä¹ˆæ‚¨åªéœ€è¦NSManagedObjectContextï¼ˆâ€œ MOCâ€ï¼‰ã€‚</p><p>  Your MOC has an   NSPersistentStoreCoordinator (â€œPSCâ€) property, which itself has an   NSManagedObjectModel (â€œMOMâ€, aka the schema). So from a single MOC, you can get any information you need about your schema, where things are being saved, what format theyâ€™re being saved in, the configuration for the persistent stores, etc.</p><p>  æ‚¨çš„MOCå…·æœ‰NSPersistentStoreCoordinatorï¼ˆâ€œ PSCâ€ï¼‰å±æ€§ï¼Œè¯¥å±æ€§æœ¬èº«å…·æœ‰NSManagedObjectModelï¼ˆâ€œ MOMâ€ï¼Œä¹Ÿç§°ä¸ºæ¶æ„ï¼‰ã€‚å› æ­¤ï¼Œä»å•ä¸ªMOCä¸­ï¼Œæ‚¨å¯ä»¥è·å¾—ä¸æ¶æ„æœ‰å…³çš„ä»»ä½•ä¿¡æ¯ï¼Œå­˜å‚¨å†…å®¹çš„ä½ç½®ï¼Œå­˜å‚¨æ ¼å¼ï¼ŒæŒä¹…æ€§å­˜å‚¨çš„é…ç½®ç­‰ã€‚</p><p>  If you decide you need to create a new, one-off MOC, itâ€™s easy to do so with your existing MOC:</p><p>  å¦‚æœæ‚¨å†³å®šéœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ä¸€æ¬¡æ€§MOCï¼Œåˆ™å¯ä»¥ä½¿ç”¨ç°æœ‰çš„MOCè½»æ¾åšåˆ°è¿™ä¸€ç‚¹ï¼š </p><p>  let existingContext: NSManagedObjectContext = ... let newContext = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType) newContext.persistentStoreCoordinator = existingContext.persistentStoreCoordinator // that&#39;s it</p><p>è®©existingContextï¼šNSManagedObjectContext = ...è®©newContext = NSManagedObjectContextï¼ˆconcurrencyTypeï¼š.privateQueueConcurrencyTypeï¼‰newContext.persistentStoreCoordinator = existingContext.persistentStoreCoordinator //åšåˆ°è¿™ä¸€ç‚¹</p><p>    (Creating new contexts like this isnâ€™t ideal, because of another law further down)</p><p>    ï¼ˆåˆ›å»ºæ–°çš„ç¯å¢ƒå¹¶ä¸ç†æƒ³ï¼Œå› ä¸ºè¿˜æœ‰å…¶ä»–æ³•å¾‹è§„å®šï¼‰</p><p>  This law is  the source of bugs when it comes to Core Data. Offhand Iâ€™d guess that more than 90% of the pain developers experience with Core Data is because of this.</p><p>  æ¶‰åŠæ ¸å¿ƒæ•°æ®æ—¶ï¼Œæ­¤æ³•å¾‹æ˜¯é”™è¯¯çš„æ¥æºã€‚éšä¾¿è¯´ä¸€å¥ï¼Œæˆ‘æƒ³å¼€å‘äººå‘˜åœ¨ä½¿ç”¨Core Dataæ—¶é‡åˆ°çš„ç—›è‹¦æœ‰90ï¼…ä»¥ä¸Šæ˜¯å› ä¸ºè¿™ä¸ªã€‚</p><p>  Core Data tries to be efficient; it typically doesnâ€™t like to load up more data than you need, which means there are times when you ask it for data (like an object property) and it doesnâ€™t have it handy. When this happens, it has to go load the data from its store (which might not even be a local file on disk!) before it can respond to you.</p><p>  æ ¸å¿ƒæ•°æ®è¯•å›¾æé«˜æ•ˆç‡ï¼›å®ƒé€šå¸¸ä¸å¸Œæœ›åŠ è½½æ¯”æ‚¨éœ€è¦çš„æ•°æ®æ›´å¤šçš„æ•°æ®ï¼Œè¿™æ„å‘³ç€æœ‰æ—¶æ‚¨ä¼šè¦æ±‚å®ƒæä¾›æ•°æ®ï¼ˆä¾‹å¦‚å¯¹è±¡å±æ€§ï¼‰ï¼Œå¹¶ä¸”å®ƒä¸æ–¹ä¾¿ä½¿ç”¨ã€‚å‘ç”Ÿè¿™ç§æƒ…å†µæ—¶ï¼Œå®ƒå¿…é¡»å…ˆä»å…¶å­˜å‚¨ä¸­åŠ è½½æ•°æ®ï¼ˆç”šè‡³å¯èƒ½ä¸æ˜¯ç£ç›˜ä¸Šçš„æœ¬åœ°æ–‡ä»¶ï¼ï¼‰ï¼Œç„¶åå®ƒæ‰èƒ½å“åº”æ‚¨ã€‚</p><p>  This is called â€œfaultingâ€. The marker value internal kept by a managed object is a â€œfaultâ€, and the process of â€œfulfillingâ€ (ie, retrieving the data) the fault is â€œfaultingâ€.</p><p>  è¿™ç§°ä¸ºâ€œæ•…éšœâ€ã€‚è¢«ç®¡ç†å¯¹è±¡ä¿ç•™çš„å†…éƒ¨æ ‡è®°å€¼æ˜¯â€œæ•…éšœâ€ï¼Œè€Œâ€œå®Œæˆâ€ï¼ˆå³ï¼Œæ£€ç´¢æ•°æ®ï¼‰æ•…éšœçš„è¿‡ç¨‹å°±æ˜¯â€œæ•…éšœâ€ã€‚</p><p>  Hereâ€™s the thing: Core Data has to be  safe. It has to synchronize these faulting calls with other accesses of the persistent store, and it has to do it in a way that isnâ€™t going to interfere with other calls to fault in data. The way it does that is by expecting that all calls to fault in data happen safely inside one of its queues.</p><p>  å…³é”®åœ¨äºï¼šæ ¸å¿ƒæ•°æ®å¿…é¡»å®‰å…¨ã€‚å®ƒå¿…é¡»å°†è¿™äº›é”™è¯¯çš„è°ƒç”¨ä¸æŒä¹…æ€§å­˜å‚¨çš„å…¶ä»–è®¿é—®è¿›è¡ŒåŒæ­¥ï¼Œå¹¶ä¸”å¿…é¡»ä»¥ä¸å¹²æ‰°å…¶ä»–æ•°æ®é”™è¯¯è°ƒç”¨çš„æ–¹å¼è¿›è¡Œã€‚è¿™æ ·åšçš„æ–¹æ³•æ˜¯æœŸæœ›æ‰€æœ‰å¯¹æ•°æ®é”™è¯¯çš„è°ƒç”¨éƒ½åœ¨å…¶é˜Ÿåˆ—ä¹‹ä¸€ä¸­å®‰å…¨åœ°å‘ç”Ÿã€‚</p><p>  Every managed object â€œbelongsâ€ to a particular MOC (more on this in a minute), and every MOC has a  DispatchQueue that it uses to synchronize its internal logic about loading data from its  persistentStoreCoordinator.</p><p>  æ¯ä¸ªå—ç®¡ç†å¯¹è±¡â€œéƒ½å±äºâ€ç‰¹å®šçš„MOCï¼ˆç¨åå°†å¯¹æ­¤è¿›è¡Œè¯¦ç»†ä»‹ç»ï¼‰ï¼Œå¹¶ä¸”æ¯ä¸ªMOCéƒ½æœ‰ä¸€ä¸ªDispatchQueueï¼Œå¯ç”¨äºåŒæ­¥å…¶æœ‰å…³ä»å…¶persistentStoreCoordinatoråŠ è½½æ•°æ®çš„å†…éƒ¨é€»è¾‘ã€‚ </p><p>  If you use an  NSManagedObject from  outside the MOCâ€™s queue, then the calls to fault in data are not properly synchronized and protected, which means youâ€™re susceptible to race conditions.</p><p>å¦‚æœæ‚¨æ˜¯åœ¨MOCé˜Ÿåˆ—ä¹‹å¤–ä½¿ç”¨NSManagedObjectçš„ï¼Œé‚£ä¹ˆå¯¹æ•°æ®æ•…éšœçš„è°ƒç”¨å°†æ— æ³•æ­£ç¡®åŒæ­¥å’Œå—åˆ°ä¿æŠ¤ï¼Œè¿™æ„å‘³ç€æ‚¨å¾ˆå®¹æ˜“å‡ºç°ç«äº‰çŠ¶å†µã€‚</p><p>  So, if you have an   NSManagedObject, the  only safe place to use it is from  inside a call to  perform or  performAndWait on its MOC, like so:</p><p>  å› æ­¤ï¼Œå¦‚æœæ‚¨æœ‰ä¸€ä¸ªNSManagedObjectï¼Œåˆ™å”¯ä¸€å®‰å…¨çš„ä½¿ç”¨ä½ç½®æ˜¯åœ¨å…¶MOCä¸Šå¯¹performæˆ–performAndWaitçš„è°ƒç”¨ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p><p>  let object: NSManagedObject = ... var propertyValue: PropertyType! object.managedObjectContext.performAndWait { propertyValue = object.property } ...</p><p>  letå¯¹è±¡ï¼šNSManagedObject = ... var propertyValueï¼šPropertyTypeï¼ object.managedObjectContext.performAndWait {propertyValue = object.property} ...</p><p>  Using your own  DispatchQueue or one of the global queues is insufficient. The managed object has to be accessed from the queue that is controlled by the MOC, and the way to do that is with the  perform and  performAndWait methods.</p><p>  ä½¿ç”¨æ‚¨è‡ªå·±çš„DispatchQueueæˆ–å…¨å±€é˜Ÿåˆ—ä¹‹ä¸€æ˜¯ä¸å¤Ÿçš„ã€‚å¿…é¡»ä»MOCæ§åˆ¶çš„é˜Ÿåˆ—ä¸­è®¿é—®æ‰˜ç®¡å¯¹è±¡ï¼Œè€Œæ‰§è¡Œæ­¤æ“ä½œçš„æ–¹æ³•æ˜¯ä½¿ç”¨performå’ŒperformAndWaitæ–¹æ³•ã€‚</p><p>  There is one special case to this, and that is dealing with managed objects that belong to a MOC whose queue is the â€œmainâ€ queue. The  DispatchQueue.main queue is bound to the main thread of your app, and so if youâ€™re on the main thread and have a main-thread-object, you can â€œsafelyâ€ not use  perform calls because you are  already inside the contextâ€™s queue.</p><p>  è¿™æœ‰ä¸€ä¸ªç‰¹æ®Šæƒ…å†µï¼Œé‚£å°±æ˜¯å¤„ç†å±äºMOCçš„æ‰˜ç®¡å¯¹è±¡ï¼Œè¯¥MOCçš„é˜Ÿåˆ—ä¸ºâ€œä¸»â€é˜Ÿåˆ—ã€‚ DispatchQueue.mainé˜Ÿåˆ—ç»‘å®šåˆ°åº”ç”¨ç¨‹åºçš„ä¸»çº¿ç¨‹ï¼Œå› æ­¤ï¼Œå¦‚æœæ‚¨åœ¨ä¸»çº¿ç¨‹ä¸Šå¹¶ä¸”å…·æœ‰ä¸»çº¿ç¨‹å¯¹è±¡ï¼Œåˆ™å¯ä»¥â€œå®‰å…¨åœ°â€ä¸ä½¿ç”¨æ‰§è¡Œè°ƒç”¨ï¼Œå› ä¸ºæ‚¨å·²ç»åœ¨ä¸Šä¸‹æ–‡çš„å†…éƒ¨é˜Ÿåˆ—ã€‚</p><p>  The  only managed object property that is safe to use outside of a queue or pass between queues/threads is the objectâ€™s  objectID: this is a Core Data-provided identifier unique for that particular object. You can access this property from anywhere, and it is the  only way to â€œtransferâ€ a managed object from one context to another:</p><p>  å¯ä»¥åœ¨é˜Ÿåˆ—å¤–ä½¿ç”¨æˆ–åœ¨é˜Ÿåˆ—/çº¿ç¨‹ä¹‹é—´ä¼ é€’çš„å”¯ä¸€å®‰å…¨æ‰˜ç®¡å¯¹è±¡å±æ€§æ˜¯å¯¹è±¡çš„objectIDï¼šè¿™æ˜¯Core Dataæä¾›çš„è¯¥ç‰¹å®šå¯¹è±¡å”¯ä¸€çš„æ ‡è¯†ç¬¦ã€‚æ‚¨å¯ä»¥ä»ä»»ä½•åœ°æ–¹è®¿é—®æ­¤å±æ€§ï¼Œè¿™æ˜¯å°†æ‰˜ç®¡å¯¹è±¡ä»ä¸€ä¸ªä¸Šä¸‹æ–‡â€œè½¬ç§»â€åˆ°å¦ä¸€ä¸ªä¸Šä¸‹æ–‡çš„å”¯ä¸€æ–¹æ³•ï¼š</p><p>  let objectInContextA: NSManagedObject = ... let objectID = objectInContextA.objectID let contextB: NSManagedObjectContext = ... contextB.perform { let objectInContextB = contextB.object(with: objectID) // objectInContextB is now a separate *instance* from the original object, // but both are backed by the same data in the persistent store }</p><p>  let objectInContextAï¼šNSManagedObject = ... let objectID = objectInContextA.objectID let contextBï¼šNSManagedObjectContext = ... contextB.perform {let objectInContextB = contextB.objectï¼ˆwithï¼šobjectIDï¼‰// objectInContextBç°åœ¨æ˜¯ä¸åŸå§‹å¯¹è±¡åˆ†å¼€çš„* instance *å¯¹è±¡ï¼Œ//ä½†éƒ½ç”±æŒä¹…æ€§å­˜å‚¨ä¸­çš„ç›¸åŒæ•°æ®æ”¯æŒ} </p><p>  I will add here that it is  really unfortunate we have to care about this. Itâ€™s not hard to imagine a world where managed objects deal with this sort of stuff automatically. However, this is what happens when weâ€™re dealing with a framework that is over 14 years old and is based on another framework ( EOF) that is 24 years old. The problem of â€œbinary compatibilityâ€ is a blog post for another day.</p><p>æˆ‘è¦åœ¨è¿™é‡Œè¡¥å……ä¸€ç‚¹ï¼Œå¾ˆé—æ†¾ï¼Œæˆ‘ä»¬å¿…é¡»å¯¹æ­¤äºˆä»¥å…³æ³¨ã€‚ä¸éš¾æƒ³è±¡ï¼Œæ‰˜ç®¡å¯¹è±¡ä¼šè‡ªåŠ¨å¤„ç†è¿™ç§äº‹æƒ…ã€‚ä½†æ˜¯ï¼Œå½“æˆ‘ä»¬å¤„ç†çš„æ¡†æ¶å·²ç»ä½¿ç”¨äº†14å¹´ä»¥ä¸Šï¼Œå¹¶ä¸”åŸºäº24å¹´çš„å¦ä¸€ä¸ªæ¡†æ¶ï¼ˆEOFï¼‰æ—¶ï¼Œå°±ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚ â€œäºŒè¿›åˆ¶å…¼å®¹æ€§â€é—®é¢˜æ˜¯å¦ä¸€å¤©çš„åšå®¢æ–‡ç« ã€‚</p><p>  This is a generalization of the previous law. Because of the weirdness around faulting and queue access, itâ€™s my opinion that  NSManagedObject shouldnâ€™t actually be a subclass of  NSObject. When we see  NSObject in our code, we have assumptions about how they work with regards to memory management, multi-threaded access, and behavior.  NSManagedObject breaks enough of these rules that it probably shouldnâ€™t be an  NSObject, but should be its own root class.</p><p>  è¿™æ˜¯å…ˆå‰æ³•å¾‹çš„æ¦‚æ‹¬ã€‚ç”±äºé”™è¯¯å’Œé˜Ÿåˆ—è®¿é—®çš„æ€ªå¼‚ï¼Œæˆ‘è®¤ä¸ºNSManagedObjectå®é™…ä¸Šä¸åº”è¯¥æ˜¯NSObjectçš„å­ç±»ã€‚å½“æˆ‘ä»¬åœ¨ä»£ç ä¸­çœ‹åˆ°NSObjectæ—¶ï¼Œå°±å¯¹å®ƒä»¬å¦‚ä½•åœ¨å†…å­˜ç®¡ç†ï¼Œå¤šçº¿ç¨‹è®¿é—®å’Œè¡Œä¸ºæ–¹é¢è¿›è¡Œäº†å‡è®¾ã€‚ NSManagedObjectè¿åäº†è¿™äº›è§„åˆ™ï¼Œå› æ­¤å®ƒå¯èƒ½ä¸åº”è¯¥æ˜¯NSObjectï¼Œè€Œåº”è¯¥æ˜¯å…¶è‡ªå·±çš„æ ¹ç±»ã€‚</p><p>  So, forget that itâ€™s an  NSObject. It doesnâ€™t really behave like one, and you shouldnâ€™t use it as if it were.</p><p>  å› æ­¤ï¼Œå¿˜è®°å®ƒæ˜¯ä¸€ä¸ªNSObjectã€‚å®ƒçš„è¡Œä¸ºå®é™…ä¸Šå¹¶ä¸åƒä¸€ä¸ªï¼Œå¹¶ä¸”æ‚¨ä¸åº”åƒä½¿ç”¨å®ƒé‚£æ ·ä½¿ç”¨å®ƒã€‚</p><p>  One of the more esoteric features of Core Data is the ability to have relationships between contexts: you can have a MOC that is not actually backed by the  NSPersistentStoreCoordinator, but is instead backed by  another MOC. This has some really interesting implications, but in general: you donâ€™t need this.</p><p>  æ ¸å¿ƒæ•°æ®çš„ä¸€é¡¹æ›´æ·±å¥¥çš„åŠŸèƒ½æ˜¯èƒ½å¤Ÿåœ¨ä¸Šä¸‹æ–‡ä¹‹é—´å»ºç«‹å…³ç³»ï¼šæ‚¨å¯ä»¥æ‹¥æœ‰ä¸€ä¸ªMOCï¼Œè¯¥MOCå®é™…ä¸Šä¸å—NSPersistentStoreCoordinatoræ”¯æŒï¼Œè€Œç”±å¦ä¸€ä¸ªMOCæ”¯æŒã€‚è¿™ç¡®å®æœ‰ä¸€äº›æœ‰è¶£çš„å«ä¹‰ï¼Œä½†æ€»çš„æ¥è¯´ï¼šæ‚¨ä¸éœ€è¦ã€‚</p><p>  The ability to have a child MOC is neat in some corner cases. Letâ€™s review the core functionality of MOCs in order to understand those cases:</p><p>  åœ¨æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œæ‹¥æœ‰å­©å­MOCçš„èƒ½åŠ›å¾ˆå·§å¦™ã€‚è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹MOCçš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä»¥äº†è§£è¿™äº›æƒ…å†µï¼š</p><p>    Thatâ€™s really the core pieces. So, you would want a child MOC if:</p><p>    é‚£æ‰æ˜¯çœŸæ­£çš„æ ¸å¿ƒã€‚å› æ­¤ï¼Œå¦‚æœæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œæ‚¨å°†éœ€è¦ä¸€ä¸ªå„¿ç«¥MOCï¼š</p><p>    As you can see, when you deal with child contexts, youâ€™re really dealing with transient (non-persisted) objects. Youâ€™re fundamentally changing loading and saving behavior.</p><p>    å¦‚æ‚¨æ‰€è§ï¼Œå½“å¤„ç†å­ä¸Šä¸‹æ–‡æ—¶ï¼Œæ‚¨å®é™…ä¸Šæ˜¯åœ¨å¤„ç†ä¸´æ—¶ï¼ˆéæŒä¹…ï¼‰å¯¹è±¡ã€‚æ‚¨å°†ä»æ ¹æœ¬ä¸Šæ”¹å˜åŠ è½½å’Œä¿å­˜è¡Œä¸ºã€‚ </p><p>  The times when you  need this are pretty rare. You would typically want this for something like a complex sub-graph creation flow, where along each step of the flow, you need to enforce relationship integrity, but donâ€™t want to actually save it to the persistent store until the flow is complete. And if the flow is cancelled, you donâ€™t want any of it to be saved at all. You could do that by having a child context, doing all the flow steps in the child context, and saving it up to a parent context, but you can still delete the child context if the user aborts.</p><p>éœ€è¦è¿™ç§æƒ…å†µçš„æ—¶é—´å¾ˆå°‘è§ã€‚å¯¹äºå¤æ‚çš„å­å›¾åˆ›å»ºæµç¨‹ï¼Œæ‚¨é€šå¸¸ä¼šå¸Œæœ›è¿™æ ·åšï¼Œåœ¨æµç¨‹çš„æ¯ä¸ªæ­¥éª¤ä¸­ï¼Œæ‚¨éƒ½éœ€è¦åŠ å¼ºå…³ç³»çš„å®Œæ•´æ€§ï¼Œä½†æ˜¯åœ¨æµç¨‹å®Œæˆä¹‹å‰ï¼Œæ‚¨ä¸å¸Œæœ›å°†å…¶å®é™…ä¿å­˜åˆ°æŒä¹…æ€§å­˜å‚¨ä¸­ã€‚è€Œä¸”ï¼Œå¦‚æœå–æ¶ˆäº†æµç¨‹ï¼Œæ‚¨æ ¹æœ¬å°±ä¸ä¼šä¿å­˜ä»»ä½•æµç¨‹ã€‚æ‚¨å¯ä»¥é€šè¿‡å…·æœ‰å­ä¸Šä¸‹æ–‡ï¼Œåœ¨å­ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œæ‰€æœ‰æµç¨‹æ­¥éª¤å¹¶å°†å…¶ä¿å­˜åˆ°çˆ¶ä¸Šä¸‹æ–‡ä¸­æ¥å®ç°ï¼Œä½†æ˜¯å¦‚æœç”¨æˆ·ä¸­æ­¢ï¼Œæ‚¨ä»ç„¶å¯ä»¥åˆ é™¤å­ä¸Šä¸‹æ–‡ã€‚</p><p>  Theyâ€™re kind of like transactions in normal database systems. You can start importing or editing a bunch of data, and if something goes wrong or is cancelled, you can roll back the changes.</p><p>  å®ƒä»¬æœ‰ç‚¹åƒæ™®é€šæ•°æ®åº“ç³»ç»Ÿä¸­çš„äº‹åŠ¡ã€‚æ‚¨å¯ä»¥å¼€å§‹å¯¼å…¥æˆ–ç¼–è¾‘å¤§é‡æ•°æ®ï¼Œå¦‚æœå‡ºç°é—®é¢˜æˆ–è¢«å–æ¶ˆï¼Œåˆ™å¯ä»¥å›æ»šæ›´æ”¹ã€‚</p><p>  Parent/child contexts are  usually advocated for something like â€œload some data in the background, and the saving it pushes it to the main queue contextâ€. That can work, but it does mean that in order to persist your data, you actually have to save  two contexts, instead of just one (because  save()-ing a context only pushes the data up one level. For a child context, the data only goes to the parent context, not all the way up to the PSC). In my opinion, using a child context like this is unnecessarily complicated.</p><p>  é€šå¸¸æå€¡çˆ¶/å­ä¸Šä¸‹æ–‡ï¼Œä¾‹å¦‚â€œåœ¨åå°åŠ è½½ä¸€äº›æ•°æ®ï¼Œå¹¶å°†å…¶ä¿å­˜åˆ°ä¸»é˜Ÿåˆ—ä¸Šä¸‹æ–‡ä¸­â€ã€‚å¯ä»¥å¥æ•ˆï¼Œä½†è¿™ç¡®å®æ„å‘³ç€è¦ä¿ç•™æ•°æ®ï¼Œå®é™…ä¸Šå¿…é¡»ä¿å­˜ä¸¤ä¸ªä¸Šä¸‹æ–‡ï¼Œè€Œä¸æ˜¯ä»…ä¿å­˜ä¸€ä¸ªä¸Šä¸‹æ–‡ï¼ˆå› ä¸ºsaveï¼ˆï¼‰ï¼ä¸Šä¸‹æ–‡åªèƒ½å°†æ•°æ®ä¸Šç§»ä¸€ä¸ªçº§åˆ«ã€‚å¯¹äºå­ä¸Šä¸‹æ–‡ï¼Œæ•°æ®ä»…åˆ°è¾¾çˆ¶ä¸Šä¸‹æ–‡ï¼Œè€Œä¸æ˜¯ä¸€ç›´åˆ°PSCï¼‰ã€‚æˆ‘è®¤ä¸ºï¼Œä½¿ç”¨è¿™æ ·çš„å„¿ç«¥ä¸Šä¸‹æ–‡ä¼šä¸å¿…è¦åœ°å˜å¾—å¤æ‚ã€‚</p><p>  For general, non-transactional usage, I think itâ€™s better to have two contexts (one for the main thread, one for the background) that both link directly to the PSC. Importation of data is done on the background context, and when it saves, the main queue listens for the  NSManagedObjectContextDidSave notification and merges in the changes with  .mergeChanges(fromContextDidSave:) method to update its internally-held objects. Even that step might be unnecessary if the context has  automaticallyMergesChangesFromParent set to  true.</p><p>  å¯¹äºä¸€èˆ¬çš„éäº‹åŠ¡æ€§ç”¨æ³•ï¼Œæˆ‘è®¤ä¸ºæœ€å¥½æœ‰ä¸¤ä¸ªç›´æ¥é“¾æ¥åˆ°PSCçš„ä¸Šä¸‹æ–‡ï¼ˆä¸€ä¸ªç”¨äºä¸»çº¿ç¨‹ï¼Œä¸€ä¸ªç”¨äºåå°ï¼‰ã€‚æ•°æ®çš„å¯¼å…¥æ˜¯åœ¨åå°ä¸Šä¸‹æ–‡ä¸­å®Œæˆçš„ï¼Œå¹¶ä¸”åœ¨ä¿å­˜æ—¶ï¼Œä¸»é˜Ÿåˆ—ä¾¦å¬NSManagedObjectContextDidSaveé€šçŸ¥ï¼Œå¹¶ä½¿ç”¨.mergeChangesï¼ˆfromContextDidSave :)æ–¹æ³•åˆå¹¶æ›´æ”¹ä»¥æ›´æ–°å…¶å†…éƒ¨ä¿å­˜çš„å¯¹è±¡ã€‚å¦‚æœä¸Šä¸‹æ–‡è‡ªåŠ¨å°†MergesChangesFromParentè®¾ç½®ä¸ºtrueï¼Œé‚£ä¹ˆå³ä½¿æ˜¯è¯¥æ­¥éª¤ä¹Ÿå¯èƒ½æ˜¯ä¸å¿…è¦çš„ã€‚</p><p>  If youâ€™re building an app that is reading information out of Core Data, displaying it to the user, and allowing minimal edits, then in my experience itâ€™s best to keep the main queue context a â€œread-onlyâ€ context.</p><p>  å¦‚æœæ‚¨è¦æ„å»ºçš„åº”ç”¨ç¨‹åºæ­£åœ¨ä»Core Dataä¸­è¯»å–ä¿¡æ¯ï¼Œå°†å…¶æ˜¾ç¤ºç»™ç”¨æˆ·å¹¶å…è®¸è¿›è¡Œæœ€å°‘çš„ç¼–è¾‘ï¼Œé‚£ä¹ˆæ ¹æ®æˆ‘çš„ç»éªŒï¼Œæœ€å¥½å°†ä¸»é˜Ÿåˆ—ä¸Šä¸‹æ–‡ä¿æŒä¸ºâ€œåªè¯»â€ä¸Šä¸‹æ–‡ã€‚</p><p>  By having strict rules around which contexts are readable vs writable, it makes it  much easier to reason about when parts of your UI should be reloaded: commands to update the UI come from a single direction (from your model towards your UI). If you allow mutation of stored information, then that can be encapsulated as a sort of â€œrequest for mutationâ€, sent off to the controller for this part of your model, and executed there. Performing the mutation on a Core Data object directly makes it harder to debug where changes are coming from (the data import step? editing in the UI? something else?), because you have a single point of entry.</p><p>  é€šè¿‡å…·æœ‰å…³äºå¯è¯»æ€§å’Œå¯å†™æ€§çš„ä¸¥æ ¼çš„è§„åˆ™ï¼Œå¯ä»¥æ›´è½»æ¾åœ°æ¨æ–­ä½•æ—¶åº”é‡æ–°åŠ è½½éƒ¨åˆ†UIï¼šç”¨äºæ›´æ–°UIçš„å‘½ä»¤æ¥è‡ªå•ä¸ªæ–¹å‘ï¼ˆä»æ¨¡å‹åˆ°UIï¼‰ã€‚å¦‚æœæ‚¨å…è®¸å¯¹å­˜å‚¨ä¿¡æ¯è¿›è¡Œçªå˜ï¼Œåˆ™å¯ä»¥å°†å…¶å°è£…ä¸ºä¸€ç§â€œçªå˜è¯·æ±‚â€ï¼Œå‘é€ç»™æ¨¡å‹è¿™ä¸€éƒ¨åˆ†çš„æ§åˆ¶å™¨ï¼Œç„¶ååœ¨æ­¤å¤„æ‰§è¡Œã€‚ç›´æ¥åœ¨Core Dataå¯¹è±¡ä¸Šæ‰§è¡Œçªå˜ä½¿æ‚¨æ›´éš¾ä»¥è°ƒè¯•æ›´æ”¹çš„æ¥æºï¼ˆæ•°æ®å¯¼å…¥æ­¥éª¤ï¼Œåœ¨UIä¸­è¿›è¡Œç¼–è¾‘æˆ–å…¶ä»–æ“ä½œï¼‰ï¼Œå› ä¸ºæ‚¨åªæœ‰ä¸€ä¸ªå…¥å£ç‚¹ã€‚</p><p>  If you follow the next law as well, then this law becomes very simple to enforce.</p><p>  å¦‚æœæ‚¨ä¹Ÿéµå¾ªä¸‹ä¸€æ¡æ³•å¾‹ï¼Œé‚£ä¹ˆæ‰§è¡Œè¯¥æ³•å¾‹å°†å˜å¾—éå¸¸ç®€å•ã€‚ </p><p>  This is more along the lines of â€œgeneral good adviceâ€ than anything specific to Core Data, but here it is:</p><p>è¿™æ›´åƒæ˜¯â€œä¸€èˆ¬æ€§å¥½çš„å»ºè®®â€ï¼Œè€Œä¸æ˜¯é’ˆå¯¹æ ¸å¿ƒæ•°æ®çš„ä»»ä½•å»ºè®®ï¼Œä½†å®é™…ä¸Šæ˜¯ï¼š</p><p>  Itâ€™s generally a smart thing to hide the fact that youâ€™re using Core Data from the rest of your app. This isnâ€™t because youâ€™re â€œashamedâ€ of it and need to obscure it (ğŸ˜‰), but is more because of the fact that Core Data objects carry a decent amount of baggage with them that the rest of your app shouldnâ€™t have to know about it (see earlier point about how objects bring along  the entire stack).</p><p>  ä»åº”ç”¨ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†éšè—æ‚¨æ­£åœ¨ä½¿ç”¨Core Dataçš„äº‹å®é€šå¸¸æ˜¯æ˜æ™ºçš„ã€‚è¿™å¹¶ä¸æ˜¯å› ä¸ºæ‚¨å¯¹æ­¤æ„Ÿåˆ°â€œç¾æ„§â€å¹¶éœ€è¦ä½¿å…¶æ¨¡ç³Šä¸æ¸…ï¼ˆğŸ˜‰ï¼‰ï¼Œè€Œæ˜¯å› ä¸ºCore Dataå¯¹è±¡éšèº«æºå¸¦äº†ç›¸å½“æ•°é‡çš„è¡Œæï¼Œè€Œåº”ç”¨ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†åˆ™ä¸åº”å¿…é¡»äº†è§£è¿™ä¸€ç‚¹ï¼ˆè¯·å‚é˜…å‰é¢çš„æœ‰å…³å¯¹è±¡å¦‚ä½•å¸¦å…¥æ•´ä¸ªå †æ ˆçš„çŸ¥è¯†ï¼‰ã€‚</p><p>  When you pass managed objects or contexts around your app, the temptation to just reach inside an object and pull out the PSC or the MOM or whatever and use it becomes too high. Donâ€™t do that. Avoid violating the  Law of Demeter and have a proper controller object that you can ask for what you need.</p><p>  å½“æ‚¨åœ¨åº”ç”¨ç¨‹åºå‘¨å›´ä¼ é€’æ‰˜ç®¡å¯¹è±¡æˆ–ä¸Šä¸‹æ–‡æ—¶ï¼Œä»…è¿›å…¥å¯¹è±¡å†…éƒ¨å¹¶æ‹‰å‡ºPSCæˆ–MOMæˆ–å…¶ä»–ä»»ä½•ä¸œè¥¿å¹¶ä½¿ç”¨å®ƒçš„è¯±æƒ‘å°±ä¼šå˜å¾—è¿‡é«˜ã€‚ä¸è¦é‚£æ ·åšé¿å…è¿åDemeteræ³•åˆ™ï¼Œå¹¶æ‹¥æœ‰é€‚å½“çš„æ§åˆ¶å™¨å¯¹è±¡ï¼Œæ‚¨å¯ä»¥ç´¢è¦æ‚¨éœ€è¦çš„ä¸œè¥¿ã€‚</p><p>  You could hide a managed object behind a protocol, but that also makes it easy to forget the law about queue usage.</p><p>  æ‚¨å¯ä»¥å°†æ‰˜ç®¡å¯¹è±¡éšè—åœ¨åè®®åé¢ï¼Œä½†æ˜¯è¿™ä¹Ÿå¾ˆå®¹æ˜“å¿˜è®°æœ‰å…³é˜Ÿåˆ—ä½¿ç”¨çš„æ³•å¾‹ã€‚</p><p>  In my opinion, you should keep the details of graph integrity and persistence to a confined part of your app, and data should only get out via custom-purpose  struct values (or something like them).</p><p>  æˆ‘è®¤ä¸ºï¼Œåº”å°†å›¾å½¢å®Œæ•´æ€§å’ŒæŒä¹…æ€§çš„è¯¦ç»†ä¿¡æ¯ä¿ç•™åœ¨åº”ç”¨ç¨‹åºçš„å—é™éƒ¨åˆ†ï¼Œå¹¶ä¸”æ•°æ®åº”ä»…é€šè¿‡è‡ªå®šä¹‰ç»“æ„å€¼ï¼ˆæˆ–ç±»ä¼¼çš„å€¼ï¼‰è¾“å‡ºã€‚</p><p>  As a rudimentary example of what this might look like, you could do something like this:</p><p>  ä½œä¸ºä¸€ä¸ªå¤§æ¦‚çš„ä¾‹å­ï¼Œæ‚¨å¯ä»¥æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š</p><p>  protocol ManagedObjectInitializable { init(managedObject: NSManagedObject) } class ModelController { func fetchObjects&lt;T&gt;(completion: @escaping (Array&lt;T&gt;) -&gt; Void) 	 where T: ManagedObjectInitializable { ... } } struct Person: ManagedObjectInitializable { let firstName: String let lastName: String ... }</p><p>  åè®®ManagedObjectInitializable {initï¼ˆmanagedObjectï¼šNSManagedObjectï¼‰}ç±»ModelController {func fetchObjectsï¼†lt; Tï¼†gt;ï¼ˆå®Œæˆï¼š@escapingï¼ˆArrayï¼†lt; Tï¼†gt;ï¼‰-ï¼†gt;æ— æ•ˆï¼‰å…¶ä¸­Tï¼šManagedObjectInitializable {...}}ç»“æ„ä½“ï¼šManagedObjectInitializable {è®©firstNameï¼šå­—ç¬¦ä¸²let lastNameï¼šå­—ç¬¦ä¸²...} </p><p>  There are many different ways you could abstract out the details of Core Data, each with their pros and cons. But hiding Core Data like this from the rest of your app is a huge step along the road to proper encapsulation and â€œneed-to-knowâ€  information hiding.</p><p>æ‚¨å¯ä»¥é‡‡ç”¨å¤šç§ä¸åŒçš„æ–¹æ³•æ¥æå–æ ¸å¿ƒæ•°æ®çš„è¯¦ç»†ä¿¡æ¯ï¼Œæ¯ç§æ–¹æ³•å„æœ‰åˆ©å¼Šã€‚ä½†æ˜¯ä»åº”ç”¨ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†éšè—è¿™æ ·çš„Core Dataæ˜¯å®ç°æ­£ç¡®å°è£…å’Œâ€œéœ€è¦çŸ¥é“â€ä¿¡æ¯éšè—çš„å·¨å¤§ä¸€æ­¥ã€‚</p><p>  These days itâ€™s pretty common to use apps that sync data between devices or are powered by a server backend. Very rarely do you find apps that produce and consume data that is  only local to the device.</p><p>  å¦‚ä»Šï¼Œä½¿ç”¨åœ¨è®¾å¤‡ä¹‹é—´åŒæ­¥æ•°æ®æˆ–ç”±æœåŠ¡å™¨åç«¯æä¾›æ”¯æŒçš„åº”ç”¨ç¨‹åºå·²ç»å¾ˆæ™®éã€‚åœ¨æå°‘æ•°æƒ…å†µä¸‹ï¼Œæ‚¨æ‰¾ä¸åˆ°ä¼šäº§ç”Ÿå’Œä½¿ç”¨ä»…è®¾å¤‡æœ¬åœ°æ•°æ®çš„åº”ç”¨ç¨‹åºã€‚</p><p>  Because of this, I find that itâ€™s nice to use Core Data as a local cache. With Core Data hidden behind an abstraction layer, itâ€™s easily integrated into a model layer from which I request data. The model layer looks in Core Data, and if the data is there, returns that. If itâ€™s not, the data is fetched, saved in to Core Data, and then returned.</p><p>  å› æ­¤ï¼Œæˆ‘å‘ç°å°†Core Dataç”¨ä½œæœ¬åœ°ç¼“å­˜éå¸¸å¥½ã€‚ç”±äºCore Dataéšè—åœ¨æŠ½è±¡å±‚çš„åé¢ï¼Œå› æ­¤å¯ä»¥è½»æ¾åœ°é›†æˆåˆ°æˆ‘ä»ä¸­è¯·æ±‚æ•°æ®çš„æ¨¡å‹å±‚ä¸­ã€‚æ¨¡å‹å±‚åœ¨æ ¸å¿ƒæ•°æ®ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæœ‰æ•°æ®ï¼Œåˆ™è¿”å›è¯¥æ•°æ®ã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™å°†è·å–æ•°æ®ï¼Œå°†å…¶ä¿å­˜åˆ°Core Dataä¸­ï¼Œç„¶åè¿”å›ã€‚</p><p>  Using Core Data in this manner means that if I ever have schema conflicts (ie, Iâ€™ve updated my app with a new schema version, and the persisted data from the old version is no longer compatible with the new version), I donâ€™t really have any qualms about just nuking the entire persistent store and starting over. Of course, I  can go through process of performing a  migration and dealing with manually shuffling data around to be in the new format,  but I donâ€™t have to. Thatâ€™s huge and saves me a ton of work.</p><p>  ä»¥è¿™ç§æ–¹å¼ä½¿ç”¨Core Dataæ„å‘³ç€ï¼Œå¦‚æœæˆ‘é‡åˆ°æ¶æ„å†²çªï¼ˆå³ï¼Œæˆ‘å·²ä½¿ç”¨æ–°çš„æ¶æ„ç‰ˆæœ¬æ›´æ–°äº†æˆ‘çš„åº”ç”¨ï¼Œå¹¶ä¸”æ—§ç‰ˆæœ¬ä¸­çš„æŒä¹…æ•°æ®ä¸å†ä¸æ–°ç‰ˆæœ¬å…¼å®¹ï¼‰ï¼Œæˆ‘ä¸ä¼šå®é™…ä¸Šï¼Œå¯¹äºå¦å®šæ•´ä¸ªæŒä¹…æ€§å­˜å‚¨å¹¶é‡æ–°å¼€å§‹æ²¡æœ‰ä»»ä½•ç–‘è™‘ã€‚å½“ç„¶ï¼Œæˆ‘å¯ä»¥æ‰§è¡Œè¿ç§»è¿‡ç¨‹å¹¶å¤„ç†æ‰‹åŠ¨æ”¹ç»„æ•°æ®ä»¥é‡‡ç”¨æ–°æ ¼å¼çš„è¿‡ç¨‹ï¼Œä½†æ˜¯æˆ‘ä¸å¿…è¿™æ ·åšã€‚é‚£æ˜¯å·¨å¤§çš„ï¼Œä¸ºæˆ‘èŠ‚çœäº†å¤§é‡çš„å·¥ä½œã€‚</p><p>  There is a big â€œgotchaâ€ with this approach though: Core Data works best when you have the  entire data set to query against. Because Core Data cares a lot about validation and graph integrity, it doesnâ€™t work as well as a cache if parts of your data are missing. You can account for that in your schema, but that can also complicate how you use it. So if youâ€™re going to use Core Data as a local cache, itâ€™s best if you can use it against a whole part of your data set.</p><p>  ä½†æ˜¯ï¼Œè¿™ç§æ–¹æ³•æœ‰ä¸€ä¸ªå¾ˆå¤§çš„â€œé™·é˜±â€ï¼šå½“æ‚¨è¦æŸ¥è¯¢æ•´ä¸ªæ•°æ®é›†æ—¶ï¼Œæ ¸å¿ƒæ•°æ®æœ€æœ‰æ•ˆã€‚ç”±äºCore Dataéå¸¸å…³æ³¨éªŒè¯å’Œå›¾å½¢å®Œæ•´æ€§ï¼Œå› æ­¤å¦‚æœä¸¢å¤±éƒ¨åˆ†æ•°æ®ï¼Œå®ƒå°±ä¸èƒ½åƒç¼“å­˜ä¸€æ ·æœ‰æ•ˆã€‚æ‚¨å¯ä»¥åœ¨æ¨¡å¼ä¸­è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ï¼Œä½†æ˜¯è¿™ä¹Ÿä¼šä½¿æ‚¨çš„ä½¿ç”¨æ–¹å¼å¤æ‚åŒ–ã€‚å› æ­¤ï¼Œå¦‚æœæ‚¨æ‰“ç®—å°†Core Dataç”¨ä½œæœ¬åœ°ç¼“å­˜ï¼Œåˆ™æœ€å¥½å°†å…¶ç”¨äºæ•´ä¸ªæ•°æ®é›†ã€‚</p><p> So, those are my â€œlawsâ€ for using Core Data. When I follow these laws, I almost  never have any problems with race conditions, corrupted data, â€œsadness like the death of optimismâ€, or data integrity. It all just works, and tends to work really, really well.</p><p> å› æ­¤ï¼Œè¿™äº›æ˜¯æˆ‘ä½¿ç”¨Core Dataçš„â€œæ³•å¾‹â€ã€‚å½“æˆ‘éµå¾ªè¿™äº›æ³•å¾‹æ—¶ï¼Œæˆ‘å‡ ä¹ä¸ä¼šé‡åˆ°ç§æ—çŠ¶å†µï¼Œæ•°æ®æŸåï¼Œâ€œæ‚²ä¼¤å¦‚ä¹è§‚ä¸»ä¹‰ä¹‹æ­»â€æˆ–æ•°æ®å®Œæ•´æ€§ç­‰é—®é¢˜ã€‚è¿™ä¸€åˆ‡éƒ½å¯ä»¥æ­£å¸¸å·¥ä½œï¼Œå¹¶ä¸”å¾€å¾€å¯ä»¥éå¸¸éå¸¸å¥½åœ°å·¥ä½œã€‚</p><p>   A special thanks to  Cole Joplin,  Tom Harrington, and  Soroush Khanlou for proof-reading and providing feedback.</p><p>   ç‰¹åˆ«æ„Ÿè°¢Cole Joplinï¼ŒTom Harringtonå’ŒSoroush Khanlouçš„æ ¡å¯¹å’Œæä¾›åé¦ˆã€‚ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://davedelong.com/blog/2018/05/09/the-laws-of-core-data/">https://davedelong.com/blog/2018/05/09/the-laws-of-core-data/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/æ•°æ®/">#æ•°æ®</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/core/">#core</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>