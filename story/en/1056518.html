<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Elixirä¸­çš„è§£æå™¨ç»„åˆè€… Parser Combinators in Elixir</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Parser Combinators in Elixir<br/>Elixirä¸­çš„è§£æå™¨ç»„åˆè€… </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-06 23:08:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/b2188a990a28459d68dc1456374c3e8c.png"><img src="http://img2.diglog.com/img/2021/4/b2188a990a28459d68dc1456374c3e8c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Parser combinators are one of the most useful tools for parsing. In contrast to regular expressions, they are much more readable and maintainable, making them an excellent choice for more complex tasks.</p><p>è§£æå™¨ç»„åˆå™¨æ˜¯è§£æçš„æœ€æœ‰ç”¨å·¥å…·ä¹‹ä¸€ã€‚ä¸æ­£åˆ™è¡¨è¾¾å¼ç›¸æ¯”ï¼Œå®ƒä»¬æ›´å…·å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œä½¿å…¶æˆä¸ºæ›´å¤æ‚ä»»åŠ¡çš„ç»ä½³é€‰æ‹©ã€‚</p><p> This article has two parts. First, lâ€™ll explain how parser combinators work and what they are made of. After that, Iâ€™ll guide you through making a CSV parser using  NimbleParsec, a parser combinator library written in Elixir.</p><p> æœ¬æ–‡æœ‰ä¸¤éƒ¨åˆ†ã€‚é¦–å…ˆï¼Œæˆ‘è§£é‡Šäº†è§£æå™¨ç»„åˆè€…å¦‚ä½•å·¥ä½œä»¥åŠå®ƒä»¬æ‰€åšçš„ã€‚ä¹‹åï¼Œæˆ‘å°†é€šè¿‡åœ¨Elixirç¼–å†™çš„è§£æå™¨ç»„åˆåº“åº“ä¸­ä½¿ç”¨nimbleparsecè¿›è¡ŒCSVè§£æå™¨æ¥æŒ‡å¯¼æ‚¨å®ŒæˆCSVè§£æå™¨ã€‚</p><p>   In this part, Iâ€™ll give a brief description of parser combinators, and we will try to build functional parser combinators from scratch. The combinators weâ€™ll make will be low-level and worse than what you would get with simple regex; they are there to illustrate the point.</p><p>   åœ¨è¿™ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘å°†ç®€è¦æè¿°è§£æå™¨ç»„åˆå™¨ï¼Œæˆ‘ä»¬å°†å°è¯•ä»å¤´å¼€å§‹æ„å»ºåŠŸèƒ½è§£æå™¨ç»„åˆå™¨ã€‚æˆ‘ä»¬å°†åˆ¶ä½œçš„ç»„åˆè€…å°†æ˜¯ä½çº§ï¼Œæ›´ç³Ÿç³•çš„æ˜¯æ‚¨å°†ä½¿ç”¨ç®€å•çš„æ­£åˆ™è¡¨è¾¾å¼è¾¾åˆ°;ä»–ä»¬åœ¨é‚£é‡Œè¯´æ˜äº†è¿™ä¸€ç‚¹ã€‚</p><p> If you want to see parser combinators in action, go straight to the  NimbleParsec section.</p><p> å¦‚æœæ‚¨æƒ³åœ¨æ“ä½œä¸­çœ‹åˆ°è§£æå™¨ç»„åˆå™¨ï¼Œè¯·ç›´æ¥åˆ°NimbleParsecéƒ¨åˆ†ã€‚</p><p>   When programming, we frequently have to parse input (like a string) into a more computer-friendly data structure (like a tree or a list).</p><p>   ç¼–ç¨‹æ—¶ï¼Œæˆ‘ä»¬ç»å¸¸å¿…é¡»å°†è¾“å…¥ï¼ˆå¦‚å­—ç¬¦ä¸²ï¼‰è§£æä¸ºæ›´å‹å¥½çš„æ•°æ®ç»“æ„ï¼ˆå¦‚æ ‘æˆ–åˆ—è¡¨ï¼‰ã€‚</p><p> One fast way to do that is to write a regex expression that captures everything we need. But these can become quite lengthy and complicated, which leads to ugly code.</p><p> ä¸€ç§å¿«é€Ÿçš„æ–¹æ³•æ˜¯ç¼–å†™ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œæ•è·æˆ‘ä»¬éœ€è¦çš„ä¸€åˆ‡ã€‚ä½†è¿™äº›å¯èƒ½å˜å¾—éå¸¸å†—é•¿å’Œå¤æ‚ï¼Œè¿™å¯¼è‡´äº†ä¸‘é™‹çš„ä»£ç ã€‚</p><p> What if we could instead write parsers that map one-to-one to semantical units in the input and combine them to make a parser for that input?</p><p> å¦‚æœæˆ‘ä»¬å¯ä»¥å°†è§£æå™¨å†™å…¥è¾“å…¥ä¸­çš„ä¸€å¯¹ä¸€çš„è§£æå™¨ï¼Œè€Œæ˜¯ä½•æ—¶ä½•æ—¶ä½•æ—¶æ˜ å°„åˆ°è¾“å…¥ä¸­ï¼Œå¹¶å°†å®ƒä»¬ç»„åˆä¸ºè¯¥è¾“å…¥è¿›è¡Œè§£æå™¨ï¼Ÿ </p><p> Ultimately, parser combinators are just this: a way to combine simple parsers to create more complex parsers.</p><p>æœ€ç»ˆï¼Œè§£æå™¨ç»„åˆå™¨å°±æ˜¯è¿™æ ·ï¼šä¸€ç§æ–¹å¼æ¥ç»„åˆç®€å•çš„è§£æå™¨æ¥åˆ›å»ºæ›´å¤æ‚çš„è§£æå™¨ã€‚</p><p>   So what do parsers do, exactly? The main goal of a parser is to parse a string of text into a different, more structured object, like a list or a tree.</p><p>   é‚£ä¹ˆè§£é‡Šè€…ç¡®å®æ˜¯ä»€ä¹ˆï¼Ÿè§£æå™¨çš„ä¸»è¦ç›®æ ‡æ˜¯å°†ä¸€ä¸²æ–‡æœ¬è§£æä¸ºä¸åŒçš„ï¼Œæ›´å¤šçš„ç»“æ„åŒ–å¯¹è±¡ï¼Œå¦‚åˆ—è¡¨æˆ–æ ‘ã€‚</p><p> For example, we could accept a list of integers as a string  &#34;3, 1, 4, 1&#34; and turn that string into a list to better represent the structure inherent in the string â€“  [3, 1, 4, 1].</p><p> ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥æ¥å—æ•´æ•°åˆ—è¡¨ä½œä¸ºå­—ç¬¦ä¸²ï¼†ï¼ƒ34; 3,1ï¼Œ1,4,13;å¹¶å°†è¯¥å­—ç¬¦ä¸²è½¬æ¢ä¸ºåˆ—è¡¨ä»¥æ›´å¥½åœ°è¡¨ç¤ºå­—ç¬¦ä¸²ä¸­å›ºæœ‰çš„ç»“æ„ -  [3,1,4,1]ã€‚</p><p> But what if we come upon a string like  &#34;3, 1, 4, 1 -- Monday, December 28th&#34;? Or  &#34;oops, I&#39;m sorry&#34;? To compose with other parsers and handle possible failure, we also need to return the rest of the input if the parser succeeds and an error if it doesnâ€™t.</p><p> ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬é‡åˆ°åƒï¼†ï¼ƒ34; 3,1.1,4,12ï¼Œæ˜ŸæœŸä¸€ï¼Œ12æœˆ28æ—¥ï¼†ï¼ƒ34 ;?æˆ–ï¼†ï¼ƒ34;å“å‘€ï¼Œæˆ‘ï¼†ï¼ƒ39;æŠ±æ­‰ï¼†ï¼ƒ34 ;?è¦ä¸å…¶ä»–è§£æå™¨è¿›è¡Œæ’°å†™å¹¶å¤„ç†å¯èƒ½çš„æ•…éšœï¼Œæˆ‘ä»¬è¿˜éœ€è¦è¿”å›å…¶ä½™çš„è¾“å…¥å¦‚æœè§£æå™¨æˆåŠŸï¼Œå¦‚æœå®ƒæ²¡æœ‰é”™è¯¯ï¼Œåˆ™é”™è¯¯ã€‚</p><p>  Hereâ€™s an example of a low-level parser that parses one decimal digit in Elixir.</p><p>  è¿™æ˜¯ä¸€ä¸ªä½çº§è§£æå™¨çš„ç¤ºä¾‹ï¼Œå®ƒåœ¨Elixirä¸­è§£æäº†ä¸€ä¸ªåè¿›åˆ¶æ•°å­—ã€‚</p><p> def  (&lt;&lt;char, rest::bitstring&gt;&gt;)  when char &gt;=  48  and char &lt;=  57,  do: { :ok, [char -  48], rest}   def  (_),  do: { :error,  :wrong_input}</p><p> defï¼ˆï¼†lt;ï¼†lt;ï¼†lt; charï¼Œstrite :: bit.ï¼†gt;ï¼‰å½“charï¼†gt; = 48å’Œcharï¼†lt; = 57ï¼Œdoï¼š{ï¼šç¡®å®šï¼Œ[char  -  48]ï¼Œrest} defï¼ˆ_ï¼‰ï¼Œåšï¼š {ï¼šé”™è¯¯ï¼Œï¼šé”™è¯¯_INPUT}</p><p> If you ask what we can do with it, the answer is: not very much. ğŸ˜… To unlock the power of parser combinators, we need to find a way to put different parsers together.</p><p> å¦‚æœæ‚¨è¯¢é—®æˆ‘ä»¬å¯ä»¥ç”¨å®ƒåšä»€ä¹ˆï¼Œç­”æ¡ˆæ˜¯ï¼šä¸æ˜¯å¾ˆå¤šã€‚ ğŸ˜…è§£é”è§£æå™¨ç»„åˆè€…çš„åŠ›é‡ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•æ¥å°†ä¸åŒçš„è§£æå™¨æ”¾åœ¨ä¸€èµ·ã€‚ </p><p>   A parser combinator is a function that combines two or more parsers into another parser.</p><p>è§£æå™¨ç»„åˆå™¨æ˜¯å°†ä¸¤ä¸ªæˆ–å¤šä¸ªè§£æå™¨ç»„åˆåˆ°å¦ä¸€ä¸ªè§£æå™¨ä¸­çš„å‡½æ•°ã€‚</p><p>  Letâ€™s think about the ways we could combine parsers. The most straightforward combination would be to link two together â€“ make the parser parse two decimal digits one by one.</p><p>  è®©æˆ‘ä»¬è€ƒè™‘æˆ‘ä»¬å¯ä»¥ç»“åˆè§£æå™¨çš„æ–¹å¼ã€‚æœ€ç®€å•çš„ç»„åˆå°†æ˜¯å°†ä¸¤ä¸ªé“¾æ¥åœ¨ä¸€èµ· - ä½¿è§£æå™¨é€ä¸ªè§£æä¸¤ä¸ªåè¿›åˆ¶æ•°å­—ã€‚</p><p> def  (fun, fun2)  do  fn x -&gt;  case fun.(x)  do { :ok, parsed, rest} -&gt;  case fun2.(rest)  do { :ok, parsed2, rest2} -&gt; { :ok, parsed ++ parsed2, rest2} err -&gt; err  end err -&gt; err  end  end  end</p><p> defï¼ˆæœ‰è¶£ï¼Œfun2ï¼‰åšfn x  - ï¼†gt;æ¡ˆä¾‹æœ‰è¶£ã€‚ï¼ˆxï¼‰do {ï¼šå¥½çš„ï¼Œè§£æï¼Œä¼‘æ¯}  - ï¼†gt;æ¡ˆä¾‹fun2ã€‚ï¼ˆä¼‘æ¯ï¼‰do {ï¼šå¥½çš„ï¼Œparsed2ï¼Œrest2}  - ï¼†gt; {ï¼šå¥½çš„ï¼Œè§£æ++ parsed2ï¼Œrest2} err  - ï¼†gt;å‘ƒç»“æŸé”™è¯¯ - ï¼†gt;å‘ƒç»“æŸç»“æŸ</p><p> Here, the resulting parser applies the first function to the input, then the second function to the rest of the input that the first function returns. We return both parsed items as a list and the input that the second function didnâ€™t consume. In case there is an error, it just gets passed further.</p><p> è¿™é‡Œï¼Œå¾—åˆ°çš„è§£æå™¨å°†ç¬¬ä¸€å‡½æ•°åº”ç”¨äºè¾“å…¥ï¼Œç„¶åå°†ç¬¬äºŒä¸ªåŠŸèƒ½ä¸ç¬¬ä¸€å‡½æ•°è¿”å›çš„å‰©ä½™è¾“å…¥çš„å…¶ä½™éƒ¨åˆ†ã€‚æˆ‘ä»¬å°†ä¸¤ä¸ªè§£æçš„é¡¹ç›®ä½œä¸ºåˆ—è¡¨è¿”å›ï¼Œç¬¬äºŒä¸ªåŠŸèƒ½æœªæ¶ˆè€—çš„è¾“å…¥ã€‚å¦‚æœå‡ºç°é”™è¯¯ï¼Œå®ƒå°±åˆšåˆšè¿›ä¸€æ­¥ä¼ é€’ã€‚</p><p>  Now we can use our combinator repeatedly to create a parser that can parse 2, 3, even 4, and more integers in a row! But thatâ€™s just the beginning.</p><p>  ç°åœ¨æˆ‘ä»¬å¯ä»¥åå¤ä½¿ç”¨Combinatoræ¥åˆ›å»ºä¸€ä¸ªå¯ä»¥åœ¨ä¸€è¡Œä¸­è§£æ2,3ï¼Œç”šè‡³4å’Œæ›´å¤šæ•´æ•°çš„è§£æå™¨ï¼ä½†è¿™åªæ˜¯ä¸€å¼€å§‹ã€‚</p><p> There are multiple other combinator possibilities out there. A frequent one is choice, a naive version of which could look like this:</p><p> é‚£é‡Œæœ‰å¤šç§å…¶ä»–ç»„åˆå™¨å¯èƒ½æ€§ã€‚é¢‘ç¹çš„æ˜¯é€‰æ‹©ï¼Œä¸€ä¸ªå¤©çœŸçš„ç‰ˆæœ¬å¯ä»¥å¦‚ä¸‹æ‰€ç¤ºï¼š</p><p> def  (fun1, fun2)  do  fn x -&gt;  case {fun1.(x), fun2.(x)}  do {{ :ok, parsed, rest}, _ } -&gt; { :ok, parsed, rest} {_, { :ok, parsed, rest}} -&gt; { :ok, parsed, rest} {err, _} -&gt; err  end  end  end</p><p> defï¼ˆfun1ï¼Œfun2ï¼‰do fn x  - ï¼†gt;æ¡ˆä¾‹{fun1ã€‚ï¼ˆxï¼‰ï¼Œfun2ã€‚ï¼ˆxï¼‰} do {{ï¼šå¥½çš„ï¼Œè§£æï¼Œä¼‘æ¯}ï¼Œ_}  - ï¼†gt; {ï¼šå¥½çš„ï¼Œè§£æï¼Œä¼‘æ¯} {_ï¼Œ{ï¼šç¡®å®šï¼Œè§£æï¼Œä¼‘æ¯}}  - ï¼†gt; {ï¼šå¥½çš„ï¼Œè§£æï¼Œä¼‘æ¯} {errï¼Œ_}  - ï¼†gt;å‘ƒç»“æŸç»“æŸ </p><p> Here, it would try parsing two different parsers one by one and pick the one that succeeds first or return an error.</p><p>åœ¨è¿™é‡Œï¼Œå®ƒå°†å°è¯•ä¸€ä¸ªæ¥ä¸€ä¸ªåœ°è§£æä¸¤ä¸ªä¸åŒçš„è§£æå™¨å¹¶é€‰æ‹©é¦–å…ˆæˆ–è¿”å›é”™è¯¯çš„é‚£ä¸ªã€‚</p><p>  def  ()  do  fn x -&gt; parse_digit(x)  end  end   def  ()  do digit_parser() |&gt; concat(digit_parser())  end   def  ()  do digit_parser() |&gt; concat(digit_parser()) |&gt; concat(digit_parser())  end   def  ()  do choice(three_digits(), two_digits())  end</p><p>  defï¼ˆï¼‰do fn x  - ï¼†gt; parse_digitï¼ˆxï¼‰ç»“æŸode defï¼ˆï¼‰do digit_parserï¼ˆï¼‰|ï¼†gt; concatï¼ˆdigit_parserï¼ˆï¼‰ï¼‰ç»“æŸdefï¼ˆï¼‰do digit_parserï¼ˆï¼‰|ï¼†gt; concatï¼ˆdigit_parserï¼ˆï¼‰ï¼‰|ï¼†gt; concatï¼ˆdigit_parserï¼ˆï¼‰ï¼‰ç»“æŸdefï¼ˆï¼‰doé€‰æ‹©ï¼ˆthree_digitsï¼ˆï¼‰ï¼Œtwo_digitsï¼ˆï¼‰ï¼‰ç»“æŸ</p><p>  By combining different parsers, you can build large, complicated parsers that represent the rules of languages like JSON or XML, for example.</p><p>  é€šè¿‡ç»„åˆä¸åŒçš„è§£æå™¨ï¼Œæ‚¨å¯ä»¥æ„å»ºä»£è¡¨JSONæˆ–XMLç­‰è¯­è¨€è§„åˆ™çš„å¤§å‹å¤æ‚è§£æå™¨ã€‚</p><p> Real parser combinator libraries usually offer an assortment of different combinators that make it possible to represent parsers in a readable manner. Weâ€™ll see that later in our  NimbleParser example.</p><p> Real Parser Combinatoråº“é€šå¸¸æä¾›å„ç§ä¸åŒçš„ç»„åˆå™¨ï¼Œä½¿å¾—å¯ä»¥ä»¥å¯è¯»æ–¹å¼è¡¨ç¤ºè§£æå™¨ã€‚æˆ‘ä»¬ä¼šåœ¨æˆ‘ä»¬çš„NimbleParserç¤ºä¾‹ä¸­çœ‹åˆ°ã€‚</p><p>   Our preliminary error handling is rather naive, and Iâ€™ve been informed that there is a misconception that parser combinators handle errors badly. Letâ€™s see how we can easily extend our parser to show the position of unexpected input.</p><p>   æˆ‘ä»¬çš„åˆæ­¥é”™è¯¯å¤„ç†æ˜¯éš¾åº¦çš„ï¼Œå¹¶ä¸”æˆ‘è¢«å‘ŠçŸ¥æœ‰ä¸€ç§è¯¯è§£ï¼Œè§£æå™¨ç»„åˆè€…ä¸¥é‡å¤„ç†é”™è¯¯ã€‚è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•è½»æ¾æ‰©å±•Parserä»¥æ˜¾ç¤ºæ„å¤–è¾“å…¥çš„ä½ç½®ã€‚</p><p>  def  (&lt;&lt;char, rest::bitstring&gt;&gt;)  when char &gt;=  48  and char &lt;=  57,  do: { :ok, [char -  48], rest}   def  (&lt;&lt;char, _rest::bitstring&gt;&gt;),  do: { :error, { :unexpected_input, &lt;&lt;char&gt;&gt;,  1}}   def  ( &#34;&#34;),  do: { :error,  :end_of_string}   def  (_),  do: { :error,  :not_string}</p><p>  defï¼ˆï¼†lt;ï¼†lt; charï¼Œä¼‘æ¯:: bit.ï¼†gt;ï¼‰å½“charï¼†gt; = 48å’Œcharï¼†lt; = 57ï¼ŒDOï¼š{ï¼šOKï¼Œ[CHAR  -  48]ï¼ŒREST} DEFï¼ˆï¼†lt;ï¼†lt; ï¼Œ_rest :: bitstringï¼†gt;ï¼†gt;ï¼‰ï¼Œdoï¼š{ï¼šé”™è¯¯ï¼Œ{ï¼šæ„å¤–çš„ï¼Œï¼†lt;ï¼†lt;ï¼†gt; charï¼†gt;ï¼†gt; 1}} defï¼ˆï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼‰ï¼Œdoï¼š{ï¼šé”™è¯¯ï¼Œ ï¼šend_of_string} defï¼ˆ_ï¼‰ï¼Œdoï¼š{ï¼šé”™è¯¯ï¼Œï¼šnot_string}</p><p> In addition to input errors, an EOS error can happen quite easily, so I made sure to cover that.</p><p> é™¤äº†è¾“å…¥é”™è¯¯ä¹‹å¤–ï¼ŒEOSé”™è¯¯ä¹Ÿä¼šå¾ˆå®¹æ˜“åœ°å‘ç”Ÿï¼Œå› æ­¤æˆ‘ç¡®ä¿è¦†ç›–ã€‚ </p><p> Now we can modify our concat combinator to track the position of an input error, if it occurs:</p><p>ç°åœ¨æˆ‘ä»¬å¯ä»¥ä¿®æ”¹èŠ¯ç‰‡ç»„åˆå™¨ä»¥è·Ÿè¸ªè¾“å…¥é”™è¯¯çš„ä½ç½®ï¼Œå¦‚æœå‘ç”Ÿï¼Ÿ</p><p> def  (fun, fun2)  do  fn x -&gt;  case fun.(x)  do { :ok, parsed, rest} -&gt;  case fun2.(rest)  do { :ok, parsed2, rest2} -&gt; { :ok, parsed ++ parsed2, rest2} { :error, { :unexpected_input, input, pos}} -&gt; { :error, { :unexpected_input, input, String.length(x) - String.length(rest) + pos}} err -&gt; err  end err -&gt; err  end  end  end</p><p> defï¼ˆæœ‰è¶£ï¼Œfun2ï¼‰åšfn x  - ï¼†gt;æ¡ˆä¾‹æœ‰è¶£ã€‚ï¼ˆxï¼‰do {ï¼šå¥½çš„ï¼Œè§£æï¼Œä¼‘æ¯}  - ï¼†gt;æ¡ˆä¾‹fun2ã€‚ï¼ˆä¼‘æ¯ï¼‰do {ï¼šå¥½çš„ï¼Œparsed2ï¼Œrest2}  - ï¼†gt; {ï¼šå¥½çš„ï¼Œè§£æ++ parsed2ï¼Œrest2} {ï¼šé”™è¯¯ï¼Œ{ï¼šæ„å¤–_ inputï¼Œè¾“å…¥ï¼Œpos}}  - ï¼†gt; {ï¼šé”™è¯¯ï¼Œ{ï¼šmementrial_inputï¼Œè¾“å…¥ï¼Œstring.lengthï¼ˆxï¼‰ -  string.lengthï¼ˆrestï¼‰+ pos}} Err  - ï¼†gt;å‘ƒç»“æŸé”™è¯¯ - ï¼†gt;å‘ƒç»“æŸç»“æŸ</p><p> The choice combinator already handles these errors well. You can see the end result  here.</p><p> é€‰æ‹©ç»„åˆå™¨å·²ç»å¾ˆå¥½åœ°å¤„ç†è¿™äº›é”™è¯¯ã€‚æ‚¨å¯ä»¥åœ¨æ­¤å¤„çœ‹åˆ°æœ€ç»ˆç»“æœã€‚</p><p> Now when we try to do  two_or_three_digits.(&#34;5a&#34;), weâ€™ll get  {:error, {:unexpected_input, &#34;a&#34;, 2}}. If we expose the code as a library, we can easily make nice error messages.</p><p> ç°åœ¨ï¼Œå½“æˆ‘ä»¬å°è¯•åšä¸¤ä¸ª_or_three_digitsæ—¶ã€‚ï¼ˆï¼†ï¼ƒ34; 5aï¼†ï¼ƒ34;ï¼‰ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°{ï¼šé”™è¯¯ï¼Œ{ï¼šmementrial_inputï¼Œï¼†ï¼ƒ34; aï¼†ï¼ƒ34;ï¼Œ2}}ã€‚å¦‚æœæˆ‘ä»¬å°†ä»£ç è§†ä¸ºåº“ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°åˆ¶ä½œé”™è¯¯æ¶ˆæ¯ã€‚</p><p> This code is, of course, for demonstration purposes only, but a similar approach is used in  megaparsec, a Haskell parser combinator library that is renowned for its decent error reporting.</p><p> å½“ç„¶ï¼Œæ­¤ä»£ç ä»…ç”¨äºæ¼”ç¤ºç›®çš„ï¼Œä½†æ˜¯åœ¨Megaparsecä¸­ä½¿ç”¨äº†ç±»ä¼¼çš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æ˜¯ä¼—æ‰€å‘¨çŸ¥çš„Haskellè§£æå™¨ç»„åˆåº“åº“ï¼Œè¯¥åº“è¢«ç€åï¼Œè¯¥åº“æ˜¯ç”±äºå…¶ä¸é”™çš„é”™è¯¯æŠ¥å‘Šã€‚</p><p>   Since parser combinators are much more powerful than regex, you can use them for parsing items with complex, recursive structures. But they can also be used for simple parsers where an item can have a lot of different alternatives, for example.</p><p>   ç”±äºParserç»„åˆå™¨æ¯”Regexæ›´å¼ºå¤§ï¼Œå› æ­¤æ‚¨å¯ä»¥ä½¿ç”¨å®ƒä»¬æ¥è§£æå…·æœ‰å¤æ‚ï¼Œé€’å½’ç»“æ„çš„é¡¹ç›®ã€‚ä½†æ˜¯ï¼Œå®ƒä»¬ä¹Ÿå¯ä»¥ç”¨äºç®€å•çš„è§£æå™¨ï¼Œå…¶ä¸­ä¸€ä¸ªé¡¹ç›®å¯ä»¥å…·æœ‰å¾ˆå¤šä¸åŒçš„æ›¿ä»£æ–¹æ¡ˆã€‚</p><p> They do not replace regex, though. Each tool has its benefits. I would use regex for simple scripts or one-liners and parser combinators for most other parsing needs.</p><p> ä½†æ˜¯ï¼Œå®ƒä»¬ä¸ä¼šæ›¿æ¢æ­£åˆ™è¡¨è¾¾å¼ã€‚æ¯ä¸ªå·¥å…·éƒ½æœ‰å®ƒçš„å¥½å¤„ã€‚å¯¹äºå¤§å¤šæ•°å…¶ä»–è§£æéœ€æ±‚ï¼Œæˆ‘å°†ä½¿ç”¨Regexä¸ºç®€å•çš„è„šæœ¬æˆ–å•è¡Œç»„å’Œè§£æå™¨ç»„åˆå™¨ã€‚ </p><p>  Quick aside: I got helped a lot in this section by  Jonn Mostovoy, who recently published a  hands-on guide to using parser combinators in Rust. If youâ€™re interested in seeing how to handle them in a bare metal language, Iâ€™d suggest checking it out.</p><p>å¿«é€ŸæŠ›å¼€ï¼šJonn Mostovoyåœ¨æ­¤éƒ¨åˆ†ä¸­å¾—åˆ°äº†å¾ˆå¤šå¸®åŠ©ï¼Œä»–æœ€è¿‘å‘è¡¨äº†ä¸€å°å®è·µæŒ‡å—ï¼Œä»¥åœ¨Rustä¸­ä½¿ç”¨Parser Combinatorsã€‚å¦‚æœæ‚¨æœ‰å…´è¶£çœ‹åˆ°å¦‚ä½•ä»¥è£¸éœ²çš„é‡‘å±è¯­è¨€å¤„ç†å®ƒä»¬ï¼Œæˆ‘å»ºè®®æ£€æŸ¥å®ƒã€‚</p><p>   NimbleParsec is a library that uses  metaprogramming to provide you with efficient parsers that compile to binary pattern matching. In this section, weâ€™ll use it to build a simple CSV parser that will take a CSV file and convert it into a list of lists.</p><p>   nimbleparsecæ˜¯ä¸€ä¸ªä½¿ç”¨å…ƒæ ‡è®°çš„åº“ï¼Œä¸ºæ‚¨æä¾›ç¼–è¯‘æˆäºŒè¿›åˆ¶æ¨¡å¼åŒ¹é…çš„é«˜æ•ˆè§£æå™¨ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å®ƒæ¥æ„å»ºä¸€ä¸ªç®€å•çš„CSVè§£æå™¨ï¼Œå°†é‡‡ç”¨CSVæ–‡ä»¶å¹¶å°†å…¶è½¬æ¢ä¸ºåˆ—è¡¨åˆ—è¡¨ã€‚</p><p>   First off, letâ€™s use  mix new CSVParser to create a new project called CSVParser. Afterward, add  {:nimble_parsec, &#34;~&gt; 1.0&#34;} to the list of dependencies in  mix.exs and import  NimbleParsec in the module.</p><p>   é¦–å…ˆï¼Œè®©æˆ‘ä»¬ä½¿ç”¨mix new csvparseråˆ›å»ºä¸€ä¸ªåä¸ºcsvparserçš„æ–°é¡¹ç›®ã€‚ä¹‹åï¼Œæ·»åŠ {ï¼šnimble_parsecï¼Œï¼†ï¼ƒ34;ã€œï¼†gt; 1.0ï¼†ï¼ƒ34;}åœ¨MIX.EXSä¸­çš„ä¾èµ–é¡¹åˆ—è¡¨å’Œæ¨¡å—ä¸­å¯¼å…¥NIMBLEPARSECã€‚</p><p>     CSV consists of lines, each of which consists of values separated by commas. We can probably define a CSV value and then use the definition to define a line. Letâ€™s write out simple definitions in English.</p><p>     CSVç”±è¡Œç»„æˆï¼Œæ¯ä¸ªçº¿æ¡ç”±é€—å·åˆ†éš”çš„å€¼ç»„æˆã€‚æˆ‘ä»¬å¯èƒ½å¯ä»¥å®šä¹‰CSVå€¼ï¼Œç„¶åä½¿ç”¨å®šä¹‰æ¥å®šä¹‰ä¸€è¡Œã€‚è®©æˆ‘ä»¬ç”¨è‹±è¯­å†™å‡ºç®€å•çš„å®šä¹‰ã€‚</p><p> Value is a string (letâ€™s ignore numbers, escape characters, and floats for now).</p><p> å€¼æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆå…è®¸ç°åœ¨å¿½ç•¥æ•°å­—ï¼Œè½¬ä¹‰å­—ç¬¦å’Œæµ®åŠ¨ï¼‰ã€‚</p><p> Line consists of a value, then possible repeats of (comma, then value), then an EOL character.</p><p> çº¿ç”±ä¸€ä¸ªå€¼ç»„æˆï¼Œç„¶åå¯èƒ½çš„é‡å¤ï¼ˆé€—å·ï¼Œç„¶åå€¼ï¼‰ï¼Œç„¶åæ˜¯EOLå­—ç¬¦ã€‚</p><p> How can we use the functions available in the library to reflect this simple grammar?</p><p> æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨åº“ä¸­å¯ç”¨çš„åŠŸèƒ½æ¥åæ˜ è¿™ä¸ªç®€å•çš„è¯­æ³•ï¼Ÿ </p><p>    To implement value, we need to think about the characters that will separate these values. One good contender would be  ,, but you can also encounter newline characters  \n and  \r. Values can also be empty, so we need to provide for that.</p><p>è¦å®ç°å€¼ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘å°†åˆ†å¼€è¿™äº›å€¼çš„å­—ç¬¦ã€‚ä¸€ä¸ªå¥½çš„ç«äº‰è€…æ˜¯ï¼Œä½†ä½ ä¹Ÿå¯ä»¥é‡åˆ°æ¢è¡Œç¬¦\ nå’Œ\ rã€‚å€¼ä¹Ÿå¯ä»¥æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æä¾›å®ƒã€‚</p><p> The best fit for our goal is  utf8_string, which lets us provide several arguments such as  not (which chars not to parse) and  min (minimum length).</p><p> æœ€é€‚åˆæˆ‘ä»¬çš„ç›®æ ‡æ˜¯UTF8_STRINGï¼Œè¿™è®©æˆ‘ä»¬æä¾›äº†å‡ ä¸ªè®ºç‚¹ï¼Œä¾‹å¦‚ä¸æ˜¯ï¼ˆä¸è§£æçš„å­—ç¬¦ï¼‰å’Œæœ€å°é•¿åº¦ï¼‰ã€‚</p><p>  Then, we need to define a line. For us, a line is a value, then a comma and a value, repeated 0 or more times, and then an EOL character.</p><p>  ç„¶åï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€è¡Œã€‚å¯¹äºæˆ‘ä»¬ï¼Œä¸€è¡Œæ˜¯ä¸€ä¸ªå€¼ï¼Œç„¶åæ˜¯é€—å·å’Œä¸€ä¸ªå€¼ï¼Œé‡å¤0æˆ–æ›´å¤šæ¬¡ï¼Œç„¶åé‡å¤ä¸ºEOLå­—ç¬¦ã€‚</p><p>  We have the value defined, but letâ€™s quickly define an EOL parser that covers Windows, macOS, and Linux.</p><p>  æˆ‘ä»¬æœ‰å€¼å®šä¹‰ï¼Œä½†è®©æˆ‘ä»¬å¿«é€Ÿå®šä¹‰æ¶µç›–Windowsï¼ŒMacOSå’ŒLinuxçš„EOLè§£æå™¨ã€‚</p><p>  As we saw before, choice enables us to parse the first option that succeeds from a list of functions.</p><p>  æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€çœ‹åˆ°çš„ï¼Œé€‰æ‹©ä½¿æˆ‘ä»¬èƒ½å¤Ÿè§£æä»åŠŸèƒ½åˆ—è¡¨ä¸­æˆåŠŸçš„ç¬¬ä¸€ä¸ªé€‰é¡¹ã€‚</p><p> After that, we can use the combinators  ignore,  concat, and  repeat together with our defined parsers to define a line.</p><p> ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Combinatorå¿½ç•¥ï¼ŒConcatå’Œä¸æˆ‘ä»¬å®šä¹‰çš„è§£æå™¨ä¸€èµ·é‡å¤ä»¥å®šä¹‰ä¸€è¡Œã€‚</p><p>  ignore will ignore the character and move forward without parsing anything,  concat composes two parsers, and  repeat repeats a parser until it doesnâ€™t succeed.</p><p>  å¿½ç•¥å°†å¿½ç•¥å­—ç¬¦å¹¶åœ¨ä¸è§£æä»»ä½•å†…å®¹çš„æƒ…å†µä¸‹å‘å‰ç§»åŠ¨ï¼Œæ±‚è§£ä¸¤ä¸ªè§£æå™¨ï¼Œå¹¶é‡å¤é‡å¤è§£æå™¨ï¼Œç›´åˆ°å®ƒä¸ä¼šæˆåŠŸã€‚ </p><p>   Now that we have the line element, it is very easy to define the full parser. To do that, we need to use the  defparsec macro.</p><p>ç°åœ¨æˆ‘ä»¬æœ‰çº¿å…ƒç´ ï¼Œå®ƒéå¸¸å®¹æ˜“å®šä¹‰å®Œæ•´çš„è§£æå™¨ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨defparsecå®ã€‚</p><p>  Here, we parse a line, wrap it in  [], and repeat the process until it doesnâ€™t succeed. Now, if we read a CSV file,  CSVParser.file(file_contents) will parse the contents of simple CSV files.</p><p>  åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è§£æä¸€è¡Œï¼Œå°†å…¶åŒ…è£…åœ¨[]ä¸­ï¼Œç„¶åé‡å¤è¯¥è¿‡ç¨‹ï¼Œç›´åˆ°å®ƒæ²¡æœ‰æˆåŠŸã€‚ç°åœ¨ï¼Œå¦‚æœæˆ‘ä»¬è¯»å–CSVæ–‡ä»¶ï¼ŒCSVParser.fileï¼ˆfile_contentsï¼‰å°†è§£æç®€å•çš„CSVæ–‡ä»¶çš„å†…å®¹ã€‚</p><p>  defmodule    do  import NimbleParsec value = utf8_string([ not: ?\r,  not: ?\n,  not: ?,],  min: 0) eol = choice([ string( &#34;\r\n&#34;), string( &#34;\n&#34;) ]) line = value |&gt; repeat(ignore(string( &#34;,&#34;)) |&gt; concat(value)) |&gt; ignore(eol) defparsec  :file, line |&gt; wrap() |&gt; repeat(),  debug:  true end</p><p>  defmodule doå¯¼å…¥nimbleparsecå€¼= utf8_stringï¼ˆ[ä¸æ˜¯ï¼š\ rï¼Œä¸æ˜¯ï¼šï¼Ÿ\ nï¼Œä¸æ˜¯ï¼šï¼Ÿï¼Œ]ï¼Œminï¼š0ï¼‰eol = choiceï¼ˆ[stringï¼ˆï¼†ï¼ƒ34; \ r \ nï¼†ï¼ƒ34;ï¼‰ ï¼Œå­—ç¬¦ä¸²ï¼ˆï¼†ï¼ƒ34; \ nï¼†ï¼ƒ34;ï¼‰]ï¼‰çº¿=å€¼|ï¼†gt;é‡å¤ï¼ˆå¿½ç•¥ï¼ˆä¸²ï¼ˆï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼‰ï¼‰|ï¼†gt; concatï¼ˆä»·å€¼ï¼‰ï¼‰|ï¼†gt;å¿½ç•¥ï¼ˆeolï¼‰defparsecï¼šæ–‡ä»¶ï¼Œçº¿|ï¼†gt;åŒ…è£¹ï¼ˆï¼‰|ï¼†gt;é‡å¤ï¼ˆï¼‰ï¼Œè°ƒè¯•ï¼šTRUE END</p><p>     Our CSV definition was very simple. It didnâ€™t cover some of the things that can appear in CSV, and it also treats numbers and strings the same. Arguably, we could have split the file on newline chars, mapped a split on commas on the resulting list, and achieved the same result.</p><p>     æˆ‘ä»¬çš„CSVå®šä¹‰éå¸¸ç®€å•ã€‚å®ƒæ²¡æœ‰æ¶µç›–åœ¨CSVä¸­å‡ºç°çš„ä¸€äº›ä¸œè¥¿ï¼Œå®ƒä¹Ÿå¯ä»¥å¤„ç†ç›¸åŒçš„æ•°å­—å’Œå­—ç¬¦ä¸²ã€‚å¯ä»¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ–‡ä»¶æ‹†åˆ†åœ¨æ¢è¡Œç¬¦ä¸Šï¼Œåœ¨ç”Ÿæˆçš„åˆ—è¡¨ä¸Šæ˜ å°„é€—å·æ‹†åˆ†ï¼Œå¹¶å®ç°äº†ç›¸åŒçš„ç»“æœã€‚</p><p> But, since we have created a good foundation, adding new definitions to the parser is much simpler than improving a two-line function. Letâ€™s try to fix one of these issues now.</p><p> ä½†æ˜¯ï¼Œç”±äºæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªè‰¯å¥½çš„åŸºç¡€ï¼Œå› æ­¤å‘è§£æå™¨æ·»åŠ æ–°å®šä¹‰æ¯”æ”¹å–„åŒçº¿åŠŸèƒ½è¦ç®€å•å¾—å¤šã€‚è®©æˆ‘ä»¬å°è¯•ç«‹å³è§£å†³è¿™äº›é—®é¢˜ä¹‹ä¸€ã€‚</p><p> One of the problems is that CSV files can have commas in entries. Our parser always splits on the comma. Letâ€™s add an option to escape commas by wrapping the entry in double quotes.</p><p> å…¶ä¸­ä¸€ä¸ªé—®é¢˜æ˜¯CSVæ–‡ä»¶å¯ä»¥åœ¨æ¡ç›®ä¸­å…·æœ‰é€—å·ã€‚æˆ‘ä»¬çš„è§£æå™¨å§‹ç»ˆåœ¨é€—å·ä¸Šæ‹†åˆ†ã€‚è®©æˆ‘ä»¬é€šè¿‡å°†æ¡ç›®åŒ…è£…åœ¨åŒå¼•å·ä¸­æ·»åŠ ä¸€ä¸ªé€‰é¡¹æ¥é€ƒè„±é€—å·ã€‚</p><p>  An escaped value consists of zero or more characters, surrounded by double quotes. In case there is a double quote inside the escaped value, the double quote will need to be escaped by another double quote.</p><p>  è½¬ä¹‰çš„å€¼ç”±é›¶ä¸ªæˆ–å¤šä¸ªå­—ç¬¦ç»„æˆï¼Œç”±åŒå¼•å·åŒ…å›´ã€‚å¦‚æœé€ƒé€¸å€¼å†…éƒ¨çš„åŒé‡å¼•ç”¨ï¼Œåˆ™éœ€è¦é€šè¿‡å¦ä¸€ä¸ªåŒé‡æŠ¥ä»·è¿›è¡ŒåŒå¼•ç”¨ã€‚ </p><p>     Then we need to figure out how to parse the inside of the double quotes to fulfill the requirements.</p><p>ç„¶åæˆ‘ä»¬éœ€è¦å¼„æ¸…æ¥šå¦‚ä½•è§£æåŒå¼•å·çš„å†…éƒ¨ä»¥æ»¡è¶³è¦æ±‚ã€‚</p><p> After going through a rather  roundabout way to achieve this (you donâ€™t want to know ğŸ™ˆ), I found a tip in  Real World Haskell that we can just read characters of the item one by one, matching only two double quotes in a row or a non-quote character.</p><p> ç»è¿‡ä¸€ä¸ªç›¸å½“ç¯å½¢äº¤æµçš„æ–¹å¼å®ç°è¿™ä¸€ç›®æ ‡ï¼ˆæ‚¨ä¸æƒ³çŸ¥é“ğŸ™ˆï¼‰ï¼Œæˆ‘å‘ç°ä¸€ä¸ªåœ¨çœŸå®ä¸–ç•Œä¸­çš„æç¤ºHaskellï¼Œæˆ‘ä»¬å¯ä»¥é€ä¸€è¯»å–é¡¹ç›®çš„å­—ç¬¦ï¼Œè¿ç»­ä¸¤ä¸ªåŒå¼•å·åŒ¹é…æˆ–éæŠ¥ä»·å­—ç¬¦ã€‚</p><p>   Now we can use the repeat combinator on  escaped_character, then join all the characters we parsed.</p><p>   ç°åœ¨æˆ‘ä»¬å¯ä»¥åœ¨Escaped_characterä¸Šä½¿ç”¨é‡å¤ç»„åˆå™¨ï¼Œç„¶ååŠ å…¥æˆ‘ä»¬è§£æçš„æ‰€æœ‰å­—ç¬¦ã€‚</p><p>  Letâ€™s rename the original value to  regular_value and make value a choice between  escaped_value and  regular_value.</p><p>  è®©æˆ‘ä»¬å°†åŸå§‹å€¼é‡å‘½åä¸ºramence_valueï¼Œå¹¶åœ¨ESCAPED_VALUEå’ŒREMINAL_VALUEä¹‹é—´è¿›è¡Œå€¼ã€‚</p><p> escaped_character = choice([ string(&#34;\&#34;\&#34;&#34;), utf8_string([not: ?&#34;], 1) ]) regular_value = utf8_string([not: ?\r, not: ?\n, not: ?,], min: 0) escaped_value = ignore(string(&#34;\&#34;&#34;)) |&gt; repeat(escaped_character) |&gt; ignore(string(&#34;\&#34;&#34;)) |&gt; reduce({Enum, :join, [&#34;&#34;]}) value = choice([ escaped_value, regular_value ])</p><p> escaped_character = choiceï¼ˆ[å­—ç¬¦ä¸²ï¼ˆï¼†ï¼ƒ34; \ï¼†ï¼ƒ34; \ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34; [34; [ä¸æ˜¯ï¼šï¼†ï¼ƒ34;]ï¼Œ1ï¼‰]ï¼‰commonal_value = utf8_stringï¼ˆ[ä¸æ˜¯ï¼š ï¼Ÿ\ rï¼Œä¸æ˜¯ï¼šï¼Ÿ\ nï¼Œä¸æ˜¯ï¼šï¼Ÿï¼Œ]ï¼Œminï¼š0ï¼‰escaped_value =å¿½ç•¥ï¼ˆå­—ç¬¦ä¸²ï¼ˆï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼‰ï¼‰|ï¼†gt;é‡å¤ï¼ˆescaped_characterï¼‰|ï¼†gt;å¿½ç•¥ï¼ˆå­—ç¬¦ä¸²ï¼ˆï¼†ï¼ƒ34; \ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;ï¼‰ï¼‰|ï¼†gt;å‡å°‘ï¼ˆ{enumï¼Œï¼šåŠ å…¥ï¼Œ[ï¼†ï¼ƒ34;ï¼†ï¼ƒ34;]}ï¼‰å€¼=é€‰æ‹©ï¼ˆ[escaped_valueï¼Œscround_value]ï¼‰</p><p> We need to put  escaped_value first because otherwise, the parser will succeed with  regular_value on our string before we get a chance to escape.</p><p> æˆ‘ä»¬éœ€è¦å…ˆå°†Escaped_valueæ”¾è¿›ï¼Œå› ä¸ºå¦åˆ™ï¼Œåœ¨æˆ‘ä»¬çš„å­—ç¬¦ä¸²ä¸Šæœ‰æœºä¼šé€ƒè„±ä¹‹å‰ï¼Œè§£æå™¨å°†åœ¨range_valueä¸Šå–å¾—æˆåŠŸã€‚</p><p>    This parser can be further improved, of course. For example, you can add support for extra whitespace or numbers, which is an exciting exercise to do on your own.</p><p>    å½“ç„¶ï¼Œå¯ä»¥è¿›ä¸€æ­¥æ”¹å–„è¿™ä¸ªè§£æå™¨ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥ä¸ºé¢å¤–çš„ç©ºç™½æˆ–æ•°å­—æ·»åŠ æ”¯æŒï¼Œè¿™æ˜¯ä¸€ä¸ªä»¤äººå…´å¥‹çš„ç»ƒä¹ ã€‚ </p><p> I hope that this has been an exciting journey and that you learned something new today! If you want to read more about Elixir, you are welcome to browse our  Elixir articles and follow us on  Twitter,  DEV or  Medium to receive updates whenever we publish new ones.</p><p>æˆ‘å¸Œæœ›è¿™æ˜¯ä¸€ä¸ªä»¤äººå…´å¥‹çš„æ—…ç¨‹ï¼Œä½ ä»Šå¤©å­¦åˆ°äº†æ–°çš„ä¸œè¥¿ï¼ å¦‚æœæ‚¨æƒ³äº†è§£æ›´å¤šå…³äºElixirçš„ä¿¡æ¯ï¼Œæ¬¢è¿æ‚¨æµè§ˆæˆ‘ä»¬çš„Elixiræ–‡ç« å¹¶åœ¨æ¨ç‰¹ä¸Šå…³æ³¨æˆ‘ä»¬ï¼Œæ¯å½“æˆ‘ä»¬å‘å¸ƒæ–°çš„æ—¶ï¼ŒDEDæˆ–Medioæ¥æ”¶æ›´æ–°ã€‚ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://serokell.io/blog/parser-combinators-in-elixir">https://serokell.io/blog/parser-combinators-in-elixir</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/è§£æå™¨/">#è§£æå™¨</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>