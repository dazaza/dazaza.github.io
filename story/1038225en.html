<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>è¿™äº›ç°ä»£ç¼–ç¨‹è¯­è¨€ä¼šè®©æ‚¨å—è‹¦ These Modern Programming Languages Will Make You Suffer</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">These Modern Programming Languages Will Make You Suffer<br/>è¿™äº›ç°ä»£ç¼–ç¨‹è¯­è¨€ä¼šè®©æ‚¨å—è‹¦ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-07 22:45:53</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/f2aaabad359a81a3e66259f9afcbf7df.jpeg"><img src="http://img2.diglog.com/img/2020/12/f2aaabad359a81a3e66259f9afcbf7df.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>What are the pros and cons of a particular programming language? Is X a good language for my task? Googling for â€œbest programming languageâ€ will give you a standard list of â€œPython, Java, JavaScript, C#, C++, PHPâ€ with a vague list of pros and cons. Seeing such articles makes me cringe in pain, their authors must have been outright lazy, inexperienced, while lacking any imagination. Letâ€™s dive deep and find out what really sucks, and what doesnâ€™t.</p><p>ç‰¹å®šç¼–ç¨‹è¯­è¨€çš„ä¼˜ç¼ºç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ Xæ˜¯æˆ‘çš„ä»»åŠ¡å¾ˆå¥½çš„è¯­è¨€å—ï¼Ÿæœå¯»â€œæœ€ä½³ç¼–ç¨‹è¯­è¨€â€å°†ä¸ºæ‚¨æä¾›â€œ Pythonï¼ŒJavaï¼ŒJavaScriptï¼ŒCï¼ƒï¼ŒC ++ï¼ŒPHPâ€çš„æ ‡å‡†åˆ—è¡¨ï¼Œä»¥åŠä¼˜ç¼ºç‚¹çš„æ¨¡ç³Šåˆ—è¡¨ã€‚çœ‹åˆ°è¿™æ ·çš„æ–‡ç« ä¼šè®©æˆ‘æ„Ÿåˆ°ç—›è‹¦ï¼Œä»–ä»¬çš„ä½œè€…ä¸€å®šæ˜¯å®Œå…¨æ‡’æƒ°ï¼Œç¼ºä¹ç»éªŒï¼ŒåŒæ—¶åˆç¼ºä¹æƒ³è±¡åŠ›ã€‚è®©æˆ‘ä»¬æ·±å…¥ç ”ç©¶ä¸€ä¸‹ï¼Œæ‰¾å‡ºçœŸæ­£çš„ç¼ºç‚¹ï¼Œè€Œä¸æ˜¯ä»€ä¹ˆã€‚</p><p>  In this articl  e, Iâ€™ll attempt to give an objective and hopefully unbiased overview of popular (and not so popular) modern programming languages, ranked from the worst to the best.</p><p>  åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å°†å°è¯•å¯¹æµè¡Œçš„ï¼ˆè€Œä¸æ˜¯é‚£ä¹ˆæµè¡Œçš„ï¼‰ç°ä»£ç¼–ç¨‹è¯­è¨€ç»™å‡ºå®¢è§‚è€Œå…¬æ­£çš„æ¦‚è¿°ï¼Œä»æœ€ååˆ°æœ€å¥½çš„æ’åã€‚</p><p> Bear in mind that thereâ€™s no one programming language perfectly suited to all possible use cases. Some languages are best suited for Frontend Development, others work best for Backend/API Development, others are great for System Programming.</p><p> è¯·è®°ä½ï¼Œæ²¡æœ‰ä¸€ç§ç¼–ç¨‹è¯­è¨€å¯ä»¥å®Œç¾åœ°é€‚åˆæ‰€æœ‰å¯èƒ½çš„ç”¨ä¾‹ã€‚ä¸€äº›è¯­è¨€æœ€é€‚åˆäºå‰ç«¯å¼€å‘ï¼Œå…¶ä»–è¯­è¨€æœ€é€‚åˆäºåç«¯/ APIå¼€å‘ï¼Œå…¶ä»–è¯­è¨€åˆ™éå¸¸é€‚åˆç³»ç»Ÿç¼–ç¨‹ã€‚</p><p> Iâ€™m going to cover two of the most common language families in the world â€”  languages descended from C, and  languages descended from ML.</p><p> æˆ‘å°†ä»‹ç»ä¸–ç•Œä¸Šä¸¤ä¸ªæœ€å¸¸è§çš„è¯­è¨€å®¶æ—-è¯­è¨€æ˜¯Cè¡ç”Ÿçš„ï¼Œè€Œè¯­è¨€æ˜¯MLè¡ç”Ÿçš„ã€‚</p><p> Programming languages are just tools in a developerâ€™s toolbox. And it is important to choose the right tool for the job. I really hope that this guide will help you in choosing the most suitable programming language for your task. Making the right choice might save you months (or even years) of development effort.</p><p> ç¼–ç¨‹è¯­è¨€åªæ˜¯å¼€å‘äººå‘˜å·¥å…·ç®±ä¸­çš„å·¥å…·ã€‚é€‰æ‹©æ­£ç¡®çš„å·¥å…·æ¥å®Œæˆè¿™é¡¹å·¥ä½œå¾ˆé‡è¦ã€‚æˆ‘çœŸçš„å¸Œæœ›æœ¬æŒ‡å—å°†å¸®åŠ©æ‚¨é€‰æ‹©æœ€é€‚åˆæ‚¨ä»»åŠ¡çš„ç¼–ç¨‹è¯­è¨€ã€‚åšå‡ºæ­£ç¡®çš„é€‰æ‹©å¯ä»¥èŠ‚çœæ‚¨æ•°æœˆï¼ˆç”šè‡³æ•°å¹´ï¼‰çš„å¼€å‘å·¥ä½œã€‚</p><p>  Most other similar articles base their comparisons on factors like   popularity and   earning potential. Popularity is rarely a good measure, especially in the world of software (although a big community &amp; ecosystem helps). Instead Iâ€™ll be taking into account the  strengths and weaknesses of a particular language.</p><p>  å¤§å¤šæ•°å…¶ä»–ç±»ä¼¼çš„æ–‡ç« éƒ½æ ¹æ®å—æ¬¢è¿ç¨‹åº¦å’Œæ½œåœ¨æ”¶å…¥ç­‰å› ç´ è¿›è¡Œæ¯”è¾ƒã€‚æµè¡Œæ€§å¾ˆå°‘æ˜¯ä¸€ä¸ªå¥½çš„è¡¡é‡æ ‡å‡†ï¼Œå°¤å…¶æ˜¯åœ¨è½¯ä»¶é¢†åŸŸï¼ˆå°½ç®¡å¤§å‹ç¤¾åŒºå’Œç”Ÿæ€ç³»ç»Ÿä¼šæœ‰æ‰€å¸®åŠ©ï¼‰ã€‚ç›¸åï¼Œæˆ‘å°†è€ƒè™‘ç‰¹å®šè¯­è¨€çš„ä¼˜ç‚¹å’Œç¼ºç‚¹ã€‚</p><p> Iâ€™ll be using a thumbs-up ğŸ‘ (i.e. +1 ), a thumbs-down ğŸ‘, or an ok ğŸ‘Œ (neither good nor bad) emojis to signify the score of a particular language characteristic.</p><p> æˆ‘å°†ä½¿ç”¨å¤§æ‹‡æŒ‡ğŸ‘ï¼ˆå³+1ï¼‰ï¼Œå¤§æ‹‡æŒ‡æœä¸‹ğŸ‘æˆ–OKğŸ‘Œï¼ˆæ— è®ºå¥½åï¼‰è¡¨æƒ…ç¬¦å·æ¥è¡¨ç¤ºç‰¹å®šè¯­è¨€ç‰¹å¾çš„å¾—åˆ†ã€‚ </p><p> Now, how will we measure? In other words, what really matters, other than language popularity?</p><p>ç°åœ¨ï¼Œæˆ‘ä»¬å°†å¦‚ä½•è¡¡é‡ï¼Ÿæ¢å¥è¯è¯´ï¼Œé™¤äº†è¯­è¨€æµè¡Œä¹‹å¤–ï¼ŒçœŸæ­£é‡è¦çš„æ˜¯ä»€ä¹ˆï¼Ÿ</p><p>    Many people swear by type systems. Thatâ€™s why languages like TypeScript have picked up in popularity in recent years. I tend to agree, type systems eliminate a large number of errors in programs, and make refactoring easier. However, â€œhavingâ€ a type system is only one part of the story.</p><p>    è®¸å¤šäººæŒ‰ç±»å‹ç³»ç»Ÿå‘èª“ã€‚å› æ­¤ï¼Œè¿‘å¹´æ¥è¯¸å¦‚TypeScriptä¹‹ç±»çš„è¯­è¨€å¼€å§‹æµè¡Œã€‚æˆ‘å€¾å‘äºåŒæ„ï¼Œç±»å‹ç³»ç»Ÿæ¶ˆé™¤äº†ç¨‹åºä¸­çš„å¤§é‡é”™è¯¯ï¼Œå¹¶ä½¿é‡æ„æ›´åŠ å®¹æ˜“ã€‚ä½†æ˜¯ï¼Œâ€œæ‹¥æœ‰â€ç±»å‹ç³»ç»Ÿåªæ˜¯æ•…äº‹çš„ä¸€éƒ¨åˆ†ã€‚</p><p> If a language has a type system, then it is also very useful to have   type inference. The best type systems are able to infer most of the types, without annotating function signatures explicitly. Unfortunately, most of the programming languages only provide rudimentary type inference.</p><p> å¦‚æœè¯­è¨€å…·æœ‰ç±»å‹ç³»ç»Ÿï¼Œé‚£ä¹ˆè¿›è¡Œç±»å‹æ¨æ–­ä¹Ÿéå¸¸æœ‰ç”¨ã€‚æœ€å¥½çš„ç±»å‹ç³»ç»Ÿèƒ½å¤Ÿæ¨æ–­å¤§å¤šæ•°ç±»å‹ï¼Œè€Œæ— éœ€æ˜¾å¼æ³¨é‡ŠåŠŸèƒ½ç­¾åã€‚ä¸å¹¸çš„æ˜¯ï¼Œå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä»…æä¾›åŸºæœ¬çš„ç±»å‹æ¨æ–­ã€‚</p><p> It is also nice for a type system to support Algebraic Data Types (more on this later).</p><p> å¯¹äºç±»å‹ç³»ç»Ÿæ¥è¯´ï¼Œæ”¯æŒä»£æ•°æ•°æ®ç±»å‹ä¹Ÿå¾ˆå¥½ï¼ˆç¨åä¼šè¯¦ç»†ä»‹ç»ï¼‰ã€‚</p><p> The most powerful type systems support Higher-Kinded Types, which are one level of abstraction above generics, and allow us to program at an even higher level of abstraction.</p><p> æœ€å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿæ”¯æŒé«˜çº§ç±»å‹ï¼Œè¿™æ˜¯æ³›å‹ä¹‹ä¸Šçš„æŠ½è±¡çº§åˆ«ï¼Œå¹¶å…è®¸æˆ‘ä»¬ä»¥æ›´é«˜çš„æŠ½è±¡çº§åˆ«è¿›è¡Œç¼–ç¨‹ã€‚</p><p> We also have to keep in mind that people tend to put too much importance on type systems. There are things that matter far more than static typing, and presence/lack of a type system shouldnâ€™t be the only factor when choosing a language.</p><p> æˆ‘ä»¬è¿˜å¿…é¡»è®°ä½ï¼Œäººä»¬å¾€å¾€å¯¹ç±»å‹ç³»ç»Ÿè¿‡äºé‡è§†ã€‚æœ‰äº›äº‹æƒ…è¿œæ¯”é™æ€ç±»å‹é‡è¦ï¼Œé€‰æ‹©ç±»å‹æ—¶ï¼Œç±»å‹ç³»ç»Ÿçš„å­˜åœ¨ä¸å¦å¹¶ä¸æ˜¯å”¯ä¸€çš„å› ç´ ã€‚</p><p>    We might have the perfect programming language, but what use is it if onboarding new developers might take months or even years (upfront investment)? On the other side of the spectrum, some programming paradigms take years to become good at.</p><p>    æˆ‘ä»¬å¯èƒ½æ‹¥æœ‰å®Œç¾çš„ç¼–ç¨‹è¯­è¨€ï¼Œä½†æ˜¯å¦‚æœæ–°å…¥èŒçš„å¼€å‘äººå‘˜å¯èƒ½è¦èŠ±è´¹æ•°æœˆç”šè‡³æ•°å¹´ï¼ˆå‰æœŸæŠ•èµ„ï¼‰ï¼Œå®ƒå°†æœ‰ä»€ä¹ˆç”¨ï¼Ÿå¦ä¸€æ–¹é¢ï¼ŒæŸäº›ç¼–ç¨‹èŒƒä¾‹éœ€è¦èŠ±è´¹æ•°å¹´æ‰èƒ½å˜å¾—ç²¾é€šã€‚ </p><p> A good language should be approachable by beginners, and shouldnâ€™t take years to master.</p><p>ä¸€é—¨å¥½çš„è¯­è¨€åº”è¯¥é€‚åˆåˆå­¦è€…ï¼Œå¹¶ä¸”ä¸éœ€è¦èŠ±å‡ å¹´çš„æ—¶é—´å°±èƒ½æŒæ¡ã€‚</p><p>    I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldnâ€™t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p><p>    æˆ‘ç§°ä¹‹ä¸ºæˆ‘çš„åäº¿ç¾å…ƒé”™è¯¯ã€‚å®ƒæ˜¯1965å¹´åˆ›å»ºçš„ç©ºå¼•ç”¨ã€‚å½“æ—¶ï¼Œæˆ‘æ­£åœ¨è®¾è®¡ç¬¬ä¸€ä¸ªå…¨é¢çš„ç±»å‹ç³»ç»Ÿï¼Œç”¨äºé¢å‘å¯¹è±¡çš„è¯­è¨€ä¸­çš„å¼•ç”¨ã€‚æˆ‘çš„ç›®æ ‡æ˜¯ç¡®ä¿å¯¹å¼•ç”¨çš„æ‰€æœ‰ä½¿ç”¨éƒ½ç»å¯¹å®‰å…¨ï¼Œå¹¶ç”±ç¼–è¯‘å™¨è‡ªåŠ¨æ‰§è¡Œæ£€æŸ¥ã€‚ä½†æ˜¯æˆ‘å¿ä¸ä½è¦æ’å…¥ç©ºå¼•ç”¨çš„è¯±æƒ‘ï¼Œä»…ä»…æ˜¯å› ä¸ºå®ƒå¾ˆå®¹æ˜“å®ç°ã€‚è¿™å¯¼è‡´äº†æ— æ•°é”™è¯¯ï¼Œæ¼æ´å’Œç³»ç»Ÿå´©æºƒï¼Œåœ¨æœ€è¿‘å››åå¹´ä¸­å¯èƒ½é€ æˆåäº¿ç¾å…ƒçš„ç—›è‹¦å’Œç ´åã€‚</p><p> Why are null references bad? Null references break type systems. When null is the default value, we can no longer rely on the compiler to check the validity of the code. Any nullable value is a bomb waiting to explode. What if we attempt to use the value that we didnâ€™t think might be null, but it in fact is null? We get a runtime exception.</p><p> ä¸ºä»€ä¹ˆç©ºå¼•ç”¨ä¸å¥½ï¼Ÿç©ºå¼•ç”¨ä¸­æ–­ç±»å‹ç³»ç»Ÿã€‚å½“nullä¸ºé»˜è®¤å€¼æ—¶ï¼Œæˆ‘ä»¬å°†ä¸å†ä¾èµ–ç¼–è¯‘å™¨æ¥æ£€æŸ¥ä»£ç çš„æœ‰æ•ˆæ€§ã€‚ä»»ä½•å¯ä¸ºç©ºçš„å€¼éƒ½æ˜¯ç­‰å¾…çˆ†ç‚¸çš„ç‚¸å¼¹ã€‚å¦‚æœæˆ‘ä»¬å°è¯•ä½¿ç”¨æˆ‘ä»¬ä¸è®¤ä¸ºå¯èƒ½ä¸ºç©ºä½†å®é™…ä¸Šä¸ºç©ºçš„å€¼æ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªè¿è¡Œæ—¶å¼‚å¸¸ã€‚</p><p>  We have to rely on   manual runtime checks to make sure that the value weâ€™re dealing with isnâ€™t null. Even in a statically-typed language, null references take away many benefits of a type system.</p><p>  æˆ‘ä»¬å¿…é¡»ä¾é æ‰‹åŠ¨è¿è¡Œæ—¶æ£€æŸ¥æ¥ç¡®ä¿æ‰€å¤„ç†çš„å€¼ä¸ä¸ºnullã€‚å³ä½¿ä½¿ç”¨é™æ€ç±»å‹çš„è¯­è¨€ï¼Œç©ºå¼•ç”¨ä¹Ÿå‰¥å¤ºäº†ç±»å‹ç³»ç»Ÿçš„è®¸å¤šå¥½å¤„ã€‚</p><p>  Such runtime checks (sometimes called null guards) in reality are workarounds around bad language design. They litter our code with boilerplate. And worst of all, there are no guarantees that we wonâ€™t forget to check for null.</p><p>  å®é™…ä¸Šï¼Œè¿™ç§è¿è¡Œæ—¶æ£€æŸ¥ï¼ˆæœ‰æ—¶ç§°ä¸ºç©ºé˜²æŠ¤ï¼‰æ˜¯é’ˆå¯¹ä¸è‰¯è¯­è¨€è®¾è®¡çš„è§£å†³æ–¹æ³•ã€‚ä»–ä»¬ç”¨æ ·æ¿ä¹±ç ã€‚æœ€ç³Ÿç³•çš„æ˜¯ï¼Œæˆ‘ä»¬æ— æ³•ä¿è¯ä¸ä¼šå¿˜è®°æ£€æŸ¥nullã€‚</p><p> In a good language, the lack or presence of a value should be type-checked at compile-time.</p><p> ç”¨ä¸€ç§å¥½çš„è¯­è¨€ï¼Œåº”è¯¥åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å€¼çš„ç¼ºå¤±æˆ–å­˜åœ¨ã€‚</p><p>     Catching exceptions is a bad way to handle errors. Throwing exceptions is fine, but only in   exceptional circumstances, when the program has no way to recover, and has to crash. Just like nulls, exceptions break the type system.</p><p>     æ•è·å¼‚å¸¸æ˜¯å¤„ç†é”™è¯¯çš„ä¸€ç§åæ–¹æ³•ã€‚æŠ›å‡ºå¼‚å¸¸æ˜¯å¯ä»¥çš„ï¼Œä½†ä»…åœ¨ä¾‹å¤–æƒ…å†µä¸‹ï¼Œç¨‹åºæ— æ³•æ¢å¤å¹¶ä¸”å¿…é¡»å´©æºƒã€‚å°±åƒç©ºå€¼ä¸€æ ·ï¼Œå¼‚å¸¸ä¼šç ´åç±»å‹ç³»ç»Ÿã€‚ </p><p> When exceptions are used as a primary way of error handling, it is impossible to know whether a function will return an expected value or blow up. Functions throwing exceptions are also impossible to compose.</p><p>å½“ä½¿ç”¨å¼‚å¸¸ä½œä¸ºé”™è¯¯å¤„ç†çš„ä¸»è¦æ–¹å¼æ—¶ï¼Œå°±ä¸å¯èƒ½çŸ¥é“å‡½æ•°æ˜¯è¿”å›æœŸæœ›å€¼è¿˜æ˜¯å´©æºƒã€‚å¼•å‘å¼‚å¸¸çš„å‡½æ•°ä¹Ÿæ˜¯ä¸å¯èƒ½ç»„æˆçš„ã€‚</p><p>  Obviously, it is not ok for an entire application to crash simply because we couldnâ€™t fetch some data. Yet this is what really happens more often than weâ€™d like to admit.</p><p>  æ˜¾ç„¶ï¼Œä»…ä»…ç”±äºæˆ‘ä»¬æ— æ³•è·å–æŸäº›æ•°æ®è€Œå¯¼è‡´æ•´ä¸ªåº”ç”¨ç¨‹åºå´©æºƒæ˜¯ä¸å¯èƒ½çš„ã€‚ä½†è¿™ç¡®å®æ¯”æˆ‘ä»¬æƒ³è¦çš„æ›´ç»å¸¸å‘ç”Ÿã€‚</p><p> One option is to manually check for raised exceptions, but this approach is fragile (we may forget to check for an exception), and adds a lot of noise:</p><p> ä¸€ç§é€‰æ‹©æ˜¯æ‰‹åŠ¨æ£€æŸ¥å¼•å‘çš„å¼‚å¸¸ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•å¾ˆè„†å¼±ï¼ˆæˆ‘ä»¬å¯èƒ½ä¼šå¿˜è®°æ£€æŸ¥å¼‚å¸¸ï¼‰ï¼Œå¹¶ä¸”ä¼šå¢åŠ å¾ˆå¤šå™ªéŸ³ï¼š</p><p>  Nowadays there are much better mechanisms of error handling, possible errors should be type-checked at compile-time. Languages that do not use exceptions by default will be ranked higher.</p><p>  å¦‚ä»Šï¼Œé”™è¯¯å¤„ç†æœºåˆ¶æ›´åŠ å®Œå–„ï¼Œå¯èƒ½çš„é”™è¯¯åº”åœ¨ç¼–è¯‘æ—¶è¿›è¡Œç±»å‹æ£€æŸ¥ã€‚é»˜è®¤æƒ…å†µä¸‹ä¸ä½¿ç”¨ä¾‹å¤–çš„è¯­è¨€å°†æ’åæ›´é«˜ã€‚</p><p>    Weâ€™ve reached the end of Mooreâ€™s law, the processors will not get any faster, period. We live in the era of multi-core CPUs, and literally, any modern application has to take advantage of multiple cores.</p><p>    æˆ‘ä»¬å·²ç»åˆ°äº†æ‘©å°”å®šå¾‹çš„å°½å¤´ï¼Œå¤„ç†å™¨å°†ä¸ä¼šæ›´å¿«ã€‚æˆ‘ä»¬ç”Ÿæ´»åœ¨å¤šæ ¸CPUæ—¶ä»£ï¼Œå®é™…ä¸Šï¼Œä»»ä½•ç°ä»£åº”ç”¨ç¨‹åºéƒ½å¿…é¡»åˆ©ç”¨å¤šæ ¸ã€‚</p><p> Unfortunately, most of the programming languages in use today were designed in the era of single-core computing, and simply do not have the features to effectively run on multiple cores.</p><p> ä¸å¹¸çš„æ˜¯ï¼Œå½“ä»Šä½¿ç”¨çš„å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€éƒ½æ˜¯åœ¨å•æ ¸è®¡ç®—æ—¶ä»£è®¾è®¡çš„ï¼Œæ ¹æœ¬ä¸å…·å¤‡å¯åœ¨å¤šæ ¸ä¸Šæœ‰æ•ˆè¿è¡Œçš„åŠŸèƒ½ã€‚</p><p> Libraries that help with concurrency are an after-thought, they simply add band-aids to languages that werenâ€™t initially designed for concurrency. This doesnâ€™t really count as good developer experience. In a modern language, concurrency support has to be built-in (think Go/Erlang/Elixir).</p><p> å¸®åŠ©å¹¶å‘çš„åº“æ˜¯äº‹åçš„æƒ³æ³•ï¼Œå®ƒä»¬åªæ˜¯å‘æœ€åˆä¸æ˜¯ä¸ºå¹¶å‘è®¾è®¡çš„è¯­è¨€æ·»åŠ äº†åˆ›å¯è´´ã€‚è¿™å¹¶ä¸æ˜¯çœŸæ­£çš„è‰¯å¥½å¼€å‘ç»éªŒã€‚åœ¨ç°ä»£è¯­è¨€ä¸­ï¼Œå¿…é¡»å†…ç½®å¹¶å‘æ”¯æŒï¼ˆè¯·è€ƒè™‘ä½¿ç”¨Go / Erlang / Elixirï¼‰ã€‚ </p><p>    I think that large objected-oriented programs struggle with increasing complexity as you build this large object graph of mutable objects. You know, trying to understand and keep in your mind what will happen when you call a method and what will the side effects be.</p><p>æˆ‘è®¤ä¸ºï¼Œå½“æ‚¨æ„å»ºå¯å˜å¯¹è±¡çš„å¤§å¯¹è±¡å›¾æ—¶ï¼Œå¤§å‹é¢å‘å¯¹è±¡çš„ç¨‹åºä¼šè¶Šæ¥è¶Šå¤æ‚ã€‚æ‚¨çŸ¥é“ï¼Œå°è¯•ç†è§£å¹¶ç‰¢è®°å½“æ‚¨è°ƒç”¨æ–¹æ³•æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆä»¥åŠå‰¯ä½œç”¨æ˜¯ä»€ä¹ˆã€‚</p><p> Programming with immutable values nowadays is becoming more and more popular. Even modern UI libraries like  React are intended to be used with immutable values. Languages with first-class support for immutable data values will be ranked higher. Simply because immutability eliminates a whole category of bugs from our code.</p><p> å¦‚ä»Šï¼Œä½¿ç”¨ä¸å˜çš„å€¼è¿›è¡Œç¼–ç¨‹å˜å¾—è¶Šæ¥è¶Šæµè¡Œã€‚ç”šè‡³åƒReactè¿™æ ·çš„ç°ä»£UIåº“ä¹Ÿæ‰“ç®—ä¸ä¸å¯å˜å€¼ä¸€èµ·ä½¿ç”¨ã€‚å…·æœ‰å¯¹ä¸å¯å˜æ•°æ®å€¼çš„ä¸€æµæ”¯æŒçš„è¯­è¨€å°†æ’åæ›´é«˜ã€‚ä»…ä»…å› ä¸ºä¸å˜æ€§æ¶ˆé™¤äº†æˆ‘ä»¬ä»£ç ä¸­çš„ä¸€æ•´ç±»é”™è¯¯ã€‚</p><p> What is immutable state? Simply put, it is data that doesnâ€™t change. Just like strings in most programming languages. For example, capitalizing a string will never change the original string â€” a new string will always be returned instead.</p><p> ä»€ä¹ˆæ˜¯ä¸å¯å˜çŠ¶æ€ï¼Ÿç®€è€Œè¨€ä¹‹ï¼Œå®ƒæ˜¯ä¸å˜çš„æ•°æ®ã€‚å°±åƒå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸­çš„å­—ç¬¦ä¸²ä¸€æ ·ã€‚ä¾‹å¦‚ï¼Œå¤§å†™å­—ç¬¦ä¸²æ°¸è¿œä¸ä¼šæ›´æ”¹åŸå§‹å­—ç¬¦ä¸²-å§‹ç»ˆä¼šè¿”å›ä¸€ä¸ªæ–°å­—ç¬¦ä¸²ã€‚</p><p> Immutability takes this idea further, and makes sure that nothing is ever changed. A new array will always be returned instead of changing the original one. Updating userâ€™s name? A new user object will be returned with its name updated, while leaving the original one intact.</p><p> ä¸å˜æ€§è¿›ä¸€æ­¥æ¨åŠ¨äº†è¿™ä¸€æƒ³æ³•ï¼Œå¹¶ç¡®ä¿ä¸€åˆ‡éƒ½æ²¡æœ‰æ”¹å˜ã€‚æ€»ä¼šè¿”å›ä¸€ä¸ªæ–°æ•°ç»„ï¼Œè€Œä¸æ˜¯æ›´æ”¹åŸå§‹æ•°ç»„ã€‚æ›´æ–°ç”¨æˆ·åï¼Ÿå°†è¿”å›ä¸€ä¸ªæ–°çš„ç”¨æˆ·å¯¹è±¡ï¼Œå¹¶æ›´æ–°å…¶åç§°ï¼ŒåŒæ—¶ä¿ç•™åŸå§‹å¯¹è±¡ã€‚</p><p> With immutable state, nothing is shared, therefore we no longer have to worry about the complexity of thread safety. Immutability makes our code easy to parallelize.</p><p> å¤„äºä¸å¯å˜çŠ¶æ€æ—¶ï¼Œä¸ä¼šå…±äº«ä»»ä½•å†…å®¹ï¼Œå› æ­¤æˆ‘ä»¬ä¸å†éœ€è¦æ‹…å¿ƒçº¿ç¨‹å®‰å…¨æ€§çš„å¤æ‚æ€§ã€‚ä¸å˜æ€§ä½¿æˆ‘ä»¬çš„ä»£ç æ˜“äºå¹¶è¡ŒåŒ–ã€‚</p><p> Functions that do not mutate(change) any state are called  pure, and are significantly easier to test, and to reason about. When working with pure functions, we never have to worry about anything outside of the function. Simply focus on just this one function that youâ€™re working with, while forgetting about everything else. You can probably imagine how much easier development becomes (in comparison to OOP, where an entire graph of objects has to be kept in mind).</p><p> ä¸å˜å¼‚ï¼ˆæ”¹å˜ï¼‰ä»»ä½•çŠ¶æ€çš„å‡½æ•°ç§°ä¸ºçº¯å‡½æ•°ï¼Œå®ƒä»¬å¾ˆå®¹æ˜“æµ‹è¯•å’Œæ¨ç†ã€‚ä½¿ç”¨çº¯å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ä¸å¿…æ‹…å¿ƒå‡½æ•°ä¹‹å¤–çš„ä»»ä½•äº‹æƒ…ã€‚åªéœ€ä¸“æ³¨äºæ‚¨æ­£åœ¨ä½¿ç”¨çš„è¿™ä¸€åŠŸèƒ½ï¼Œè€Œå¿½ç•¥å…¶ä»–æ‰€æœ‰åŠŸèƒ½ã€‚æ‚¨å¯èƒ½å¯ä»¥æƒ³è±¡ï¼Œå¼€å‘å˜å¾—å¤šä¹ˆå®¹æ˜“ï¼ˆä¸OOPç›¸æ¯”ï¼Œå¿…é¡»ç‰¢è®°æ•´ä¸ªå¯¹è±¡å›¾ï¼‰ã€‚</p><p>    A language may not be very good, but it may have a large ecosystem which makes it appealing. Having access to good libraries may save one months (or even years) of development effort.</p><p>    è¯­è¨€å¯èƒ½ä¸æ˜¯å¾ˆå¥½ï¼Œä½†æ˜¯å®ƒå¯èƒ½å…·æœ‰åºå¤§çš„ç”Ÿæ€ç³»ç»Ÿï¼Œå› æ­¤å¾ˆæœ‰å¸å¼•åŠ›ã€‚è®¿é—®ä¼˜è´¨çš„å›¾ä¹¦é¦†å¯ä»¥èŠ‚çœä¸€ä¸ªæœˆï¼ˆç”šè‡³å‡ å¹´ï¼‰çš„å¼€å‘å·¥ä½œã€‚ </p><p>     How fast does the language   compile? How fast do the programs start? What is the runtime performance? All of these matter, and will be included in the ranking.</p><p>è¯­è¨€çš„ç¼–è¯‘é€Ÿåº¦å¦‚ä½•ï¼Ÿç¨‹åºå¯åŠ¨é€Ÿåº¦æœ‰å¤šå¿«ï¼Ÿè¿è¡Œæ—¶æ€§èƒ½å¦‚ä½•ï¼Ÿæ‰€æœ‰è¿™äº›éƒ½å¾ˆé‡è¦ï¼Œå¹¶å°†åˆ—å…¥æ’åã€‚</p><p>    Although there are some exceptions, generally, newer languages will be better than older ones. Simply because newer languages learn from the mistakes of their predecessors.</p><p>    å°½ç®¡æœ‰ä¸€äº›ä¾‹å¤–ï¼Œä½†æ˜¯ä¸€èˆ¬è€Œè¨€ï¼Œè¾ƒæ–°çš„è¯­è¨€ä¼šæ¯”è¾ƒæ—§çš„è¯­è¨€æ›´å¥½ã€‚ä»…ä»…å› ä¸ºæ›´æ–°çš„è¯­è¨€å¯ä»¥ä»å…¶å‰è¾ˆçš„é”™è¯¯ä¸­å­¦ä¹ ã€‚</p><p>  Letâ€™s begin our rating with the worst of the worst, probably one of the biggest mistakes of computer science, C++. Yes, C++ is not considered a shiny modern programming language. But it is still in wide use today and had to be included in the list.</p><p>  è®©æˆ‘ä»¬ä»æœ€åçš„æƒ…å†µå…¥æ‰‹ï¼Œè¿™å¯èƒ½æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€å¤§çš„é”™è¯¯ä¹‹ä¸€ï¼ŒC ++ã€‚æ˜¯çš„ï¼ŒC ++ä¸è¢«è®¤ä¸ºæ˜¯ä¸€ç§å´­æ–°çš„ç°ä»£ç¼–ç¨‹è¯­è¨€ã€‚ä½†æ˜¯ä»Šå¤©å®ƒä»åœ¨å¹¿æ³›ä½¿ç”¨ï¼Œå¿…é¡»å°†å…¶åŒ…æ‹¬åœ¨åˆ—è¡¨ä¸­ã€‚</p><p>     C++ is a horrible languageâ€¦ And limiting your project to C means that people donâ€™t screw things up with any idiotic â€œobject modelâ€ c&amp;@p.  â€” Linus Torvalds, the creator of Linux.</p><p>     C ++æ˜¯ä¸€ç§å¯æ€•çš„è¯­è¨€â€¦è€Œä¸”å°†æ‚¨çš„é¡¹ç›®é™åˆ¶ä¸ºCæ„å‘³ç€äººä»¬ä¸ä¼šç”¨ä»»ä½•æ„šè ¢çš„â€œå¯¹è±¡æ¨¡å‹â€ cï¼†amp; @på¼„ä¹±äº‹æƒ…ã€‚ â€” Linuxçš„åˆ›å»ºè€…Linus Torvaldsã€‚</p><p> C++ is bloated with features. It attempts to do everything, while not being good at any particular thing. C++ has  goto , pointers, references, OOP, operator overloading, and many other non-productive features.</p><p> C ++å…·æœ‰è®¸å¤šåŠŸèƒ½ã€‚å®ƒå°è¯•åšæ‰€æœ‰äº‹æƒ…ï¼ŒåŒæ—¶åˆä¸æ“…é•¿ä»»ä½•ç‰¹å®šçš„äº‹æƒ…ã€‚ C ++å…·æœ‰gotoï¼ŒæŒ‡é’ˆï¼Œå¼•ç”¨ï¼ŒOOPï¼Œè¿ç®—ç¬¦é‡è½½å’Œè®¸å¤šå…¶ä»–éç”Ÿäº§æ€§åŠŸèƒ½ã€‚</p><p> Why is C++ so bad? In my opinion, the biggest reason is its age. C++ was designed long ago in 1979. At that time the designers lacked the experience, and had no idea what to focus on. The features added might have seemed like a good idea at that time. The language was very popular, which meant that many more features were added to support various use cases (creating an even bigger mess of features).</p><p> ä¸ºä»€ä¹ˆC ++å¦‚æ­¤ç³Ÿç³•ï¼Ÿæˆ‘è®¤ä¸ºï¼Œæœ€å¤§çš„åŸå› æ˜¯å®ƒçš„å¹´é¾„ã€‚ C ++æ˜¯åœ¨1979å¹´è®¾è®¡çš„å¾ˆæ—©çš„æ—¶å€™ã€‚å½“æ—¶çš„è®¾è®¡å¸ˆç¼ºä¹ç»éªŒï¼Œä¹Ÿä¸çŸ¥é“è¯¥å…³æ³¨ä»€ä¹ˆã€‚å½“æ—¶æ·»åŠ çš„åŠŸèƒ½ä¼¼ä¹æ˜¯ä¸ªå¥½ä¸»æ„ã€‚è¯¥è¯­è¨€éå¸¸æµè¡Œï¼Œè¿™æ„å‘³ç€æ·»åŠ äº†è®¸å¤šåŠŸèƒ½æ¥æ”¯æŒå„ç§ç”¨ä¾‹ï¼ˆåˆ›å»ºæ›´å¤§çš„åŠŸèƒ½æ··ä¹±ï¼‰ã€‚</p><p>  C++ is notorious for its slow compilation time. Significantly slower than Java, not as bad as Scala.</p><p>  C ++å› å…¶ç¼–è¯‘æ—¶é—´æ…¢è€Œè‡­åæ˜­è‘—ã€‚æ¯”Javaæ…¢å¾—å¤šï¼Œä¸å¦‚Scalaå·®ã€‚ </p><p>      I had hoped that a garbage collector which could be optionally enabled would be part of C++0x, but there were enough technical problemsâ€¦</p><p>æˆ‘æ›¾å¸Œæœ›å¯ä»¥é€‰æ‹©å¯ç”¨çš„åƒåœ¾æ”¶é›†å™¨å°†æˆä¸ºC ++ 0xçš„ä¸€éƒ¨åˆ†ï¼Œä½†æ˜¯å­˜åœ¨è¶³å¤Ÿçš„æŠ€æœ¯é—®é¢˜â€¦â€¦</p><p> Garbage collection was never added into C++. Manual memory management is extremely error prone. The developers have to worry about manually releasing and allocating memory. I will never miss the days when I was using non-garbage-collected languages, the innumerous number of bugs that are nowadays easily prevented in garbage-collected languages.</p><p> åƒåœ¾å›æ”¶ä»æœªæ·»åŠ åˆ°C ++ä¸­ã€‚æ‰‹åŠ¨å†…å­˜ç®¡ç†ææ˜“å‡ºé”™ã€‚å¼€å‘äººå‘˜å¿…é¡»æ‹…å¿ƒæ‰‹åŠ¨é‡Šæ”¾å’Œåˆ†é…å†…å­˜ã€‚æˆ‘å°†æ°¸è¿œä¸ä¼šé”™è¿‡ä½¿ç”¨éåƒåœ¾æ”¶é›†è¯­è¨€çš„æ—¥å­ï¼Œå¦‚ä»Šåœ¨åƒåœ¾æ”¶é›†è¯­è¨€ä¸­å¾ˆå®¹æ˜“é¿å…è®¸å¤šé”™è¯¯ã€‚</p><p>  I invented the term Object-Oriented, and I can tell you I did not have C++ in mind.</p><p>  æˆ‘å‘æ˜äº†æœ¯è¯­â€œé¢å‘å¯¹è±¡â€ï¼Œæˆ‘å¯ä»¥å‘Šè¯‰ä½ æˆ‘æ²¡æœ‰C ++ã€‚</p><p> Having appeared in the late 60s, OOP was a cool new technology when the work on C++ has started. Itâ€™s very unfortunate that C++ made a few crucial mistakes in their implementation of OOP (unlike languages like Smalltalk), which has turned a really good idea into a nightmare.</p><p> OOPå‡ºç°äº60å¹´ä»£åæœŸï¼Œæ˜¯C ++å·¥ä½œå¼€å§‹æ—¶çš„ä¸€é¡¹å¾ˆé…·çš„æ–°æŠ€æœ¯ã€‚ä¸å¹¸çš„æ˜¯ï¼ŒC ++åœ¨å®ç°OOPæ—¶çŠ¯äº†ä¸€äº›å…³é”®é”™è¯¯ï¼ˆä¸Smalltalkç­‰è¯­è¨€ä¸åŒï¼‰ï¼Œè¿™ä½¿ä¸€ä¸ªå¥½ä¸»æ„å˜æˆäº†ä¸€åœºå™©æ¢¦ã€‚</p><p> One good thing about C++, in comparison to Java is that OOP in C++ at least is optional.</p><p> ä¸Javaç›¸æ¯”ï¼ŒC ++çš„ä¸€ä»¶å¥½äº‹æ˜¯C ++ä¸­çš„OOPè‡³å°‘æ˜¯å¯é€‰çš„ã€‚</p><p>   C++ is a complicated low-level language with no automated memory management. Due to its feature bloat, beginners have to spend a lot of time learning the language.</p><p>   C ++æ˜¯ä¸€ç§å¤æ‚çš„ä½çº§è¯­è¨€ï¼Œæ²¡æœ‰è‡ªåŠ¨å†…å­˜ç®¡ç†ã€‚ç”±äºå…¶åŠŸèƒ½è†¨èƒ€ï¼Œåˆå­¦è€…ä¸å¾—ä¸èŠ±å¾ˆå¤šæ—¶é—´å­¦ä¹ è¯¥è¯­è¨€ã€‚</p><p>  C++ was designed in the era of single-core computing, and has only rudimentary concurrency mechanisms that were added in the past decade.</p><p>  C ++æ˜¯åœ¨å•æ ¸è®¡ç®—æ—¶ä»£è®¾è®¡çš„ï¼Œä»…åœ¨è¿‡å»åå¹´ä¸­æ·»åŠ äº†åŸºæœ¬çš„å¹¶å‘æœºåˆ¶ã€‚ </p><p>           The best use of C++ is probably system programming. However, given much better and modern alternatives in existence (Rust and Go), C++ shouldnâ€™t even be used for that. I donâ€™t think that C++ has any pros at all, feel free to prove me wrong.</p><p>C ++çš„æœ€ä½³ç”¨é€”å¯èƒ½æ˜¯ç³»ç»Ÿç¼–ç¨‹ã€‚ä½†æ˜¯ï¼Œé‰´äºå­˜åœ¨æ›´å¥½ï¼Œæ›´ç°ä»£çš„æ›¿ä»£æ–¹æ¡ˆï¼ˆRust and Goï¼‰ï¼ŒC ++ç”šè‡³ä¸åº”è¯¥ç”¨äºæ­¤ã€‚æˆ‘è®¤ä¸ºC ++æ¯«æ— ä¼˜åŠ¿ï¼Œè¯·éšæ—¶è¯æ˜æˆ‘æ˜¯é”™çš„ã€‚</p><p>  Having first appeared in 1995, Java is 16 years younger than C++. Java is a much simpler language, which likely has contributed to its popularity.</p><p>  è‡ª1995å¹´é¦–æ¬¡å‡ºç°ä»¥æ¥ï¼ŒJavaæ¯”C ++å¹´é¾„å°16å²ã€‚ Javaæ˜¯ä¸€ç§ç®€å•å¾—å¤šçš„è¯­è¨€ï¼Œè¿™å¯èƒ½æœ‰åŠ©äºå…¶æµè¡Œã€‚</p><p>    One of the biggest benefits that Java provides over C++ is garbage collection, which by itself eliminates a large category of bugs.</p><p>    Javaæä¾›çš„ä¼˜äºC ++çš„æœ€å¤§å¥½å¤„ä¹‹ä¸€æ˜¯åƒåœ¾æ”¶é›†ï¼Œåƒåœ¾æ”¶é›†æœ¬èº«æ¶ˆé™¤äº†è®¸å¤šé”™è¯¯ã€‚</p><p>  Java has been around for a long time, and it has a huge ecosystem for backend development, which significantly reduces development effort.</p><p>  Javaå·²ç»å­˜åœ¨äº†å¾ˆé•¿æ—¶é—´ï¼Œå¹¶ä¸”å®ƒå…·æœ‰ä¸€ä¸ªåºå¤§çš„ç”¨äºåç«¯å¼€å‘çš„ç”Ÿæ€ç³»ç»Ÿï¼Œä»è€Œå¤§å¤§å‡å°‘äº†å¼€å‘å·¥ä½œã€‚</p><p>  I will not go too deep into the drawbacks of OOP here, for a more detailed analysis you may read my other article  Object-Oriented Programming â€” The Trillion Dollar Disaster.</p><p>  åœ¨è¿™é‡Œï¼Œæˆ‘ä¸ä¼šæ·±å…¥æ¢è®¨OOPçš„å¼Šç«¯ï¼Œæœ‰å…³æ›´è¯¦ç»†çš„åˆ†æï¼Œæ‚¨å¯ä»¥é˜…è¯»æˆ‘çš„å…¶ä»–æ–‡ç« ã€Šé¢å‘å¯¹è±¡ç¼–ç¨‹â€”ä¸‡äº¿ç¾å…ƒç¾éš¾ã€‹ã€‚</p><p> Instead Iâ€™ll simply quote some of the most prominent people in computer science, to get their opinion on OOP:</p><p> ç›¸åï¼Œæˆ‘åªæ˜¯å¼•ç”¨ä¸€äº›è®¡ç®—æœºç§‘å­¦é¢†åŸŸæœ€æ°å‡ºçš„äººï¼Œä»¥å¾—åˆ°ä»–ä»¬å¯¹OOPçš„çœ‹æ³•ï¼š</p><p> Iâ€™m sorry that I long ago coined the term â€œobjectsâ€ for this topic because it gets many people to focus on the lesser idea. The big idea is messaging. - Alan Kay, the inventor of OOP</p><p> å¾ˆæŠ±æ­‰ï¼Œæˆ‘å¾ˆä¹…ä»¥å‰å°±ä¸ºè¯¥ä¸»é¢˜åˆ›é€ äº†â€œå¯¹è±¡â€ä¸€è¯ï¼Œå› ä¸ºå®ƒä½¿è®¸å¤šäººä¸“æ³¨äºè¾ƒå°çš„æƒ³æ³•ã€‚å¤§æƒ³æ³•æ˜¯æ¶ˆæ¯ä¼ é€’ã€‚ -OOPçš„å‘æ˜è€…è‰¾ä¼¦Â·å‡¯ï¼ˆAlan Kayï¼‰ </p><p> Alan Kay is right, the mainstream OOP languages focus on the wrong thing â€” classes, and objects, while ignoring messaging. Thankfully, there are modern languages that got this idea right (Erlang/Elixir).</p><p>è‰¾ä¼¦Â·å‡¯ï¼ˆAlan Kayï¼‰æ˜¯å¯¹çš„ï¼Œä¸»æµçš„OOPè¯­è¨€ä¸“æ³¨äºé”™è¯¯çš„äº‹ç‰©ï¼ˆç±»å’Œå¯¹è±¡ï¼‰ï¼Œè€Œå¿½ç•¥äº†æ¶ˆæ¯ä¼ é€’ã€‚å€¼å¾—åº†å¹¸çš„æ˜¯ï¼Œç°ä»£è¯­è¨€æ­£ç¡®åœ°å®ç°äº†è¿™ä¸ªæƒ³æ³•ï¼ˆErlang / Elixirï¼‰ã€‚</p><p> With OOP-inflected programming languages, computer software becomes more verbose, less readable, less descriptive, and harder to modify and maintain.</p><p> ä½¿ç”¨å—OOPå½±å“çš„ç¼–ç¨‹è¯­è¨€ï¼Œè®¡ç®—æœºè½¯ä»¶å˜å¾—æ›´å†—é•¿ï¼Œå¯è¯»æ€§æ›´å·®ï¼Œæè¿°æ€§æ›´å¼ºï¼Œæ›´éš¾ä¿®æ”¹å’Œç»´æŠ¤ã€‚</p><p> Anyone whoâ€™s used an OOP language (like Java or C#), and then had experience working in a non-OOP language, can probably relate.</p><p> ä½¿ç”¨è¿‡OOPè¯­è¨€ï¼ˆä¾‹å¦‚Javaæˆ–Cï¼ƒï¼‰å¹¶å…·æœ‰ä½¿ç”¨éOOPè¯­è¨€çš„ç»éªŒçš„ä»»ä½•äººéƒ½å¯ä»¥è”ç³»ã€‚</p><p>  Java, obviously, runs on top of Java Virtual Machine, which is notorious for its slow startup times. Iâ€™ve seen programs running on top of JVM take 30 seconds and longer to start up, which is unacceptable for modern cloud-native programs.</p><p>  æ˜¾ç„¶ï¼ŒJavaåœ¨Javaè™šæ‹Ÿæœºä¹‹ä¸Šè¿è¡Œï¼Œè€ŒJavaè™šæ‹Ÿæœºçš„å¯åŠ¨æ—¶é—´å¾ˆæ…¢ã€‚æˆ‘å·²ç»çœ‹åˆ°ï¼Œåœ¨JVMä¸Šè¿è¡Œçš„ç¨‹åºéœ€è¦30ç§’ç”šè‡³æ›´é•¿çš„æ—¶é—´æ‰èƒ½å¯åŠ¨ï¼Œè¿™å¯¹äºç°ä»£çš„äº‘åŸç”Ÿç¨‹åºæ¥è¯´æ˜¯ä¸å¯æ¥å—çš„ã€‚</p><p> The compilation speed is slow on bigger projects, significantly impacting developer productivity (although nowhere as bad as Scala).</p><p> åœ¨è¾ƒå¤§çš„é¡¹ç›®ä¸Šï¼Œç¼–è¯‘é€Ÿåº¦å¾ˆæ…¢ï¼Œè¿™æå¤§åœ°å½±å“äº†å¼€å‘äººå‘˜çš„ç”Ÿäº§åŠ›ï¼ˆå°½ç®¡æ²¡æœ‰Scalaé‚£æ ·ç³Ÿç³•ï¼‰ã€‚</p><p>   While Java is a rather simple language, its focus on Object-Oriented Programming makes becoming good really hard. One can easily write a simple program. However, knowing how to write reliable and maintainable Object-Oriented code may take well over a decade.</p><p>   å°½ç®¡Javaæ˜¯ä¸€ç§ç›¸å½“ç®€å•çš„è¯­è¨€ï¼Œä½†å®ƒå¯¹é¢å‘å¯¹è±¡ç¼–ç¨‹çš„å…³æ³¨ä½¿çœŸæ­£å˜å¾—å¾ˆéš¾ã€‚å¯ä»¥è½»æ¾ç¼–å†™ä¸€ä¸ªç®€å•çš„ç¨‹åºã€‚ä½†æ˜¯ï¼ŒçŸ¥é“å¦‚ä½•ç¼–å†™å¯é ä¸”å¯ç»´æŠ¤çš„é¢å‘å¯¹è±¡ä»£ç å¯èƒ½è¦èŠ±åå¹´çš„æ—¶é—´ã€‚</p><p>  Java was designed in the era of single-core computing, and like C++ has only rudimentary concurrency support.</p><p>  Javaæ˜¯åœ¨å•æ ¸è®¡ç®—æ—¶ä»£è®¾è®¡çš„ï¼Œå¹¶ä¸”åƒC ++ä¸€æ ·ï¼Œä»…å…·æœ‰åŸºæœ¬çš„å¹¶å‘æ”¯æŒã€‚ </p><p>          Java was a decent language when it has appeared. Its too bad that Java (unlike Scala) has always focused exclusively on OOP. The language is very verbose, and suffers a lot from boilerplate code.</p><p>Javaå‡ºç°æ—¶æ˜¯ä¸€ç§ä¸é”™çš„è¯­è¨€ã€‚å¤ªç³Ÿç³•äº†ï¼ŒJavaï¼ˆä¸Scalaä¸åŒï¼‰ä¸€ç›´åªä¸“æ³¨äºOOPã€‚è¯¥è¯­è¨€éå¸¸å†—é•¿ï¼Œå¹¶ä¸”å—æ ·æ¿ä»£ç çš„å½±å“å¾ˆå¤§ã€‚</p><p>  Fundamentally, thereâ€™s very little difference between C# and Java (since the early versions of C# were actually a Microsoft implementation of Java).</p><p>  ä»æ ¹æœ¬ä¸Šè®²ï¼ŒCï¼ƒå’ŒJavaä¹‹é—´å‡ ä¹æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ï¼ˆå› ä¸ºCï¼ƒçš„æ—©æœŸç‰ˆæœ¬å®é™…ä¸Šæ˜¯Javaçš„Microsoftå®ç°ï¼‰ã€‚</p><p> C# shares most of its cons with Java. Having first appeared in 2000, C# is 5 years younger than Java, and has learned a few things from Javaâ€™s mistakes.</p><p> Cï¼ƒä¸Javaå…±äº«å¤§å¤šæ•°ç¼ºç‚¹ã€‚ Cï¼ƒäº2000å¹´é¦–æ¬¡å‡ºç°ï¼Œä½†æ¯”Javaå¹´é¾„å°5å²ï¼Œå¹¶ä¸”å·²ç»ä»Javaçš„é”™è¯¯ä¸­å­¦åˆ°äº†ä¸€äº›ä¸œè¥¿ã€‚</p><p>    C# syntax has always been a little ahead of Java. C# suffers less from boilerplate code than Java. Although being an OOP language, C# is more on the verbose side. Itâ€™s good to see C# syntax being improved with every release, with the addition of features like expression-bodied function members, pattern matching, tuples, and others.</p><p>    Cï¼ƒè¯­æ³•ä¸€ç›´é¢†å…ˆäºJavaã€‚ Cï¼ƒæ¯”æ ·æ¿ä»£ç é­å—çš„ç—›è‹¦æ›´å°‘ã€‚å°½ç®¡Cï¼ƒæ˜¯ä¸€ç§OOPè¯­è¨€ï¼Œä½†å®ƒåœ¨å†—é•¿çš„æ–¹é¢æ›´ä¸ºé‡è¦ã€‚å¾ˆé«˜å…´çœ‹åˆ°Cï¼ƒè¯­æ³•åœ¨æ¯ä¸ªç‰ˆæœ¬ä¸­éƒ½å¾—åˆ°äº†æ”¹è¿›ï¼Œå¹¶å¢åŠ äº†è¯¸å¦‚è¡¨è¾¾å¼å¼ºå¥çš„å‡½æ•°æˆå‘˜ï¼Œæ¨¡å¼åŒ¹é…ï¼Œå…ƒç»„ç­‰åŠŸèƒ½ã€‚</p><p>  Just like Java, C# focuses mostly on OOP. Once again, Iâ€™m not going to spend too much time here trying to convince you of the drawbacks of OOP, Iâ€™ll simply quote a few more prominent people in computer science.</p><p>  å°±åƒJavaä¸€æ ·ï¼ŒCï¼ƒä¸»è¦å…³æ³¨OOPã€‚å†ä¸€æ¬¡ï¼Œæˆ‘ä¸ä¼šåœ¨è¿™é‡ŒèŠ±å¤ªå¤šæ—¶é—´è¯•å›¾è¯´æœOOPçš„ç¼ºç‚¹ï¼Œæˆ‘åªæƒ³å¼•ç”¨ä¸€äº›è®¡ç®—æœºç§‘å­¦é¢†åŸŸçš„æ°å‡ºäººç‰©ã€‚</p><p> I think the lack of reusability comes in object-oriented languages, not in functional languages. Because the problem with object-oriented languages is theyâ€™ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.</p><p> æˆ‘è®¤ä¸ºç¼ºä¹å¯é‡ç”¨æ€§çš„æ˜¯é¢å‘å¯¹è±¡çš„è¯­è¨€ï¼Œè€Œä¸æ˜¯åŠŸèƒ½è¯­è¨€ã€‚å› ä¸ºé¢å‘å¯¹è±¡è¯­è¨€çš„é—®é¢˜åœ¨äºå®ƒä»¬æ‹¥æœ‰äº†å®ƒä»¬æ‰€ä¼´éšçš„æ‰€æœ‰éšå¼ç¯å¢ƒã€‚æ‚¨æƒ³è¦é¦™è•‰ï¼Œä½†æ˜¯å¾—åˆ°çš„æ˜¯ä¸€åªå¤§çŒ©çŒ©ï¼Œæ‹¿ç€é¦™è•‰å’Œæ•´ä¸ªä¸›æ—ã€‚</p><p> I have to agree with Joe Armstrong, reusing object-oriented code is very difficult, in comparison with functional (or even imperative) code.</p><p> æˆ‘å¿…é¡»åŒæ„Joe Armstrongçš„è§‚ç‚¹ï¼Œä¸åŠŸèƒ½ï¼ˆç”šè‡³å‘½ä»¤æ€§ï¼‰ä»£ç ç›¸æ¯”ï¼Œé‡ç”¨é¢å‘å¯¹è±¡çš„ä»£ç éå¸¸å›°éš¾ã€‚ </p><p> Object oriented programs are offered as alternatives to correct onesâ€¦  â€” Edsger W. Dijkstra, pioneer of computer science</p><p>æä¾›é¢å‘å¯¹è±¡çš„ç¨‹åºä½œä¸ºæ­£ç¡®ç¨‹åºçš„æ›¿ä»£æ–¹æ¡ˆâ€¦â€¦â€”è®¡ç®—æœºç§‘å­¦å…ˆé©±Edsger W. Dijkstra</p><p> Having worked with both OOP and non-OOP languages throughout my career, I have to agree that OOP code is much harder to get right, in comparison to non-OOP code.</p><p> åœ¨æˆ‘æ•´ä¸ªèŒä¸šç”Ÿæ¶¯ä¸­éƒ½ä½¿ç”¨è¿‡OOPå’ŒéOOPè¯­è¨€ä¹‹åï¼Œæˆ‘ä¸å¾—ä¸åŒæ„ä¸éOOPä»£ç ç›¸æ¯”ï¼ŒOOPä»£ç æ›´éš¾æ­£ç¡®ã€‚</p><p>  C# claims to be a multi-paradigm language. In particular, C# claims to support functional programming. I must disagree, having support for first-class functions is simply not enough for a language to be called functional.</p><p>  Cï¼ƒå£°ç§°æ˜¯ä¸€ç§å¤šèŒƒå¼è¯­è¨€ã€‚ç‰¹åˆ«æ˜¯ï¼ŒCï¼ƒå£°ç§°æ”¯æŒåŠŸèƒ½ç¼–ç¨‹ã€‚æˆ‘å¿…é¡»ä¸åŒæ„ï¼Œä»…ä»…æ”¯æŒä¸€æµçš„åŠŸèƒ½è¿˜ä¸è¶³ä»¥ä½¿ä¸€ç§è¯­è¨€ç§°ä¸ºåŠŸèƒ½ã€‚</p><p> What functional features should a language have? At the very least, built-in support for immutable data structures, pattern matching, pipe operator for function composition, Algebraic Datatypes.</p><p> è¯­è¨€åº”å…·æœ‰å“ªäº›åŠŸèƒ½ï¼Ÿè‡³å°‘ï¼Œå¯¹ä¸å¯å˜æ•°æ®ç»“æ„ï¼Œæ¨¡å¼åŒ¹é…ï¼Œå‡½æ•°ç»„åˆçš„ç®¡é“è¿ç®—ç¬¦ï¼Œä»£æ•°æ•°æ®ç±»å‹çš„å†…ç½®æ”¯æŒã€‚</p><p>  C# was created in the era of single-core computing, and like Java has only rudimentary concurrency support.</p><p>  Cï¼ƒæ˜¯åœ¨å•æ ¸è®¡ç®—æ—¶ä»£åˆ›å»ºçš„ï¼Œå°±åƒJavaä¸€æ ·ï¼Œå®ƒä»…å…·æœ‰åŸºæœ¬çš„å¹¶å‘æ”¯æŒã€‚</p><p>          Iâ€™ve spent a large chunk of my career working with C#, and was always mostly frustrated with the language. Just like with Java, Iâ€™d recommend looking for more modern alternatives. It is the same Java under the hood, with a little more modern syntax.</p><p>          æˆ‘åœ¨Cï¼ƒçš„èŒä¸šç”Ÿæ¶¯ä¸­èŠ±è´¹äº†å¤§é‡æ—¶é—´ï¼Œå¹¶ä¸”æ€»æ˜¯å¯¹è¿™ç§è¯­è¨€æ„Ÿåˆ°æ²®ä¸§ã€‚ä¸Javaä¸€æ ·ï¼Œæˆ‘å»ºè®®æ‚¨å¯»æ‰¾æ›´ç°ä»£çš„æ›¿ä»£æ–¹æ¡ˆã€‚å®ƒæ˜¯ç›¸åŒçš„Javaï¼Œä½†è¯­æ³•æ›´ç°ä»£ã€‚</p><p>  Having first appeared in 1991, Python is an old language. Along with JavaScript, Python is one of the most popular languages in the world.</p><p>  è‡ª1991å¹´é¦–æ¬¡å‡ºç°ä»¥æ¥ï¼ŒPythonæ˜¯ä¸€é—¨å¤è€çš„è¯­è¨€ã€‚ä¸JavaScriptä¸€èµ·ï¼ŒPythonæ˜¯ä¸–ç•Œä¸Šæœ€å—æ¬¢è¿çš„è¯­è¨€ä¹‹ä¸€ã€‚ </p><p>    Python has a library almost for anything. Unlike JavaScript, Python canâ€™t be used for Frontend Web Development, however Python easily makes up with a huge number of data science libraries.</p><p>Pythonå‡ ä¹æœ‰ä»»ä½•åº“ã€‚ä¸JavaScriptä¸åŒï¼ŒPythonæ— æ³•ç”¨äºå‰ç«¯Webå¼€å‘ï¼Œä½†æ˜¯Pythonå¯ä»¥è½»æ¾åœ°æ„æˆå¤§é‡çš„æ•°æ®ç§‘å­¦åº“ã€‚</p><p>  Python is a very simple language which can be picked up by beginners in a couple of weeks.</p><p>  Pythonæ˜¯ä¸€ç§éå¸¸ç®€å•çš„è¯­è¨€ï¼Œåˆå­¦è€…å¯ä»¥åœ¨å‡ å‘¨å†…æŒæ¡å®ƒä»¬ã€‚</p><p>  Python is dynamically typed, thereâ€™s not much more to say about the type system.</p><p>  Pythonæ˜¯åŠ¨æ€ç±»å‹çš„ï¼Œå…³äºç±»å‹ç³»ç»Ÿæ²¡æœ‰å¤ªå¤šè¦è¯´çš„äº†ã€‚</p><p>  Python is an interpreted language and is notorious for being one of the slowest programming languages, in terms of runtime performance. Using Cython instead of plain Python may be a good solution where runtime performance is critical.</p><p>  Pythonæ˜¯ä¸€ç§è§£é‡Šå‹è¯­è¨€ï¼Œä»¥è¿è¡Œæ—¶æ€§èƒ½è€Œè¨€ï¼Œå®ƒæ˜¯æœ€æ…¢çš„ç¼–ç¨‹è¯­è¨€ä¹‹ä¸€è€Œè‡­åæ˜­è‘—ã€‚åœ¨è¿è¡Œæ—¶æ€§èƒ½è‡³å…³é‡è¦çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨Cythonä»£æ›¿æ™®é€šçš„Pythonå¯èƒ½æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆã€‚</p><p>   Having used Python along with other modern languages, itâ€™s hard not to be disappointed with Pythonâ€™s dependency management. Thereâ€™s pip, pipenv, virtualenv,  pip freeze and others. In comparison, NPM in JavaScript is the only tool youâ€™ll ever need.</p><p>   åœ¨å°†Pythonå’Œå…¶ä»–ç°ä»£è¯­è¨€ä¸€èµ·ä½¿ç”¨åï¼Œå¾ˆéš¾ä¸å¯¹Pythonçš„ä¾èµ–é¡¹ç®¡ç†æ„Ÿåˆ°å¤±æœ›ã€‚ç‚¹å­ï¼Œpipenvï¼Œvirtualenvï¼Œç‚¹å­å†»ç»“ç­‰ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒJavaScriptä¸­çš„NPMæ˜¯æ‚¨å”¯ä¸€éœ€è¦çš„å·¥å…·ã€‚</p><p>            It is really unfortunate that Python has no proper support for functional programming. Functional Programming is suited extremely well for problems that data science is trying to solve. Even for very pythonic tasks like web scraping, functional languages (like Elixir) are a much better fit.</p><p>            çœŸçš„å¾ˆä¸å¹¸ï¼ŒPythonæ²¡æœ‰å¯¹å‡½æ•°å¼ç¼–ç¨‹çš„é€‚å½“æ”¯æŒã€‚å‡½æ•°å¼ç¼–ç¨‹éå¸¸é€‚åˆäºæ•°æ®ç§‘å­¦è¯•å›¾è§£å†³çš„é—®é¢˜ã€‚å³ä½¿å¯¹äºè¯¸å¦‚ç½‘ç»œæŠ“å–ä¹‹ç±»çš„éå¸¸Pythonçš„ä»»åŠ¡ï¼ŒåŠŸèƒ½æ€§è¯­è¨€ï¼ˆä¾‹å¦‚Elixirï¼‰ä¹Ÿæ›´åˆé€‚ã€‚</p><p> I donâ€™t recommend using Python for large projects, the language was not built with serious software engineering in mind.</p><p> æˆ‘ä¸å»ºè®®å°†Pythonç”¨äºå¤§å‹é¡¹ç›®ï¼Œå› ä¸ºè¯¥è¯­è¨€åœ¨æ„å»ºæ—¶å¹¶æœªè€ƒè™‘åˆ°ä¸¥æ ¼çš„è½¯ä»¶å·¥ç¨‹ã€‚ </p><p> Python shouldnâ€™t be used for anything other than data science, when no other alternatives are available.  Julia seems to be a good modern alternative to Python in the field of data science, although its ecosystem is not nearly as mature as Pythonâ€™s.</p><p>å½“æ²¡æœ‰å…¶ä»–æ›¿ä»£æ–¹æ³•å¯ç”¨æ—¶ï¼ŒPythonä¸åº”ç”¨äºæ•°æ®ç§‘å­¦ä»¥å¤–çš„å…¶ä»–ä»»ä½•ç”¨é€”ã€‚åœ¨æ•°æ®ç§‘å­¦é¢†åŸŸï¼ŒJuliaä¼¼ä¹æ˜¯Pythonçš„ä¸€ä¸ªå¾ˆå¥½çš„ç°ä»£æ›¿ä»£å“ï¼Œå°½ç®¡å®ƒçš„ç”Ÿæ€ç³»ç»Ÿè¿˜ä¸å¦‚Pythonæˆç†Ÿã€‚</p><p>  Rust was designed from the ground up to be fast. Compilation of Rust programs takes longer than compilation of Go programs. The runtime performance of Rust programs is a little faster than Go.</p><p>  Rustä»ä¸€å¼€å§‹å°±è¢«è®¾è®¡ä¸ºå¿«é€Ÿã€‚ Rustç¨‹åºçš„ç¼–è¯‘æ¯”Goç¨‹åºçš„ç¼–è¯‘èŠ±è´¹æ›´é•¿çš„æ—¶é—´ã€‚ Rustç¨‹åºçš„è¿è¡Œæ—¶æ€§èƒ½æ¯”Goå¿«ä¸€ç‚¹ã€‚</p><p>  The first language on our list with a modern null alternative! Rust doesnâ€™t have a null or nil value, and Rust developers use the Option Pattern instead.</p><p>  æˆ‘ä»¬åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ç§è¯­è¨€ï¼Œå¸¦æœ‰ç°ä»£nullæ›¿ä»£é€‰é¡¹ï¼ Rustæ²¡æœ‰nullæˆ–nilå€¼ï¼ŒRustå¼€å‘äººå‘˜æ”¹ç”¨Option Patternã€‚</p><p>   Rust takes a modern functional approach to error handling, and uses a dedicated  Result type to signify an operation that might fail. It is very similar to the  Option above, however the  None case now also has a value.</p><p>   Rusté‡‡ç”¨äº†â€‹â€‹ä¸€ç§ç°ä»£çš„åŠŸèƒ½æ€§æ–¹æ³•æ¥å¤„ç†é”™è¯¯ï¼Œå¹¶ä½¿ç”¨ä¸“ç”¨çš„Resultç±»å‹æ¥è¡¨ç¤ºå¯èƒ½å¤±è´¥çš„æ“ä½œã€‚å®ƒä¸ä¸Šé¢çš„é€‰é¡¹éå¸¸ç›¸ä¼¼ï¼Œä½†æ˜¯Noneæƒ…å†µç°åœ¨ä¹Ÿæœ‰ä¸€ä¸ªå€¼ã€‚</p><p>   Rust is the only modern language on our list with no garbage collection. This forces the developers to think about low-level memory management, and makes developer productivity suffer.</p><p>   Rustæ˜¯æˆ‘ä»¬åˆ—è¡¨ä¸­å”¯ä¸€æ²¡æœ‰åƒåœ¾å›æ”¶çš„ç°ä»£è¯­è¨€ã€‚è¿™è¿«ä½¿å¼€å‘äººå‘˜è€ƒè™‘è¿›è¡Œä½çº§å†…å­˜ç®¡ç†ï¼Œå¹¶ä½¿å¼€å‘äººå‘˜çš„å·¥ä½œæ•ˆç‡ä¸‹é™ã€‚</p><p>  Due to the lack of garbage collection, concurrency is rather hard in Rust. Developers have to worry about things like boxing and pinning, which typically are done automatically in a garbage-collected language.</p><p>  ç”±äºç¼ºä¹åƒåœ¾æ”¶é›†ï¼Œå› æ­¤åœ¨Rustä¸­å¹¶å‘éå¸¸å›°éš¾ã€‚å¼€å‘äººå‘˜å¿…é¡»æ‹…å¿ƒè¯¸å¦‚è£…ç®±å’Œå›ºå®šä¹‹ç±»çš„äº‹æƒ…ï¼Œè¿™äº›äº‹æƒ…é€šå¸¸ä¼šä»¥åƒåœ¾å›æ”¶è¯­è¨€è‡ªåŠ¨å®Œæˆã€‚</p><p>    Being a low-level language, developer productivity in Rust canâ€™t be as high as in other higher-level languages. This also makes the learning effort significantly harder.</p><p>    ä½œä¸ºä¸€ç§ä½çº§è¯­è¨€ï¼ŒRustä¸­çš„å¼€å‘äººå‘˜ç”Ÿäº§åŠ›æ— æ³•è¾¾åˆ°å…¶ä»–é«˜çº§è¯­è¨€ä¸­çš„æ°´å¹³ã€‚è¿™ä¹Ÿä½¿å­¦ä¹ åŠªåŠ›å˜å¾—æ›´åŠ å›°éš¾ã€‚ </p><p>    Rust is a good fit for system programming. Although more complex than Go, it provides a powerful type system. Rust provides a modern alternative to nulls, and a modern way for handling errors.</p><p>Rustéå¸¸é€‚åˆç³»ç»Ÿç¼–ç¨‹ã€‚å°½ç®¡å®ƒæ¯”Goæ›´å¤æ‚ï¼Œä½†å®ƒæä¾›äº†å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿã€‚ Rustä¸ºç©ºå€¼æä¾›äº†ä¸€ç§ç°ä»£çš„æ›¿ä»£æ–¹æ³•ï¼Œå¹¶æä¾›äº†ä¸€ç§å¤„ç†é”™è¯¯çš„ç°ä»£æ–¹æ³•ã€‚</p><p> Why is Rust still ranked below TypeScript and JavaScript? It is a low-level language designed for system programming. Rust is not a very good fit for Backend/Web API development. It lacks garbage collection, and has no built-in support for immutability.</p><p> ä¸ºä»€ä¹ˆRustä»ç„¶æ’åä½äºTypeScriptå’ŒJavaScriptï¼Ÿå®ƒæ˜¯ä¸ºç³»ç»Ÿç¼–ç¨‹è®¾è®¡çš„ä½çº§è¯­è¨€ã€‚ Rustå¹¶ééå¸¸é€‚åˆåç«¯/ Web APIå¼€å‘ã€‚å®ƒç¼ºå°‘åƒåœ¾æ”¶é›†ï¼Œå¹¶ä¸”ä¸å†…ç½®å¯¹ä¸å˜æ€§çš„æ”¯æŒã€‚</p><p>  TypeScript is a compile-to-js language. Its main goal is to make a â€œbetter JavaScriptâ€ by adding static typing to JavaScript. Just like JavaScript, TypeScript is being used for both frontend and backend development.</p><p>  TypeScriptæ˜¯ä¸€ç§jsç¼–è¯‘è¯­è¨€ã€‚å®ƒçš„ä¸»è¦ç›®æ ‡æ˜¯é€šè¿‡å‘JavaScriptæ·»åŠ é™æ€ç±»å‹æ¥åˆ¶ä½œâ€œæ›´å¥½çš„JavaScriptâ€ã€‚å°±åƒJavaScriptä¸€æ ·ï¼ŒTypeScriptè¢«ç”¨äºå‰ç«¯å’Œåç«¯å¼€å‘ã€‚</p><p> TypeScript was designed by Anders Hejlsberg, the same person, who has designed C#. TypeScript code feels very C-sharpy, and fundamentally can be thought of as C# for the browser.</p><p> TypeScriptæ˜¯ç”±è®¾è®¡Cï¼ƒçš„åŒä¸€äººAnders Hejlsbergè®¾è®¡çš„ã€‚ TypeScriptä»£ç æ„Ÿè§‰éå¸¸Cå°–é”ï¼Œä»æ ¹æœ¬ä¸Šè®²ï¼Œå¯ä»¥å°†å…¶è§†ä¸ºæµè§ˆå™¨çš„Cï¼ƒã€‚</p><p>    Yes, being a superset of JavaScript has helped a lot with the adoption of TypeScript. After all, a lot of people already know JavaScript.</p><p>    æ˜¯çš„ï¼ŒJavaScriptçš„è¶…é›†å¯¹TypeScriptçš„é‡‡ç”¨èµ·åˆ°äº†å¾ˆå¤§çš„å¸®åŠ©ã€‚æ¯•ç«Ÿï¼Œå¾ˆå¤šäººå·²ç»çŸ¥é“JavaScriptã€‚</p><p> However, being a superset of JavaScript is more of a dr</p><p> ä½†æ˜¯ï¼Œæˆä¸ºJavaScriptçš„è¶…é›†æ›´åƒæ˜¯åšå£«</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://suzdalnitski.medium.com/modern-languages-suck-ad21cbc8a57c">https://suzdalnitski.medium.com/modern-languages-suck-ad21cbc8a57c</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ç¼–ç¨‹/">#ç¼–ç¨‹</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ç¼–ç¨‹è¯­è¨€/">#ç¼–ç¨‹è¯­è¨€</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/è¯­è¨€/">#è¯­è¨€</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¶æ/">#æ¶æ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å·¥å…·/">#å·¥å…·</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ†äº«/">#åˆ†äº«</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>