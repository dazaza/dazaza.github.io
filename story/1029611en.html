<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ç»„åˆå™¨å¸¦æ¥çš„ä¹è¶£</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ç»„åˆå™¨å¸¦æ¥çš„ä¹è¶£</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-18 23:11:34</div><div class="page_narrow text-break page_content"><p>There are a bunch of â€œminimalâ€ computational models out there: Turing machines, lambda calculus, PowerPoint  (Wildenhain  2017), etc. These are radically simple languages which are nonetheless Turing complete, so theoretically â€œas powerfulâ€ as each other. Of those, lambda calculus is without question my favourite to actually write programs in: itâ€™s the one which is closest to crawling out of the  Turing tarpit.</p><p>å¸‚é¢ä¸Šæœ‰ä¸€å †â€œæœ€å°â€çš„è®¡ç®—æ¨¡å‹ï¼šå›¾çµæœºã€Î»å¾®ç§¯åˆ†ã€PowerPoint(Wildenhain 2017)ç­‰ã€‚è¿™äº›éƒ½æ˜¯éå¸¸ç®€å•çš„è¯­è¨€ï¼Œä½†å›¾çµæ˜¯å®Œå…¨çš„ï¼Œç†è®ºä¸Šå½¼æ­¤â€œä¸€æ ·å¼ºå¤§â€ã€‚å…¶ä¸­ï¼Œlambdaæ¼”ç®—æ— ç–‘æ˜¯æˆ‘æœ€å–œæ¬¢ç”¨æ¥å®é™…ç¼–å†™ç¨‹åºçš„æ¼”ç®—ï¼šå®ƒæ˜¯æœ€æ¥è¿‘ä»å›¾çµæ²¹ç½ä¸­çˆ¬å‡ºæ¥çš„æ¼”ç®—ã€‚</p><p> In terms of implementation, though, it is  far from simple. Lambda calculus has  variables, which introduce huge complexity into the interpreter: especially if you want to do any kind of formal reasoning about programs, this complexity is a problem. We might want to reach for something even lower-level than lambda calculus: this is where combinator calculi come in.</p><p>ç„¶è€Œï¼Œå°±å®ç°è€Œè¨€ï¼Œè¿™è¿œä¸æ˜¯ä¸€ä»¶ç®€å•çš„äº‹æƒ…ã€‚Lambdaæ¼”ç®—æœ‰å˜é‡ï¼Œè¿™ç»™è§£é‡Šå™¨å¸¦æ¥äº†å·¨å¤§çš„å¤æ‚æ€§ï¼šç‰¹åˆ«æ˜¯å¦‚æœä½ æƒ³å¯¹ç¨‹åºè¿›è¡Œä»»ä½•å½¢å¼çš„æ¨ç†ï¼Œè¿™ç§å¤æ‚æ€§æ˜¯ä¸€ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬å¯èƒ½æƒ³è¦ç ”ç©¶ä¸€äº›æ¯”Î»å¾®ç§¯åˆ†æ›´ä½å±‚æ¬¡çš„ä¸œè¥¿ï¼šè¿™å°±æ˜¯ç»„åˆå­å¾®ç§¯åˆ†çš„ç”¨æ­¦ä¹‹åœ°ã€‚</p><p> You may have heard of SKI combinator calculus: itâ€™s the â€œsimplestâ€ of the calculi, but itâ€™s not actually very easy to understand, and itâ€™s absolute murder to try use. So weâ€™re going to start with  BCKW, a more obscure calculus, actually invented by Haskell Curry.</p><p>æ‚¨å¯èƒ½å¬è¯´è¿‡ski Combinatorå¾®ç§¯åˆ†ï¼šå®ƒæ˜¯å¾®ç§¯åˆ†ä¸­â€œæœ€ç®€å•çš„â€ï¼Œä½†å®é™…ä¸Šå¹¶ä¸æ˜¯å¾ˆå®¹æ˜“ç†è§£ï¼Œå°è¯•ä½¿ç”¨ç»å¯¹æ˜¯è°‹æ€ã€‚æ‰€ä»¥æˆ‘ä»¬å°†ä»BCKWå¼€å§‹ï¼Œè¿™æ˜¯ä¸€ç§æ›´ä¸ºæ™¦æ¶©éš¾æ‡‚çš„å¾®ç§¯åˆ†ï¼Œå®é™…ä¸Šæ˜¯ç”±å“ˆæ–¯å…‹å°”Â·åº“é‡Œ(Haskell Curry)å‘æ˜çš„ã€‚</p><p> There are 4 combinators in  BCKW:  B,  C,  K, and  W (shocking, I know). You can think about these combinators as functions which manipulate the beginning of strings:</p><p>BCKWä¸­æœ‰4ä¸ªç»„åˆç¬¦ï¼šBã€Cã€Kå’ŒW(ä»¤äººéœ‡æƒŠï¼Œæˆ‘çŸ¥é“)ã€‚æ‚¨å¯ä»¥å°†è¿™äº›ç»„åˆç¬¦è§†ä¸ºæ“ä½œå­—ç¬¦ä¸²å¼€å¤´çš„å‡½æ•°ï¼š</p><p>  Letâ€™s work with some examples to get a sense for how these combinators work.</p><p>è®©æˆ‘ä»¬ä½¿ç”¨ä¸€äº›ç¤ºä¾‹æ¥äº†è§£è¿™äº›ç»„åˆç¬¦æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚</p><p> Upper case letters are combinators, lower-case are variables. Yes, yes, I know I said that combinator calculi didnâ€™t need variables, and it doesnâ€™t! Iâ€™m just using them here to explain how each of the combinators work. If you really want to be pedantic you can think of the lower case letters as notational placeholders meaning â€œany given combinatorâ€. They wonâ€™t exist in any actual programs we write.</p><p>å¤§å†™å­—æ¯æ˜¯ç»„åˆç¬¦ï¼Œå°å†™å­—æ¯æ˜¯å˜é‡ã€‚æ˜¯çš„ï¼Œæ˜¯çš„ï¼Œæˆ‘çŸ¥é“æˆ‘è¯´è¿‡ç»„åˆæ¼”ç®—ä¸éœ€è¦å˜é‡ï¼Œç°åœ¨ä¹Ÿä¸éœ€è¦ï¼æˆ‘åœ¨è¿™é‡Œåªæ˜¯ç”¨å®ƒä»¬æ¥è§£é‡Šæ¯ä¸ªç»„åˆå­æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚å¦‚æœä½ çœŸçš„æƒ³å˜å¾—ä¹¦ç”Ÿæ°”åè¶³ï¼Œä½ å¯ä»¥æŠŠå°å†™å­—æ¯æƒ³è±¡æˆç¬¦å·å ä½ç¬¦ï¼Œæ„æ€æ˜¯â€œä»»ä½•ç»™å®šçš„ç»„åˆç¬¦â€ã€‚å®ƒä»¬ä¸ä¼šå­˜åœ¨äºæˆ‘ä»¬ç¼–å†™çš„ä»»ä½•å®é™…ç¨‹åºä¸­ã€‚</p><p> The simplest combinator is  K: itâ€™s actually equivalent to the  const function from Haskell. It discards its second argument, and returns the first. If you give a combinator more arguments than it usually accepts, you just keep the extra arguments in the output:</p><p>æœ€ç®€å•çš„ç»„åˆç¬¦æ˜¯Kï¼šå®ƒå®é™…ä¸Šç­‰åŒäºæ¥è‡ªHaskellçš„constå‡½æ•°ã€‚å®ƒä¸¢å¼ƒç¬¬äºŒä¸ªå‚æ•°ï¼Œå¹¶è¿”å›ç¬¬ä¸€ä¸ªå‚æ•°ã€‚å¦‚æœä¸ºç»„åˆå™¨æä¾›çš„å‚æ•°æ¯”å®ƒé€šå¸¸æ¥å—çš„å‚æ•°å¤šï¼Œåˆ™åªéœ€åœ¨è¾“å‡ºä¸­ä¿ç•™é¢å¤–çš„å‚æ•°å³å¯ï¼š</p><p>      Next we have  C: this is equivalent to the Haskell function  flip. It swaps the second and third arguments:</p><p>æ¥ä¸‹æ¥æˆ‘ä»¬æœ‰Cï¼šï¼Œè¿™ç›¸å½“äºHaskellå‡½æ•°çš„ç¿»è½¬ã€‚å®ƒäº¤æ¢äº†ç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªå‚æ•°ï¼š</p><p>  Hereâ€™s a small little evaluator for expressions which use  C,  K, and  W. You can edit the expression, and press enter to step through it.</p><p>ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨Cã€Kå’ŒWçš„è¡¨è¾¾å¼çš„å°å‹æ±‚å€¼å™¨ã€‚æ‚¨å¯ä»¥ç¼–è¾‘è¡¨è¾¾å¼ï¼Œç„¶åæŒ‰Enteré”®é€æ­¥æ‰§è¡Œã€‚</p><p>    You can write parentheses yourself: implicitly, all expressions are left-associative. That means that the following are all equal:</p><p>æ‚¨å¯ä»¥è‡ªå·±ç¼–å†™æ‹¬å·ï¼šéšå¼åœ°è¯´ï¼Œæ‰€æœ‰è¡¨è¾¾å¼éƒ½æ˜¯å·¦å…³è”çš„ã€‚è¿™æ„å‘³ç€ä»¥ä¸‹å„é¡¹éƒ½æ˜¯ç›¸ç­‰çš„ï¼š</p><p>   And hereâ€™s a puzzle to start flexing your combinator skills: one of the combinators in SKI combinator calculus is  I, which is the identity function.</p><p>è¿™é‡Œæœ‰ä¸€ä¸ªå¼€å§‹å±•ç¤ºä½ çš„ç»„åˆå™¨æŠ€èƒ½çš„éš¾é¢˜ï¼šSKIç»„åˆå™¨æ¼”ç®—ä¸­çš„ä¸€ä¸ªç»„åˆå­æ˜¯iï¼Œå®ƒæ˜¯æ’ç­‰å¼å‡½æ•°ã€‚</p><p>  Try write an expression which functions the same way as  I, using only the  BCKW combinators. Use the following evaluator to try and figure out how to do it: write an expression after  Î»&gt; which functions the same as  I.</p><p>å°è¯•ä»…ä½¿ç”¨BCKWç»„åˆç¬¦ç¼–å†™ä¸€ä¸ªåŠŸèƒ½ä¸Iç›¸åŒçš„è¡¨è¾¾å¼ã€‚ä½¿ç”¨ä»¥ä¸‹æ±‚å€¼å™¨å°è¯•å¹¶å¼„æ¸…æ¥šå¦‚ä½•æ‰§è¡Œæ­¤æ“ä½œï¼šåœ¨Î»&gtï¼›ä¹‹åç¼–å†™ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå…¶åŠŸèƒ½ä¸Iç›¸åŒã€‚</p><p>      Each of the combinators weâ€™ve defined so far work a little weird: they seem to skip over their first argument, and work on their second. Indeed, there is another, equivalent combinator calculus which doesnâ€™t have this peculiarity:</p><p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å®šä¹‰çš„æ¯ä¸ªç»„åˆå­çš„å·¥ä½œæ–¹å¼éƒ½æœ‰äº›å¥‡æ€ªï¼šå®ƒä»¬ä¼¼ä¹è·³è¿‡äº†ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œè€Œåœ¨ç¬¬äºŒä¸ªå‚æ•°ä¸Šå·¥ä½œã€‚äº‹å®ä¸Šï¼Œè¿˜æœ‰å¦ä¸€ç§ç­‰ä»·çš„ç»„åˆå­æ¼”ç®—æ²¡æœ‰è¿™ç§ç‰¹æ€§ï¼š</p><p>  B stays the same in this calculus, but the rest of the combinators get switched out for seemingly simpler versions.  K goes to  A  1:</p><p>åœ¨è¿™ä¸ªå¾®ç§¯åˆ†ä¸­Bä¿æŒä¸å˜ï¼Œä½†æ˜¯å…¶ä½™çš„ç»„åˆå­è¢«æ¢æˆäº†çœ‹ä¼¼æ›´ç®€å•çš„å½¢å¼ã€‚Kè½¬åˆ°A1ï¼š</p><p>  Which isnâ€™t a huge change. Itâ€™s the other two where we see the real difference.  W has been swapped out for  M:</p><p>è¿™å¹¶ä¸æ˜¯ä¸€ä¸ªå·¨å¤§çš„å˜åŒ–ã€‚æˆ‘ä»¬çœ‹åˆ°çœŸæ­£ä¸åŒä¹‹å¤„çš„æ˜¯å¦å¤–ä¸¤ä¸ªã€‚Wå·²æ›¿æ¢ä¸ºMï¼š</p><p>  As you can see  W basically does the same thing as  M, but while passing through its first argument. The difference between  T and  C is similar:</p><p>ä½ ä»¬å¯ä»¥çœ‹åˆ°ï¼ŒWåŸºæœ¬ä¸Šå’ŒMåšäº†åŒæ ·çš„äº‹æƒ…ï¼Œä½†æ˜¯é€šè¿‡äº†å®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚Tå’ŒCä¹‹é—´çš„åŒºåˆ«ç›¸ä¼¼ï¼š</p><p>  So, first of all, it is pretty simple to show that  BCKW contains all of the  BAMT combinators. Try find a way to write  T using only  BCKW combinators (hint: you might want to use your previous answer for writing  I using  BCKW).</p><p>æ‰€ä»¥ï¼Œé¦–å…ˆï¼Œå¾ˆç®€å•åœ°è¯æ˜BCKWåŒ…å«æ‰€æœ‰çš„BAMTç»„åˆå­ã€‚å°è¯•æ‰¾åˆ°ä¸€ç§ä»…ä½¿ç”¨BCKWç»„åˆç¬¦æ¥ç¼–å†™Tçš„æ–¹æ³•(æç¤ºï¼šæ‚¨å¯èƒ½å¸Œæœ›ä½¿ç”¨BCKWç¼–å†™Iæ—¶ä½¿ç”¨å…ˆå‰çš„ç­”æ¡ˆ)ã€‚</p><p>   So in fact all of the changed  BAMT combinators can be encoded using  BCKW by putting  I (or  CKC or what have you) after the corresponding  BCKW combinator. In other words:</p><p>å› æ­¤ï¼Œå®é™…ä¸Šï¼Œæ‰€æœ‰æ›´æ”¹åçš„BAMTç»„åˆç¬¦éƒ½å¯ä»¥ä½¿ç”¨BCKWè¿›è¡Œç¼–ç ï¼Œæ–¹æ³•æ˜¯åœ¨ç›¸åº”çš„BCKWç»„åˆç¬¦åé¢åŠ ä¸Ši(æˆ–CKCæˆ–å…¶ä»–ä»»ä½•å†…å®¹)ã€‚æ¢è¨€ä¹‹ï¼š</p><p>  Itâ€™s pretty easy to go from  BCKW to  BAMT, then. However, itâ€™s  extremely difficult to go the other way. Here, try to write  K in terms of  BAMT (this is quite difficult, do not expect to get it!):</p><p>é‚£ä¹ˆï¼Œä»BCKWåˆ°BAMTç›¸å½“å®¹æ˜“ã€‚ç„¶è€Œï¼Œè¦èµ°å¦ä¸€æ¡è·¯æ˜¯æå…¶å›°éš¾çš„ã€‚åœ¨è¿™é‡Œï¼Œè¯•ç€ç”¨BAMTæ¥å†™K(è¿™ç›¸å½“å›°éš¾ï¼Œä¸è¦æŒ‡æœ›èƒ½å¾—åˆ°å®ƒï¼)ï¼š</p><p>     So this is why we will stick to  BCKW for the time being:  BAMT is just too painful to use.</p><p>å› æ­¤ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬æš‚æ—¶åšæŒä½¿ç”¨BCKWçš„åŸå› ï¼šBAMTä½¿ç”¨èµ·æ¥å¤ªç—›è‹¦äº†ã€‚</p><p>  One of the things  BCKW has over  SKI is that each combinator represents a concrete capability.  K and  W especially: without these combinators, we can neither duplicate nor discard variables. This makes the languages without one or both of these interesting (albeit not Turing-complete).</p><p>BCKWæ‹¥æœ‰çš„å…³äºSKIçš„ä¸€ä»¶äº‹æ˜¯ï¼Œæ¯ä¸ªç»„åˆå™¨ä»£è¡¨ä¸€ç§å…·ä½“çš„åŠŸèƒ½ã€‚ç‰¹åˆ«æ˜¯Kå’ŒWï¼šæ²¡æœ‰è¿™äº›ç»„åˆå­ï¼Œæˆ‘ä»¬æ—¢ä¸èƒ½å¤åˆ¶å˜é‡ï¼Œä¹Ÿä¸èƒ½ä¸¢å¼ƒå˜é‡ã€‚è¿™ä½¿å¾—æ²¡æœ‰å…¶ä¸­ä¸€ç§æˆ–ä¸¤ç§éƒ½æ²¡æœ‰çš„è¯­è¨€å˜å¾—æœ‰è¶£(å°½ç®¡ä¸æ˜¯å®Œå…¨çš„å›¾çµ)ã€‚</p><p> If we say that we canâ€™t use  W, we know that the will not duplicate any input. In fact, encoded appropriately, we know that the program can only decrease its size through execution. The  BCK system is in fact an encoding of  affine logic, which is all the rage nowadays. Rust uses affine types to guarantee memory safety: by preventing duplication of references, you can know that whenever youâ€™re looking at a variable youâ€™re free to modify it, or destroy it if necessary (obviously Rust is a bit more complex than what Iâ€™ve described here, but  BCK is indeed the fundamental basis for the system in the same way that  SK can be the basis for any programming language).</p><p>å¦‚æœæˆ‘ä»¬è¯´æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨Wï¼Œæˆ‘ä»¬çŸ¥é“ä¸ä¼šé‡å¤ä»»ä½•è¾“å…¥ã€‚äº‹å®ä¸Šï¼Œå¦‚æœç¼–ç å¾—å½“ï¼Œæˆ‘ä»¬çŸ¥é“ç¨‹åºåªèƒ½é€šè¿‡æ‰§è¡Œæ¥å‡å°å…¶å¤§å°ã€‚BCKç³»ç»Ÿå®é™…ä¸Šæ˜¯å½“ä»Šæµè¡Œçš„ä»¿å°„é€»è¾‘çš„ç¼–ç ã€‚Rustä½¿ç”¨ä»¿å°„ç±»å‹æ¥ä¿è¯å†…å­˜å®‰å…¨ï¼šé€šè¿‡é˜²æ­¢é‡å¤å¼•ç”¨ï¼Œæ‚¨å¯ä»¥çŸ¥é“ï¼Œæ— è®ºä½•æ—¶æŸ¥çœ‹å˜é‡ï¼Œæ‚¨éƒ½å¯ä»¥è‡ªç”±åœ°ä¿®æ”¹å®ƒï¼Œæˆ–è€…åœ¨å¿…è¦æ—¶é”€æ¯å®ƒ(æ˜¾ç„¶ï¼ŒRustæ¯”æˆ‘åœ¨è¿™é‡Œæè¿°çš„ç¨å¾®å¤æ‚ä¸€äº›ï¼Œä½†æ˜¯BCKç¡®å®æ˜¯ç³»ç»Ÿçš„åŸºæœ¬åŸºç¡€ï¼Œå°±åƒSKå¯ä»¥ä½œä¸ºä»»ä½•ç¼–ç¨‹è¯­è¨€çš„åŸºç¡€ä¸€æ ·)ã€‚</p><p> If we remove  K as well we have a  linear language. This is even more restrictive, but is also quite actively researched at the moment: linear types have been used to construct languages for differential privacy, for instance.</p><p>å¦‚æœæˆ‘ä»¬å»æ‰Kï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†çº¿æ€§è¯­è¨€ã€‚è¿™æ–¹é¢çš„é™åˆ¶ç”šè‡³æ›´å¤šï¼Œä½†ç›®å‰çš„ç ”ç©¶ä¹Ÿç›¸å½“æ´»è·ƒï¼šä¾‹å¦‚ï¼Œçº¿æ€§ç±»å‹å·²è¢«ç”¨æ¥æ„é€ ç”¨äºä¸åŒéšç§çš„è¯­è¨€ã€‚</p><p> Thereâ€™s one small issue with  BC: it doesnâ€™t (strictly speaking) have an equivalent to  I. You can write an expression which is  close, but it will only actually compute when applied to at least 3 arguments. See if you can find it.</p><p>BCæœ‰ä¸€ä¸ªå°é—®é¢˜ï¼šå®ƒæ²¡æœ‰(ä¸¥æ ¼åœ°è¯´)ç­‰åŒäºIã€‚æ‚¨å¯ä»¥ç¼–å†™ä¸€ä¸ªæ¥è¿‘çš„è¡¨è¾¾å¼ï¼Œä½†å®ƒåªæœ‰åœ¨åº”ç”¨äºè‡³å°‘3ä¸ªå‚æ•°æ—¶æ‰èƒ½å®é™…è®¡ç®—ã€‚çœ‹çœ‹ä½ èƒ½ä¸èƒ½æ‰¾åˆ°ã€‚</p><p>       S is the only combinator we havenâ€™t seen yet. Itâ€™s kind of a combination of  B,  C, and  W:</p><p>%sæ˜¯æˆ‘ä»¬è¿˜æ²¡æœ‰è§è¿‡çš„å”¯ä¸€ä¸€ä¸ªCombinatorã€‚å®ƒæœ‰ç‚¹åƒæ˜¯Bã€Cå’ŒWçš„ç»„åˆï¼š</p><p>  It does parenthesising, reordering,  and duplication. This allows it to be powerful to be Turing complete only with the addition of  K. Try first to construct  I given only  S and  K:</p><p>å®ƒå¯ä»¥æ’å…¥ã€é‡æ–°æ’åºå’Œå¤åˆ¶ã€‚è¿™ä½¿å¾—å®ƒå¯ä»¥æ˜¯å¼ºå¤§çš„ï¼Œåªæœ‰åœ¨æ·»åŠ Kçš„æƒ…å†µä¸‹æ‰èƒ½å®Œæˆå›¾çµã€‚å°è¯•é¦–å…ˆæ„é€ Iï¼Œä»…ç»™å‡ºSå’ŒKï¼š</p><p>          Of course, to show that  SK is universal weâ€™d need to show that it contains one of the other universal systems. We wonâ€™t do that exhaustively here, but first just try to figure out  B and  W:</p><p>å½“ç„¶ï¼Œè¦è¯æ˜SKæ˜¯é€šç”¨çš„ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜å®ƒåŒ…å«å…¶ä»–é€šç”¨ç³»ç»Ÿä¹‹ä¸€ã€‚æˆ‘ä»¬ä¸ä¼šåœ¨è¿™é‡Œè¯¦ç»†è¯´æ˜ï¼Œä½†é¦–å…ˆè¯•ç€æ‰¾å‡ºBå’ŒWï¼š</p><p>          The next task is to encode the  Y combinator. This is a combinator that evaluates to the following:</p><p>ä¸‹ä¸€ä¸ªä»»åŠ¡æ˜¯å¯¹Yç»„åˆç¬¦è¿›è¡Œç¼–ç ã€‚è¿™æ˜¯ä¸€ä¸ªåˆå¹¶å™¨ï¼Œè®¡ç®—ç»“æœå¦‚ä¸‹ï¼š</p><p>  As you can see, it encodes  recursion. Like the  fix function in Haskell, this combinator allows us to do recursion without explicit self-reference. And, of course, we can define this combinator using the combinators weâ€™ve seen before, since our language is Turing complete. One encoding is  BM(CBM):</p><p>å¦‚æ‚¨æ‰€è§ï¼Œå®ƒå¯¹é€’å½’è¿›è¡Œç¼–ç ã€‚ä¸Haskellä¸­çš„FIXå‡½æ•°ä¸€æ ·ï¼Œæ­¤ç»„åˆå™¨å…è®¸æˆ‘ä»¬åœ¨æ²¡æœ‰æ˜¾å¼è‡ªå¼•ç”¨çš„æƒ…å†µä¸‹è¿›è¡Œé€’å½’ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬ä»¥å‰è§è¿‡çš„ç»„åˆå­æ¥å®šä¹‰è¿™ä¸ªç»„åˆå­ï¼Œå› ä¸ºæˆ‘ä»¬çš„è¯­è¨€æ˜¯å›¾çµå®Œæˆçš„ã€‚ä¸€ç§ç¼–ç æ˜¯BM(CBM)ï¼š</p><p>  As you can see,  BM(CBM), when applied to  f, yields  f(M(CBMf)), which is equivalent to  f(BM(CBM)f) (the  B just hasnâ€™t been applied inside the  f). So this is indeed a proper recursion combinator.</p><p>å¦‚æ‚¨æ‰€è§ï¼Œbm(Cbm)ï¼Œå½“åº”ç”¨äºfæ—¶ï¼Œäº§ç”Ÿf(M(Cbmf))ï¼Œç›¸å½“äºf(bm(Cbm)f)(Båªæ˜¯æ²¡æœ‰åœ¨fä¸­åº”ç”¨)ã€‚æ‰€ä»¥è¿™ç¡®å®æ˜¯ä¸€ä¸ªåˆé€‚çš„é€’å½’ç»„åˆå™¨ã€‚</p><p>   In the lambada calculus, to encode numbers we often use the  church numerals: thatâ€™s what weâ€™re going to do here, too. A church numeral representing some number    n n is a function which takes two arguments, and applies the first argument to the second    n n times. Here are some church numerals in Haskell:</p><p>åœ¨lambadaæ¼”ç®—ä¸­ï¼Œä¸ºäº†ç¼–ç æ•°å­—ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨æ•™ä¼šæ•°å­—ï¼šè¿™ä¹Ÿæ˜¯æˆ‘ä»¬åœ¨è¿™é‡Œè¦åšçš„ã€‚è¡¨ç¤ºæŸä¸ªæ•°å­—n nçš„æ•™ä¼šæ•°å­—æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œå¹¶å°†ç¬¬ä¸€ä¸ªå‚æ•°åº”ç”¨äºç¬¬äºŒä¸ªnæ¬¡ã€‚ä»¥ä¸‹æ˜¯å“ˆæ–¯å…‹å°”çš„ä¸€äº›æ•™ä¼šæ•°å­—ï¼š</p><p> zero :: (a -&gt; a) -&gt; a -&gt; azero f x = xone :: (a -&gt; a) -&gt; a -&gt; aone f x = f xtwo :: (a -&gt; a) -&gt; a -&gt; atwo f x = f (f x)three :: (a -&gt; a) -&gt; a -&gt; athree f x = f (f (f x))</p><p>é›¶ï¼šï¼š(a-&gtï¼›a)-&gtï¼›a-&gtï¼›Azerfx=xoneï¼šï¼š(a-&gtï¼›a)-&gtï¼›a-&gtï¼›aone f x=f xTwoï¼šï¼š(a-&gtï¼›a)-&gtï¼›a-&gtï¼›atwo f x=f(Fx)ä¸‰ï¼šï¼š(a-&gtï¼›a)-&gtï¼›a-&gtï¼›atrifx=f(f(Fx))</p><p> Encoding these numerals in combinators is a little more difficult. Zero and one are obvious: they are  A and  I, respectively. Try to figure out two and three:</p><p>åœ¨ç»„åˆç¬¦ä¸­å¯¹è¿™äº›æ•°å­—è¿›è¡Œç¼–ç ç¨å¾®å›°éš¾ä¸€äº›ã€‚0å’Œ1æ˜¯æ˜¾è€Œæ˜“è§çš„ï¼šå®ƒä»¬åˆ†åˆ«æ˜¯Aå’ŒIã€‚è¯•ç€ç®—å‡º2å’Œ3ï¼š</p><p>    WB    SB(WB) It turns out that itâ€™s pretty easy to encode numbers in a relatively small amount of space, using a binary encoding. First, multiplication on Church numerals is simply composition: so thatâ€™s  B on our combinators. We already have 2 defined, so the next thing we need for a binary encoding is a successor function. And we know what  that is, from the answer to 3!</p><p>WB SB(WB)äº‹å®è¯æ˜ï¼Œä½¿ç”¨äºŒè¿›åˆ¶ç¼–ç ï¼Œåœ¨ç›¸å¯¹è¾ƒå°çš„ç©ºé—´å†…å¯¹æ•°å­—è¿›è¡Œç¼–ç æ˜¯ç›¸å½“å®¹æ˜“çš„ã€‚é¦–å…ˆï¼Œæ•™ä¼šæ•°å­—ä¸Šçš„ä¹˜æ³•å°±æ˜¯ç®€å•çš„åˆæˆï¼šæ‰€ä»¥è¿™å°±æ˜¯æˆ‘ä»¬çš„åˆå¹¶å™¨ä¸Šçš„Bã€‚æˆ‘ä»¬å·²ç»å®šä¹‰äº†2ï¼Œæ‰€ä»¥äºŒè¿›åˆ¶ç¼–ç çš„ä¸‹ä¸€ä»¶äº‹æ˜¯åç»§å‡½æ•°ã€‚æˆ‘ä»¬çŸ¥é“è¿™æ˜¯ä»€ä¹ˆï¼Œä»ç­”æ¡ˆåˆ°3ï¼</p><p> This means we can encode normal number in      ğ’ª ( log n ) \mathcal{O}(\log n) space (although it still takes linear time to evaluate). The following repl allows for numbers:</p><p>è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åœ¨ğ’ª(Logn)\æ•°å­¦{O}(\logn)ç©ºé—´ä¸­ç¼–ç æ­£æ€æ•°(å°½ç®¡è®¡ç®—ä»ç„¶éœ€è¦çº¿æ€§æ—¶é—´)ã€‚ä¸‹é¢çš„replå…è®¸ä½¿ç”¨æ•°å­—ï¼š</p><p>  We could take up even less space if we allowed for non-normal forms. 4, for instance, could be encoded like so:</p><p>å¦‚æœæˆ‘ä»¬è€ƒè™‘éæ­£è§„å½¢ï¼Œæˆ‘ä»¬å¯ä»¥å ç”¨æ›´å°‘çš„ç©ºé—´ã€‚ä¾‹å¦‚ï¼Œ4å¯ä»¥è¿™æ ·ç¼–ç ï¼š</p><p>  But we generally prefer to keep our encodings in normal form: otherwise thereâ€™s some extra evaluation we have to pay for when we go to use them.</p><p>ä½†æ˜¯æˆ‘ä»¬é€šå¸¸æ›´å–œæ¬¢å°†æˆ‘ä»¬çš„ç¼–ç ä¿æŒåœ¨æ ‡å‡†å½¢å¼ï¼šå¦åˆ™ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨å®ƒä»¬æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»æ”¯ä»˜ä¸€äº›é¢å¤–çš„è¯„ä¼°è´¹ç”¨ã€‚</p><p>  Once upon a time SKI combinators were used as a target for functional compilers: Miranda, Haskellâ€™s precursor, compiled down to a set of combinators which included  SKI. Nowadays, Haskell is compiled to the â€œspineless tagless G-machineâ€: its compilation technique took over from combinators in the late 80s, and has been the dominant form since. Apparently the reason is that, on the current architecture of most computers, combinator-based compilation targets just arenâ€™t fast enough. They generate too much garbage: as a result, switching to the STG yielded about a 40% speedup.</p><p>æ›¾å‡ ä½•æ—¶ï¼ŒSKIç»„åˆå™¨è¢«ç”¨ä½œå‡½æ•°ç¼–è¯‘å™¨çš„ç›®æ ‡ï¼šHaskellçš„å‰èº«Mirandaè¢«ç¼–è¯‘æˆä¸€ç»„åŒ…å«SKIçš„ç»„åˆå™¨ã€‚å¦‚ä»Šï¼ŒHaskellè¢«ç¼–è¯‘æˆâ€œæ— åˆºæ— æ ‡è®°çš„G-æœºå™¨â€ï¼šå®ƒçš„ç¼–è¯‘æŠ€æœ¯åœ¨80å¹´ä»£æœ«å–ä»£äº†ç»„åˆå™¨ï¼Œä»é‚£ä»¥åä¸€ç›´æ˜¯ä¸»å¯¼å½¢å¼ã€‚æ˜¾ç„¶ï¼ŒåŸå› åœ¨äºï¼Œåœ¨å½“å‰å¤§å¤šæ•°è®¡ç®—æœºçš„ä½“ç³»ç»“æ„ä¸Šï¼ŒåŸºäºç»„åˆå™¨çš„ç¼–è¯‘ç›®æ ‡ä¸å¤Ÿå¿«ã€‚å®ƒä»¬ä¼šäº§ç”Ÿå¤ªå¤šçš„åƒåœ¾ï¼šå› æ­¤ï¼Œåˆ‡æ¢åˆ°STGä¼šå¸¦æ¥å¤§çº¦40%çš„åŠ é€Ÿã€‚</p><p>  An Introduction to Combinator Compilers and Graph Reduction Machines, by  David Graunke  ( 2016), which goes through a high-level history and explanation of combinator compilers and why we switched away from them. A very interesting tidbit in this talk was that some people started making custom hardware to handle combinator calculi a little better. Even more interesting is the fact that these days we have FPGAs all over the place, so maybe combinator compilers are ripe for reintroduction?</p><p>David Graunke(2016)çš„â€œCombinatorç¼–è¯‘å™¨å’Œå›¾å½¢ç¼©å‡æœºç®€ä»‹â€(A Introduction To Combinator Compilers And Graph Reducing Machines)ï¼Œå®ƒå›é¡¾äº†Combinatorç¼–è¯‘å™¨çš„é«˜çº§å†å²å’Œè§£é‡Šï¼Œä»¥åŠæˆ‘ä»¬ä¸ºä»€ä¹ˆæ”¾å¼ƒå®ƒä»¬ã€‚è¿™æ¬¡æ¼”è®²ä¸­ä¸€ä¸ªéå¸¸æœ‰è¶£çš„èŠ±çµ®æ˜¯ï¼Œä¸€äº›äººå¼€å§‹åˆ¶ä½œå®šåˆ¶çš„ç¡¬ä»¶æ¥æ›´å¥½åœ°å¤„ç†ç»„åˆå­æ¼”ç®—ã€‚æ›´æœ‰è¶£çš„æ˜¯ï¼Œè¿™äº›å¤©æˆ‘ä»¬åˆ°å¤„éƒ½æ˜¯FPGAï¼Œæ‰€ä»¥ä¹Ÿè®¸é‡æ–°å¼•å…¥ç»„åˆå™¨ç¼–è¯‘å™¨çš„æ—¶æœºå·²ç»æˆç†Ÿäº†ï¼Ÿ</p><p> Combinators Revisited, by  Edward Kmett  ( 2018), which goes through a little more of the details of the problems with combinator compilers, and mentions some of the places in which weâ€™re tantalisingly close to making combinator compilation work.</p><p>Edward Kmett(2018)çš„â€œCombinator Reviskedâ€ä¸€ä¹¦æ›´è¯¦ç»†åœ°ä»‹ç»äº†Combinatorç¼–è¯‘å™¨çš„é—®é¢˜ï¼Œå¹¶æåˆ°äº†ä¸€äº›æˆ‘ä»¬éå¸¸æ¥è¿‘ä½¿Combinatorç¼–è¯‘å·¥ä½œçš„åœ°æ–¹ã€‚</p><p> So compilation to combinators was once upon a time an extremely active area of research, but it has since fallen by the wayside a little because our current hardware is unable to evaluate it efficiently. What this means for us, though, is that thereâ€™s a large body of work on how to compile lambda terms to combinators!</p><p>å› æ­¤ï¼Œåˆå¹¶å™¨çš„ç¼–è¯‘æ›¾ç»æ˜¯ä¸€ä¸ªéå¸¸æ´»è·ƒçš„ç ”ç©¶é¢†åŸŸï¼Œä½†åæ¥ç”±äºæˆ‘ä»¬ç›®å‰çš„ç¡¬ä»¶æ— æ³•æœ‰æ•ˆåœ°è¯„ä¼°å®ƒï¼Œå®ƒå·²ç»æœ‰ç‚¹åŠé€”è€ŒåºŸäº†ã€‚ä¸è¿‡ï¼Œè¿™å¯¹æˆ‘ä»¬æ¥è¯´æ„å‘³ç€æœ‰å¤§é‡çš„å·¥ä½œæ˜¯å…³äºå¦‚ä½•å°†lambdaæœ¯è¯­ç¼–è¯‘æˆç»„åˆå­çš„ï¼</p><p> We use the following basic combinator set for compilation:  SKIBC.  S is really the most important one here: of course we only need it and  K, but we use  I because it dramatically simplifies the expressions we generate, and we use  B and  C because they are special cases of  S, as weâ€™ll see in a second. The translation works like so:</p><p>æˆ‘ä»¬ä½¿ç”¨ä»¥ä¸‹åŸºæœ¬ç»„åˆå™¨é›†è¿›è¡Œç¼–è¯‘ï¼šSKIBCã€‚Såœ¨è¿™é‡Œæ˜¯æœ€é‡è¦çš„ï¼šå½“ç„¶æˆ‘ä»¬åªéœ€è¦å®ƒå’ŒKï¼Œä½†æ˜¯æˆ‘ä»¬ä½¿ç”¨iæ˜¯å› ä¸ºå®ƒæå¤§åœ°ç®€åŒ–äº†æˆ‘ä»¬ç”Ÿæˆçš„è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬ä½¿ç”¨Bå’ŒCæ˜¯å› ä¸ºå®ƒä»¬æ˜¯Sçš„ç‰¹ä¾‹ï¼Œæˆ‘ä»¬ç¨åä¼šçœ‹åˆ°ã€‚ç¿»è¯‘æ˜¯è¿™æ ·è¿›è¡Œçš„ï¼š</p><p> \x. e1 e2 -&gt; S (\x. e1) (\x. e2)\x. x -&gt; I\x. e -&gt; K e</p><p>\x.e1 e2-&gtï¼›S(\x.e1)(\x.E2)\x.x-&gtï¼›i\x.e-&gtï¼›K eã€‚</p><p> The translation works bottom-up. Weâ€™re only interested in removing the lambdas: combinator calculus does have application, after all, so thereâ€™s nothing we need to do in that case. For that reason, the algorithm is often called â€œabstraction eliminationâ€, and itâ€™s the one the  pointfree.io uses to automatically pointfree Haskell expressions.</p><p>ç¿»è¯‘å·¥ä½œæ˜¯è‡ªä¸‹è€Œä¸Šçš„ã€‚æˆ‘ä»¬åªå¯¹åˆ é™¤lambdasæ„Ÿå…´è¶£ï¼šæ¯•ç«ŸCombinatoræ¼”ç®—ç¡®å®æœ‰åº”ç”¨ç¨‹åºï¼Œæ‰€ä»¥åœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬ä¸éœ€è¦åšä»»ä½•äº‹æƒ…ã€‚å› æ­¤ï¼Œè¯¥ç®—æ³•é€šå¸¸è¢«ç§°ä¸ºâ€œæŠ½è±¡æ¶ˆé™¤â€ï¼Œå¹¶ä¸”å®ƒä¹Ÿæ˜¯æ— ç‚¹.ioç”¨æ¥è‡ªåŠ¨æ‰§è¡Œæ— ç‚¹Haskellè¡¨è¾¾å¼çš„ç®—æ³•ã€‚</p><p> There are three forms of abstraction: abstraction into an expression which is an application, abstraction which returns its argument, and abstraction which returns something other than its argument. In the first case, we use  S to pass the argument down each branch of the abstraction. In the second, we just use  I. And in the third case, we use  K to just ignore the argument. We wonâ€™t ever get  \x. \y. e, since the algorithm works bottom-up, so the  \y. e is eliminated before looking at the  \x. \y. e.</p><p>æŠ½è±¡æœ‰ä¸‰ç§å½¢å¼ï¼šæŠ½è±¡ä¸ºè¡¨è¾¾å¼(å³åº”ç”¨ç¨‹åº)ã€æŠ½è±¡(è¿”å›å…¶å‚æ•°)å’ŒæŠ½è±¡(è¿”å›å‚æ•°ä»¥å¤–çš„å†…å®¹)ã€‚åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨Så‘ä¸‹ä¼ é€’æŠ½è±¡çš„æ¯ä¸ªåˆ†æ”¯çš„å‚æ•°ã€‚åœ¨ç¬¬äºŒç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªä½¿ç”¨Iï¼Œåœ¨ç¬¬ä¸‰ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨Kæ¥å¿½ç•¥å‚æ•°ã€‚æˆ‘ä»¬æ°¸è¿œå¾—ä¸åˆ°\x\yï¼Œå› ä¸ºç®—æ³•æ˜¯è‡ªä¸‹è€Œä¸Šå·¥ä½œçš„ï¼Œæ‰€ä»¥åœ¨æŸ¥çœ‹\x\yä¹‹å‰ï¼Œ\yä¼šè¢«å»æ‰ã€‚</p><p> B and  C work like special cases of  S: when we pass  x down both branches of the application in the first case, sometimes that work is unnecessary. Sometimes one of the branches doesnâ€™t use the passed variable: in this case, we use  B or  C, depending on which branch ignores the variable.</p><p>Bå’ŒCçš„å·¥ä½œæ–¹å¼ç±»ä¼¼äºSçš„ç‰¹æ®Šæƒ…å†µï¼šå½“æˆ‘ä»¬åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹å‘åº”ç”¨ç¨‹åºçš„ä¸¤ä¸ªåˆ†æ”¯ä¼ é€’xæ—¶ï¼Œæœ‰æ—¶è¿™é¡¹å·¥ä½œæ˜¯ä¸å¿…è¦çš„ã€‚æœ‰æ—¶å…¶ä¸­ä¸€ä¸ªåˆ†æ”¯ä¸ä½¿ç”¨ä¼ é€’çš„å˜é‡ï¼šåœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨Bæˆ–Cï¼Œå…·ä½“å–å†³äºå“ªä¸ªåˆ†æ”¯å¿½ç•¥è¯¥å˜é‡ã€‚</p><p> \x. e1 e2, x âˆ‰ e1 -&gt; B e1 (\x. e2)\x. e1 e2, x âˆ‰ e2 -&gt; C (\x. e1) e2</p><p>\x.e1 e2ï¼Œxâˆ‰e1-&gtï¼›B e1(\x.E2)\x.e1 e2ï¼Œxâˆ‰e2-&gtï¼›C(\x.e1)e2ã€‚</p><p> There is one issue with this approach: it produces combinator expressions which are of order      ğ’ª (  n 3 ) \mathcal{O}(n^3) larger than the corresponding lambda expression. With some tricks (like our usage of  C and  B) we can get that down to      ğ’ª (  n 2 ) \mathcal{O}(n^2), but thatâ€™s still a pretty unpleasant size increase.</p><p>è¿™ç§æ–¹æ³•æœ‰ä¸€ä¸ªé—®é¢˜ï¼šå®ƒäº§ç”Ÿçš„ç»„åˆå­è¡¨è¾¾å¼çš„é˜¶ä¸ºğ’ª(N3)\mathcal{O}(n^3)ï¼Œæ¯”ç›¸åº”çš„lambdaè¡¨è¾¾å¼å¤§ã€‚é€šè¿‡ä¸€äº›æŠ€å·§(æ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨Cå’ŒB)ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ç®€åŒ–ä¸ºğ’ª(N2)\mathcal{O}(n^2)ï¼Œä½†è¿™ä»ç„¶æ˜¯ä¸€ä¸ªéå¸¸ä»¤äººä¸å¿«çš„å¤§å°å¢åŠ ã€‚</p><p> The issue is that weâ€™re basically passing the arguments as a singly-linked list, where naive access is     ğ’ª (  ğ“ƒ 2 ) \mathcal{O(n^2)}, and more sophisticated access is      ğ’ª ( n ) \mathcal{O}(n).</p><p>é—®é¢˜æ˜¯æˆ‘ä»¬åŸºæœ¬ä¸Šå°†å‚æ•°ä½œä¸ºå•é“¾è¡¨ä¼ é€’ï¼Œå…¶ä¸­ç®€å•çš„è®¿é—®æ˜¯ğ’ª(ğ“ƒ2)\mathcal{O(n^2)}ï¼Œè€Œæ›´å¤æ‚çš„è®¿é—®æ˜¯ğ’ª(N)\mathcal{O}(N)ã€‚</p><p> Oleg Kiselyov wrote a  paper  ( 2018) on getting this down to      ğ’ª ( n ) \mathcal{O}(n), with some memoisation. Thereâ€™s also a blog post  (Lynn  2018), describing how to get that conversion without memoisation in      ğ’ª ( n log n ) \mathcal{O}(n \log n) time, and an online implementation  here.</p><p>å¥¥åˆ—æ ¼Â·åŸºå¡å»–å¤«(Oleg Kiselyov)å†™äº†ä¸€ç¯‡è®ºæ–‡(2018å¹´)ï¼Œå†…å®¹æ˜¯å°†è¿™ä¸€ç‚¹å½’ç»“ä¸ºğ’ª(N)\Mathcal{O}(N)ï¼Œå¹¶é™„ä¸Šäº†ä¸€äº›å¤‡å¿˜å½•ã€‚è¿˜æœ‰ä¸€ç¯‡åšå®¢æ–‡ç« (Lynn2018)ï¼Œæè¿°äº†å¦‚ä½•åœ¨ğ’ª(Nlogn)\Mathcal{O}(n\logn)æ—¶é—´å†…è·å¾—è½¬æ¢è€Œä¸éœ€è¦è®°å¿†ï¼Œå¹¶åœ¨è¿™é‡Œæä¾›äº†ä¸€ä¸ªåœ¨çº¿å®ç°ã€‚</p><p>  Thatâ€™s all for this post! Iâ€™ll probably write more about combinators in the future: theyâ€™re an extremely interesting subject, and a lot of fun as puzzles to mess around with. One thing that I havenâ€™t mentioned is the connection between combinators and concatenative languages: it turns out that these two things are pretty much the same thing! Maybe Iâ€™ll look at it in a future post.</p><p>è¿™å°±æ˜¯è¿™ç¯‡æ–‡ç« çš„å…¨éƒ¨å†…å®¹ï¼å°†æ¥æˆ‘å¯èƒ½ä¼šå†™æ›´å¤šå…³äºç»„åˆå­çš„æ–‡ç« ï¼šå®ƒä»¬æ˜¯ä¸€ä¸ªéå¸¸æœ‰è¶£çš„ä¸»é¢˜ï¼Œåƒæ‹¼å›¾ä¸€æ ·éå¸¸æœ‰è¶£ã€‚æœ‰ä¸€ä»¶äº‹æˆ‘æ²¡æœ‰æåˆ°ï¼Œé‚£å°±æ˜¯ç»„åˆç¬¦å’Œä¸²è”è¯­è¨€ä¹‹é—´çš„è”ç³»ï¼šäº‹å®è¯æ˜ï¼Œè¿™ä¸¤ä»¶äº‹å‡ ä¹æ˜¯ä¸€å›äº‹ï¼ä¹Ÿè®¸æˆ‘ä¼šåœ¨ä»¥åçš„å¸–å­é‡Œçœ‹çœ‹ã€‚</p><p>  Graunke, David. 2016. â€œAn Introduction to Combinator Compilers and Graph Reduction Machines.â€ St. Louis.  https://www.youtube.com/watch?v=GawiQQCn3bk.</p><p>æ ¼æœ—å…‹ï¼Œå¤§å«ã€‚2016å¹´ã€‚â€œç»„åˆå™¨ç¼–è¯‘å™¨å’Œå›¾å½¢ç¼©å‡æœºç®€ä»‹ã€‚â€åœ£è·¯æ˜“æ–¯ã€‚Https://www.youtube.com/watch?v=GawiQQCn3bk.ã€‚</p><p> Kiselyov, Oleg. 2018. â€œ   Î» \lambda to SKI, Semantically.â€ In  Functional and Logic Programming, ed by. John P. Gallagher and Martin Sulzmann, 33â€“50. Lecture Notes in Computer Science. Cham: Springer International Publishing. doi: 10.1007/978-3-319-90686-7_3.  http://okmij.org/ftp/tagless-final/ski.pdf.</p><p>åŸºå¡å»–å¤«ï¼Œå¥¥åˆ—æ ¼ã€‚2018å¹´ã€‚â€œä»è¯­ä¹‰ä¸Šè®²ï¼ŒÎ»\lambdaè¡¨ç¤ºæ»‘é›ªã€‚â€åœ¨å‡½æ•°å¼å’Œé€»è¾‘ç¨‹åºè®¾è®¡ä¸­ï¼Œç”±ã€‚çº¦ç¿°Â·PÂ·åŠ æ‹‰æ ¼å°”å’Œé©¬ä¸Â·è‹å…¹æ›¼ï¼Œ33èƒœ50è´Ÿã€‚è®¡ç®—æœºç§‘å­¦è®²ä¹‰ã€‚æŸ¥å§†ï¼šæ–¯æ™®æ—æ ¼å›½é™…å‡ºç‰ˆç¤¾ã€‚ç½‘å€ï¼š90686-7_3.http://okmij.org/ftp/tagless-final/ski.pdf.ã€‚</p><p>  Lynn, Ben. 2018. â€œBen Lynnâ€™s Online Garbage: Lambda the Penultimate.â€  Ben Lynnâ€™s Online Garbage.  https://benlynn.blogspot.com/2018/11/lambda-penultimate_16.html.</p><p>æ—æ©ï¼Œè¿™æ˜¯æœ¬ã€‚2018å¹´ã€‚â€œæœ¬Â·æ—æ©çš„ç½‘ä¸Šåƒåœ¾ï¼šå€’æ•°ç¬¬äºŒä¸ªå…°å§†è¾¾ã€‚â€æœ¬Â·æ—æ©çš„ç½‘ä¸Šåƒåœ¾ã€‚Https://benlynn.blogspot.com/2018/11/lambda-penultimate_16.html.ã€‚</p><p> If you want to look up these combinators elsewhere, this is the only one you wonâ€™t be able to find: itâ€™s much less common than  K, and where I have found it people just call it  K, so I had to pick a different letter to distinguish it â†©ï¸</p><p>å¦‚æœä½ æƒ³åœ¨å…¶ä»–åœ°æ–¹æŸ¥æ‰¾è¿™äº›ç»„åˆç¬¦ï¼Œè¿™æ˜¯ä½ å”¯ä¸€æ‰¾ä¸åˆ°çš„ï¼šå®ƒæ¯”Kå°‘è§å¾—å¤šï¼Œåœ¨æˆ‘å‘ç°å®ƒçš„åœ°æ–¹ï¼Œäººä»¬åªå«å®ƒKï¼Œæ‰€ä»¥æˆ‘ä¸å¾—ä¸é€‰ä¸€ä¸ªä¸åŒçš„å­—æ¯æ¥åŒºåˆ†å®ƒâ†©ï¸</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://doisinkidney.com/posts/2020-10-17-ski.html">https://doisinkidney.com/posts/2020-10-17-ski.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ç»„åˆ/">#ç»„åˆ</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fun/">#fun</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¾å›½/">#ç¾å›½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¨‹åº/">#ç¨‹åº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>