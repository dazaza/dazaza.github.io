<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>å…°å§†è¾¾å¾®ç§¯åˆ†çš„ä¹è¶£</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">å…°å§†è¾¾å¾®ç§¯åˆ†çš„ä¹è¶£</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 20:31:27</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/e2b8bc38276bc158265a5470ba58d117.png"><img src="http://img2.diglog.com/img/2020/10/e2b8bc38276bc158265a5470ba58d117.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In 1935, a gentleman called Alonzo Church came up with a simple scheme that could computeâ€¦just about anything. His scheme was called Lambda Calculus. It was a phenomenal innovation, given that there werenâ€™t even computers for him to test out his ideas. Even cooler is that those very ideas affect us today: anytime you use a function, you owe a hat tip to Mr. Church.</p><p>1935å¹´ï¼Œä¸€ä½åå«é˜¿éš†ä½Â·ä¸˜å¥‡çš„ç»…å£«æƒ³å‡ºäº†ä¸€ä¸ªå¯ä»¥è®¡ç®—â€¦çš„ç®€å•æ–¹æ¡ˆã€‚å‡ ä¹ä»€ä¹ˆéƒ½è¡Œã€‚ä»–çš„æ–¹æ¡ˆè¢«ç§°ä¸ºå…°å§†è¾¾å¾®ç§¯åˆ†(Lambda Calculus)ã€‚è¿™æ˜¯ä¸€é¡¹éå‡¡çš„åˆ›æ–°ï¼Œå› ä¸ºä»–ç”šè‡³æ²¡æœ‰ç”µè„‘æ¥æµ‹è¯•ä»–çš„æƒ³æ³•ã€‚æ›´é…·çš„æ˜¯ï¼Œè¿™äº›æƒ³æ³•åœ¨ä»Šå¤©å½±å“ç€æˆ‘ä»¬ï¼šä»»ä½•æ—¶å€™ä½ ä½¿ç”¨ä¸€ä¸ªå‡½æ•°ï¼Œä½ éƒ½åº”è¯¥å‘ä¸˜å¥‡å…ˆç”Ÿè‡´æ•¬ã€‚</p><p> Lambda Calculus is so cool that many hackers use it as their secret handshake â€” a â€œdiscreet signalâ€ if you will. The most famous, of course, is PGâ€™s Y Combinator. In this essay, weâ€™ll find out what itâ€™s all about, and do things with functions that weâ€™d never have imagined. In the end youâ€™ll have built just about every programming concept: numbers, booleans, you name itâ€¦just with functions.</p><p>Lambdaæ¼”ç®—æ˜¯å¦‚æ­¤é…·ï¼Œä»¥è‡³äºè®¸å¤šé»‘å®¢å°†å…¶ç”¨ä½œç§˜å¯†æ¡æ‰‹--å¦‚æœä½ æ„¿æ„çš„è¯ï¼Œè¿™æ˜¯ä¸€ä¸ªâ€œè°¨æ…çš„ä¿¡å·â€ã€‚å½“ç„¶ï¼Œæœ€è‘—åçš„æ˜¯PGçš„Yç»„åˆå™¨ã€‚åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ‰¾å‡ºå®ƒçš„å…¨éƒ¨å†…å®¹ï¼Œå¹¶ç”¨æˆ‘ä»¬ä»æœªæƒ³è±¡è¿‡çš„åŠŸèƒ½æ¥åšä¸€äº›äº‹æƒ…ã€‚æœ€åï¼Œæ‚¨å°†æ„å»ºå‡ ä¹æ‰€æœ‰çš„ç¼–ç¨‹æ¦‚å¿µï¼šæ•°å­—ã€å¸ƒå°”å€¼ï¼Œæ‚¨å¯ä»¥å°†å…¶å‘½åä¸ºâ€¦ã€‚åªéœ€ä½¿ç”¨å‡½æ•°å³å¯ã€‚</p><p>  City dwellers who drive SUVs rarely consider their cars as ferocious machines that traverse rocky deserts and flooded rivers. Itâ€™s the same with programmers and functions. Hereâ€™s what we  think functions do:</p><p>å¼€SUVçš„åŸå¸‚å±…æ°‘å¾ˆå°‘è®¤ä¸ºä»–ä»¬çš„æ±½è½¦æ˜¯ç©¿è¶Šå¤šå²©çŸ³çš„æ²™æ¼ å’Œæ´ªæ°´æ³›æ»¥çš„æ²³æµçš„å‡¶çŒ›æœºå™¨ã€‚ç¨‹åºå‘˜å’Œå‡½æ•°ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä¸‹é¢æ˜¯æˆ‘ä»¬è®¤ä¸ºå‡½æ•°çš„ä½œç”¨ï¼š</p><p>  Safe, clean, and useful. Weâ€™re so accustomed that it would surprise us to find the myriad of ways we can bend functions to do just about anything.</p><p>å®‰å…¨ã€å¹²å‡€ã€æœ‰ç”¨ã€‚æˆ‘ä»¬å·²ç»ä¹ ä»¥ä¸ºå¸¸äº†ï¼Œå¦‚æœæˆ‘ä»¬å‘ç°æˆ‘ä»¬å¯ä»¥ç”¨æ— æ•°ç§æ–¹æ³•æ¥å¼¯æ›²å‡½æ•°æ¥åšä»»ä½•äº‹æƒ…ï¼Œé‚£ä¼šè®©æˆ‘ä»¬å¤§åƒä¸€æƒŠã€‚</p><p> Letâ€™s step out into the wilderness a bit. Say you wanted to make a data structure for pairs:</p><p>è®©æˆ‘ä»¬åˆ°è’é‡é‡Œèµ°ä¸€èµ°å§ã€‚å‡è®¾æ‚¨æƒ³ä¸ºPairåˆ›å»ºä¸€ä¸ªæ•°æ®ç»“æ„ï¼š</p><p>  How would you do it? Itâ€™s sensible to use a map or a class or a record to represent a pair. Butâ€¦you could use functions too.</p><p>ä½ ä¼šæ€ä¹ˆåšå‘¢ï¼Ÿä½¿ç”¨åœ°å›¾ã€ç±»æˆ–è®°å½•æ¥è¡¨ç¤ºä¸€å¯¹æ˜¯æ˜æ™ºçš„ã€‚ä½†æ˜¯â€¦ã€‚æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨å‡½æ•°ã€‚</p><p>     Now our  ex-pair takes a  selector argument. What if we ran ex-pair with this selector:</p><p>ç°åœ¨æˆ‘ä»¬çš„å‰æ­æ¡£æ¥å—ä¸€ä¸ªé€‰æ‹©å™¨å‚æ•°ã€‚å¦‚æœæˆ‘ä»¬ç”¨è¿™ä¸ªé€‰æ‹©å™¨è¿è¡Œå‰ä»»é…å¯¹ä¼šæ€ä¹ˆæ ·ï¼š</p><p>     That just gave us the  first value of our pair! We can use that to write a  church-first function:</p><p>è¿™æ­£å¥½ç»™æˆ‘ä»¬å¸¦æ¥äº†æˆ‘ä»¬è¿™åŒé‹çš„ç¬¬ä¸€ä¸ªä»·å€¼ï¼æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥ç¼–å†™æ•™å ‚ä¼˜å…ˆå‡½æ•°ï¼š</p><p>      We just used functions to represent pairs. Now, since the grammar for Lisp is just a bunch of pairs plopped together, that also means we can represent the grammar of Lispâ€¦with just functions!</p><p>æˆ‘ä»¬åªæ˜¯ç”¨å‡½æ•°æ¥è¡¨ç¤ºå¯¹ã€‚ç°åœ¨ï¼Œç”±äºLispçš„è¯­æ³•åªæ˜¯ä¸€å †ç»„åˆåœ¨ä¸€èµ·çš„å¯¹ï¼Œè¿™ä¹Ÿæ„å‘³ç€æˆ‘ä»¬å¯ä»¥è¡¨ç¤ºLispâ€¦çš„è¯­æ³•ã€‚åŠŸèƒ½é½å…¨ï¼</p><p>  What we just did was analogous to a city dweller driving their SUVâ€¦on a snowy day. It gets a  lot crazier.</p><p>æˆ‘ä»¬åˆšæ‰æ‰€åšçš„ç±»ä¼¼äºä¸€ä¸ªåŸå¸‚å±…æ°‘é©¾é©¶ä»–ä»¬çš„è¶Šé‡è½¦â€¦ã€‚åœ¨ä¸€ä¸ªä¸‹é›ªçš„æ—¥å­é‡Œã€‚å®ƒå˜å¾—æ›´ç–¯ç‹‚äº†ã€‚</p><p>  Hereâ€™s what can do. Letâ€™s take a function we know and love, and implement it from top-to-bottom in Lambda Calculus.</p><p>è¿™å°±æ˜¯æˆ‘ä»¬èƒ½åšçš„ã€‚è®©æˆ‘ä»¬å–ä¸€ä¸ªæˆ‘ä»¬ç†Ÿæ‚‰å’Œå–œçˆ±çš„å‡½æ•°ï¼Œå¹¶åœ¨Lambdaæ¼”ç®—ä¸­è‡ªä¸Šè€Œä¸‹åœ°å®ç°å®ƒã€‚</p><p>    By the end of this essay, weâ€™ll have built factorial, only with functions.</p><p>åœ¨æœ¬æ–‡ç»“æŸæ—¶ï¼Œæˆ‘ä»¬å°†åªä½¿ç”¨å‡½æ•°æ„å»ºé˜¶ä¹˜ã€‚</p><p>  To do this, I want to come up front and say I am cheating a little bit. In Churchâ€™s Lambda Calculus, there is no  def, and all functions take one argument. Hereâ€™s all he says:</p><p>ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘æƒ³èµ°åˆ°å‰é¢è¯´æˆ‘æœ‰ä¸€ç‚¹ä½œå¼Šã€‚åœ¨ä¸˜å¥‡çš„Lambdaæ¼”ç®—ä¸­ï¼Œæ²¡æœ‰å®šä¹‰ï¼Œæ‰€æœ‰å‡½æ•°éƒ½æœ‰ä¸€ä¸ªå‚æ•°ã€‚ä»¥ä¸‹æ˜¯ä»–æ‰€è¯´çš„ï¼š</p><p>  In his rules, you define anonymous functions by popping a little  Î» in front. What follows is the argument, following by a  . .After the  . is the application.</p><p>åœ¨ä»–çš„è§„åˆ™ä¸­ï¼Œæ‚¨é€šè¿‡åœ¨å‰é¢å¼¹å‡ºä¸€ä¸ªå°Î»æ¥å®šä¹‰åŒ¿åå‡½æ•°ã€‚ä¸‹é¢æ˜¯å‚æ•°ï¼Œåé¢è·Ÿç€ä¸€ä¸ªã€‚.åœ¨..ä¹‹åã€‚æ˜¯åº”ç”¨ç¨‹åºã€‚</p><p> This is very much akin to a single-argument anonymous function in Clojure:  Î» x. x =&gt;  (fn [x] x)</p><p>è¿™éå¸¸ç±»ä¼¼äºclojureä¸­çš„å•å‚æ•°åŒ¿åå‡½æ•°ï¼šÎ»x.x=&gtï¼›(fn[x]x)ã€‚</p><p> We could follow those rules, but writing factorial like that is going to get hard to reason about very quickly. Letâ€™s tweak the rules just a little bit. The changes wonâ€™t affect the essence of Lambda Calculus but will make it easier for us to think about our code. Here it goes:</p><p>æˆ‘ä»¬å¯ä»¥éµå¾ªè¿™äº›è§„åˆ™ï¼Œä½†æ˜¯åƒé‚£æ ·ç¼–å†™é˜¶ä¹˜å°†å¾ˆéš¾å¾ˆå¿«å¾—åˆ°æ¨ç†ã€‚è®©æˆ‘ä»¬ç¨å¾®è°ƒæ•´ä¸€ä¸‹è§„åˆ™ã€‚è¿™äº›æ›´æ”¹ä¸ä¼šå½±å“Lambdaæ¼”ç®—çš„æœ¬è´¨ï¼Œä½†ä¼šä½¿æˆ‘ä»¬æ›´å®¹æ˜“è€ƒè™‘ä»£ç ã€‚å®ƒæ˜¯è¿™æ ·çš„ï¼š</p><p>  1) for a single argument function,  (fn [x] x) maps pretty well to Churchâ€™s encoding. We can go ahead and use it as is.</p><p>1)å¯¹äºå•å‚æ•°å‡½æ•°ï¼Œ(fn[x]x)å¾ˆå¥½åœ°æ˜ å°„åˆ°Churchçš„ç¼–ç ã€‚æˆ‘ä»¬å¯ä»¥ç»§ç»­æŒ‰åŸæ ·ä½¿ç”¨å®ƒã€‚</p><p> 2) Since Churchâ€™s lambdas only take one argument, For him to express a function with two arguments, he has to write  two anonymous functions:</p><p>2)ç”±äºChurchçš„lambdasåªæ¥å—ä¸€ä¸ªå‚æ•°ï¼Œè¦ç”¨ä¸¤ä¸ªå‚æ•°è¡¨ç¤ºä¸€ä¸ªå‡½æ•°ï¼Œä»–å¿…é¡»ç¼–å†™ä¸¤ä¸ªåŒ¿åå‡½æ•°ï¼š</p><p>    But, nesting our functions like this can get annoying in Clojure  1. To make life easier for us, weâ€™ll allow for multi-argument functions:</p><p>ä½†æ˜¯ï¼Œåœ¨Clojure 1ä¸­ï¼Œåƒè¿™æ ·åµŒå¥—æˆ‘ä»¬çš„å‡½æ•°å¯èƒ½ä¼šå¾ˆçƒ¦äººã€‚ä¸ºäº†è®©æˆ‘ä»¬çš„å·¥ä½œæ›´è½»æ¾ï¼Œæˆ‘ä»¬å°†å…è®¸ä½¿ç”¨å¤šå‚æ•°å‡½æ•°ï¼š</p><p>  3) Finally, Church has no concepts of variables outside of whatâ€™s provided by a function definition.</p><p>3)æœ€åï¼Œé™¤äº†å‡½æ•°å®šä¹‰æä¾›çš„å˜é‡ä¹‹å¤–ï¼ŒChurchæ²¡æœ‰å˜é‡çš„æ¦‚å¿µã€‚</p><p>     To keep our code sane, weâ€™ll allow for  def, but with one rule:</p><p>ä¸ºäº†ä½¿æˆ‘ä»¬çš„ä»£ç ä¿æŒæ­£å¸¸ï¼Œæˆ‘ä»¬å°†å…è®¸defï¼Œä½†æœ‰ä¸€æ¡è§„åˆ™ï¼š</p><p> You can use   def  , as long as you can â€œreplaceâ€ it with an anonymous function and nothing breaks.</p><p>æ‚¨å¯ä»¥ä½¿ç”¨defï¼Œåªè¦æ‚¨å¯ä»¥ç”¨åŒ¿åå‡½æ•°â€œæ›¿æ¢â€å®ƒå¹¶ä¸”æ²¡æœ‰ä¸­æ–­ã€‚</p><p>   This would break because if we replaced  (def make-pair â€¦) with an anonymous function, there would be no variable called  make-pair anymore!</p><p>è¿™å°†ä¸­æ–­ï¼Œå› ä¸ºå¦‚æœæˆ‘ä»¬æ›¿æ¢(å®šä¹‰Make-Pairâ€¦)ã€‚ä½¿ç”¨åŒ¿åå‡½æ•°ï¼Œå°†ä¸å†æœ‰åä¸ºMake-Pairçš„å˜é‡ï¼</p><p> Thatâ€™s it, these are our rules. With that, weâ€™re ready to make factorial!</p><p>å°±æ˜¯è¿™æ ·ï¼Œè¿™æ˜¯æˆ‘ä»¬çš„è§„çŸ©ã€‚æœ‰äº†è¿™äº›ï¼Œæˆ‘ä»¬å°±å¯ä»¥åšé˜¶ä¹˜äº†ï¼</p><p>  The first thing we need is the concept of a number. How can we do that?</p><p>æˆ‘ä»¬é¦–å…ˆéœ€è¦çš„æ˜¯æ•°å­—çš„æ¦‚å¿µã€‚æˆ‘ä»¬æ€ä¹ˆèƒ½åšåˆ°è¿™ä¸€ç‚¹å‘¢ï¼Ÿ</p><p> Church thought of a pretty cool idea. What if â€œnumbersâ€, where higher-order functions with two arguments: a function  f, and a value  v.</p><p>ä¸˜å¥‡æƒ³åˆ°äº†ä¸€ä¸ªå¾ˆé…·çš„ä¸»æ„ã€‚å¦‚æœæ˜¯â€œNumbersâ€ï¼Œå…¶ä¸­é«˜é˜¶å‡½æ•°æœ‰ä¸¤ä¸ªå‚æ•°ï¼šå‡½æ•°få’Œå€¼vï¼Œæƒ…å†µä¼šæ€æ ·å‘¢ï¼Ÿ</p><p> ( def  zero ( fn  [f v] v)) ( def  one ( fn  [f v]  ( f  ( zero  f v)))) ( def  two ( fn  [f v]  ( f  ( one  f v))))</p><p>(defé›¶(fn[f v]v))(def one(fn[f v](f(é›¶f v)(def Two(fn[f v](f(One F V)ã€‚</p><p> We can figure out what number each function represents by â€œcountingâ€ the number of times   f  was composed.</p><p>æˆ‘ä»¬å¯ä»¥é€šè¿‡â€œè®¡æ•°â€fè¢«åˆæˆçš„æ¬¡æ•°æ¥è®¡ç®—å‡ºæ¯ä¸ªå‡½æ•°ä»£è¡¨çš„æ•°å­—ã€‚</p><p> For example, 0 would compose  f zero times: it would just return  v. 1, would compose f once:  (f v). 2 would compose twice:  (f (f v)), and so on.</p><p>ä¾‹å¦‚ï¼Œ0å°†åˆæˆfçš„æ¬¡æ•°ä¸ºé›¶ï¼šå®ƒåªè¿”å›vã€‚1ï¼Œå°†åˆæˆfä¸€æ¬¡ï¼š(Fv)ã€‚2å°†ç»„æˆä¸¤æ¬¡ï¼š(F(fï¼Œv))ï¼Œä¾æ­¤ç±»æ¨ã€‚</p><p> To help us see these numbers in our REPL, letâ€™s create a quick converter function:</p><p>ä¸ºäº†å¸®åŠ©æˆ‘ä»¬åœ¨REPLä¸­æŸ¥çœ‹è¿™äº›æ•°å­—ï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå¿«é€Ÿè½¬æ¢å™¨å‡½æ•°ï¼š</p><p>  Since a church numeral composes  f the number of times it is called with  v as the first argument, all we need to see what number it is in Clojure, is to provide  inc as  f and  0 as  v! Now  2 would do  (inc (inc 0)) for example, and get us the corresponding Clojure number.</p><p>å› ä¸ºæ•™å ‚æ•°å­—ç”±å®ƒè¢«è°ƒç”¨çš„æ¬¡æ•°ç»„æˆï¼Œå…¶ä¸­væ˜¯ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦çŸ¥é“å®ƒåœ¨Clojureä¸­æ˜¯ä»€ä¹ˆæ•°å­—ï¼Œåªéœ€æä¾›Incä½œä¸ºfï¼Œæä¾›0ä½œä¸ºvï¼ä¾‹å¦‚ï¼Œç°åœ¨2å°†åš(Inc(Inc0))ï¼Œå¹¶ä¸ºæˆ‘ä»¬è·å¾—ç›¸åº”çš„Clojureç¼–å·ã€‚</p><p>      What we did here, is  delegate fâ€™s composition to the numeral before (in this case  one ), and then just called  f  one more time.</p><p>æˆ‘ä»¬åœ¨è¿™é‡Œåšçš„æ˜¯å§”æ‰˜fç»„æˆå‰é¢çš„æ•°å­—(åœ¨æœ¬ä¾‹ä¸­æ˜¯1)ï¼Œç„¶åå†è°ƒç”¨fä¸€æ¬¡ã€‚</p><p>   Voila. Give this function a numeral, and it will return a new numeral that calls  f  one more time. Weâ€™ve just discovered  inc!</p><p>ç§å•Šã€‚ç»™è¿™ä¸ªå‡½æ•°ä¸€ä¸ªæ•°å­—ï¼Œå®ƒå°†è¿”å›ä¸€ä¸ªæ–°çš„æ•°å­—ï¼Œå¹¶å†æ¬¡è°ƒç”¨fã€‚æˆ‘ä»¬åˆšåˆšå‘ç°äº†Inc.ï¼</p><p>   Now that we have this function, we can also write a quick helper to translate Clojure numbers to these numbers:</p><p>ç°åœ¨æˆ‘ä»¬æœ‰äº†è¿™ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç¼–å†™ä¸€ä¸ªå¿«é€Ÿå¸®åŠ©å™¨å°†Clojureæ•°å­—è½¬æ¢ä¸ºè¿™äº›æ•°å­—ï¼š</p><p>     Next up, we need a way to â€œdecrementâ€ a number. Well, with  inc we create a numeral that composes  f  one more time. If we can make some kind of function that composes  f  one less time, then weâ€™d have  dec!</p><p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥â€œé€’å‡â€ä¸€ä¸ªæ•°å­—ã€‚å—¯ï¼Œä½¿ç”¨Incï¼Œæˆ‘ä»¬å†ä¸€æ¬¡åˆ›å»ºä¸€ä¸ªç»„æˆfçš„æ•°å­—ã€‚å¦‚æœæˆ‘ä»¬èƒ½å°‘åšä¸€æ¬¡ç»„æˆfçš„å‡½æ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æœ‰äº†decï¼</p><p>   Remember our  pair data structure? Letâ€™s create a function for it (weâ€™ll use this in just a moment below):  shift-and-inc. All it would do, is take pair of numbers, and â€œshiftâ€ the pair forward by one:</p><p>è¿˜è®°å¾—æˆ‘ä»¬çš„é…å¯¹æ•°æ®ç»“æ„å—ï¼Ÿè®©æˆ‘ä»¬ä¸ºå®ƒåˆ›å»ºä¸€ä¸ªå‡½æ•°(æˆ‘ä»¬ç¨åä¼šç”¨åˆ°è¿™ä¸ªå‡½æ•°)ï¼šShift-and-Incã€‚å®ƒæ‰€è¦åšçš„å°±æ˜¯å–ä¸€å¯¹æ•°å­—ï¼Œå¹¶å°†è¿™å¯¹æ•°å­—â€œå‰ç§»â€ä¸€ä½ï¼š</p><p> For example, applying  shift-and-inc to  (0 1), would produce  (1 2). One more time, it would produce  (2 3), and so on.</p><p>ä¾‹å¦‚ï¼Œå¯¹(0 1)åº”ç”¨Shift-and-Incå°†ç”Ÿæˆ(1 2)ã€‚å†ä¸€æ¬¡ï¼Œå®ƒå°†äº§ç”Ÿ(2 3)ï¼Œä¾æ­¤ç±»æ¨ã€‚</p><p>   Bam, we take a pair. The second item is shifted over to the first positions and is replaced with its  inced friend. Letâ€™s try it out:</p><p>ç­å§†ï¼Œæˆ‘ä»¬æ‹¿ä¸€åŒã€‚ç¬¬äºŒä»¶ç‰©å“è¢«ç§»åˆ°ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå¹¶è¢«å®ƒçš„åˆ»ç—•æœ‹å‹å–ä»£ã€‚è®©æˆ‘ä»¬è¯•è¯•çœ‹ï¼š</p><p> ( let  [p ( shift-and-inc  ( church-pair  one two))]  ( map  church-numeral-&gt;int [( church-first  p) ( church-second  p)])) ; =&gt; (2 3)</p><p>(è®¾[p(Shift-and-Inc(æ•™å ‚å¯¹ä¸€äºŒ))](æ˜ å°„æ•™å ‚æ•°å­—-&gtï¼›int[(æ•™å ‚ç¬¬ä¸€ä¸ªp)(æ•™å ‚ç¬¬äºŒä¸ªp)]))ï¼›=&gtï¼›(23)ã€‚</p><p>     Remember that our  church-numeral would call  shift-and-inc N times, representing its numeral value. If we started with a pair  (0, 0), then what would the result b, if we composed  shift-and-inc  N times?</p><p>è¯·è®°ä½ï¼Œæˆ‘ä»¬çš„æ•™å ‚æ•°å­—å°†è°ƒç”¨Shift-and-Inc Næ¬¡ï¼Œè¡¨ç¤ºå…¶æ•°å€¼ã€‚å¦‚æœæˆ‘ä»¬ä»ä¸€ä¸ªå¯¹(0ï¼Œ0)å¼€å§‹ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬å°†Shift-and-Inc.ç»„åˆNæ¬¡ï¼Œé‚£ä¹ˆç»“æœbä¼šæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ</p><p> Our result would be the pair  (N-1, N). This means that if we take the first part of our pair, we have  dec!</p><p>æˆ‘ä»¬çš„ç»“æœå°†æ˜¯å¯¹(N-1ï¼ŒN)ã€‚è¿™æ„å‘³ç€å¦‚æœæˆ‘ä»¬æŠŠæˆ‘ä»¬å¯¹çš„ç¬¬ä¸€éƒ¨åˆ†å–èµ°ï¼Œæˆ‘ä»¬å°±æœ‰äº†12æœˆï¼</p><p>    Next up, multiplication. Say we multiply  a by  b. Weâ€™d need to produce a church numeral that composes  f,  a * b times. To do that, we can leverage the following idea:</p><p>æ¥ä¸‹æ¥æ˜¯ä¹˜æ³•ã€‚å‡è®¾æˆ‘ä»¬ç”¨aä¹˜ä»¥bï¼Œæˆ‘ä»¬éœ€è¦äº§ç”Ÿä¸€ä¸ªæ•™ä¼šæ•°å­—ï¼Œç»„æˆfï¼Œa*bæ¬¡ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä»¥ä¸‹æƒ³æ³•ï¼š</p><p> Say we made a function  g, which composes  f  b times. If we fed that function to  a, it would call  g,  a times.</p><p>å‡è®¾æˆ‘ä»¬åšäº†ä¸€ä¸ªå‡½æ•°gï¼Œå®ƒç»„æˆäº†fï¼Œbæ¬¡ã€‚å¦‚æœæˆ‘ä»¬æŠŠè¿™ä¸ªå‡½æ•°æä¾›ç»™aï¼Œå®ƒä¼šè°ƒç”¨gï¼Œaæ¬¡ã€‚</p><p>  If  a was â€œ2â€ and â€œbâ€ was 3, how many times would  f get composed? Well,  g would be composed twice. Each time  g is composed,  f is composed 3 times. That comes out to a total of 6 times!</p><p>å¦‚æœaæ˜¯â€œ2â€ï¼Œâ€œbâ€æ˜¯3ï¼Œfä¼šåˆæˆå‡ æ¬¡ï¼Ÿå—¯ï¼Œgä¼šç»„æˆä¸¤æ¬¡ã€‚æ¯æ¬¡åˆæˆgï¼Œå°±åˆæˆf 3æ¬¡ã€‚ä¸€å…±å‡ºäº†6æ¬¡ï¼</p><p>       Weâ€™ve got numbers, weâ€™ve got  * and weâ€™ve got  dec. Next upâ€¦booleans!</p><p>æˆ‘ä»¬æœ‰æ•°å­—ï¼Œæˆ‘ä»¬æœ‰*ï¼Œæˆ‘ä»¬æœ‰12æœˆã€‚Next Upâ€¦ã€‚å¸ƒå°”äººï¼</p><p>    They take a â€œtrueâ€ case and a â€œfalseâ€ case. Our  church-true function would return the true case, and  church-false function would return the false case.</p><p>ä»–ä»¬æ¥å—ä¸€ä¸ªâ€œçœŸâ€æ¡ˆå’Œä¸€ä¸ªâ€œå‡â€æ¡ˆã€‚æˆ‘ä»¬çš„chorge-trueå‡½æ•°å°†è¿”å›true caseï¼Œè€Œchocket-falseå‡½æ•°å°†è¿”å›false caseã€‚</p><p> Thatâ€™s it. Surprisingly this is enough to handle booleans. Hereâ€™s how we could convert them to Clojure bools.</p><p>å°±è¿™æ ·ã€‚ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œè¿™è¶³ä»¥å¤„ç†å¸ƒå°”å€¼ã€‚ä¸‹é¢æ˜¯æˆ‘ä»¬å¦‚ä½•å°†å®ƒä»¬è½¬æ¢ä¸ºClojure boolsã€‚</p><p>  Our  church-true would return the first argument (true), and our  church-false would return the second one!</p><p>æˆ‘ä»¬çš„æ•™å ‚-trueå°†è¿”å›ç¬¬ä¸€ä¸ªå‚æ•°(True)ï¼Œè€Œæˆ‘ä»¬çš„æ•™å ‚-falseå°†è¿”å›ç¬¬äºŒä¸ªå‚æ•°ï¼</p><p>  Do they look familiar? Those are our  selector functions for  church-first and  church-second! We could interchange them if we wished ğŸ˜®</p><p>ä»–ä»¬çœ‹èµ·æ¥çœ¼ç†Ÿå—ï¼Ÿè¿™å°±æ˜¯æˆ‘ä»¬æ•™ä¼šç¬¬ä¸€å’Œæ•™ä¼šç¬¬äºŒçš„é€‰æ‹©å™¨åŠŸèƒ½ï¼å¦‚æœæˆ‘ä»¬æ„¿æ„ï¼Œæˆ‘ä»¬å¯ä»¥äº’æ¢å®ƒä»¬ï¼ŒğŸ˜®ã€‚</p><p>  If you are like me, you were a bit suspicious of those booleans. Letâ€™s put them to use and quiet our fears. Hereâ€™s how could create an  if construct:</p><p>å¦‚æœä½ å’Œæˆ‘ä¸€æ ·ï¼Œä½ å¯¹é‚£äº›å¸ƒå°”äººæœ‰ç‚¹æ€€ç–‘ã€‚è®©æˆ‘ä»¬å¥½å¥½åˆ©ç”¨å®ƒä»¬ï¼Œå¹³æ¯æˆ‘ä»¬çš„ææƒ§å§ã€‚ä¸‹é¢æ˜¯å¦‚ä½•åˆ›å»ºIfç»“æ„çš„æ–¹æ³•ï¼š</p><p>  All we do to make  if, is to simply shuffle things around and provide the  when-true and  when-false cases to our boolean!  church-true would return the  when-true case, and  church-false would return the  when-false case.</p><p>æˆ‘ä»¬è¦åšçš„æ‰€æœ‰äº‹æƒ…å°±æ˜¯ç®€å•åœ°å°†äº‹ç‰©æ‰“ä¹±ï¼Œå¹¶å‘æˆ‘ä»¬çš„å¸ƒå°”å€¼æä¾›When-Trueå’ŒWhen-Falseçš„æƒ…å†µï¼Church-trueå°†è¿”å›When-Trueå¤§å°å†™ï¼Œè€ŒChurch-Falseå°†è¿”å›When-Falseå¤§å°å†™ã€‚</p><p>    We have almost  all the constructs we need to implement  factorial. One missing piece:  zero?. We need a way to tell when a numeral is zero.</p><p>æˆ‘ä»¬å‡ ä¹æ‹¥æœ‰å®ç°é˜¶ä¹˜æ‰€éœ€çš„æ‰€æœ‰æ„é€ ã€‚å°‘äº†ä¸€å—ï¼šé›¶å—ï¼Ÿæˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥åˆ¤æ–­æ•°å­—ä½•æ—¶ä¸ºé›¶ã€‚</p><p>     If a number is greater than zero,  f would be called, which would replace  v with  church-false. Otherwise, weâ€™d return the initial value of  v,  church-true.</p><p>å¦‚æœä¸€ä¸ªæ•°å­—å¤§äºé›¶ï¼Œåˆ™ä¼šè°ƒç”¨fï¼Œè¿™ä¼šå°†væ›¿æ¢ä¸ºchocket-falseã€‚å¦åˆ™ï¼Œæˆ‘ä»¬å°†è¿”å›vçš„åˆå§‹å€¼ï¼Œæ•™å ‚ä¸ºçœŸã€‚</p><p>      Well, we have  numerals, we have  if, we have  zero? we have  *, we have  dec. We could translate this:</p><p>å—¯ï¼Œæˆ‘ä»¬æœ‰æ•°å­—ï¼Œæˆ‘ä»¬æœ‰å¦‚æœï¼Œæˆ‘ä»¬æœ‰é›¶ï¼Ÿæˆ‘ä»¬æœ‰*ï¼Œæˆ‘ä»¬æœ‰12æœˆã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·ç¿»è¯‘ï¼š</p><p> ( def  factorial-v0  ( fn  [church-numeral-n]  (( church-if  ( church-zero?  church-numeral-n)  ( fn  [] one)  ( fn  []  ( church-*  church-numeral-n  ( factorial-v0  ( church-dec  church-numeral-n))))))))</p><p>(defé˜¶ä¹˜-V0(Fn[æ•™ä¼šæ•°å­—-n](æ•™ä¼š-IF(æ•™ä¼š-é›¶ï¼Ÿæ•™å ‚æ•°å­—-n)(fn[]one)(fn[](æ•™å ‚-*æ•™å ‚æ•°å­—-n(é˜¶ä¹˜-v0(æ•™å ‚-åäºŒæœˆæ•™å ‚-æ•°å­—-n)ã€‚</p><p>  The only weird thing is that we wrapped the  when-true and  when-false cases in an anonymous function. This is because our  church-if is a little different than Clojureâ€™s  if. Clojureâ€™s if  only evaluates one of the  when-true and  when-false cases. Ours evaluates both cases, which triggers an infinite recursion. We avoid this by wrapping both cases in a lambda, which â€œdelaysâ€ the evaluation for us.  2</p><p>å”¯ä¸€å¥‡æ€ªçš„æ˜¯ï¼Œæˆ‘ä»¬å°†WHEN-TRUEå’ŒWHEN-FALSEæ¡ˆä¾‹åŒ…è£…åœ¨ä¸€ä¸ªåŒ¿åå‡½æ•°ä¸­ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„æ•™ä¼šIFä¸Clojureçš„IFç•¥æœ‰ä¸åŒã€‚Clojureçš„IFåªè¯„ä¼°WHEN-TRUEå’ŒWHEN-FALSEæ¡ˆä¾‹ä¸­çš„ä¸€ä¸ªã€‚æˆ‘ä»¬çš„æ–¹æ³•å¯¹è¿™ä¸¤ç§æƒ…å†µéƒ½æ±‚å€¼ï¼Œè¿™ä¼šè§¦å‘æ— é™é€’å½’ã€‚æˆ‘ä»¬é€šè¿‡å°†ä¸¤ç§æƒ…å†µéƒ½åŒ…è£…åœ¨ä¸€ä¸ªlambdaä¸­æ¥é¿å…è¿™ä¸€ç‚¹ï¼Œè¿™ä¼šâ€œå»¶è¿Ÿâ€æˆ‘ä»¬çš„è¯„ä¼°ã€‚2ä¸ª</p><p>     Okay, almost. We cheated. Remember our  Rule 3:  If we replace our variables with an anonymous function, everything should work well. What would happen if we wrote  factorial-v0 as an anonymous function?</p><p>å¥½çš„ï¼Œå·®ä¸å¤šäº†ã€‚æˆ‘ä»¬ä½œå¼Šäº†ã€‚è®°ä½æˆ‘ä»¬çš„è§„åˆ™3ï¼šå¦‚æœæˆ‘ä»¬ç”¨åŒ¿åå‡½æ•°æ›¿æ¢å˜é‡ï¼Œä¸€åˆ‡éƒ½åº”è¯¥æ­£å¸¸å·¥ä½œã€‚å¦‚æœæˆ‘ä»¬å°†é˜¶ä¹˜-V0ç¼–å†™ä¸ºåŒ¿åå‡½æ•°ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ</p><p> ( fn  [church-numeral-n]  (( church-if  ( church-zero?  church-numeral-n)  ( fn  [] one)  ( fn  []  ( church-*  church-numeral-n   ; :&lt; :&lt; :&lt; :&lt; uh oh  ( factorial-v0  ( church-dec  church-numeral-n)))))))</p><p>(fn[æ•™å ‚-æ•°å­—-n]((æ•™å ‚-IF(æ•™å ‚-é›¶ï¼Ÿæ•™å ‚æ•°å­—-n)(fn[]one)(fn[](æ•™å ‚-*æ•™å ‚æ•°å­—-nï¼›ï¼š&ltï¼›ï¼š&ltï¼›å‘ƒoh(factorial-v0(æ•™å ‚-12æœˆæ•™å ‚-æ•°å­—-n)ã€‚</p><p>  Hereâ€™s one way we can fix it. We could update this so  factorial is  provided as an argument to itself.</p><p>è¿™é‡Œæœ‰ä¸€ç§æˆ‘ä»¬å¯ä»¥è§£å†³çš„æ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥æ›´æ–°è¿™ä¸€ç‚¹ï¼Œè¿™æ ·é˜¶ä¹˜å°±å¯ä»¥ä½œä¸ºå‚æ•°æä¾›ç»™å®ƒè‡ªå·±ã€‚</p><p> ( fn  [factorial-cb]  ( fn  [church-numeral-n]  (( church-if  ( church-zero?  church-numeral-n)  ( fn  [] one)  ( fn  []  ( church-*  church-numeral-n  ( factorial-cb  ( church-dec  church-numeral-n)))))))  ????)</p><p>(Fn[é˜¶ä¹˜-Cb](Fn[æ•™ä¼šæ•°å­—-n])((æ•™ä¼š-IF(æ•™ä¼š-é›¶ï¼Ÿæ•™å ‚æ•°å­—-n)(fn[]one)(fn[](æ•™å ‚-*æ•™å ‚æ•°å­—-n(factorial-cb(æ•™å ‚-12æœˆæ•™å ‚-æ•°å­—-n)ï¼Ÿ)ã€‚</p><p> That  would work, but we only punt the problem down. What the heck would  ???? be? We need some way to pass a reference of  factorial to  itself!</p><p>é‚£æ˜¯å¯è¡Œçš„ï¼Œä½†æˆ‘ä»¬åªæ˜¯æŠŠé—®é¢˜è½»ææ·¡å†™ã€‚ä»–å¦ˆçš„ä¼šæ€ä¹ˆåšï¼Ÿæ˜¯å—ï¼Ÿæˆ‘ä»¬éœ€è¦æŸç§æ–¹å¼å°†é˜¶ä¹˜çš„å¼•ç”¨ä¼ é€’ç»™å®ƒæœ¬èº«ï¼</p><p>  Letâ€™s see if we can do make this work. First, letâ€™s write our factorial, that accepts some kind of â€œinjectableâ€ version of itself:</p><p>è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬èƒ½ä¸èƒ½æŠŠè¿™ä»¶äº‹åŠå¥½ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç¼–å†™é˜¶ä¹˜ï¼Œå®ƒæ¥å—è‡ªèº«çš„æŸç§â€œå¯æ³¨å…¥â€ç‰ˆæœ¬ï¼š</p><p> ( def  injectable-factorial  ( fn  [factorial-cb]  ( fn  [church-numeral-n]  (( church-if  ( church-zero?  church-numeral-n)  ( fn  [] one)  ( fn  []  ( church-*  church-numeral-n  ( factorial-cb  ( church-dec  church-numeral-n)))))))))</p><p>(defå¯æ³¨å°„-é˜¶ä¹˜(Fn[é˜¶ä¹˜-Cb](Fn[æ•™ä¼šæ•°å­—-n])((æ•™ä¼š-IF(æ•™ä¼š-é›¶ï¼Ÿæ•™å ‚æ•°å­—-n)(fn[]one)(fn[](æ•™å ‚-*æ•™å ‚æ•°å­—-n(é˜¶ä¹˜-cb(æ•™å ‚-åäºŒæœˆæ•™å ‚-æ•°å­—-n)ã€‚</p><p>    Okay, all we did now is move the problem into this  make-recursable function ğŸ˜…. Bear with me.</p><p>å¥½çš„ï¼Œæˆ‘ä»¬ç°åœ¨æ‰€åšçš„å°±æ˜¯å°†é—®é¢˜è½¬ç§»åˆ°è¿™ä¸ªMake-Recursableå‡½æ•°ğŸ˜…ä¸­ã€‚è¯·è€å¿ƒå¬æˆ‘è¯´ã€‚</p><p> Letâ€™s imagine what the solution would need to look like. Weâ€™d want to call  injectable-f with some  factorial-cb function handles the â€œnext callâ€.</p><p>è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹è§£å†³æ–¹æ¡ˆéœ€è¦çœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·å­ã€‚æˆ‘ä»¬å¸Œæœ›ä½¿ç”¨æŸä¸ªé˜¶ä¹˜cbå‡½æ•°è°ƒç”¨injectable-fæ¥å¤„ç†â€œä¸‹ä¸€æ¬¡è°ƒç”¨â€ã€‚</p><p>  That seems right. Note the comment  recursion-handler . This is in reference to this form:</p><p>è¿™ä¼¼ä¹æ˜¯å¯¹çš„ã€‚è¯·æ³¨æ„æ³¨é‡Šé€’å½’å¤„ç†ç¨‹åºã€‚è¿™æ˜¯é’ˆå¯¹æ­¤è¡¨å•çš„ï¼š</p><p>  If we somehow had access to this form, we can use that in  ????! Well, letâ€™s punt the problem down again:</p><p>å¦‚æœæˆ‘ä»¬ä»¥æŸç§æ–¹å¼è®¿é—®æ­¤è¡¨å•ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ï¼Ÿï¼ä¸­ä½¿ç”¨å®ƒã€‚å¥½å§ï¼Œè®©æˆ‘ä»¬æŠŠè¿™ä¸ªé—®é¢˜å†è¯´ä¸€éï¼š</p><p>  Here, we wrap our  recursion-handler into a function. If it could get a copy of itself, weâ€™d be golden. But that means weâ€™re back to the same problem: how could we give  recursion-handler a copy of itself?  Hereâ€™s one idea:</p><p>åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†é€’å½’å¤„ç†ç¨‹åºåŒ…è£…åˆ°ä¸€ä¸ªå‡½æ•°ä¸­ã€‚å¦‚æœå®ƒèƒ½è‡ªå·±å¤åˆ¶ä¸€ä»½ï¼Œæˆ‘ä»¬å°±å¤§åŠŸå‘Šæˆäº†ã€‚ä½†è¿™æ„å‘³ç€æˆ‘ä»¬åˆå›åˆ°äº†åŒæ ·çš„é—®é¢˜ä¸Šï¼šæˆ‘ä»¬å¦‚ä½•æ‰èƒ½ç»™é€’å½’å¤„ç†ç¨‹åºä¸€ä¸ªè‡ªèº«çš„å‰¯æœ¬å‘¢ï¼Ÿè¿™é‡Œæœ‰ä¸€ä¸ªæƒ³æ³•ï¼š</p><p> ( def  make-recursable  ( fn  [injectable-f]  (( fn  [recursion-handler] ( recursion-handler  recursion-handler))  ( fn  [recursion-handler]  ( injectable-f  ( fn  [next-arg]  (( recursion-handler  recursion-handler) next-arg)))))))</p><p>(def make-recursable(fn[Injectable-f]((fn[é€’å½’å¤„ç†ç¨‹åº](é€’å½’å¤„ç†ç¨‹åºé€’å½’å¤„ç†ç¨‹åº)(fn[é€’å½’å¤„ç†ç¨‹åº](Injectable-f(Fn[Next-Arg]((é€’å½’å¤„ç†ç¨‹åºé€’å½’å¤„ç†ç¨‹åº)Next-Arg)ã€‚</p><p>                      This would end up producing a new  factorial function that had a  factorial-cb. Then we would call that with  next-arg, and keep the party going!</p><p>è¿™å°†æœ€ç»ˆäº§ç”Ÿä¸€ä¸ªå…·æœ‰é˜¶ä¹˜CBçš„æ–°é˜¶ä¹˜å‡½æ•°ã€‚ç„¶åæˆ‘ä»¬å°±ç”¨Next-Argæ¥ç§°å‘¼å®ƒï¼Œè®©æ´¾å¯¹ç»§ç»­è¿›è¡Œä¸‹å»ï¼</p><p>     This  make-recursable function is also called the Y Combinator. You may have heard a lot of stuff about it, and this example may be hard to follow. If you want to learn more, I recommend  Jimâ€™s keynote.</p><p>è¿™ä¸ªMake-Recursableå‡½æ•°ä¹Ÿç§°ä¸ºYç»„åˆå™¨ã€‚ä½ å¯èƒ½å¬è¯´è¿‡å¾ˆå¤šå…³äºå®ƒçš„äº‹æƒ…ï¼Œè¿™ä¸ªä¾‹å­å¯èƒ½å¾ˆéš¾æ•ˆä»¿ã€‚å¦‚æœä½ æƒ³äº†è§£æ›´å¤šï¼Œæˆ‘æ¨èå‰å§†çš„ä¸»é¢˜æ¼”è®²ã€‚</p><p>  Wow, we did it. We just wrote  factorial, and  all we used were anonymous functions. To prove the point, letâ€™s remove some of our rules. Hereâ€™s how our code would end up looking without any variable definitions:</p><p>å“‡ï¼Œæˆ‘ä»¬åšåˆ°äº†ã€‚æˆ‘ä»¬åˆšåˆšç¼–å†™äº†é˜¶ä¹˜ï¼Œæ‰€æœ‰æˆ‘ä»¬ä½¿ç”¨çš„éƒ½æ˜¯åŒ¿åå‡½æ•°ã€‚ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬åˆ é™¤ä¸€äº›è§„åˆ™ã€‚ä¸‹é¢æ˜¯æˆ‘ä»¬çš„ä»£ç åœ¨æ²¡æœ‰ä»»ä½•å˜é‡å®šä¹‰çš„æƒ…å†µä¸‹å°†å¦‚ä½•ç»“æŸï¼š</p><p> ( church-numeral-&gt;int  ((( fn  [injectable-f]  (( fn  [recursion-handler] ( recursion-handler  recursion-handler))  ( fn  [recursion-handler] ( injectable-f  ( fn  [next-arg] (( recursion-handler  recursion-handler) next-arg))))))  ( fn  [factorial-cb]  ( fn  [church-numeral-n]  ((( fn  [church-bool  when-true   when-false ] ( church-bool   when-true   when-false ))  (( fn  [church-numeral]  ( church-numeral  ( fn  [v] ( fn  [ when-true   when-false ]  when-false )) ( fn  [ when-true   when-false ]  when-true )))  church-numeral-n)  ( fn  [] ( fn  [f v] ( f  (( fn  [f v] v) f v))))  ( fn  []  (( fn  [num-a num-b] ( fn  [f v] ( num-a  ( partial  num-b f) v)))  church-numeral-n  ( factorial-cb  (( fn  [church-numeral]  (( fn  [pair] ( pair  ( fn  [a b] a)))  ( church-numeral  ( fn  [pair]  (( fn  [a b] ( fn  [selector] ( selector  a b)))  (( fn  [pair] ( pair  ( fn  [a b] b))) pair)  (( fn  [church-numeral] ( fn  [f v] ( f  ( church-numeral  f v)))) (( fn  [pair] ( pair  ( fn  [a b] b))) pair))))  (( fn  [a b] ( fn  [selector] ( selector  a b))) ( fn  [f v] v) ( fn  [f v] v)))))  church-numeral-n)))))))))  (( fn  [church-numeral] ( fn  [f v] ( f  ( church-numeral  f v))))  (( fn  [church-numeral] ( fn  [f v] ( f  ( church-numeral  f v))))  (( fn  [church-numeral] ( fn  [f v] ( f  ( church-numeral  f v)))) ( fn  [f v] ( f  (( fn  [f v] ( f  (( fn  [f v] v) f v))) f v))))))))</p><p>(æ•™å ‚-æ•°å­—-&gtï¼›Int(Fn[Injectable-f]((Fn[é€’å½’å¤„ç†ç¨‹åº](é€’å½’å¤„ç†ç¨‹åºé€’å½’å¤„ç†ç¨‹åº)(Fn[é€’å½’å¤„ç†ç¨‹åº](Injectable-f(Injectable-f(Fn[Next-Arg]((é€’å½’å¤„ç†ç¨‹åºé€’å½’å¤„ç†ç¨‹åº)Next-Arg)(Fn[é˜¶ä¹˜-Cb](Fn[æ•™å ‚æ•°å­—-n](Fn[æ•™å ‚å¸ƒå°”When-true When-False](æ•™å ‚å¸ƒå°”When-True-False)ã€‚TRUE WHEN-FALSE))((FN[æ•™å ‚ç¼–å·](æ•™å ‚ç¼–å·(FN[v](Fn[WHEN-TRUE WHEN-FALSE]WHEN-FALSE]WHEN-FALSE))(FN[WHEN-TRUE WHEN-FALSE]WHEN-TRUE)æ•™å ‚ç¼–å·-n)(FN[](Fn[](Fn[f v](f((Fn[f v]v)f v)(Fn[]((Fnã€‚[num-a num-b](fn[fv](num-a(éƒ¨åˆ†num-bf)v))æ•™å ‚æ•°å­—-n(é˜¶ä¹˜-cb((fn[æ•™å ‚æ•°å­—]((fn[a b]a)(æ•™å ‚æ•°å­—(fn[å¯¹](fn[b]a))((fn[b]((fn[a b](fn[é€‰æ‹©å™¨](é€‰æ‹©å™¨a b)(fn[å¯¹ã€‚](Pair(Fn[a b]b))Pair)((Fn[æ•™å ‚æ•°å­—](Fn[f v](f(æ•™å ‚æ•°å­—f v)((Fn[Pair](Pair(Fn[a b]b)((Fn[a b](Fn[é€‰æ‹©å™¨](é€‰æ‹©å™¨a b)(Fn[f]v)(fn[f]v)(fn[f]ã€‚V)æ•™å ‚ç¼–å·-n)((fn[æ•™å ‚ç¼–å·](fn[f v](f(æ•™å ‚ç¼–å·f v)((fn[æ•™å ‚ç¼–å·](fn[f v](f(æ•™å ‚ç¼–å·f v)((fn[æ•™å ‚ç¼–å·](fn[f v](f(æ•™å ‚ç¼–å·f v)(fnã€‚[fv](f((fn[fv](f((fn[fv]v)fv)ã€‚</p><p>    Well, we just took our functions through the Mojave desert! We made numbers, booleans, arithmetic, and recursionâ€¦all from anonymous functions. I hope you had fun! If youâ€™d like to see the code in full, take a look at the  GH repo.</p><p>æˆ‘ä»¬åˆšåˆšæŠŠæˆ‘ä»¬çš„ä»»åŠ¡å¸¦è¿‡äº†è«å“ˆéŸ¦æ²™æ¼ ï¼æˆ‘ä»¬åˆ¶ä½œäº†æ•°å­—ã€å¸ƒå°”å€¼ã€ç®—æœ¯å’Œé€’å½’â€¦ã€‚å…¨éƒ¨æ¥è‡ªåŒ¿åå‡½æ•°ã€‚å¸Œæœ›ä½ ç©å¾—å¼€å¿ƒï¼å¦‚æœæ‚¨æƒ³æŸ¥çœ‹å®Œæ•´çš„ä»£ç ï¼Œè¯·æŸ¥çœ‹GHå›è´­ã€‚</p><p>  Iâ€™ll leave with you with some Clojure macro fun. When the time came to â€œreplaceâ€ all our  defs with anonymous functions, how did we do it?</p><p>æˆ‘å°†å¸¦ç€ä¸€äº›Clojureå®è§‚ä¹è¶£ç¦»å¼€ã€‚å½“ç”¨åŒ¿åå‡½æ•°â€œæ›¿æ¢â€æ‰€æœ‰Deffçš„æ—¶å€™ï¼Œæˆ‘ä»¬æ˜¯å¦‚ä½•åšåˆ°çš„å‘¢ï¼Ÿ</p><p> In wimpier languages we might have needed to do some manual copy pastin  3. In lisp, we can use  macros.</p><p>åœ¨è¾ƒå¼±çš„è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦æ‰‹åŠ¨å¤åˆ¶ç²˜è´´3ã€‚åœ¨LISPä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ã€‚</p><p> First, letâ€™s rewrite  def. This version will â€œstoreâ€ the source code of every  def as metadata:</p><p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬é‡å†™defã€‚æ­¤ç‰ˆæœ¬å°†æ¯ä¸ªdefçš„æºä»£ç â€œå­˜å‚¨â€ä¸ºå…ƒæ•°æ®ï¼š</p><p> ( defmacro  def#   &#34;A light wrapper around `def`, that keeps track of the  _source code_ for each definition  This let&#39;s us _unwrap_ all the definitions later : &gt;&#34;  [name v]  `( do  ( def  ~name ~v)  ( alter-meta!  ( var  ~name) assoc  :source  { :name  &#39;~name  :v  &#39;~v})  ( var  ~name)))</p><p>(defå®def#&#34ï¼›`def`å‘¨å›´çš„è½»å‹åŒ…è£…ï¼Œç”¨äºè·Ÿè¸ªæ­¤letçš„æ¯ä¸ªå®šä¹‰çš„_source code_åé¢çš„us_unwork_allå®šä¹‰ï¼š&gtï¼›&#34ï¼›[name v]`(do(def~name~v)(alt-metaï¼(var~name)assocï¼šsource{ï¼šname&#39ï¼›~nameï¼šv&#39ï¼›~v})(var~name))ã€‚</p><p> Then, we can create an  unwrap function, that recursively replaces all  def symbols with with their corresponding source code:</p><p>ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå±•å¼€å‡½æ•°ï¼Œè¯¥å‡½æ•°é€’å½’åœ°å°†æ‰€æœ‰defç¬¦å·æ›¿æ¢ä¸ºå…¶å¯¹åº”çš„æºä»£ç ï¼š</p><p> ( defn  expand   &#34;This takes a form like  (church-numeral-&gt;int (factorial-yc (int-&gt;church-numeral 5)))  And expands all the function definitions, to give  us the intuition for how our &#39;lambda calculus&#39; way would look!&#34;  [form]  ( cond  ( symbol?  form)  ( if-let  [source ( some-&gt;  ( str  *ns*  &#34;/&#34;  form)  symbol  find-var  meta   :source )]  ( expand  ( :v  source))  form)  ( seq?  form)  ( map  expand form)   :else  form))</p><p>(Defn Expand&#34ï¼›thisé‡‡ç”¨ç±»ä¼¼äº(chorge-numeral-&gtï¼›int(factorial-yc(int-&gtï¼›chetch-numeral 5)çš„å½¢å¼ï¼Œå¹¶å±•å¼€æ‰€æœ‰å‡½æ•°å®šä¹‰ï¼Œè®©æˆ‘ä»¬ç›´è§‚åœ°çœ‹åˆ°æˆ‘ä»¬çš„lambdaæ¼”ç®—æ–¹æ³•ä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼&#34ï¼›[form](cond(Symbolï¼ŸForm)(if-let[source(ome-&&gt;ï¼›(str*ns*&34ï¼›/&#34ï¼›form)ç¬¦å·find-var metaï¼šsource)](å±•å¼€(ï¼šv source))form)(åºå·ï¼Ÿè¡¨å•)(åœ°å›¾å±•å¼€è¡¨å•)ï¼šELSEè¡¨å•))</p><p>     Thanks to Alex Reichert, Daniel Woelfel, Sean Grove, Irakli Safareli, Alex Kotliarskyi, Davit Magaltadze, Joe Averbukh for reviewing drafts of this essay</p><p>æ„Ÿè°¢Alex Reichertï¼ŒDaniel Woelfelï¼ŒSean Groveï¼ŒIrakli Safareliï¼ŒAlex Kotliarskyiï¼ŒDavit Magaltadzeï¼ŒJoe Averbukhå®¡é˜…æœ¬æ–‡è‰ç¨¿</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://stopa.io/post/263">https://stopa.io/post/263</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/å¾®ç§¯åˆ†/">#å¾®ç§¯åˆ†</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lambda/">#lambda</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/å‡½æ•°/">#å‡½æ•°</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è®¾è®¡/">#è®¾è®¡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ¸¸æˆ/">#æ¸¸æˆ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åˆ›æ„/">#åˆ›æ„</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‹¹æœ/">#è‹¹æœ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‘„å½±/">#æ‘„å½±</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è½¯ä»¶/">#è½¯ä»¶</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¾å›½/">#ç¾å›½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å›¾ç‰‡/">#å›¾ç‰‡</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/æ‰‹æœº/">#æ‰‹æœº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è§†é¢‘/">#è§†é¢‘</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¹¿å‘Š/">#å¹¿å‘Š</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å…è´¹/">#å…è´¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è°·æ­Œ/">#è°·æ­Œ</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç½‘ç«™/">#ç½‘ç«™</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/å¾®è½¯/">#å¾®è½¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ä¸‹è½½/">#ä¸‹è½½</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/éŸ³ä¹/">#éŸ³ä¹</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/åšå®¢/">#åšå®¢</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ç¨‹åº/">#ç¨‹åº</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/è‰ºæœ¯/">#è‰ºæœ¯</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>